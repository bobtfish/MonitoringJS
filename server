#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AnyEvent/Server/PSGI.pm"} = <<'ANYEVENT_SERVER_PSGI';
  package AnyEvent::Server::PSGI;
  use parent 'Twiggy::Server';
  
  1;
ANYEVENT_SERVER_PSGI

$fatpacked{"Class/Accessor.pm"} = <<'CLASS_ACCESSOR';
  package Class::Accessor;
  require 5.00502;
  use strict;
  $Class::Accessor::VERSION = '0.34';
  
  sub new {
      my($proto, $fields) = @_;
      my($class) = ref $proto || $proto;
  
      $fields = {} unless defined $fields;
  
      # make a copy of $fields.
      bless {%$fields}, $class;
  }
  
  sub mk_accessors {
      my($self, @fields) = @_;
  
      $self->_mk_accessors('rw', @fields);
  }
  
  if (eval { require Sub::Name }) {
      Sub::Name->import;
  }
  
  {
      no strict 'refs';
  
      sub import {
          my ($class, @what) = @_;
          my $caller = caller;
          for (@what) {
              if (/^(?:antlers|moose-?like)$/i) {
                  *{"${caller}::has"} = sub {
                      my ($f, %args) = @_;
                      $caller->_mk_accessors(($args{is}||"rw"), $f);
                  };
                  *{"${caller}::extends"} = sub {
                      @{"${caller}::ISA"} = @_;
                      unless (grep $_->can("_mk_accessors"), @_) {
                          push @{"${caller}::ISA"}, $class;
                      }
                  };
                  # we'll use their @ISA as a default, in case it happens to be
                  # set already
                  &{"${caller}::extends"}(@{"${caller}::ISA"});
              }
          }
      }
  
      sub follow_best_practice {
          my($self) = @_;
          my $class = ref $self || $self;
          *{"${class}::accessor_name_for"}  = \&best_practice_accessor_name_for;
          *{"${class}::mutator_name_for"}  = \&best_practice_mutator_name_for;
      }
  
      sub _mk_accessors {
          my($self, $access, @fields) = @_;
          my $class = ref $self || $self;
          my $ra = $access eq 'rw' || $access eq 'ro';
          my $wa = $access eq 'rw' || $access eq 'wo';
  
          foreach my $field (@fields) {
              my $accessor_name = $self->accessor_name_for($field);
              my $mutator_name = $self->mutator_name_for($field);
              if( $accessor_name eq 'DESTROY' or $mutator_name eq 'DESTROY' ) {
                  $self->_carp("Having a data accessor named DESTROY  in '$class' is unwise.");
              }
              if ($accessor_name eq $mutator_name) {
                  my $accessor;
                  if ($ra && $wa) {
                      $accessor = $self->make_accessor($field);
                  } elsif ($ra) {
                      $accessor = $self->make_ro_accessor($field);
                  } else {
                      $accessor = $self->make_wo_accessor($field);
                  }
                  my $fullname = "${class}::$accessor_name";
                  my $subnamed = 0;
                  unless (defined &{$fullname}) {
                      subname($fullname, $accessor) if defined &subname;
                      $subnamed = 1;
                      *{$fullname} = $accessor;
                  }
                  if ($accessor_name eq $field) {
                      # the old behaviour
                      my $alias = "${class}::_${field}_accessor";
                      subname($alias, $accessor) if defined &subname and not $subnamed;
                      *{$alias} = $accessor unless defined &{$alias};
                  }
              } else {
                  my $fullaccname = "${class}::$accessor_name";
                  my $fullmutname = "${class}::$mutator_name";
                  if ($ra and not defined &{$fullaccname}) {
                      my $accessor = $self->make_ro_accessor($field);
                      subname($fullaccname, $accessor) if defined &subname;
                      *{$fullaccname} = $accessor;
                  }
                  if ($wa and not defined &{$fullmutname}) {
                      my $mutator = $self->make_wo_accessor($field);
                      subname($fullmutname, $mutator) if defined &subname;
                      *{$fullmutname} = $mutator;
                  }
              }
          }
      }
  
  }
  
  sub mk_ro_accessors {
      my($self, @fields) = @_;
  
      $self->_mk_accessors('ro', @fields);
  }
  
  sub mk_wo_accessors {
      my($self, @fields) = @_;
  
      $self->_mk_accessors('wo', @fields);
  }
  
  sub best_practice_accessor_name_for {
      my ($class, $field) = @_;
      return "get_$field";
  }
  
  sub best_practice_mutator_name_for {
      my ($class, $field) = @_;
      return "set_$field";
  }
  
  sub accessor_name_for {
      my ($class, $field) = @_;
      return $field;
  }
  
  sub mutator_name_for {
      my ($class, $field) = @_;
      return $field;
  }
  
  sub set {
      my($self, $key) = splice(@_, 0, 2);
  
      if(@_ == 1) {
          $self->{$key} = $_[0];
      }
      elsif(@_ > 1) {
          $self->{$key} = [@_];
      }
      else {
          $self->_croak("Wrong number of arguments received");
      }
  }
  
  sub get {
      my $self = shift;
  
      if(@_ == 1) {
          return $self->{$_[0]};
      }
      elsif( @_ > 1 ) {
          return @{$self}{@_};
      }
      else {
          $self->_croak("Wrong number of arguments received");
      }
  }
  
  sub make_accessor {
      my ($class, $field) = @_;
  
      return sub {
          my $self = shift;
  
          if(@_) {
              return $self->set($field, @_);
          } else {
              return $self->get($field);
          }
      };
  }
  
  sub make_ro_accessor {
      my($class, $field) = @_;
  
      return sub {
          my $self = shift;
  
          if (@_) {
              my $caller = caller;
              $self->_croak("'$caller' cannot alter the value of '$field' on objects of class '$class'");
          }
          else {
              return $self->get($field);
          }
      };
  }
  
  sub make_wo_accessor {
      my($class, $field) = @_;
  
      return sub {
          my $self = shift;
  
          unless (@_) {
              my $caller = caller;
              $self->_croak("'$caller' cannot access the value of '$field' on objects of class '$class'");
          }
          else {
              return $self->set($field, @_);
          }
      };
  }
  
  
  use Carp ();
  
  sub _carp {
      my ($self, $msg) = @_;
      Carp::carp($msg || $self);
      return;
  }
  
  sub _croak {
      my ($self, $msg) = @_;
      Carp::croak($msg || $self);
      return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
    Class::Accessor - Automated accessor generation
  
  =head1 SYNOPSIS
  
    package Foo;
    use base qw(Class::Accessor);
    Foo->follow_best_practice;
    Foo->mk_accessors(qw(name role salary));
  
    # or if you prefer a Moose-like interface...
   
    package Foo;
    use Class::Accessor "antlers";
    has name => ( is => "rw", isa => "Str" );
    has role => ( is => "rw", isa => "Str" );
    has salary => ( is => "rw", isa => "Num" );
  
    # Meanwhile, in a nearby piece of code!
    # Class::Accessor provides new().
    my $mp = Foo->new({ name => "Marty", role => "JAPH" });
  
    my $job = $mp->role;  # gets $mp->{role}
    $mp->salary(400000);  # sets $mp->{salary} = 400000 # I wish
    
    # like my @info = @{$mp}{qw(name role)}
    my @info = $mp->get(qw(name role));
    
    # $mp->{salary} = 400000
    $mp->set('salary', 400000);
  
  
  =head1 DESCRIPTION
  
  This module automagically generates accessors/mutators for your class.
  
  Most of the time, writing accessors is an exercise in cutting and
  pasting.  You usually wind up with a series of methods like this:
  
      sub name {
          my $self = shift;
          if(@_) {
              $self->{name} = $_[0];
          }
          return $self->{name};
      }
  
      sub salary {
          my $self = shift;
          if(@_) {
              $self->{salary} = $_[0];
          }
          return $self->{salary};
      }
  
    # etc...
  
  One for each piece of data in your object.  While some will be unique,
  doing value checks and special storage tricks, most will simply be
  exercises in repetition.  Not only is it Bad Style to have a bunch of
  repetitious code, but it's also simply not lazy, which is the real
  tragedy.
  
  If you make your module a subclass of Class::Accessor and declare your
  accessor fields with mk_accessors() then you'll find yourself with a
  set of automatically generated accessors which can even be
  customized!
  
  The basic set up is very simple:
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors( qw(far bar car) );
  
  Done.  Foo now has simple far(), bar() and car() accessors
  defined.
  
  Alternatively, if you want to follow Damian's I<best practice> guidelines 
  you can use:
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->follow_best_practice;
      Foo->mk_accessors( qw(far bar car) );
  
  B<Note:> you must call C<follow_best_practice> before calling C<mk_accessors>.
  
  =head2 Moose-like
  
  By popular demand we now have a simple Moose-like interface.  You can now do:
  
      package Foo;
      use Class::Accessor "antlers";
      has far => ( is => "rw" );
      has bar => ( is => "rw" );
      has car => ( is => "rw" );
  
  Currently only the C<is> attribute is supported.
  
  =head1 CONSTRUCTOR
  
  Class::Accessor provides a basic constructor, C<new>.  It generates a
  hash-based object and can be called as either a class method or an
  object method.  
  
  =head2 new
  
      my $obj = Foo->new;
      my $obj = $other_obj->new;
  
      my $obj = Foo->new(\%fields);
      my $obj = $other_obj->new(\%fields);
  
  It takes an optional %fields hash which is used to initialize the
  object (handy if you use read-only accessors).  The fields of the hash
  correspond to the names of your accessors, so...
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors('foo');
  
      my $obj = Foo->new({ foo => 42 });
      print $obj->foo;    # 42
  
  however %fields can contain anything, new() will shove them all into
  your object.
  
  =head1 MAKING ACCESSORS
  
  =head2 follow_best_practice
  
  In Damian's Perl Best Practices book he recommends separate get and set methods
  with the prefix set_ and get_ to make it explicit what you intend to do.  If you
  want to create those accessor methods instead of the default ones, call:
  
      __PACKAGE__->follow_best_practice
  
  B<before> you call any of the accessor-making methods.
  
  =head2 accessor_name_for / mutator_name_for
  
  You may have your own crazy ideas for the names of the accessors, so you can
  make those happen by overriding C<accessor_name_for> and C<mutator_name_for> in
  your subclass.  (I copied that idea from Class::DBI.)
  
  =head2 mk_accessors
  
      __PACKAGE__->mk_accessors(@fields);
  
  This creates accessor/mutator methods for each named field given in
  @fields.  Foreach field in @fields it will generate two accessors.
  One called "field()" and the other called "_field_accessor()".  For
  example:
  
      # Generates foo(), _foo_accessor(), bar() and _bar_accessor().
      __PACKAGE__->mk_accessors(qw(foo bar));
  
  See L<CAVEATS AND TRICKS/"Overriding autogenerated accessors">
  for details.
  
  =head2 mk_ro_accessors
  
    __PACKAGE__->mk_ro_accessors(@read_only_fields);
  
  Same as mk_accessors() except it will generate read-only accessors
  (ie. true accessors).  If you attempt to set a value with these
  accessors it will throw an exception.  It only uses get() and not
  set().
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_ro_accessors(qw(foo bar));
  
      # Let's assume we have an object $foo of class Foo...
      print $foo->foo;  # ok, prints whatever the value of $foo->{foo} is
      $foo->foo(42);    # BOOM!  Naughty you.
  
  
  =head2 mk_wo_accessors
  
    __PACKAGE__->mk_wo_accessors(@write_only_fields);
  
  Same as mk_accessors() except it will generate write-only accessors
  (ie. mutators).  If you attempt to read a value with these accessors
  it will throw an exception.  It only uses set() and not get().
  
  B<NOTE> I'm not entirely sure why this is useful, but I'm sure someone
  will need it.  If you've found a use, let me know.  Right now it's here
  for orthoginality and because it's easy to implement.
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_wo_accessors(qw(foo bar));
  
      # Let's assume we have an object $foo of class Foo...
      $foo->foo(42);      # OK.  Sets $self->{foo} = 42
      print $foo->foo;    # BOOM!  Can't read from this accessor.
  
  =head1 Moose!
  
  If you prefer a Moose-like interface to create accessors, you can use C<has> by
  importing this module like this:
  
    use Class::Accessor "antlers";
  
  or
  
    use Class::Accessor "moose-like";
  
  Then you can declare accessors like this:
  
    has alpha => ( is => "rw", isa => "Str" );
    has beta  => ( is => "ro", isa => "Str" );
    has gamma => ( is => "wo", isa => "Str" );
  
  Currently only the C<is> attribute is supported.  And our C<is> also supports
  the "wo" value to make a write-only accessor.
  
  If you are using the Moose-like interface then you should use the C<extends>
  rather than tweaking your C<@ISA> directly.  Basically, replace
  
    @ISA = qw/Foo Bar/;
  
  with
  
    extends(qw/Foo Bar/);
  
  =head1 DETAILS
  
  An accessor generated by Class::Accessor looks something like
  this:
  
      # Your foo may vary.
      sub foo {
          my($self) = shift;
          if(@_) {    # set
              return $self->set('foo', @_);
          }
          else {
              return $self->get('foo');
          }
      }
  
  Very simple.  All it does is determine if you're wanting to set a
  value or get a value and calls the appropriate method.
  Class::Accessor provides default get() and set() methods which
  your class can override.  They're detailed later.
  
  =head2 Modifying the behavior of the accessor
  
  Rather than actually modifying the accessor itself, it is much more
  sensible to simply override the two key methods which the accessor
  calls.  Namely set() and get().
  
  If you -really- want to, you can override make_accessor().
  
  =head2 set
  
      $obj->set($key, $value);
      $obj->set($key, @values);
  
  set() defines how generally one stores data in the object.
  
  override this method to change how data is stored by your accessors.
  
  =head2 get
  
      $value  = $obj->get($key);
      @values = $obj->get(@keys);
  
  get() defines how data is retreived from your objects.
  
  override this method to change how it is retreived.
  
  =head2 make_accessor
  
      $accessor = __PACKAGE__->make_accessor($field);
  
  Generates a subroutine reference which acts as an accessor for the given
  $field.  It calls get() and set().
  
  If you wish to change the behavior of your accessors, try overriding
  get() and set() before you start mucking with make_accessor().
  
  =head2 make_ro_accessor
  
      $read_only_accessor = __PACKAGE__->make_ro_accessor($field);
  
  Generates a subroutine refrence which acts as a read-only accessor for
  the given $field.  It only calls get().
  
  Override get() to change the behavior of your accessors.
  
  =head2 make_wo_accessor
  
      $read_only_accessor = __PACKAGE__->make_wo_accessor($field);
  
  Generates a subroutine refrence which acts as a write-only accessor
  (mutator) for the given $field.  It only calls set().
  
  Override set() to change the behavior of your accessors.
  
  =head1 EXCEPTIONS
  
  If something goes wrong Class::Accessor will warn or die by calling Carp::carp
  or Carp::croak.  If you don't like this you can override _carp() and _croak() in
  your subclass and do whatever else you want.
  
  =head1 EFFICIENCY
  
  Class::Accessor does not employ an autoloader, thus it is much faster
  than you'd think.  Its generated methods incur no special penalty over
  ones you'd write yourself.
  
    accessors:
                Rate  Basic   Fast Faster Direct
    Basic   367589/s     --   -51%   -55%   -89%
    Fast    747964/s   103%     --    -9%   -77%
    Faster  819199/s   123%    10%     --   -75%
    Direct 3245887/s   783%   334%   296%     --
  
    mutators:
                Rate    Acc   Fast Faster Direct
    Acc     265564/s     --   -54%   -63%   -91%
    Fast    573439/s   116%     --   -21%   -80%
    Faster  724710/s   173%    26%     --   -75%
    Direct 2860979/s   977%   399%   295%     --
  
  Class::Accessor::Fast is faster than methods written by an average programmer
  (where "average" is based on Schwern's example code).
  
  Class::Accessor is slower than average, but more flexible.
  
  Class::Accessor::Faster is even faster than Class::Accessor::Fast.  It uses an
  array internally, not a hash.  This could be a good or bad feature depending on
  your point of view.
  
  Direct hash access is, of course, much faster than all of these, but it
  provides no encapsulation.
  
  Of course, it's not as simple as saying "Class::Accessor is slower than
  average".  These are benchmarks for a simple accessor.  If your accessors do
  any sort of complicated work (such as talking to a database or writing to a
  file) the time spent doing that work will quickly swamp the time spend just
  calling the accessor.  In that case, Class::Accessor and the ones you write
  will be roughly the same speed.
  
  
  =head1 EXAMPLES
  
  Here's an example of generating an accessor for every public field of
  your class.
  
      package Altoids;
      
      use base qw(Class::Accessor Class::Fields);
      use fields qw(curiously strong mints);
      Altoids->mk_accessors( Altoids->show_fields('Public') );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
          return fields::new($class);
      }
  
      my Altoids $tin = Altoids->new;
  
      $tin->curiously('Curiouser and curiouser');
      print $tin->{curiously};    # prints 'Curiouser and curiouser'
  
      
      # Subclassing works, too.
      package Mint::Snuff;
      use base qw(Altoids);
  
      my Mint::Snuff $pouch = Mint::Snuff->new;
      $pouch->strong('Blow your head off!');
      print $pouch->{strong};     # prints 'Blow your head off!'
  
  
  Here's a simple example of altering the behavior of your accessors.
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors(qw(this that up down));
  
      sub get {
          my $self = shift;
  
          # Note every time someone gets some data.
          print STDERR "Getting @_\n";
  
          $self->SUPER::get(@_);
      }
  
      sub set {
          my ($self, $key) = splice(@_, 0, 2);
  
          # Note every time someone sets some data.
          print STDERR "Setting $key to @_\n";
  
          $self->SUPER::set($key, @_);
      }
  
  
  =head1 CAVEATS AND TRICKS
  
  Class::Accessor has to do some internal wackiness to get its
  job done quickly and efficiently.  Because of this, there's a few
  tricks and traps one must know about.
  
  Hey, nothing's perfect.
  
  =head2 Don't make a field called DESTROY
  
  This is bad.  Since DESTROY is a magical method it would be bad for us
  to define an accessor using that name.  Class::Accessor will
  carp if you try to use it with a field named "DESTROY".
  
  =head2 Overriding autogenerated accessors
  
  You may want to override the autogenerated accessor with your own, yet
  have your custom accessor call the default one.  For instance, maybe
  you want to have an accessor which checks its input.  Normally, one
  would expect this to work:
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors(qw(email this that whatever));
  
      # Only accept addresses which look valid.
      sub email {
          my($self) = shift;
          my($email) = @_;
  
          if( @_ ) {  # Setting
              require Email::Valid;
              unless( Email::Valid->address($email) ) {
                  carp("$email doesn't look like a valid address.");
                  return;
              }
          }
  
          return $self->SUPER::email(@_);
      }
  
  There's a subtle problem in the last example, and it's in this line:
  
      return $self->SUPER::email(@_);
  
  If we look at how Foo was defined, it called mk_accessors() which
  stuck email() right into Foo's namespace.  There *is* no
  SUPER::email() to delegate to!  Two ways around this... first is to
  make a "pure" base class for Foo.  This pure class will generate the
  accessors and provide the necessary super class for Foo to use:
  
      package Pure::Organic::Foo;
      use base qw(Class::Accessor);
      Pure::Organic::Foo->mk_accessors(qw(email this that whatever));
  
      package Foo;
      use base qw(Pure::Organic::Foo);
  
  And now Foo::email() can override the generated
  Pure::Organic::Foo::email() and use it as SUPER::email().
  
  This is probably the most obvious solution to everyone but me.
  Instead, what first made sense to me was for mk_accessors() to define
  an alias of email(), _email_accessor().  Using this solution,
  Foo::email() would be written with:
  
      return $self->_email_accessor(@_);
  
  instead of the expected SUPER::email().
  
  
  =head1 AUTHORS
  
  Copyright 2009 Marty Pauley <marty+perl@kasei.com>
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  That means either (a) the GNU General Public
  License or (b) the Artistic License.
  
  =head2 ORIGINAL AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  =head2 THANKS
  
  Liz and RUZ for performance tweaks.
  
  Tels, for his big feature request/bug report.
  
  Various presenters at YAPC::Asia 2009 for criticising the non-Moose interface.
  
  =head1 SEE ALSO
  
  See L<Class::Accessor::Fast> and L<Class::Accessor::Faster> if speed is more
  important than flexibility.
  
  These are some modules which do similar things in different ways
  L<Class::Struct>, L<Class::Methodmaker>, L<Class::Generate>,
  L<Class::Class>, L<Class::Contract>, L<Moose>, L<Mouse>
  
  See L<Class::DBI> for an example of this module in use.
  
  =cut
CLASS_ACCESSOR

$fatpacked{"Class/Accessor/Fast.pm"} = <<'CLASS_ACCESSOR_FAST';
  package Class::Accessor::Fast;
  use base 'Class::Accessor';
  use strict;
  $Class::Accessor::Fast::VERSION = '0.34';
  
  sub make_accessor {
      my($class, $field) = @_;
  
      return sub {
          return $_[0]->{$field} if scalar(@_) == 1;
          return $_[0]->{$field}  = scalar(@_) == 2 ? $_[1] : [@_[1..$#_]];
      };
  }
  
  
  sub make_ro_accessor {
      my($class, $field) = @_;
  
      return sub {
          return $_[0]->{$field} if @_ == 1;
          my $caller = caller;
          $_[0]->_croak("'$caller' cannot alter the value of '$field' on objects of class '$class'");
      };
  }
  
  
  sub make_wo_accessor {
      my($class, $field) = @_;
  
      return sub {
          if (@_ == 1) {
              my $caller = caller;
              $_[0]->_croak("'$caller' cannot access the value of '$field' on objects of class '$class'");
          }
          else {
              return $_[0]->{$field} = $_[1] if @_ == 2;
              return (shift)->{$field} = \@_;
          }
      };
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Fast - Faster, but less expandable, accessors
  
  =head1 SYNOPSIS
  
    package Foo;
    use base qw(Class::Accessor::Fast);
  
    # The rest is the same as Class::Accessor but without set() and get().
  
  =head1 DESCRIPTION
  
  This is a faster but less expandable version of Class::Accessor.
  Class::Accessor's generated accessors require two method calls to accompish
  their task (one for the accessor, another for get() or set()).
  Class::Accessor::Fast eliminates calling set()/get() and does the access itself,
  resulting in a somewhat faster accessor.
  
  The downside is that you can't easily alter the behavior of your
  accessors, nor can your subclasses.  Of course, should you need this
  later, you can always swap out Class::Accessor::Fast for
  Class::Accessor.
  
  Read the documentation for Class::Accessor for more info.
  
  =head1 EFFICIENCY
  
  L<Class::Accessor/EFFICIENCY> for an efficiency comparison.
  
  =head1 AUTHORS
  
  Copyright 2007 Marty Pauley <marty+perl@kasei.com>
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  That means either (a) the GNU General Public
  License or (b) the Artistic License.
  
  =head2 ORIGINAL AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  =cut
CLASS_ACCESSOR_FAST

$fatpacked{"Class/Accessor/Faster.pm"} = <<'CLASS_ACCESSOR_FASTER';
  package Class::Accessor::Faster;
  use base 'Class::Accessor';
  use strict;
  $Class::Accessor::Faster::VERSION = '0.34';
  
  my %slot;
  sub _slot {
      my($class, $field) = @_;
      my $n = $slot{$class}->{$field};
      return $n if defined $n;
      $n = keys %{$slot{$class}};
      $slot{$class}->{$field} = $n;
      return $n;
  }
  
  sub new {
      my($proto, $fields) = @_;
      my($class) = ref $proto || $proto;
      my $self = bless [], $class;
  
      $fields = {} unless defined $fields;
      for my $k (keys %$fields) {
          my $n = $class->_slot($k);
          $self->[$n] = $fields->{$k};
      }
      return $self;
  }
  
  sub make_accessor {
      my($class, $field) = @_;
      my $n = $class->_slot($field);
      return sub {
          return $_[0]->[$n] if scalar(@_) == 1;
          return $_[0]->[$n]  = scalar(@_) == 2 ? $_[1] : [@_[1..$#_]];
      };
  }
  
  sub make_ro_accessor {
      my($class, $field) = @_;
      my $n = $class->_slot($field);
      return sub {
          return $_[0]->[$n] if @_ == 1;
          my $caller = caller;
          $_[0]->_croak("'$caller' cannot alter the value of '$field' on objects of class '$class'");
      };
  }
  
  sub make_wo_accessor {
      my($class, $field) = @_;
      my $n = $class->_slot($field);
      return sub {
          if (@_ == 1) {
              my $caller = caller;
              $_[0]->_croak("'$caller' cannot access the value of '$field' on objects of class '$class'");
          } else {
              return $_[0]->[$n] = $_[1] if @_ == 2;
              return (shift)->[$n] = \@_;
          }
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Faster - Even faster, but less expandable, accessors
  
  =head1 SYNOPSIS
  
    package Foo;
    use base qw(Class::Accessor::Faster);
  
  =head1 DESCRIPTION
  
  This is a faster but less expandable version of Class::Accessor::Fast.
  
  Class::Accessor's generated accessors require two method calls to accompish
  their task (one for the accessor, another for get() or set()).
  
  Class::Accessor::Fast eliminates calling set()/get() and does the access itself,
  resulting in a somewhat faster accessor.
  
  Class::Accessor::Faster uses an array reference underneath to be faster.
  
  Read the documentation for Class::Accessor for more info.
  
  =head1 AUTHORS
  
  Copyright 2007 Marty Pauley <marty+perl@kasei.com>
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  That means either (a) the GNU General Public
  License or (b) the Artistic License.
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  =cut
CLASS_ACCESSOR_FASTER

$fatpacked{"Devel/StackTrace.pm"} = <<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  BEGIN {
    $Devel::StackTrace::VERSION = '1.27';
  }
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Devel::StackTrace::Frame;
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""'     => \&as_string,
      fallback => 1;
  
  sub new {
      my $class = shift;
      my %p     = @_;
  
      # Backwards compatibility - this parameter was renamed to no_refs
      # ages ago.
      $p{no_refs} = delete $p{no_object_refs}
          if exists $p{no_object_refs};
  
      my $self = bless {
          index  => undef,
          frames => [],
          raw    => [],
          %p,
      }, $class;
  
      $self->_record_caller_data();
  
      return $self;
  }
  
  sub _record_caller_data {
      my $self = shift;
  
      # We exclude this method by starting one frame back.
      my $x = 1;
      while (
          my @c
          = do { package # the newline keeps dzil from adding a version here
                     DB; @DB::args = (); caller( $x++ ) }
          ) {
          my @args = @DB::args;
  
          if ( $self->{no_refs} ) {
              @args = map { ref $_ ? $self->_ref_to_string($_) : $_ } @args;
          }
  
          push @{ $self->{raw} }, {
              caller => \@c,
              args   => \@args,
              };
      }
  }
  
  sub _ref_to_string {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      local $@;
      local $SIG{__DIE__};
  
      my $str = eval { $ref . '' };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames {
      my $self = shift;
  
      my $filter = $self->_make_frame_filter;
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} ) {
          next unless $filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub {1};
  
  sub _make_frame_filter {
      my $self = shift;
  
      my ( @i_pack_re, %i_class );
      if ( $self->{ignore_package} ) {
          $self->{ignore_package} = [ $self->{ignore_package} ]
              unless UNIVERSAL::isa( $self->{ignore_package}, 'ARRAY' );
  
          @i_pack_re
              = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} ) {
          $self->{ignore_class} = [ $self->{ignore_class} ]
              unless ref $self->{ignore_class};
          %i_class = map { $_ => 1 } @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ($user_filter) {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame {
      my $self = shift;
      my $c    = shift;
      my $args = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, ( undef, undef ) if scalar @$c == 6;
  
      if ( $self->{no_refs} ) {
      }
  
      push @{ $self->{frames} },
          Devel::StackTrace::Frame->new(
          $c,
          $args,
          $self->{respect_overload},
          $self->{max_arg_length},
          $self->{message},
          $self->{indent}
          );
  }
  
  sub next_frame {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames();
      if ( defined $f[ $self->{index} + 1 ] ) {
          return $f[ ++$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub prev_frame {
      my $self = shift;
  
      my @f = $self->frames();
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 ) {
          return $f[ --$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer {
      my $self = shift;
  
      $self->{index} = undef;
  }
  
  sub frames {
      my $self = shift;
  
      $self->_make_frames() if $self->{raw};
  
      return @{ $self->{frames} };
  }
  
  sub frame {
      my $self = shift;
      my $i    = shift;
  
      return unless defined $i;
  
      return ( $self->frames() )[$i];
  }
  
  sub frame_count {
      my $self = shift;
  
      return scalar( $self->frames() );
  }
  
  sub as_string {
      my $self = shift;
  
      my $st    = '';
      my $first = 1;
      foreach my $f ( $self->frames() ) {
          $st .= $f->as_string($first) . "\n";
          $first = 0;
      }
  
      return $st;
  }
  
  {
      package
          Devel::StackTraceFrame;
  
      our @ISA = 'Devel::StackTrace::Frame';
  }
  
  1;
  
  # ABSTRACT: An object representing a stack trace
  
  
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace - An object representing a stack trace
  
  =head1 VERSION
  
  version 1.27
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new;
  
    print $trace->as_string; # like carp
  
    # from top (most recent) of stack to bottom.
    while (my $frame = $trace->next_frame) {
        print "Has args\n" if $frame->hasargs;
    }
  
    # from bottom (least recent) of stack to top.
    while (my $frame = $trace->prev_frame) {
        print "Sub: ", $frame->subroutine, "\n";
    }
  
  =head1 DESCRIPTION
  
  The Devel::StackTrace module contains two classes, Devel::StackTrace
  and Devel::StackTrace::Frame.  The goal of this object is to encapsulate
  the information that can found through using the caller() function, as
  well as providing a simple interface to this data.
  
  The Devel::StackTrace object contains a set of Devel::StackTrace::Frame
  objects, one for each level of the stack.  The frames contain all the
  data available from C<caller()>.
  
  This code was created to support my L<Exception::Class::Base> class
  (part of Exception::Class) but may be useful in other contexts.
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top'
  and 'bottom'.  In this context, the 'top' frame on the stack is the
  most recent frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo {
       bar();
    }
  
    sub bar {
       Devel::StackTrace->new;  # top frame is here.
    }
  
  =head1 Devel::StackTrace METHODS
  
  =over 4
  
  =item * Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 8
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the
  call to its its constructor.
  
  However, you may want to filter out some frames with more granularity
  than 'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data
  for each frame. This is a hash reference with two keys, "caller", and
  "args", both of which are array references. The "caller" key is the
  raw data as returned by Perl's C<caller()> function, and the "args"
  key are the subroutine arguments found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or
  false if it should be skipped.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on
  the stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages
  (or is the same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package'
  parameter, meaning that the Devel::StackTrace package is B<ALWAYS>
  ignored.  However, if you create a subclass of Devel::StackTrace it
  will not be ignored.
  
  =item * no_refs => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store
  references internally when generating stacktrace frames.  This lets
  your objects go out of scope.
  
  Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef()> to get
  the underlying string representation of an object, instead of
  respecting the object's stringification overloading.  If you would
  prefer to see the overloaded representation of objects in stack
  traces, then set this parameter to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for
  each subroutine call. Setting this parameter causes it to truncate the
  argument's string representation if it is longer than this number of
  characters.
  
  =item * message => $string
  
  By default, Devel::StackTrace will use 'Trace begun' as the message for the
  first stack frame when you call C<as_string>. You can supply an alternative
  message using this option.
  
  =item * indent => $boolean
  
  If this parameter is true, each stack frame after the first will start with a
  tab character, just like C<Carp::confess()>.
  
  =back
  
  =item * $trace->next_frame
  
  Returns the next Devel::StackTrace::Frame object down on the stack.  If
  it hasn't been called before it returns the first frame.  It returns
  undef when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<next_frame> or C<prev_frame> will work
  properly.
  
  =item * $trace->prev_frame
  
  Returns the next Devel::StackTrace::Frame object up on the stack.  If it
  hasn't been called before it returns the last frame.  It returns undef
  when it reaches the top of the stack and then resets its pointer so
  pointer so the next call to C<next_frame> or C<prev_frame> will work
  properly.
  
  =item * $trace->reset_pointer
  
  Resets the pointer so that the next call C<next_frame> or
  C<prev_frame> will start at the top or bottom of the stack, as
  appropriate.
  
  =item * $trace->frames
  
  Returns a list of Devel::StackTrace::Frame objects.  The order they are
  returned is from top (most recent) to bottom.
  
  =item * $trace->frame ($index)
  
  Given an index, returns the relevant frame or undef if there is not
  frame at that index.  The index is exactly like a Perl array.  The
  first frame is 0 and negative indexes are allowed.
  
  =item * $trace->frame_count
  
  Returns the number of frames in the trace object.
  
  =item * $trace->as_string
  
  Calls as_string on each frame from top to bottom, producing output
  quite similar to the Carp module's cluck/confess methods.
  
  =back
  
  =head1 SUPPORT
  
  Please submit bugs to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel%3A%3AStackTrace
  or via email at bug-devel-stacktrace@rt.cpan.org.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2011 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
  
  
  __END__
  
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/AsHTML.pm"} = <<'DEVEL_STACKTRACE_ASHTML';
  package Devel::StackTrace::AsHTML;
  
  use strict;
  use 5.008_001;
  our $VERSION = '0.11';
  
  use Data::Dumper;
  use Devel::StackTrace;
  use Scalar::Util;
  
  no warnings 'qw';
  my %enc = qw( & &amp; > &gt; < &lt; " &quot; ' &#39; );
  
  # NOTE: because we don't know which encoding $str is in, or even if
  # $str is a wide character (decoded strings), we just leave the low
  # bits, including latin-1 range and encode everything higher as HTML
  # entities. I know this is NOT always correct, but should mostly work
  # in case $str is encoded in utf-8 bytes or wide chars. This is a
  # necessary workaround since we're rendering someone else's code which
  # we can't enforce string encodings.
  
  sub encode_html {
      my $str = shift;
      $str =~ s/([^\x00-\x21\x23-\x25\x28-\x3b\x3d\x3f-\xff])/$enc{$1} || '&#' . ord($1) . ';' /ge;
      utf8::downgrade($str);
      $str;
  }
  
  sub Devel::StackTrace::as_html {
      __PACKAGE__->render(@_);
  }
  
  sub render {
      my $class = shift;
      my $trace = shift;
      my %opt   = @_;
  
      my $msg = encode_html($trace->frame(0)->as_string(1));
      my $out = qq{<!doctype html><head><title>Error: ${msg}</title>};
  
      $opt{style} ||= \<<STYLE;
  a.toggle { color: #444 }
  body { margin: 0; padding: 0; background: #fff; color: #000; }
  h1 { margin: 0 0 .5em; padding: .25em .5em .1em 1.5em; border-bottom: thick solid #002; background: #444; color: #eee; font-size: x-large; }
  pre.message { margin: .5em 1em; }
  li.frame { font-size: small; margin-top: 3em }
  li.frame:nth-child(1) { margin-top: 0 }
  pre.context { border: 1px solid #aaa; padding: 0.2em 0; background: #fff; color: #444; font-size: medium; }
  pre .match { color: #000;background-color: #f99; font-weight: bold }
  pre.vardump { margin:0 }
  pre code strong { color: #000; background: #f88; }
  
  table.lexicals, table.arguments { border-collapse: collapse }
  table.lexicals td, table.arguments td { border: 1px solid #000; margin: 0; padding: .3em }
  table.lexicals tr:nth-child(2n) { background: #DDDDFF }
  table.arguments tr:nth-child(2n) { background: #DDFFDD }
  .lexicals, .arguments { display: none }
  .variable, .value { font-family: monospace; white-space: pre }
  td.variable { vertical-align: top }
  STYLE
  
      if (ref $opt{style}) {
          $out .= qq(<style type="text/css">${$opt{style}}</style>);
      } else {
          $out .= qq(<link rel="stylesheet" type="text/css" href=") . encode_html($opt{style}) . q(" />);
      }
  
      $out .= <<HEAD;
  <script language="JavaScript" type="text/javascript">
  function toggleThing(ref, type, hideMsg, showMsg) {
   var css = document.getElementById(type+'-'+ref).style;
   css.display = css.display == 'block' ? 'none' : 'block';
  
   var hyperlink = document.getElementById('toggle-'+ref);
   hyperlink.textContent = css.display == 'block' ? hideMsg : showMsg;
  }
  
  function toggleArguments(ref) {
   toggleThing(ref, 'arguments', 'Hide function arguments', 'Show function arguments');
  }
  
  function toggleLexicals(ref) {
   toggleThing(ref, 'lexicals', 'Hide lexical variables', 'Show lexical variables');
  }
  </script>
  </head>
  <body>
  <h1>Error trace</h1><pre class="message">$msg</pre><ol>
  HEAD
  
      my $i = 0;
      while (my $frame = $trace->next_frame) {
          $i++;
          $out .= join(
              '',
              '<li class="frame">',
              $frame->subroutine ? encode_html("in " . $frame->subroutine) : '',
              ' at ',
              $frame->filename ? encode_html($frame->filename) : '',
              ' line ',
              $frame->line,
              q(<pre class="context"><code>),
              _build_context($frame) || '',
              q(</code></pre>),
              _build_arguments($i, [$frame->args]),
              $frame->can('lexicals') ? _build_lexicals($i, $frame->lexicals) : '',
              q(</li>),
          );
      }
      $out .= qq{</ol>};
      $out .= "</body></html>";
  
      $out;
  }
  
  my $dumper = sub {
      my $value = shift;
      $value = $$value if ref $value eq 'SCALAR' or ref $value eq 'REF';
      my $d = Data::Dumper->new([ $value ]);
      $d->Indent(1)->Terse(1)->Deparse(1);
      chomp(my $dump = $d->Dump);
      $dump;
  };
  
  sub _build_arguments {
      my($id, $args) = @_;
      my $ref = "arg-$id";
  
      return '' unless @$args;
  
      my $html = qq(<p><a class="toggle" id="toggle-$ref" href="javascript:toggleArguments('$ref')">Show function arguments</a></p><table class="arguments" id="arguments-$ref">);
  
      # Don't use while each since Dumper confuses that
      for my $idx (0 .. @$args - 1) {
          my $value = $args->[$idx];
          my $dump = $dumper->($value);
          $html .= qq{<tr>};
          $html .= qq{<td class="variable">\$_[$idx]</td>};
          $html .= qq{<td class="value">} . encode_html($dump) . qq{</td>};
          $html .= qq{</tr>};
      }
      $html .= qq(</table>);
  
      return $html;
  }
  
  sub _build_lexicals {
      my($id, $lexicals) = @_;
      my $ref = "lex-$id";
  
      return '' unless keys %$lexicals;
  
      my $html = qq(<p><a class="toggle" id="toggle-$ref" href="javascript:toggleLexicals('$ref')">Show lexical variables</a></p><table class="lexicals" id="lexicals-$ref">);
  
      # Don't use while each since Dumper confuses that
      for my $var (sort keys %$lexicals) {
          my $value = $lexicals->{$var};
          my $dump = $dumper->($value);
          $dump =~ s/^\{(.*)\}$/($1)/s if $var =~ /^\%/;
          $dump =~ s/^\[(.*)\]$/($1)/s if $var =~ /^\@/;
          $html .= qq{<tr>};
          $html .= qq{<td class="variable">} . encode_html($var)  . qq{</td>};
          $html .= qq{<td class="value">}    . encode_html($dump) . qq{</td>};
          $html .= qq{</tr>};
      }
      $html .= qq(</table>);
  
      return $html;
  }
  
  sub _build_context {
      my $frame = shift;
      my $file    = $frame->filename;
      my $linenum = $frame->line;
      my $code;
      if (-f $file) {
          my $start = $linenum - 3;
          my $end   = $linenum + 3;
          $start = $start < 1 ? 1 : $start;
          open my $fh, '<', $file
              or die "cannot open $file:$!";
          my $cur_line = 0;
          while (my $line = <$fh>) {
              ++$cur_line;
              last if $cur_line > $end;
              next if $cur_line < $start;
              $line =~ s|\t|        |g;
              my @tag = $cur_line == $linenum
                  ? (q{<strong class="match">}, '</strong>')
                      : ('', '');
              $code .= sprintf(
                  '%s%5d: %s%s', $tag[0], $cur_line, encode_html($line),
                  $tag[1],
              );
          }
          close $file;
      }
      return $code;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Devel::StackTrace::AsHTML - Displays stack trace in HTML
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace::AsHTML;
  
    my $trace = Devel::StackTrace->new;
    my $html  = $trace->as_html;
  
  =head1 DESCRIPTION
  
  Devel::StackTrace::AsHTML adds C<as_html> method to L<Devel::StackTrace> which
  displays the stack trace in beautiful HTML, with code snippet context and
  function parameters. If you call it on an instance of
  L<Devel::StackTrace::WithLexicals>, you even get to see the lexical variables
  of each stack frame.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt>
  
  Shawn M Moore
  
  HTML generation code is ripped off from L<CGI::ExceptionManager> written by Tokuhiro Matsuno and Kazuho Oku.
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace> L<Devel::StackTrace::WithLexicals> L<CGI::ExceptionManager>
  
  =cut
DEVEL_STACKTRACE_ASHTML

$fatpacked{"Devel/StackTrace/Frame.pm"} = <<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;
  BEGIN {
    $Devel::StackTrace::Frame::VERSION = '1.27';
  }
  
  use strict;
  use warnings;
  
  # Create accessor routines
  BEGIN {
      no strict 'refs';
      foreach my $f (
          qw( package filename line subroutine hasargs
          wantarray evaltext is_require hints bitmask args )
          ) {
          next if $f eq 'args';
          *{$f} = sub { my $s = shift; return $s->{$f} };
      }
  }
  
  {
      my @fields = (
          qw( package filename line subroutine hasargs wantarray
              evaltext is_require hints bitmask )
      );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{$self}{@fields} = @{ shift() };
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          $self->{args} = shift;
  
          $self->{respect_overload} = shift;
  
          $self->{max_arg_length} = shift;
  
          $self->{message} = shift;
  
          $self->{indent} = shift;
  
          return $self;
      }
  }
  
  sub args {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string {
      my $self  = shift;
      my $first = shift;
  
      my $sub = $self->subroutine;
  
      # This code stolen straight from Carp.pm and then tweaked.  All
      # errors are probably my fault  -dave
      if ($first) {
          $sub
              = defined $self->{message}
              ? $self->{message}
              : 'Trace begun';
      }
      else {
  
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if ( my $eval = $self->evaltext ) {
              if ( $self->is_require ) {
                  $sub = "require $eval";
              }
              else {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ( $sub eq '(eval)' ) {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args ) {
              for (@a) {
  
                  # set args to the string "undef" if undefined
                  $_ = "undef", next unless defined $_;
  
                  # hack!
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
  
                  local $SIG{__DIE__};
                  local $@;
  
                  eval {
                      if ( $self->{max_arg_length}
                          && length $_ > $self->{max_arg_length} ) {
                          substr( $_, $self->{max_arg_length} ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
  
                  if ( my $e = $@ ) {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join( ', ', @a ) . ')';
              $sub .= ' called';
          }
      }
  
      # If the user opted into indentation (a la Carp::confess), pre-add a tab
      my $tab = $self->{indent} && !$first ? "\t" : q{};
  
      return "${tab}$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  # ABSTRACT: A single frame in a stack trace
  
  
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace::Frame - A single frame in a stack trace
  
  =head1 VERSION
  
  version 1.27
  
  =head1 DESCRIPTION
  
  See L<Devel::StackTrace> for details.
  
  =head1 METHODS
  
  See the L<caller> documentation for more information on what these
  methods return.
  
  =over 4
  
  =item * $frame->package
  
  =item * $frame->filename
  
  =item * $frame->line
  
  =item * $frame->subroutine
  
  =item * $frame->hasargs
  
  =item * $frame->wantarray
  
  =item * $frame->evaltext
  
  Returns undef if the frame was not part of an eval.
  
  =item * $frame->is_require
  
  Returns undef if the frame was not part of a require.
  
  =item * $frame->args
  
  Returns the arguments passed to the frame.  Note that any arguments
  that are references are returned as references, not copies.
  
  =item * $frame->hints
  
  =item * $frame->bitmask
  
  =back
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2011 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
  
  
  __END__
  
DEVEL_STACKTRACE_FRAME

$fatpacked{"Fliggy.pm"} = <<'FLIGGY';
  package Fliggy;
  
  use strict;
  use warnings;
  
  use 5.008_001;
  
  our $VERSION = '0.009003';
  
  1;
  __END__
  
  =head1 NAME
  
  Fliggy - Twiggy with inlined Flash Policy Server
  
  =head1 SYNOPSIS
  
    fliggy --listen :8080
  
  See C<fliggy -h> for more details.
  
    use Fliggy::Server;
  
    my $server = Fliggy::Server->new(
        host => $host,
        port => $port,
    );
    $server->register_service($app);
  
    AE::cv->recv;
  
  =head1 DESCRIPTION
  
  Fliggy inherits Twiggy and adds support for inlined Flash Policy server (useful
  for L<Plack::Middleware::SocketIO> or Flash WebSocket fallback).
  
  No need to run Flash Policy server as root on 843 port!
  
  Usage is exactly the same as L<Twiggy>, whenever you run C<twiggy> command, replace it
  with C<fliggy> and you're ready to go.
  
  =head1 SEE ALSO
  
  L<Plack> L<AnyEvent> L<Twiggy>
  
  =cut
  
  =head1 DEVELOPMENT
  
  =head2 Repository
  
      http://github.com/vti/fliggy
  
  =head1 AUTHOR
  
  Viacheslav Tykhanovskyi, C<vti@cpan.org>.
  
  =head1 CREDITS
  
  L<Twiggy> authors.
  
  Johannes Plunien (plu)
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2011, Viacheslav Tykhanovskyi
  
  This program is free software, you can redistribute it and/or modify it under
  the terms of the Artistic License version 2.0.
  
  =cut
FLIGGY

$fatpacked{"Fliggy/Server.pm"} = <<'FLIGGY_SERVER';
  package Fliggy::Server;
  
  use strict;
  use warnings;
  
  BEGIN {
      $ENV{TWIGGY_DEBUG} = $ENV{FLIGGY_DEBUG} || 0;
  }
  
  use base 'Twiggy::Server';
  
  use Errno qw(EAGAIN EINTR);
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  
  use constant DEBUG => $ENV{FLIGGY_DEBUG};
  
  # Copied from Twiggy::Server (can't stand copypasting, but this is the only way)
  sub _try_read_headers {
      my ($self, $sock, undef) = @_;
  
      # FIXME add a timer to manage read timeouts
      local $/ = "\012";
  
    read_more: for my $headers ($_[2]) {
          if ($headers eq '') {
              my $buf = $self->_safe_read($sock, 1);
              return unless defined $buf;
  
              if ($buf eq '<') {
                  $buf = $self->_safe_read($sock, 22);
                  return unless defined $buf;
  
                  if ($buf eq "policy-file-request/>\0") {
                      DEBUG && warn "Flash policy request\n";
                      $self->_write_flash_policy_response($sock);
                      die;
                  }
                  else {
                      $headers .= $buf;
                  }
              }
              else {
                  $headers .= $buf;
              }
          }
  
          if (defined(my $line = <$sock>)) {
              $headers .= $line;
  
              if ($line eq "\015\012" or $line eq "\012") {
  
                  # got an empty line, we're done reading the headers
                  return 1;
              }
              else {
  
                  # try to read more lines using buffered IO
                  redo read_more;
              }
          }
          elsif ($! and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              die $!;
          }
          elsif (!$!) {
              die "client disconnected";
          }
      }
  
      DEBUG
        && warn
        "$sock did not read to end of req, wait for more data to arrive\n";
      return;
  }
  
  sub _write_flash_policy_response {
      my ($self, $sock) = @_;
  
      return unless defined $sock and defined fileno $sock;
  
      # FIXME restrict domain and ports
      my $body = <<"EOF";
  <?xml version="1.0"?>
  <!DOCTYPE cross-domain-policy SYSTEM "/xml/dtds/cross-domain-policy.dtd">
  <cross-domain-policy>
  <site-control permitted-cross-domain-policies="master-only"/>
  <allow-access-from domain="*" to-ports="*" secure="false"/>
  </cross-domain-policy>
  EOF
  
      my $cv = AE::cv;
  
      # From _write_psgi_response
      $self->_write_body($sock, [$body])->cb(
          sub {
              shutdown $sock, 1;
              close $sock;
              $self->{exit_guard}->end;
              local $@;
              eval { $cv->send($_[0]->recv); 1 } or $cv->croak($@);
          }
      );
  
      return;
  }
  
  sub _safe_read {
      my $self = shift;
      my ($sock, $size) = @_;
  
      my $rcount = sysread($sock, my $buf, $size);
  
      # $rcount contains number of bytes read, 0 at end of file
      if (defined $rcount && $rcount == 0) {
          die "client disconnected";
      }
  
      if (!defined $buf || !defined $rcount) {
          if ($! and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              die $!;
          }
          elsif (!$!) {
              die "client disconnected (unknown error)";
          }
  
          return;
      }
  
      return unless $rcount == $size;
  
      return $buf;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Fliggy::Server - Fliggy implementation
  
  =head1 DESCRIPTION
  
  This is an actual L<Fliggy> implementation.
  
  =head1 SEE ALSO
  
  L<Fliggy> L<Twiggy>
  
  =cut
FLIGGY_SERVER

$fatpacked{"HTTP/Body.pm"} = <<'HTTP_BODY';
  package HTTP::Body;
  {
    $HTTP::Body::VERSION = '1.15';
  }
  
  use strict;
  
  use Carp       qw[ ];
  
  our $TYPES = {
      'application/octet-stream'          => 'HTTP::Body::OctetStream',
      'application/x-www-form-urlencoded' => 'HTTP::Body::UrlEncoded',
      'multipart/form-data'               => 'HTTP::Body::MultiPart',
      'multipart/related'                 => 'HTTP::Body::XFormsMultipart',
      'application/xml'                   => 'HTTP::Body::XForms'
  };
  
  require HTTP::Body::OctetStream;
  require HTTP::Body::UrlEncoded;
  require HTTP::Body::MultiPart;
  require HTTP::Body::XFormsMultipart;
  require HTTP::Body::XForms;
  
  use HTTP::Headers;
  use HTTP::Message;
  
  =head1 NAME
  
  HTTP::Body - HTTP Body Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body;
      
      sub handler : method {
          my ( $class, $r ) = @_;
  
          my $content_type   = $r->headers_in->get('Content-Type');
          my $content_length = $r->headers_in->get('Content-Length');
          
          my $body   = HTTP::Body->new( $content_type, $content_length );
          my $length = $content_length;
  
          while ( $length ) {
  
              $r->read( my $buffer, ( $length < 8192 ) ? $length : 8192 );
  
              $length -= length($buffer);
              
              $body->add($buffer);
          }
          
          my $uploads     = $body->upload;     # hashref
          my $params      = $body->param;      # hashref
          my $param_order = $body->param_order # arrayref
          my $body        = $body->body;       # IO::Handle
      }
  
  =head1 DESCRIPTION
  
  HTTP::Body parses chunks of HTTP POST data and supports 
  application/octet-stream, application/x-www-form-urlencoded, and
  multipart/form-data.
  
  Chunked bodies are supported by not passing a length value to new().
  
  It is currently used by L<Catalyst> to parse POST bodies.
  
  =head1 NOTES
  
  When parsing multipart bodies, temporary files are created to store any
  uploaded files.  You must delete these temporary files yourself after
  processing them, or set $body->cleanup(1) to automatically delete them
  at DESTROY-time.
  
  =head1 METHODS
  
  =over 4 
  
  =item new 
  
  Constructor. Takes content type and content length as parameters,
  returns a L<HTTP::Body> object.
  
  =cut
  
  sub new {
      my ( $class, $content_type, $content_length ) = @_;
  
      unless ( @_ >= 2 ) {
          Carp::croak( $class, '->new( $content_type, [ $content_length ] )' );
      }
  
      my $type;
      foreach my $supported ( keys %{$TYPES} ) {
          if ( index( lc($content_type), $supported ) >= 0 ) {
              $type = $supported;
          }
      }
  
      my $body = $TYPES->{ $type || 'application/octet-stream' };
  
      my $self = {
          cleanup        => 0,
          buffer         => '',
          chunk_buffer   => '',
          body           => undef,
          chunked        => !defined $content_length,
          content_length => defined $content_length ? $content_length : -1,
          content_type   => $content_type,
          length         => 0,
          param          => {},
          param_order    => [],
          state          => 'buffering',
          upload         => {},
          tmpdir         => File::Spec->tmpdir(),
      };
  
      bless( $self, $body );
  
      return $self->init;
  }
  
  sub DESTROY {
      my $self = shift;
      
      if ( $self->{cleanup} ) {
          my @temps = ();
          for my $upload ( values %{ $self->{upload} } ) {
              push @temps, map { $_->{tempname} || () }
                  ( ref $upload eq 'ARRAY' ? @{$upload} : $upload );
          }
          
          unlink map { $_ } grep { -e $_ } @temps;
      }
  }
  
  =item add
  
  Add string to internal buffer. Will call spin unless done. returns
  length before adding self.
  
  =cut
  
  sub add {
      my $self = shift;
      
      if ( $self->{chunked} ) {
          $self->{chunk_buffer} .= $_[0];
          
          while ( $self->{chunk_buffer} =~ m/^([\da-fA-F]+).*\x0D\x0A/ ) {
              my $chunk_len = hex($1);
              
              if ( $chunk_len == 0 ) {
                  # Strip chunk len
                  $self->{chunk_buffer} =~ s/^([\da-fA-F]+).*\x0D\x0A//;
                  
                  # End of data, there may be trailing headers
                  if (  my ($headers) = $self->{chunk_buffer} =~ m/(.*)\x0D\x0A/s ) {
                      if ( my $message = HTTP::Message->parse( $headers ) ) {
                          $self->{trailing_headers} = $message->headers;
                      }
                  }
                  
                  $self->{chunk_buffer} = '';
                  
                  # Set content_length equal to the amount of data we read,
                  # so the spin methods can finish up.
                  $self->{content_length} = $self->{length};
              }
              else {
                  # Make sure we have the whole chunk in the buffer (+CRLF)
                  if ( length( $self->{chunk_buffer} ) >= $chunk_len ) {
                      # Strip chunk len
                      $self->{chunk_buffer} =~ s/^([\da-fA-F]+).*\x0D\x0A//;
                      
                      # Pull chunk data out of chunk buffer into real buffer
                      $self->{buffer} .= substr $self->{chunk_buffer}, 0, $chunk_len, '';
                  
                      # Strip remaining CRLF
                      $self->{chunk_buffer} =~ s/^\x0D\x0A//;
                  
                      $self->{length} += $chunk_len;
                  }
                  else {
                      # Not enough data for this chunk, wait for more calls to add()
                      return;
                  }
              }
              
              unless ( $self->{state} eq 'done' ) {
                  $self->spin;
              }
          }
          
          return;
      }
      
      my $cl = $self->content_length;
  
      if ( defined $_[0] ) {
          $self->{length} += length( $_[0] );
          
          # Don't allow buffer data to exceed content-length
          if ( $self->{length} > $cl ) {
              $_[0] = substr $_[0], 0, $cl - $self->{length};
              $self->{length} = $cl;
          }
          
          $self->{buffer} .= $_[0];
      }
  
      unless ( $self->state eq 'done' ) {
          $self->spin;
      }
  
      return ( $self->length - $cl );
  }
  
  =item body
  
  accessor for the body.
  
  =cut
  
  sub body {
      my $self = shift;
      $self->{body} = shift if @_;
      return $self->{body};
  }
  
  =item chunked
  
  Returns 1 if the request is chunked.
  
  =cut
  
  sub chunked {
      return shift->{chunked};
  }
  
  =item cleanup
  
  Set to 1 to enable automatic deletion of temporary files at DESTROY-time.
  
  =cut
  
  sub cleanup {
      my $self = shift;
      $self->{cleanup} = shift if @_;
      return $self->{cleanup};
  }
  
  =item content_length
  
  Returns the content-length for the body data if known.
  Returns -1 if the request is chunked.
  
  =cut
  
  sub content_length {
      return shift->{content_length};
  }
  
  =item content_type
  
  Returns the content-type of the body data.
  
  =cut
  
  sub content_type {
      return shift->{content_type};
  }
  
  =item init
  
  return self.
  
  =cut
  
  sub init {
      return $_[0];
  }
  
  =item length
  
  Returns the total length of data we expect to read if known.
  In the case of a chunked request, returns the amount of data
  read so far.
  
  =cut
  
  sub length {
      return shift->{length};
  }
  
  =item trailing_headers
  
  If a chunked request body had trailing headers, trailing_headers will
  return an HTTP::Headers object populated with those headers.
  
  =cut
  
  sub trailing_headers {
      return shift->{trailing_headers};
  }
  
  =item spin
  
  Abstract method to spin the io handle.
  
  =cut
  
  sub spin {
      Carp::croak('Define abstract method spin() in implementation');
  }
  
  =item state
  
  Returns the current state of the parser.
  
  =cut
  
  sub state {
      my $self = shift;
      $self->{state} = shift if @_;
      return $self->{state};
  }
  
  =item param
  
  Get/set body parameters.
  
  =cut
  
  sub param {
      my $self = shift;
  
      if ( @_ == 2 ) {
  
          my ( $name, $value ) = @_;
  
          if ( exists $self->{param}->{$name} ) {
              for ( $self->{param}->{$name} ) {
                  $_ = [$_] unless ref($_) eq "ARRAY";
                  push( @$_, $value );
              }
          }
          else {
              $self->{param}->{$name} = $value;
          }
  
          push @{$self->{param_order}}, $name;
      }
  
      return $self->{param};
  }
  
  =item upload
  
  Get/set file uploads.
  
  =cut
  
  sub upload {
      my $self = shift;
  
      if ( @_ == 2 ) {
  
          my ( $name, $upload ) = @_;
  
          if ( exists $self->{upload}->{$name} ) {
              for ( $self->{upload}->{$name} ) {
                  $_ = [$_] unless ref($_) eq "ARRAY";
                  push( @$_, $upload );
              }
          }
          else {
              $self->{upload}->{$name} = $upload;
          }
      }
  
      return $self->{upload};
  }
  
  =item tmpdir 
  
  Specify a different path for temporary files.  Defaults to the system temporary path.
  
  =cut
  
  sub tmpdir {
      my $self = shift;
      $self->{tmpdir} = shift if @_;
      return $self->{tmpdir};
  }
  
  =item param_order
  
  Returns the array ref of the param keys in the order how they appeared on the body
  
  =cut
  
  sub param_order {
      return shift->{param_order};
  }
  
  =back
  
  =head1 SUPPORT
  
  Since its original creation this module has been taken over by the Catalyst
  development team. If you want to contribute patches, these will be your
  primary contact points:
  
  IRC:
  
      Join #catalyst-dev on irc.perl.org.
  
  Mailing Lists:
  
      http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/catalyst-dev
  
  =head1 AUTHOR
  
  Christian Hansen, C<chansen@cpan.org>
  
  Sebastian Riedel, C<sri@cpan.org>
  
  Andy Grundman, C<andy@hybridized.org>
  
  =head1 CONTRIBUTORS
  
  Simon Elliott C<cpan@papercreatures.com>
  
  Kent Fredric <kentnl@cpan.org>
  
  Christian Walde
  
  Torsten Raudssus <torsten@raudssus.de>
  
  =head1 LICENSE
  
  This library is free software. You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY

$fatpacked{"HTTP/Body/MultiPart.pm"} = <<'HTTP_BODY_MULTIPART';
  package HTTP::Body::MultiPart;
  {
    $HTTP::Body::MultiPart::VERSION = '1.15';
  }
  
  use strict;
  use base 'HTTP::Body';
  use bytes;
  
  use IO::File;
  use File::Temp 0.14;
  use File::Spec;
  
  =head1 NAME
  
  HTTP::Body::MultiPart - HTTP Body Multipart Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::Multipart;
  
  =head1 DESCRIPTION
  
  HTTP Body Multipart Parser.
  
  =head1 METHODS
  
  =over 4
  
  =item init
  
  =cut
  
  sub init {
      my $self = shift;
  
      unless ( $self->content_type =~ /boundary=\"?([^\";]+)\"?/ ) {
          my $content_type = $self->content_type;
          Carp::croak("Invalid boundary in content_type: '$content_type'");
      }
  
      $self->{boundary} = $1;
      $self->{state}    = 'preamble';
  
      return $self;
  }
  
  =item spin
  
  =cut
  
  sub spin {
      my $self = shift;
  
      while (1) {
  
          if ( $self->{state} =~ /^(preamble|boundary|header|body)$/ ) {
              my $method = "parse_$1";
              return unless $self->$method;
          }
  
          else {
              Carp::croak('Unknown state');
          }
      }
  }
  
  =item boundary
  
  =cut
  
  sub boundary {
      return shift->{boundary};
  }
  
  =item boundary_begin
  
  =cut
  
  sub boundary_begin {
      return "--" . shift->boundary;
  }
  
  =item boundary_end
  
  =cut
  
  sub boundary_end {
      return shift->boundary_begin . "--";
  }
  
  =item crlf
  
  =cut
  
  sub crlf () {
      return "\x0d\x0a";
  }
  
  =item delimiter_begin
  
  =cut
  
  sub delimiter_begin {
      my $self = shift;
      return $self->crlf . $self->boundary_begin;
  }
  
  =item delimiter_end
  
  =cut
  
  sub delimiter_end {
      my $self = shift;
      return $self->crlf . $self->boundary_end;
  }
  
  =item parse_preamble
  
  =cut
  
  sub parse_preamble {
      my $self = shift;
  
      my $index = index( $self->{buffer}, $self->boundary_begin );
  
      unless ( $index >= 0 ) {
          return 0;
      }
  
      # replace preamble with CRLF so we can match dash-boundary as delimiter
      substr( $self->{buffer}, 0, $index, $self->crlf );
  
      $self->{state} = 'boundary';
  
      return 1;
  }
  
  =item parse_boundary
  
  =cut
  
  sub parse_boundary {
      my $self = shift;
  
      if ( index( $self->{buffer}, $self->delimiter_begin . $self->crlf ) == 0 ) {
  
          substr( $self->{buffer}, 0, length( $self->delimiter_begin ) + 2, '' );
          $self->{part}  = {};
          $self->{state} = 'header';
  
          return 1;
      }
  
      if ( index( $self->{buffer}, $self->delimiter_end . $self->crlf ) == 0 ) {
  
          substr( $self->{buffer}, 0, length( $self->delimiter_end ) + 2, '' );
          $self->{part}  = {};
          $self->{state} = 'done';
  
          return 0;
      }
  
      return 0;
  }
  
  =item parse_header
  
  =cut
  
  sub parse_header {
      my $self = shift;
  
      my $crlf  = $self->crlf;
      my $index = index( $self->{buffer}, $crlf . $crlf );
  
      unless ( $index >= 0 ) {
          return 0;
      }
  
      my $header = substr( $self->{buffer}, 0, $index );
  
      substr( $self->{buffer}, 0, $index + 4, '' );
  
      my @headers;
      for ( split /$crlf/, $header ) {
          if (s/^[ \t]+//) {
              $headers[-1] .= $_;
          }
          else {
              push @headers, $_;
          }
      }
  
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
  
      for my $header (@headers) {
  
          $header =~ s/^($token):[\t ]*//;
  
          ( my $field = $1 ) =~ s/\b(\w)/uc($1)/eg;
  
          if ( exists $self->{part}->{headers}->{$field} ) {
              for ( $self->{part}->{headers}->{$field} ) {
                  $_ = [$_] unless ref($_) eq "ARRAY";
                  push( @$_, $header );
              }
          }
          else {
              $self->{part}->{headers}->{$field} = $header;
          }
      }
  
      $self->{state} = 'body';
  
      return 1;
  }
  
  =item parse_body
  
  =cut
  
  sub parse_body {
      my $self = shift;
  
      my $index = index( $self->{buffer}, $self->delimiter_begin );
  
      if ( $index < 0 ) {
  
          # make sure we have enough buffer to detect end delimiter
          my $length = length( $self->{buffer} ) - ( length( $self->delimiter_end ) + 2 );
  
          unless ( $length > 0 ) {
              return 0;
          }
  
          $self->{part}->{data} .= substr( $self->{buffer}, 0, $length, '' );
          $self->{part}->{size} += $length;
          $self->{part}->{done} = 0;
  
          $self->handler( $self->{part} );
  
          return 0;
      }
  
      $self->{part}->{data} .= substr( $self->{buffer}, 0, $index, '' );
      $self->{part}->{size} += $index;
      $self->{part}->{done} = 1;
  
      $self->handler( $self->{part} );
  
      $self->{state} = 'boundary';
  
      return 1;
  }
  
  =item handler
  
  =cut
  
  sub handler {
      my ( $self, $part ) = @_;
  
      unless ( exists $part->{name} ) {
  
          my $disposition = $part->{headers}->{'Content-Disposition'};
          my ($name)      = $disposition =~ / name="?([^\";]+)"?/;
          my ($filename)  = $disposition =~ / filename="?([^\"]*)"?/;
          # Need to match empty filenames above, so this part is flagged as an upload type
  
          $part->{name} = $name;
  
          if ( defined $filename ) {
              $part->{filename} = $filename;
  
              if ( $filename ne "" ) {
                  my $basename = (File::Spec->splitpath($filename))[2];
                  my $suffix = $basename =~ /[^.]+(\.[^\\\/]+)$/ ? $1 : q{};
  
                  my $fh = File::Temp->new( UNLINK => 0, DIR => $self->tmpdir, SUFFIX => $suffix );
  
                  $part->{fh}       = $fh;
                  $part->{tempname} = $fh->filename;
              }
          }
      }
  
      if ( $part->{fh} && ( my $length = length( $part->{data} ) ) ) {
          $part->{fh}->write( substr( $part->{data}, 0, $length, '' ), $length );
      }
  
      if ( $part->{done} ) {
  
          if ( exists $part->{filename} ) {
              if ( $part->{filename} ne "" ) {
                  $part->{fh}->close if defined $part->{fh};
  
                  delete @{$part}{qw[ data done fh ]};
  
                  $self->upload( $part->{name}, $part );
              }
          }
          else {
              $self->param( $part->{name}, $part->{data} );
          }
      }
  }
  
  =back
  
  =head1 AUTHOR
  
  Christian Hansen, C<ch@ngmedia.com>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_MULTIPART

$fatpacked{"HTTP/Body/OctetStream.pm"} = <<'HTTP_BODY_OCTETSTREAM';
  package HTTP::Body::OctetStream;
  {
    $HTTP::Body::OctetStream::VERSION = '1.15';
  }
  
  use strict;
  use base 'HTTP::Body';
  use bytes;
  
  use File::Temp 0.14;
  
  =head1 NAME
  
  HTTP::Body::OctetStream - HTTP Body OctetStream Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::OctetStream;
  
  =head1 DESCRIPTION
  
  HTTP Body OctetStream Parser.
  
  =head1 METHODS
  
  =over 4
  
  =item spin
  
  =cut
  
  sub spin {
      my $self = shift;
  
      unless ( $self->body ) {
          $self->body( File::Temp->new( DIR => $self->tmpdir ) );
      }
  
      if ( my $length = length( $self->{buffer} ) ) {
          $self->body->write( substr( $self->{buffer}, 0, $length, '' ), $length );
      }
  
      if ( $self->length == $self->content_length ) {
          seek( $self->body, 0, 0 );
          $self->state('done');
      }
  }
  
  =back
  
  =head1 AUTHOR
  
  Christian Hansen, C<ch@ngmedia.com>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_OCTETSTREAM

$fatpacked{"HTTP/Body/UrlEncoded.pm"} = <<'HTTP_BODY_URLENCODED';
  package HTTP::Body::UrlEncoded;
  {
    $HTTP::Body::UrlEncoded::VERSION = '1.15';
  }
  
  use strict;
  use base 'HTTP::Body';
  use bytes;
  
  our $DECODE = qr/%([0-9a-fA-F]{2})/;
  
  our %hex_chr;
  
  for my $num ( 0 .. 255 ) {
      my $h = sprintf "%02X", $num;
      $hex_chr{ lc $h } = $hex_chr{ uc $h } = chr $num;
  }
  
  =head1 NAME
  
  HTTP::Body::UrlEncoded - HTTP Body UrlEncoded Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::UrlEncoded;
  
  =head1 DESCRIPTION
  
  HTTP Body UrlEncoded Parser.
  
  =head1 METHODS
  
  =over 4
  
  =item spin
  
  =cut
  
  sub spin {
      my $self = shift;
  
      return unless $self->length == $self->content_length;
      
      # I tested parsing this using APR::Request, but perl is faster
      # Pure-Perl    2560/s
      # APR::Request 2305/s
      
      # Note: s/// appears faster than tr///
      $self->{buffer} =~ s/\+/ /g;
  
      for my $pair ( split( /[&;](?:\s+)?/, $self->{buffer} ) ) {
  
          my ( $name, $value ) = split( /=/, $pair , 2 );
  
          next unless defined $name;
          next unless defined $value;
          
          $name  =~ s/$DECODE/$hex_chr{$1}/gs;
          $value =~ s/$DECODE/$hex_chr{$1}/gs;
  
          $self->param( $name, $value );
      }
  
      $self->{buffer} = '';
      $self->{state}  = 'done';
  }
  
  =back
  
  =head1 AUTHORS
  
  Christian Hansen, C<ch@ngmedia.com>
  
  Andy Grundman, C<andy@hybridized.org>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_URLENCODED

$fatpacked{"HTTP/Body/XForms.pm"} = <<'HTTP_BODY_XFORMS';
  package HTTP::Body::XForms;
  {
    $HTTP::Body::XForms::VERSION = '1.15';
  }
  
  use strict;
  use base 'HTTP::Body';
  use bytes;
  
  use File::Temp 0.14;
  
  =head1 NAME
  
  HTTP::Body::XForms - HTTP Body XForms Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::XForms;
  
  =head1 DESCRIPTION
  
  HTTP Body XForms Parser. This module parses single part XForms
  submissions, which are identifiable by the content-type
  application/xml. The XML is stored unparsed on the parameter
  XForms:Model.
  
  =head1 METHODS
  
  =over 4
  
  =item spin
  
  This method is overwrited to set the param XForms:Model with
  the buffer content.
  
  =cut
  
  sub spin {
      my $self = shift;
  
      return unless $self->length == $self->content_length;
  
      $self->body($self->{buffer});
      $self->param( 'XForms:Model', $self->{buffer} );
      $self->{buffer} = '';
      $self->{state}  = 'done';
  
      return $self->SUPER::init();
  }
  
  =back
  
  =head1 AUTHOR
  
  Daniel Ruoso, C<daniel@ruoso.com>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_XFORMS

$fatpacked{"HTTP/Body/XFormsMultipart.pm"} = <<'HTTP_BODY_XFORMSMULTIPART';
  package HTTP::Body::XFormsMultipart;
  {
    $HTTP::Body::XFormsMultipart::VERSION = '1.15';
  }
  
  use strict;
  use base 'HTTP::Body::MultiPart';
  use bytes;
  
  use IO::File;
  use File::Temp 0.14;
  
  =head1 NAME
  
  HTTP::Body::XFormsMultipart - HTTP Body XForms multipart/related submission Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::XForms;
  
  =head1 DESCRIPTION
  
  HTTP Body XForms submission Parser. Inherits HTTP::Body::MultiPart.
  
  This body type is used to parse XForms submission. In this case, the
  XML part that contains the model is indicated by the start attribute
  in the content-type. The XML content is stored unparsed on the
  parameter XForms:Model.
  
  =head1 METHODS
  
  =over 4
  
  =item init
  
  This function is overrided to detect the start part of the
  multipart/related post.
  
  =cut
  
  sub init {
      my $self = shift;
      $self->SUPER::init(@_);
      unless ( $self->content_type =~ /start=\"?\<?([^\"\>;,]+)\>?\"?/ ) {
          my $content_type = $self->content_type;
          Carp::croak( "Invalid boundary in content_type: '$content_type'" );
      }
      
      $self->{start} = $1;
  
      return $self;
  }
  
  =item start
  
  Defines the start part of the multipart/related body.
  
  =cut
  
  sub start {
      return shift->{start};
  }
  
  =item handler
  
  This function is overrided to differ the start part, which should be
  set as the XForms:Model param if its content type is application/xml.
  
  =cut
  
  sub handler {
      my ( $self, $part ) = @_;
  
      my $contentid = $part->{headers}{'Content-ID'};
      $contentid =~ s/^.*[\<\"]//;
      $contentid =~ s/[\>\"].*$//;
      
      if ( $contentid eq $self->start ) {
          $part->{name} = 'XForms:Model';
          if ($part->{done}) {
              $self->body($part->{data});
          }
      }
      elsif ( defined $contentid ) {
          $part->{name}     = $contentid;
          $part->{filename} = $contentid;
      }
  
      return $self->SUPER::handler($part);
  }
  
  =back
  
  =head1 AUTHOR
  
  Daniel Ruoso C<daniel@ruoso.com>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_XFORMSMULTIPART

$fatpacked{"HTTP/Config.pm"} = <<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use URI;
  use vars qw($VERSION);
  
  $VERSION = "6.00";
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          return 1 if $request->header($k) eq $v;
          return 1 if $response && $response->header($k) eq $v;
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuation object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 2008, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_CONFIG

$fatpacked{"HTTP/Date.pm"} = <<'HTTP_DATE';
  package HTTP::Date;
  
  $VERSION = "6.00";
  
  require 5.004;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(time2str str2time);
  @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  use strict;
  require Time::Local;
  
  use vars qw(@DoW @MoY %MoY);
  @DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = (1..12);
  
  my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);
  
  
  sub time2str (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
      sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
  	    $DoW[$wday],
  	    $mday, $MoY[$mon], $year+1900,
  	    $hour, $min, $sec);
  }
  
  
  sub str2time ($;$)
  {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
  	return eval {
  	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
  	    $t < 0 ? undef : $t;
  	};
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;        # month
  
      my $tz = pop(@d);
      unless (defined $tz) {
  	unless (defined($tz = shift)) {
  	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  			  my $t = Time::Local::timelocal(reverse @d) + $frac;
  			  $t < 0 ? undef : $t;
  		        };
  	}
      }
  
      my $offset = 0;
      if ($GMT_ZONE{uc $tz}) {
  	# offset already zero
      }
      elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
  	$offset = 3600 * $2;
  	$offset += 60 * $3 if $3;
  	$offset *= -1 if $1 && $1 eq '-';
      }
      else {
  	eval { require Time::Zone } || return undef;
  	$offset = Time::Zone::tz_offset($tz);
  	return undef unless defined $offset;
      }
  
      return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  		  my $t = Time::Local::timegm(reverse @d) + $frac;
  		  $t < 0 ? undef : $t - $offset;
  		};
  }
  
  
  sub parse_date ($)
  {
      local($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;  # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday
  
      my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);
  
      # Then we are able to check for most of the formats with this regexp
      (($day,$mon,$yr,$hr,$min,$sec,$tz) =
          /^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\))?	       # ASCII representation of timezone in parens.
  	    \s*$
  	/x)
  
      ||
  
      # Try the ctime and asctime format
      (($mon, $day, $hr, $min, $sec, $tz, $yr) =
  	/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)
  
      ||
  
      # Then the Unix 'ls -l' date format
      (($mon, $day, $yr, $hr, $min, $sec) =
  	/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)
  
      ||
  
      # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
      (($yr, $mon, $day, $hr, $min, $sec, $tz) =
  	/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)
  
      ||
  
      # Windows 'dir' 11-12-96  03:52PM
      (($mon, $day, $yr, $hr, $min, $ampm) =
          /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)
  
      ||
      return;  # unrecognized format
  
      # Translate month name to number
      $mon = $MoY{$mon} ||
             $MoY{"\u\L$mon"} ||
  	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
             return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless (defined $yr) {
  	my $cur_mon;
  	($cur_mon, $yr) = (localtime)[4, 5];
  	$yr += 1900;
  	$cur_mon++;
  	$yr-- if $mon > $cur_mon;
      }
      elsif (length($yr) < 3) {
  	# Find "obvious" year
  	my $cur_yr = (localtime)[5] + 1900;
  	my $m = $cur_yr % 100;
  	my $tmp = $yr;
  	$yr += $cur_yr - $m;
  	$m -= $tmp;
  	$yr += ($m > 0) ? 100 : -100
  	    if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
  	$ampm = uc $ampm;
  	$hr = 0 if $hr == 12 && $ampm eq 'AM';
  	$hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return($yr, $mon, $day, $hr, $min, $sec, $tz)
  	if wantarray;
  
      if (defined $tz) {
  	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
  	$tz = "";
      }
      return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
  		   $yr, $mon, $day, $hr, $min, $sec, $tz);
  }
  
  
  sub time2iso (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02d",
  	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  
  sub time2isoz (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
              $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Date - date conversion routines
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  returned will B<not> have the number 1900 subtracted from it and the
  $month numbers start with 1.
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned.
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_DATE

$fatpacked{"HTTP/Headers.pm"} = <<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use Carp ();
  
  use vars qw($VERSION $TRANSLATE_UNDERSCORE);
  $VERSION = "6.00";
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless(defined $standard_case{$field}) {
  	    # generate a %standard_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $standard_case{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	next if substr($key, 0, 1) eq '_';
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $key, $vals);
  	}
      }
  }
  
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		my $field = $standard_case{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    my $field = $standard_case{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # intial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  
  if (eval { require Storable; 1 }) {
      *clone = \&Storable::dclone;
  } else {
      *clone = sub {
  	my $self = shift;
  	my $clone = HTTP::Headers->new;
  	$self->scan(sub { $clone->push_header(@_);} );
  	$clone;
      };
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promise that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS

$fatpacked{"HTTP/Headers/Auth.pm"} = <<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  use HTTP::Headers;
  
  package HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
HTTP_HEADERS_AUTH

$fatpacked{"HTTP/Headers/ETag.pm"} = <<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
HTTP_HEADERS_ETAG

$fatpacked{"HTTP/Headers/Util.pm"} = <<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = "6.00";
  
  require Exporter;
  @ISA=qw(Exporter);
  
  @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessary be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS_UTIL

$fatpacked{"HTTP/Message.pm"} = <<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use vars qw($VERSION $AUTOLOAD);
  $VERSION = "6.02";
  
  require HTTP::Headers;
  require Carp;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  $HTTP::URI_CLASS ||= $ENV{PERL_HTTP_URI_CLASS} || "URI";
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
      }, $class;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = $_[1];
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = $_[1];
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32-LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32-BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16-LE" if /^\xFF\xFE/;
  	return "UTF-16-BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32-BE" if /^\x00\x00\x00</;
  	    return "UTF-32-LE" if /^<\x00\x00\x00/;
  	    return "UTF-16-BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16-LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	my $charset;
  	require HTML::Parser;
  	my $p = HTML::Parser->new(
  	    start_h => [sub {
  		my($tag, $attr, $self) = @_;
  		$charset = $attr->{charset};
  		unless ($charset) {
  		    # look at $attr->{content} ...
  		    if (my $c = $attr->{content}) {
  			require HTTP::Headers::Util;
  			my @v = HTTP::Headers::Util::split_header_words($c);
  			return unless @v;
  			my($ct, undef, %ct_param) = @{$v[0]};
  			$charset = $ct_param{charset};
  		    }
  		    return unless $charset;
  		}
  		if ($charset =~ /^utf-?16/i) {
  		    # converted document, assume UTF-8
  		    $charset = "UTF-8";
  		}
  		$self->eof;
  	    }, "tagname, attr, self"],
  	    report_tags => [qw(meta)],
  	    utf8_mode => 1,
  	);
  	$p->parse($$cref);
  	return $charset if $charset;
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require IO::Uncompress::Gunzip;
  		    my $output;
  		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
  			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2") {
  		    require IO::Uncompress::Bunzip2;
  		    my $output;
  		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
  			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    if ($charset eq "none") {
  		# leave it asis
  	    }
  	    elsif ($charset eq "us-ascii" || $charset eq "iso-8859-1") {
  		if ($$content_ref =~ /[^\x00-\x7F]/ && defined &utf8::upgrade) {
  		    unless ($content_ref_iscopy) {
  			my $copy = $$content_ref;
  			$content_ref = \$copy;
  			$content_ref_iscopy++;
  		    }
  		    utf8::upgrade($$content_ref);
  		}
  	    }
  	    else {
  		require Encode;
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset eq "none";
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require IO::Uncompress::Gunzip;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require IO::Uncompress::Bunzip2;
          push(@enc, "x-bzip2");
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = "(no content)";
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = "(no content)";
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = HTTP::Message->new($self->remove_content_headers,
  				   $self->content(""));
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  
  # delegate all other method calls the the headers object.
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->headers->$method(@_) };
      goto &$method;
  }
  
  
  sub DESTROY {}  # avoid AUTOLOADing it
  
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--\r?\n.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map HTTP::Message->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ HTTP::Message->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 SYNOPSIS
  
   use base 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and for textual content
  the raw content encoded to Perl's Unicode strings.  If the C<Content-Encoding>
  or C<charset> of the message is unknown this method will fail by returning
  C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This override the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This override the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2" and "base64".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If an @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_MESSAGE

$fatpacked{"HTTP/Message/PSGI.pm"} = <<'HTTP_MESSAGE_PSGI';
  package HTTP::Message::PSGI;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw( req_to_psgi res_from_psgi );
  
  use Carp ();
  use HTTP::Status qw(status_message);
  use URI::Escape ();
  use Plack::Util;
  use Try::Tiny;
  
  my $TRUE  = (1 == 1);
  my $FALSE = !$TRUE;
  
  sub req_to_psgi {
      my $req = shift;
  
      unless (try { $req->isa('HTTP::Request') }) {
          Carp::croak("Request is not HTTP::Request: $req");
      }
  
      # from HTTP::Request::AsCGI
      my $host = $req->header('Host');
      my $uri  = $req->uri->clone;
      $uri->scheme('http')    unless $uri->scheme;
      $uri->host('localhost') unless $uri->host;
      $uri->port(80)          unless $uri->port;
      $uri->host_port($host)  unless !$host || ( $host eq $uri->host_port );
  
      # STUPID: If the request URI is utf-8 decoded, methods like ->path
      # and ->host returns decoded strings in ascii, which causes double
      # encoded strings in uri_unescape and URI concatenation in
      # Plack::Request :/
      utf8::downgrade $$uri;
  
      my $input;
      my $content = $req->content;
      if (ref $content eq 'CODE') {
          if (defined $req->content_length) {
              $input = HTTP::Message::PSGI::ChunkedInput->new($content);
          } else {
              $req->header("Transfer-Encoding" => "chunked");
              $input = HTTP::Message::PSGI::ChunkedInput->new($content, 1);
          }
      } else {
          open $input, "<", \$content;
          $req->content_length(length $content)
              unless defined $req->content_length;
      }
  
      my $env = {
          PATH_INFO         => URI::Escape::uri_unescape($uri->path || '/'),
          QUERY_STRING      => $uri->query || '',
          SCRIPT_NAME       => '',
          SERVER_NAME       => $uri->host,
          SERVER_PORT       => $uri->port,
          SERVER_PROTOCOL   => $req->protocol || 'HTTP/1.1',
          REMOTE_ADDR       => '127.0.0.1',
          REMOTE_HOST       => 'localhost',
          REMOTE_PORT       => int( rand(64000) + 1000 ),                   # not in RFC 3875
          REQUEST_URI       => $uri->path_query || '/',                     # not in RFC 3875
          REQUEST_METHOD    => $req->method,
          'psgi.version'      => [ 1, 1 ],
          'psgi.url_scheme'   => $uri->scheme eq 'https' ? 'https' : 'http',
          'psgi.input'        => $input,
          'psgi.errors'       => *STDERR,
          'psgi.multithread'  => $FALSE,
          'psgi.multiprocess' => $FALSE,
          'psgi.run_once'     => $TRUE,
          'psgi.streaming'    => $TRUE,
          'psgi.nonblocking'  => $FALSE,
          @_,
      };
  
      for my $field ( $req->headers->header_field_names ) {
          my $key = uc("HTTP_$field");
          $key =~ tr/-/_/;
          $key =~ s/^HTTP_// if $field =~ /^Content-(Length|Type)$/;
  
          unless ( exists $env->{$key} ) {
              $env->{$key} = $req->headers->header($field);
          }
      }
  
      if ($env->{SCRIPT_NAME}) {
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E/\//;
          $env->{PATH_INFO} =~ s/^\/+/\//;
      }
  
      return $env;
  }
  
  sub res_from_psgi {
      my ($psgi_res) = @_;
  
      my $res;
      if (ref $psgi_res eq 'ARRAY') {
          _res_from_psgi($psgi_res, \$res);
      }
      elsif (ref $psgi_res eq 'CODE') {
          $psgi_res->(sub {
              _res_from_psgi($_[0], \$res);
          });
      }
  
      return $res;
  }
  
  sub _res_from_psgi {
      my ($status, $headers, $body) = @{+shift};
      my $res_ref = shift;
  
      my $convert_resp = sub {
          my $res = HTTP::Response->new($status);
          $res->message(status_message($status));
          $res->headers->header(@$headers) if @$headers;
  
          if (ref $body eq 'ARRAY') {
              $res->content(join '', grep defined, @$body);
          } else {
              local $/ = \4096;
              my $content;
              while (defined(my $buf = $body->getline)) {
                  $content .= $buf;
              }
              $body->close;
              $res->content($content);
          }
  
          ${ $res_ref } = $res;
  
          return;
      };
  
      if (!defined $body) {
          my $o = Plack::Util::inline_object
              write => sub { push @{ $body ||= [] }, @_ },
              close => $convert_resp;
  
          return $o;
      }
  
      $convert_resp->();
  }
  
  sub HTTP::Request::to_psgi {
      req_to_psgi(@_);
  }
  
  sub HTTP::Response::from_psgi {
      my $class = shift;
      res_from_psgi(@_);
  }
  
  package
      HTTP::Message::PSGI::ChunkedInput;
  
  sub new {
      my($class, $content, $chunked) = @_;
  
      my $content_cb;
      if ($chunked) {
          my $done;
          $content_cb = sub {
              my $chunk = $content->();
              return if $done;
              unless (defined $chunk) {
                  $done = 1;
                  return "0\015\012\015\012";
              }
              return '' unless length $chunk;
              return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
          };
      } else {
          $content_cb = $content;
      }
  
      bless { content => $content_cb }, $class;
  }
  
  sub read {
      my $self = shift;
  
      my $chunk = $self->{content}->();
      return 0 unless defined $chunk;
  
      $_[0] = '';
      substr($_[0], $_[2] || 0, length $chunk) = $chunk;
  
      return length $chunk;
  }
  
  sub close { }
  
  package HTTP::Message::PSGI;
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Message::PSGI - Converts HTTP::Request and HTTP::Response from/to PSGI env and response
  
  =head1 SYNOPSIS
  
    use HTTP::Message::PSGI;
  
    # $req is HTTP::Request, $res is HTTP::Response
    my $env = req_to_psgi($req);
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
    # Adds methods to HTTP::Request/Response class as well
    my $env = $req->to_psgi;
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  =head1 DESCRIPTION
  
  HTTP::Message::PSGI gives you convenient methods convert HTTP::Request
  object to PSGI env hash and convert PSGI response array ref to
  HTTP::Response object.
  
  If you want the other way round, see L<Plack::Request> and
  L<Plack::Response>.
  
  =head1 METHODS
  
  =over 4
  
  =item req_to_psgi
  
    my $env = req_to_psgi($req [, $key => $val ... ]);
  
  Converts HTTP::Request object into PSGI env hash reference.
  
  =item HTTP::Request::to_psgi
  
    my $env = $req->to_psgi;
  
  Same as C<req_to_psgi> but an instance method in L<HTTP::Request>.
  
  =item res_from_psgi
  
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
  Creates HTTP::Response object from PSGI response array ref.
  
  =item HTTP::Response->from_psgi
  
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  Same as C<res_from_psgi> but a class method in L<HTTP::Response>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Request::AsCGI> L<HTTP::Message> L<Plack::Test>
  
  =cut
  
HTTP_MESSAGE_PSGI

$fatpacked{"HTTP/Request.pm"} = <<'HTTP_REQUEST';
  package HTTP::Request;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.00";
  
  use strict;
  
  
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $request_line;
      if ($str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($method, $uri, $protocol) = split(' ', $request_line);
      $self->method($method) if defined($method);
      $self->uri($uri) if defined($uri);
      $self->protocol($protocol) if $protocol;
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
      return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parseable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_REQUEST

$fatpacked{"HTTP/Request/Common.pm"} = <<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use vars qw(@EXPORT @EXPORT_OK $VERSION $DYNAMIC_FILE_UPLOAD);
  
  $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT =qw(GET HEAD PUT POST);
  @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  
  $VERSION = "6.00";
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub PUT  { _simple_req('PUT' , @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  
  sub POST
  {
      my $url = shift;
      my $req = HTTP::Request->new(POST => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      my($k,$v);
      while (($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename =~ s,.*/,, if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.  
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, 2048, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf 
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);
  
  =head1 DESCRIPTION
  
  This module provide functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.  The
  following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The GET() function returns an C<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the PUT() and POST()
  functions described below.
  
  The get(...) method of C<LWP::UserAgent> exists as a shortcut for
  $ua->request(GET ...).
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The head(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(HEAD ...).
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $content
  
  Like GET() but the method in the request is "PUT".
  
  The content of the request can be specified using the "Content"
  pseudo-header.  This steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like GET() but the method in the request is "DELETE".  This function
  is not exported by default.
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  This works mostly like PUT() with "POST" as the method, but this
  function also takes a second optional array or hash reference
  parameter $form_ref.  As for PUT() the content can also be specified
  directly using the "Content" pseudo-header, and you may also provide
  the $form_ref this way.
  
  The $form_ref argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate a HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create a HTTP::Request object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the $form_ref is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by LWP::MediaTypes::guess_media_type()
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create a HTTP::Request object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the $DYNAMIC_FILE_UPLOAD variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no Content-Length header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the Content-Length is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The post(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(POST ...).
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  
  =head1 COPYRIGHT
  
  Copyright 1997-2004, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
HTTP_REQUEST_COMMON

$fatpacked{"HTTP/Response.pm"} = <<'HTTP_RESPONSE';
  package HTTP::Response;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.01";
  
  use strict;
  use HTTP::Status ();
  
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $status_line;
      if ($str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($protocol, $code, $message);
      if ($status_line =~ /^\d{3} /) {
         # Looks like a response created by HTTP::Response->new
         ($code, $message) = split(' ', $status_line, 2);
      } else {
         ($protocol, $code, $message) = split(' ', $status_line, 3);
      }
      $self->protocol($protocol) if $protocol;
      $self->code($code) if defined($code);
      $self->message($message) if defined($message);
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Content-Location'),    # HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require Encode::Locale;
  			Encode::from_to($encfile, $charset, "locale_fs");
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      require HTTP::Status;
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = $self->status_line;
      $body =~ s/&/&amp;/g;
      $body =~ s/</&lt;/g;
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request)
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meaning these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of a HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" or a "Content-Location:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  When the LWP protocol modules produce the HTTP::Response object, then
  any base URI embedded in the document (step 1) will already have
  initialized the "Content-Base:" header. This means that this method
  only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_RESPONSE

$fatpacked{"HTTP/Server/PSGI.pm"} = <<'HTTP_SERVER_PSGI';
  package HTTP::Server::PSGI;
  use strict;
  use warnings;
  
  use Carp ();
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Plack::TempBuffer;
  use Plack::Middleware::ContentLength;
  use POSIX qw(EINTR);
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use Try::Tiny;
  use Time::HiRes qw(time);
  
  my $alarm_interval;
  BEGIN {
      if ($^O eq 'MSWin32') {
          $alarm_interval = 1;
      } else {
          Time::HiRes->import('alarm');
          $alarm_interval = 0.1;
      }
  }
  
  use constant MAX_REQUEST_SIZE => 131072;
  use constant MSWin32          => $^O eq 'MSWin32';
  
  sub new {
      my($class, %args) = @_;
  
      my $self = bless {
          host               => $args{host} || 0,
          port               => $args{port} || 8080,
          timeout            => $args{timeout} || 300,
          server_software    => $args{server_software} || $class,
          server_ready       => $args{server_ready} || sub {},
          ssl                => $args{ssl},
          ipv6               => $args{ipv6},
          ssl_key_file       => $args{ssl_key_file},
          ssl_cert_file      => $args{ssl_cert_file},
      }, $class;
  
      if ($args{max_workers} && $args{max_workers} > 1) {
          Carp::carp(
              "Preforking in $class is deprecated. Falling back to the non-forking mode. ",
              "If you need preforking, use Starman or Starlet instead and run like `plackup -s Starlet`",
          );
      }
  
      $self;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub prepare_socket_class {
      my($self, $args) = @_;
  
      if ($self->{ssl} && $self->{ipv6}) {
          Carp::croak("SSL and IPv6 are not supported at the same time (yet). Choose one.");
      }
  
      if ($self->{ssl}) {
          eval { require IO::Socket::SSL; 1 }
              or Carp::croak("SSL suport requires IO::Socket::SSL");
          $args->{SSL_key_file}  = $self->{ssl_key_file};
          $args->{SSL_cert_file} = $self->{ssl_cert_file};
          return "IO::Socket::SSL";
      } elsif ($self->{ipv6}) {
          eval { require IO::Socket::IP; 1 }
              or Carp::croak("IPv6 support requires IO::Socket::IP");
          $self->{host}      ||= '::';
          $args->{LocalAddr} ||= '::';
          return "IO::Socket::IP";
      }
  
      return "IO::Socket::INET";
  }
  
  sub setup_listener {
      my $self = shift;
  
      my %args = (
          Listen    => SOMAXCONN,
          LocalPort => $self->{port},
          LocalAddr => $self->{host},
          Proto     => 'tcp',
          ReuseAddr => 1,
      );
  
      my $class = $self->prepare_socket_class(\%args);
      $self->{listen_sock} ||= $class->new(%args)
          or die "failed to listen to port $self->{port}: $!";
  
      $self->{server_ready}->($self);
  }
  
  sub accept_loop {
      my($self, $app) = @_;
  
      $app = Plack::Middleware::ContentLength->wrap($app);
  
      while (1) {
          local $SIG{PIPE} = 'IGNORE';
          if (my $conn = $self->{listen_sock}->accept) {
              $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                  or die "setsockopt(TCP_NODELAY) failed:$!";
              my $env = {
                  SERVER_PORT => $self->{port},
                  SERVER_NAME => $self->{host},
                  SCRIPT_NAME => '',
                  REMOTE_ADDR => $conn->peerhost,
                  'psgi.version' => [ 1, 1 ],
                  'psgi.errors'  => *STDERR,
                  'psgi.url_scheme' => $self->{ssl} ? 'https' : 'http',
                  'psgi.run_once'     => Plack::Util::FALSE,
                  'psgi.multithread'  => Plack::Util::FALSE,
                  'psgi.multiprocess' => Plack::Util::FALSE,
                  'psgi.streaming'    => Plack::Util::TRUE,
                  'psgi.nonblocking'  => Plack::Util::FALSE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'          => $conn,
              };
  
              $self->handle_connection($env, $conn, $app);
              $conn->close;
          }
      }
  }
  
  sub handle_connection {
      my($self, $env, $conn, $app) = @_;
  
      my $buf = '';
      my $res = [ 400, [ 'Content-Type' => 'text/plain' ], [ 'Bad Request' ] ];
  
      while (1) {
          my $rlen = $self->read_timeout(
              $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
              $self->{timeout},
          ) or return;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
              $buf = substr $buf, $reqlen;
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Plack::TempBuffer->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout})
                              or return;
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  open my $input, "<", \$buf;
                  $env->{'psgi.input'} = $input;
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res, $conn);
      } elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0], $conn);
          });
      } else {
          die "Bad response $res";
      }
  
      return;
  }
  
  sub _handle_response {
      my($self, $res, $conn) = @_;
  
      my @lines = (
          "Date: @{[HTTP::Date::time2str()]}\015\012",
          "Server: $self->{server_software}\015\012",
      );
  
      Plack::Util::header_iter($res->[1], sub {
          my ($k, $v) = @_;
          push @lines, "$k: $v\015\012";
      });
  
      unshift @lines, "HTTP/1.0 $res->[0] @{[ HTTP::Status::status_message($res->[0]) ]}\015\012";
      push @lines, "\015\012";
  
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $res->[2]) {
          my $err;
          my $done;
          {
              local $@;
              eval {
                  Plack::Util::foreach(
                      $res->[2],
                      sub {
                          $self->write_all($conn, $_[0], $self->{timeout})
                              or die "failed to send all data\n";
                      },
                  );
                  $done = 1;
              };
              $err = $@;
          };
          unless ($done) {
              if ($err =~ /^failed to send all data\n/) {
                  return;
              } else {
                  die $err;
              }
          }
      } else {
          return Plack::Util::inline_object
              write => sub { $self->write_all($conn, $_[0], $self->{timeout}) },
              close => sub { };
      }
  }
  
  # returns 1 if socket is ready, undef on timeout
  sub do_timeout {
      my ($self, $cb, $timeout) = @_;
      local $SIG{ALRM} = sub {};
      my $wait_until = time + $timeout;
      alarm($timeout);
      my $ret;
      while (1) {
          if ($ret = $cb->()) {
              last;
          } elsif (! (! defined($ret) && $! == EINTR)) {
              undef $ret;
              last;
          }
          # got EINTR
          my $left = $wait_until - time;
          last if $left <= 0;
          alarm($left + $alarm_interval);
      }
      alarm(0);
      $ret;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->sysread($$buf, $len, $off) }, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->syswrite($buf, $len, $off) }, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      return 0 unless defined $buf;
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Server::PSGI - Standalone PSGI compatible HTTP server
  
  =head1 SYNOPSIS
  
    use HTTP::Server::PSGI;
  
    my $server = HTTP::Server::PSGI->new(
        host => "127.0.0.1",
        port => 9091,
        timeout => 120,
    );
  
    $server->run($app);
  
  =head1 DESCRIPTION
  
  HTTP::Server::PSGI is a standalone, single-process and PSGI compatible
  HTTP server implementations.
  
  This server should be great for the development and testing, but might
  not be suitable for a production use.
  
  Some features in HTTP/1.1, notably chunked requests, responses and
  pipeline requests are B<NOT> supported. See L<Starman> if you want
  those features.
  
  =head1 PREFORKING
  
  L<HTTP::Server::PSGI> does B<NOT> support preforking. See L<Starman>
  or L<Starlet> if you want a multi-process prefork web servers.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Standalone> L<Starman> L<Starlet>
  
  =cut
HTTP_SERVER_PSGI

$fatpacked{"HTTP/Status.pm"} = <<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  require 5.002;   # because we use prototypes
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  @EXPORT_OK = qw(is_client_error is_server_error);
  $VERSION = "6.00";
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 2616
  # See also: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ tr/a-z \-/A-Z__/;
      $mnemonicCode .= "sub HTTP_$message () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  
  sub is_info         ($) { $_[0] >= 100 && $_[0] < 200; }
  sub is_success      ($) { $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect     ($) { $_[0] >= 300 && $_[0] < 400; }
  sub is_error        ($) { $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error ($) { $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error ($) { $_[0] >= 500 && $_[0] < 600; }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of a HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
     HTTP_REQUEST_URI_TOO_LARGE           (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_NO_CODE                         (425)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_RETRY_WITH                      (449)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
     HTTP_NOT_EXTENDED                    (510)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above.  If the $code is unknown, then C<undef> is returned.
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  return TRUE for both client error or a server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is an I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is an I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explict imports and
  the C<:constants> tag instead of relying on this.
HTTP_STATUS

$fatpacked{"Hash/MultiValue.pm"} = <<'HASH_MULTIVALUE';
  package Hash::MultiValue;
  
  use strict;
  use 5.006_002;
  our $VERSION = '0.11';
  
  use Carp ();
  use Scalar::Util qw(refaddr);
  
  my %keys;
  my %values;
  my %registry;
  
  BEGIN {
      require Config;
      my $needs_registry = ($^O eq 'Win32' || $Config::Config{useithreads});
      if ($needs_registry) {
          *CLONE = sub {
              foreach my $oldaddr (keys %registry) {
                  my $this = refaddr $registry{$oldaddr};
                  $keys{$this}   = delete $keys{$oldaddr};
                  $values{$this} = delete $values{$oldaddr};
                  Scalar::Util::weaken($registry{$this} = delete $registry{$oldaddr});
              }
          };
      }
      *NEEDS_REGISTRY = sub () { $needs_registry };
  }
  
  if (defined &UNIVERSAL::ref::import) {
      UNIVERSAL::ref->import;
  }
  
  sub ref { 'HASH' }
  
  sub create {
      my $class = shift;
      my $self = bless {}, $class;
      my $this = refaddr $self;
      $keys{$this} = [];
      $values{$this} = [];
      if (NEEDS_REGISTRY) {
          Scalar::Util::weaken($registry{$this} = $self);
      }
      $self;
  }
  
  sub new {
      my $class = shift;
      my $self = $class->create;
      unshift @_, $self;
      goto &{ $self->can('merge_flat') };
  }
  
  sub from_mixed {
      my $class = shift;
      my $self = $class->create;
      unshift @_, $self;
      goto &{ $self->can('merge_mixed') };
  }
  
  sub DESTROY {
      my $this = refaddr shift;
      delete $keys{$this};
      delete $values{$this};
      if (NEEDS_REGISTRY) {
          delete $registry{$this};
      }
  }
  
  sub get {
      my($self, $key) = @_;
      $self->{$key};
  }
  
  sub get_all {
      my($self, $key) = @_;
      my $this = refaddr $self;
      my $k = $keys{$this};
      (@{$values{$this}}[grep { $key eq $k->[$_] } 0 .. $#$k]);
  }
  
  sub get_one {
      my ($self, $key) = @_;
      my @v = $self->get_all($key);
      return $v[0] if @v == 1;
      Carp::croak "Key not found: $key" if not @v;
      Carp::croak "Multiple values match: $key";
  }
  
  sub set {
      my $self = shift;
      my $key = shift;
  
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my @idx = grep { $key eq $k->[$_] } 0 .. $#$k;
  
      my $added = @_ - @idx;
      if ($added > 0) {
          my $start = $#$k + 1;
          push @$k, ($key) x $added;
          push @idx, $start .. $#$k;
      }
      elsif ($added < 0) {
          my ($start, @drop, @keep) = splice @idx, $added;
          for my $i ($start+1 .. $#$k) {
              if ($i == $drop[0]) {
                shift @drop;
                next;
              }
              push @keep, $i;
          }
  
          # this used to be written as
          #   splice @$_, $start, 0+@$_, @$_[@keep]
          # however older perls crash on attempts to splice-replace a subscript
          # of the array currently being splice()d
          #
          # I can not seem to find a relevant RT or perldelta entry, but this
          # seems to have been fixed in 5.8.7
          @$_ = @$_[0 .. $start-1, @keep] for ($k, $v);
      }
  
      if (@_) {
          @$v[@idx] = @_;
          $self->{$key} = $_[-1];
      }
      else {
          delete $self->{$key};
      }
  
      $self;
  }
  
  sub add {
      my $self = shift;
      my $key = shift;
      $self->merge_mixed( $key => \@_ );
      $self;
  }
  
  sub merge_flat {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      push @{ $_ & 1 ? $v : $k }, $_[$_] for 0 .. $#_;
      @{$self}{@$k} = @$v;
      $self;
  }
  
  sub merge_mixed {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my $hash;
      $hash = shift if @_ == 1;
  
      while ( my ($key, $value) = @_ ? splice @_, 0, 2 : each %$hash ) {
          my @value = CORE::ref($value) eq 'ARRAY' ? @$value : $value;
          next if not @value;
          $self->{$key} = $value[-1];
          push @$k, ($key) x @value;
          push @$v, @value;
      }
  
      $self;
  }
  
  sub remove {
      my ($self, $key) = @_;
      $self->set($key);
      $self;
  }
  
  sub clear {
      my $self = shift;
      %$self = ();
      my $this = refaddr $self;
      $keys{$this} = [];
      $values{$this} = [];
      $self;
  }
  
  sub clone {
      my $self = shift;
      CORE::ref($self)->new($self->flatten);
  }
  
  sub keys {
      my $self = shift;
      return @{$keys{refaddr $self}};
  }
  
  sub values {
      my $self = shift;
      return @{$values{refaddr $self}};
  }
  
  sub flatten {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      map { $k->[$_], $v->[$_] } 0 .. $#$k;
  }
  
  sub each {
      my ($self, $code) = @_;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      for (0 .. $#$k) {
          $code->($k->[$_], $v->[$_]);
      }
      return $self;
  }
  
  sub as_hashref {
      my $self = shift;
      my %hash = %$self;
      \%hash;
  }
  
  sub as_hashref_mixed {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my %hash;
      push @{$hash{$k->[$_]}}, $v->[$_] for 0 .. $#$k;
      for (CORE::values %hash) {
          $_ = $_->[0] if 1 == @$_;
      }
  
      \%hash;
  }
  
  sub mixed { $_[0]->as_hashref_mixed }
  
  sub as_hashref_multi {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my %hash;
      push @{$hash{$k->[$_]}}, $v->[$_] for 0 .. $#$k;
  
      \%hash;
  }
  
  sub multi { $_[0]->as_hashref_multi }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Hash::MultiValue - Store multiple values per key
  
  =head1 SYNOPSIS
  
    use Hash::MultiValue;
  
    my $hash = Hash::MultiValue->new(
        foo => 'a',
        foo => 'b',
        bar => 'baz',
    );
  
    # $hash is an object, but can be used as a hashref and DWIMs!
    my $foo = $hash->{foo};         # 'b' (the last entry)
    my $foo = $hash->get('foo');    # 'b' (always, regardless of context)
    my @foo = $hash->get_all('foo'); # ('a', 'b')
  
    keys %$hash; # ('foo', 'bar')    not guaranteed to be ordered
    $hash->keys; # ('foo', 'foo', 'bar') guaranteed to be ordered
  
  =head1 DESCRIPTION
  
  Hash::MultiValue is an object (and a plain hash reference) that may
  contain multiple values per key, inspired by MultiDict of WebOb.
  
  =head1 RATIONALE
  
  In a typical web application, the request parameters (a.k.a CGI
  parameters) can be single value or multi values. Using CGI.pm style
  C<param> is one way to deal with this problem (and it is good, as long
  as you're aware of its list context gotcha), but there's another
  approach to convert parameters into a hash reference, like Catalyst's
  C<< $c->req->parameters >> does, and it B<sucks>.
  
  Why? Because the value could be just a scalar if there is one value
  and an array ref if there are multiple, depending on I<user input>
  rather than I<how you code it>. So your code should always be like
  this to be defensive:
  
    my $p = $c->req->parameters;
    my @maybe_multi = ref $p->{m} eq 'ARRAY' ? @{$p->{m}} : ($p->{m});
    my $must_single = ref $p->{m} eq 'ARRAY' ? $p->{m}->[0] : $p->{m};
  
  Otherwise you'll get a random runtime exception of I<Can't use string
  as an ARRAY ref> or get stringified array I<ARRAY(0xXXXXXXXXX)> as a
  string, I<depending on user input> and that is miserable and
  insecure.
  
  This module provides a solution to this by making it behave like a
  single value hash reference, but also has an API to get multiple
  values on demand, explicitly.
  
  =head1 HOW THIS WORKS
  
  The object returned by C<new> is a blessed hash reference that
  contains the last entry of the same key if there are multiple values,
  but it also keeps the original pair state in the object tracker (a.k.a
  inside out objects) and allows you to access the original pairs and
  multiple values via the method calls, such as C<get_all> or C<flatten>.
  
  This module does not use C<tie> or L<overload> and is quite fast.
  
  Yes, there is L<Tie::Hash::MultiValue> and this module tries to solve
  exactly the same problem, but using a different implementation.
  
  =head1 UPDATING CONTENTS
  
  When you update the content of the hash, B<DO NOT UPDATE> using the
  hash reference interface: this won't write through to the tracking
  object.
  
    my $hash = Hash::MultiValue->new(...);
  
    # WRONG
    $hash->{foo} = 'bar';
    delete $hash->{foo};
  
    # Correct
    $hash->add(foo => 'bar');
    $hash->remove('foo');
  
  See below for the list of updating methods.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $hash = Hash::MultiValue->new(@pairs);
  
  Creates a new object that can be treated as a plain hash reference as well.
  
  =item get
  
    $value = $hash->get($key);
    $value = $hash->{$key};
  
  Returns a single value for the given C<$key>. If there are multiple
  values, the last one (not first one) is returned. See below for why.
  
  Note that this B<always> returns the single element as a scalar,
  regardless of its context, unlike CGI.pm's C<param> method etc.
  
  =item get_one
  
    $value = $hash->get_one($key);
  
  Returns a single value for the given C<$key>. This method B<croaks> if
  there is no value or multiple values associated with the key, so you
  should wrap it with eval or modules like L<Try::Tiny>.
  
  =item get_all
  
    @values = $hash->get_all($key);
  
  Returns a list of values for the given C<$key>. This method B<always>
  returns a list regardless of its context. If there is no value
  attached, the result will be an empty list.
  
  =item keys
  
    @keys = $hash->keys;
  
  Returns a list of all keys, including duplicates (see the example in the
  L</SYNOPSIS>).
  
  If you want only unique keys, use C<< keys %$hash >>, as normal.
  
  =item values
  
    @values = $hash->values;
  
  Returns a list of all values, in the same order as C<< $hash->keys >>.
  
  =item set
  
    $hash->set($key [, $value ... ]);
  
  Changes the stored value(s) of the given C<$key>. This removes or adds
  pairs as necessary to store the new list but otherwise preserves order
  of existing pairs. C<< $hash->{$key} >> is updated to point to the last
  value.
  
  =item add
  
    $hash->add($key, $value [, $value ... ]);
  
  Appends a new value to the given C<$key>. This updates the value of
  C<< $hash->{$key} >> as well so it always points to the last value.
  
  =item remove
  
    $hash->remove($key);
  
  Removes a key and associated values for the given C<$key>.
  
  =item clear
  
    $hash->clear;
  
  Clears the hash to be an empty hash reference.
  
  =item flatten
  
    @pairs = $hash->flatten;
  
  Gets pairs of keys and values. This should be exactly the same pairs
  which are given to C<new> method unless you updated the data.
  
  =item each
  
    $hash->each($code);
  
    # e.g.
    $hash->each(sub { print "$_[0] = $_[1]\n" });
  
  Calls C<$code> once for each C<($key, $value)> pair.  This is a more convenient
  alternative to calling C<flatten> and then iterating over it two items at a
  time.
  
  Inside C<$code>, C<$_> contains the current iteration through the loop,
  starting at 0.  For example:
  
    $hash = Hash::MultiValue->new(a => 1, b => 2, c => 3, a => 4);
  
    $hash->each(sub { print "$_: $_[0] = $_[1]\n" });
    # 0: a = 1
    # 1: b = 2
    # 2: c = 3
    # 3: a = 4
  
  Be careful B<not> to change C<@_> inside your coderef!  It will update
  the tracking object but not the plain hash.  In the future, this
  limitation I<may> be removed.
  
  =item clone
  
    $new = $hash->clone;
  
  Creates a new Hash::MultiValue object that represents the same data,
  but obviously not sharing the reference. It's identical to:
  
    $new = Hash::MultiValue->new($hash->flatten);
  
  =item as_hashref
  
    $copy = $hash->as_hashref;
  
  Creates a new plain (unblessed) hash reference where a value is a
  single scalar. It's identical to:
  
    $copy = +{%$hash};
  
  =item as_hashref_mixed, mixed
  
    $mixed = $hash->as_hashref_mixed;
    $mixed = $hash->mixed;
  
  Creates a new plain (unblessed) hash reference where the value is a
  single scalar, or an array ref when there are multiple values for a
  same key. Handy to create a hash reference that is often used in web
  application frameworks request objects such as L<Catalyst>. Ths method
  does exactly the opposite of C<from_mixed>.
  
  =item as_hashref_multi, multi
  
    $multi = $hash->as_hashref_multi;
    $multi = $hash->multi;
  
  Creates a new plain (unblessed) hash reference where values are all
  array references, regardless of there are single or multiple values
  for a same key.
  
  =item from_mixed
  
    $hash = Hash::MultiValue->from_mixed({
        foo => [ 'a', 'b' ],
        bar => 'c',
    });
  
  Creates a new object out of a hash reference where the value is single
  or an array ref depending on the number of elements. Handy to convert
  from those request objects used in web frameworks such as L<Catalyst>.
  This method does exactly the opposite of C<as_hashref_mixed>.
  
  =back
  
  =head1 WHY LAST NOT FIRST?
  
  You might wonder why this module uses the I<last> value of the same
  key instead of I<first>. There's no strong reasoning on this decision
  since one is as arbitrary as the other, but this is more consistent to
  what Perl does:
  
    sub x {
        return ('a', 'b', 'c');
    }
  
    my $x = x(); # $x = 'c'
  
    my %a = ( a => 1 );
    my %b = ( a => 2 );
  
    my %m = (%a, %b); # $m{a} = 2
  
  When perl gets a list in a scalar context it gets the last entry. Also
  if you merge hashes having a same key, the last one wins.
  
  =head1 NOTES ON ref
  
  If you pass this MultiValue hash object to some upstream functions
  that you can't control and does things like:
  
    if (ref $args eq 'HASH') {
        ...
    }
  
  because this is a blessed hash reference it doesn't match and would
  fail. To avoid that you should call C<as_hashref> to get a
  I<finalized> (= non-blessed) hash reference.
  
  You can also use UNIVERSAL::ref to make it work magically:
  
    use UNIVERSAL::ref;    # before loading Hash::MultiValue
    use Hash::MultiValue;
  
  and then all C<ref> calls to Hash::MultiValue objects will return I<HASH>.
  
  =head1 THREAD SAFETY
  
  Prior to version 0.09, this module wasn't safe in a threaded
  environment, including win32 fork() emulation. Versions newer than
  0.09 is considered thread safe.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt>
  
  Aristotle Pagaltzis
  
  Hans Dieter Pearcey
  
  Thanks to Michael Peters for the suggestion to use inside-out objects
  instead of tie.
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<http://pythonpaste.org/webob/#multidict>
  
  =item * L<Tie::Hash::MultiValue>
  
  =back
  
  =cut
HASH_MULTIVALUE

$fatpacked{"JSON.pm"} = <<'JSON';
  package JSON;
  
  
  use strict;
  use Carp ();
  use base qw(Exporter);
  @JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);
  
  BEGIN {
      $JSON::VERSION = '2.53';
      $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);
      $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };
  }
  
  my $Module_XS  = 'JSON::XS';
  my $Module_PP  = 'JSON::PP';
  my $Module_bp  = 'JSON::backportPP'; # included in JSON distribution
  my $PP_Version = '2.27200';
  my $XS_Version = '2.27';
  
  
  # XS and PP common methods
  
  my @PublicMethods = qw/
      ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref 
      allow_blessed convert_blessed filter_json_object filter_json_single_key_object 
      shrink max_depth max_size encode decode decode_prefix allow_unknown
  /;
  
  my @Properties = qw/
      ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref
      allow_blessed convert_blessed shrink max_depth max_size allow_unknown
  /;
  
  my @XSOnlyMethods = qw//; # Currently nothing
  
  my @PPOnlyMethods = qw/
      indent_length sort_by
      allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed
  /; # JSON::PP specific
  
  
  # used in _load_xs and _load_pp ($INSTALL_ONLY is not used currently)
  my $_INSTALL_DONT_DIE  = 1; # When _load_xs fails to load XS, don't die.
  my $_INSTALL_ONLY      = 2; # Don't call _set_methods()
  my $_ALLOW_UNSUPPORTED = 0;
  my $_UNIV_CONV_BLESSED = 0;
  my $_USSING_bpPP       = 0;
  
  
  # Check the environment variable to decide worker module. 
  
  unless ($JSON::Backend) {
      $JSON::DEBUG and  Carp::carp("Check used worker module...");
  
      my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;
  
      if ($backend eq '1' or $backend =~ /JSON::XS\s*,\s*JSON::PP/) {
          _load_xs($_INSTALL_DONT_DIE) or _load_pp();
      }
      elsif ($backend eq '0' or $backend eq 'JSON::PP') {
          _load_pp();
      }
      elsif ($backend eq '2' or $backend eq 'JSON::XS') {
          _load_xs();
      }
      elsif ($backend eq 'JSON::backportPP') {
          $_USSING_bpPP = 1;
          _load_pp();
      }
      else {
          Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid.";
      }
  }
  
  
  sub import {
      my $pkg = shift;
      my @what_to_export;
      my $no_export;
  
      for my $tag (@_) {
          if ($tag eq '-support_by_pp') {
              if (!$_ALLOW_UNSUPPORTED++) {
                  JSON::Backend::XS
                      ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend eq $Module_XS);
              }
              next;
          }
          elsif ($tag eq '-no_export') {
              $no_export++, next;
          }
          elsif ( $tag eq '-convert_blessed_universally' ) {
              eval q|
                  require B;
                  *UNIVERSAL::TO_JSON = sub {
                      my $b_obj = B::svref_2object( $_[0] );
                      return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                              : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                              : undef
                              ;
                  }
              | if ( !$_UNIV_CONV_BLESSED++ );
              next;
          }
          push @what_to_export, $tag;
      }
  
      return if ($no_export);
  
      __PACKAGE__->export_to_level(1, $pkg, @what_to_export);
  }
  
  
  # OBSOLETED
  
  sub jsonToObj {
      my $alternative = 'from_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'decode';
      }
      Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";
      return JSON::from_json(@_);
  };
  
  sub objToJson {
      my $alternative = 'to_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'encode';
      }
      Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";
      JSON::to_json(@_);
  };
  
  
  # INTERFACES
  
  sub to_json ($@) {
      if (
          ref($_[0]) eq 'JSON'
          or (@_ > 2 and $_[0] eq 'JSON')
      ) {
          Carp::croak "to_json should not be called as a method.";
      }
      my $json = new JSON;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  
  sub from_json ($@) {
      if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = new JSON;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  
  sub true  { $JSON::true  }
  
  sub false { $JSON::false }
  
  sub null  { undef; }
  
  
  sub require_xs_version { $XS_Version; }
  
  sub backend {
      my $proto = shift;
      $JSON::Backend;
  }
  
  #*module = *backend;
  
  
  sub is_xs {
      return $_[0]->module eq $Module_XS;
  }
  
  
  sub is_pp {
      return not $_[0]->xs;
  }
  
  
  sub pureperl_only_methods { @PPOnlyMethods; }
  
  
  sub property {
      my ($self, $name, $value) = @_;
  
      if (@_ == 1) {
          my %props;
          for $name (@Properties) {
              my $method = 'get_' . $name;
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  $props{$name} = $value == 1 ? 0 : $value;
                  next;
              }
              $props{$name} = $self->$method();
          }
          return \%props;
      }
      elsif (@_ > 3) {
          Carp::croak('property() can take only the option within 2 arguments.');
      }
      elsif (@_ == 2) {
          if ( my $method = $self->can('get_' . $name) ) {
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  return $value == 1 ? 0 : $value;
              }
              $self->$method();
          }
      }
      else {
          $self->$name($value);
      }
  
  }
  
  
  
  # INTERNAL
  
  sub _load_xs {
      my $opt = shift;
  
      $JSON::DEBUG and Carp::carp "Load $Module_XS.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($Module_PP);
  
      eval qq|
          use $Module_XS $XS_Version ();
      |;
  
      if ($@) {
          if (defined $opt and $opt & $_INSTALL_DONT_DIE) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_XS...($@)";
              return 0;
          }
          Carp::croak $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_XS );
          my $data = join("", <DATA>); # this code is from Jcode 2.xx.
          close(DATA);
          eval $data;
          JSON::Backend::XS->init;
      }
  
      return 1;
  };
  
  
  sub _load_pp {
      my $opt = shift;
      my $backend = $_USSING_bpPP ? $Module_bp : $Module_PP;
  
      $JSON::DEBUG and Carp::carp "Load $backend.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($backend);
  
      if ( $_USSING_bpPP ) {
          eval qq| require $backend |;
      }
      else {
          eval qq| use $backend $PP_Version () |;
      }
  
      if ($@) {
          if ( $backend eq $Module_PP ) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_PP ($@), so try to load $Module_bp";
              $_USSING_bpPP++;
              $backend = $Module_bp;
              JSON::Boolean::_overrride_overload($backend);
              local $^W; # if PP installed but invalid version, backportPP redifines methods.
              eval qq| require $Module_bp |;
          }
          Carp::croak $@ if $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_PP ); # even if backportPP, set $Backend with 'JSON::PP'
          JSON::Backend::PP->init;
      }
  };
  
  
  sub _set_module {
      return if defined $JSON::true;
  
      my $module = shift;
  
      local $^W;
      no strict qw(refs);
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::ISA, $module;
      push @{"$module\::Boolean::ISA"}, qw(JSON::Boolean);
  
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      for my $method ($module eq $Module_XS ? @PPOnlyMethods : @XSOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  
  
  #
  # JSON Boolean
  #
  
  package JSON::Boolean;
  
  my %Installed;
  
  sub _overrride_overload {
      return if ($Installed{ $_[0] }++);
  
      my $boolean = $_[0] . '::Boolean';
  
      eval sprintf(q|
          package %s;
          use overload (
              '""' => sub { ${$_[0]} == 1 ? 'true' : 'false' },
              'eq' => sub {
                  my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);
                  if ($op eq 'true' or $op eq 'false') {
                      return "$obj" eq 'true' ? 'true' eq $op : 'false' eq $op;
                  }
                  else {
                      return $obj ? 1 == $op : 0 == $op;
                  }
              },
          );
      |, $boolean);
  
      if ($@) { Carp::croak $@; }
  
      return 1;
  }
  
  
  #
  # Helper classes for Backend Module (PP)
  #
  
  package JSON::Backend::PP;
  
  sub init {
      local $^W;
      no strict qw(refs); # this routine may be called after JSON::Backend::XS init was called.
      *{"JSON::decode_json"} = \&{"JSON::PP::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::PP::encode_json"};
      *{"JSON::PP::is_xs"}  = sub { 0 };
      *{"JSON::PP::is_pp"}  = sub { 1 };
      return 1;
  }
  
  #
  # To save memory, the below lines are read only when XS backend is used.
  #
  
  package JSON;
  
  1;
  __DATA__
  
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  use constant INDENT_LENGTH_FLAG => 15 << 12;
  
  use constant UNSUPPORTED_ENCODE_FLAG => {
      ESCAPE_SLASH      => 0x00000010,
      ALLOW_BIGNUM      => 0x00000020,
      AS_NONBLESSED     => 0x00000040,
      EXPANDED          => 0x10000000, # for developer's
  };
  
  use constant UNSUPPORTED_DECODE_FLAG => {
      LOOSE             => 0x00000001,
      ALLOW_BIGNUM      => 0x00000002,
      ALLOW_BAREKEY     => 0x00000004,
      ALLOW_SINGLEQUOTE => 0x00000008,
      EXPANDED          => 0x20000000, # for developer's
  };
  
  
  sub init {
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"JSON::XS::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::XS::encode_json"};
      *{"JSON::XS::is_xs"}  = sub { 1 };
      *{"JSON::XS::is_pp"}  = sub { 0 };
      return 1;
  }
  
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      local $^W;
      no strict qw(refs);
  
      my $JSON_XS_encode_orignal     = \&JSON::XS::encode;
      my $JSON_XS_decode_orignal     = \&JSON::XS::decode;
      my $JSON_XS_incr_parse_orignal = \&JSON::XS::incr_parse;
  
      *JSON::XS::decode     = \&JSON::Backend::XS::Supportable::_decode;
      *JSON::XS::encode     = \&JSON::Backend::XS::Supportable::_encode;
      *JSON::XS::incr_parse = \&JSON::Backend::XS::Supportable::_incr_parse;
  
      *{JSON::XS::_original_decode}     = $JSON_XS_decode_orignal;
      *{JSON::XS::_original_encode}     = $JSON_XS_encode_orignal;
      *{JSON::XS::_original_incr_parse} = $JSON_XS_incr_parse_orignal;
  
      push @JSON::Backend::XS::Supportable::ISA, 'JSON';
  
      my $pkg = 'JSON::Backend::XS::Supportable';
  
      *{JSON::new} = sub {
          my $proto = new JSON::XS; $$proto = 0;
          bless  $proto, $pkg;
      };
  
  
      for my $method (@methods) {
          my $flag = uc($method);
          my $type |= (UNSUPPORTED_ENCODE_FLAG->{$flag} || 0);
             $type |= (UNSUPPORTED_DECODE_FLAG->{$flag} || 0);
  
          next unless($type);
  
          $pkg->_make_unsupported_method($method => $type);
      }
  
      push @{"JSON::XS::Boolean::ISA"}, qw(JSON::PP::Boolean);
      push @{"JSON::PP::Boolean::ISA"}, qw(JSON::Boolean);
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  
      return 1;
  }
  
  
  
  
  #
  # Helper classes for XS
  #
  
  package JSON::Backend::XS::Supportable;
  
  $Carp::Internal{'JSON::Backend::XS::Supportable'} = 1;
  
  sub _make_unsupported_method {
      my ($pkg, $method, $type) = @_;
  
      local $^W;
      no strict qw(refs);
  
      *{"$pkg\::$method"} = sub {
          local $^W;
          if (defined $_[1] ? $_[1] : 1) {
              ${$_[0]} |= $type;
          }
          else {
              ${$_[0]} &= ~$type;
          }
          $_[0];
      };
  
      *{"$pkg\::get_$method"} = sub {
          ${$_[0]} & $type ? 1 : '';
      };
  
  }
  
  
  sub _set_for_pp {
      JSON::_load_pp( $_INSTALL_ONLY );
  
      my $type  = shift;
      my $pp    = new JSON::PP;
      my $prop = $_[0]->property;
  
      for my $name (keys %$prop) {
          $pp->$name( $prop->{$name} ? $prop->{$name} : 0 );
      }
  
      my $unsupported = $type eq 'encode' ? JSON::Backend::XS::UNSUPPORTED_ENCODE_FLAG
                                          : JSON::Backend::XS::UNSUPPORTED_DECODE_FLAG;
      my $flags       = ${$_[0]} || 0;
  
      for my $name (keys %$unsupported) {
          next if ($name eq 'EXPANDED'); # for developer's
          my $enable = ($flags & $unsupported->{$name}) ? 1 : 0;
          my $method = lc $name;
          $pp->$method($enable);
      }
  
      $pp->indent_length( $_[0]->get_indent_length );
  
      return $pp;
  }
  
  sub _encode { # using with PP encod
      if (${$_[0]}) {
          _set_for_pp('encode' => @_)->encode($_[1]);
      }
      else {
          $_[0]->_original_encode( $_[1] );
      }
  }
  
  
  sub _decode { # if unsupported-flag is set, use PP
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->decode($_[1]);
      }
      else {
          $_[0]->_original_decode( $_[1] );
      }
  }
  
  
  sub decode_prefix { # if unsupported-flag is set, use PP
      _set_for_pp('decode' => @_)->decode_prefix($_[1]);
  }
  
  
  sub _incr_parse {
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->incr_parse($_[1]);
      }
      else {
          $_[0]->_original_incr_parse( $_[1] );
      }
  }
  
  
  sub get_indent_length {
      ${$_[0]} << 4 >> 16;
  }
  
  
  sub indent_length {
      my $length = $_[1];
  
      if (!defined $length or $length > 15 or $length < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          local $^W;
          $length <<= 12;
          ${$_[0]} &= ~ JSON::Backend::XS::INDENT_LENGTH_FLAG;
          ${$_[0]} |= $length;
          *JSON::XS::encode = \&JSON::Backend::XS::Supportable::_encode;
      }
  
      $_[0];
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # If you want to use PP only support features, call with '-support_by_pp'
   # When XS unsupported feature is enable, using PP (de|en)code instead of XS ones.
   
   use JSON -support_by_pp;
   
   # option-acceptable interfaces (expect/generate UNICODE by default)
   
   $json_text   = to_json( $perl_scalar, { ascii => 1, pretty => 1 } );
   $perl_scalar = from_json( $json_text, { utf8  => 1 } );
   
   # Between (en|de)code_json and (to|from)_json, if you want to write
   # a code which communicates to an outer world (encoded in UTF-8),
   # recommend to use (en|de)code_json.
   
  =head1 VERSION
  
      2.53
  
  This version is compatible with JSON::XS B<2.27> and later.
  
  
  =head1 NOTE
  
  JSON::PP was inculded in C<JSON> distribution.
  It comes to be a perl core module in Perl 5.14.
  And L<JSON::PP> will be split away it.
  
  C<JSON> distribution will inculde yet another JSON::PP modules.
  They are JSNO::backportPP and so on. JSON.pm should work as it did at all.
  
  =head1 DESCRIPTION
  
   ************************** CAUTION ********************************
   * This is 'JSON module version 2' and there are many differences  *
   * to version 1.xx                                                 *
   * Please check your applications useing old version.              *
   *   See to 'INCOMPATIBLE CHANGES TO OLD VERSION'                  *
   *******************************************************************
  
  JSON (JavaScript Object Notation) is a simple data format.
  See to L<http://www.json.org/> and C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>).
  
  This module converts Perl data structures to JSON and vice versa using either
  L<JSON::XS> or L<JSON::PP>.
  
  JSON::XS is the fastest and most proper JSON module on CPAN which must be
  compiled and installed in your environment.
  JSON::PP is a pure-Perl module which is bundled in this distribution and
  has a strong compatibility to JSON::XS.
  
  This module try to use JSON::XS by default and fail to it, use JSON::PP instead.
  So its features completely depend on JSON::XS or JSON::PP.
  
  See to L<BACKEND MODULE DECISION>.
  
  To distinguish the module name 'JSON' and the format type JSON,
  the former is quoted by CE<lt>E<gt> (its results vary with your using media),
  and the latter is left just as it is.
  
  Module name : C<JSON>
  
  Format type : JSON
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module (i.e. backend modules) knows how to handle Unicode, documents
  how and when it does so, and even documents what "correct" means.
  
  Even though there are limitations, this feature is available since Perl version 5.6.
  
  JSON::XS requires Perl 5.8.2 (but works correctly in 5.8.8 or later), so in older versions
  C<JSON> sholud call JSON::PP as the backend which can be used since Perl 5.005.
  
  With Perl 5.8.x JSON::PP works, but from 5.8.0 to 5.8.2, because of a Perl side problem,
  JSON::PP works slower in the versions. And in 5.005, the Unicode handling is not available.
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> for more information.
  
  See also to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>
  and L<JSON::XS/ENCODING/CODESET_FLAG_NOTES>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  L</MAPPING> section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  See to L<JSON::XS/FEATURES> and L<JSON::PP/FEATURES>.
  
  =item * fast
  
  This module returns a JSON::XS object itself if available.
  Compared to other JSON modules and other serialisers such as Storable,
  JSON::XS usually compares favourably in terms of speed, too.
  
  If not available, C<JSON> returns a JSON::PP object instead of JSON::XS and
  it is very slow as pure-Perl.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an
  object oriented interface interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format possible
  (nice for simple line-based protocols), a pure-ASCII format (for when your transport
  is not 8-bit clean, still supports the whole Unicode range), or a pretty-printed
  format (for when you want to read that stuff). Or you can combine those features
  in whatever way you like.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  C<to_json> and C<from_json> are additional functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar)
  
  Converts the given Perl data structure to a json string.
  
  This function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Takes a hash reference as the second.
  
     $json_text = to_json($perl_scalar, $flag_hashref)
  
  So,
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
  
  equivalent to:
  
     $json_text = JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<encode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text)
  
  The opposite of C<to_json>: expects a json string and tries
  to parse it, returning the resulting reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->decode($json_text)
  
  Takes a hash reference as the second.
  
      $perl_scalar = from_json($json_text, $flag_hashref)
  
  So,
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
  
  equivalent to:
  
      $perl_scalar = JSON->new->utf8(1)->decode($json_text)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<decode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl vresion is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<from_json>.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
    # or
    $perl_scalar = from_json( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<to_json>.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # or 
    $unicode_json_text = to_json( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  =head2 new
  
      $json = new JSON
  
  Returns a new C<JSON> object inherited from either JSON::XS or JSON::PP
  that can be used to de/encode JSON strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
  This feature depends on the used Perl version and environment.
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  The indent space length is three and JSON::XS cannot change the indent
  space length.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, identing them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guarenteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The indent space length is three.
  With JSON::PP, you can also access C<indent_length> to change indent space length.
  
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =over
  
  =item convert_blessed_universally mode
  
  If use C<JSON> with C<-convert_blessed_universally>, the C<UNIVERSAL::TO_JSON>
  subroutine is defined as the below code:
  
     *UNIVERSAL::TO_JSON = sub {
         my $b_obj = B::svref_2object( $_[0] );
         return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                 : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                 : undef
                 ;
     }
  
  This will cause that C<encode> method converts simple blessed objects into
  JSON objects as non-blessed object.
  
     JSON -convert_blessed_universally;
     $json->allow_blessed->convert_blessed->encode( $blessed_object )
  
  This feature is experimental and may be removed in the future.
  
  =back
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  With JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  With JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>. See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE> and L<JSON::PP/METHODS>.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing. (JSON::XS)
  
  With JSON::PP as the backend, when a large value (100 or more) was set and
  it de/encodes a deep nested object/text, it may raise a warning
  'Deep recursion on subroutin' at the perl runtime phase.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS>, below, for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 property
  
      $boolean = $json->property($property_name)
  
  Returns a boolean value about above some properties.
  
  The available properties are C<ascii>, C<latin1>, C<utf8>,
  C<indent>,C<space_before>, C<space_after>, C<relaxed>, C<canonical>,
  C<allow_nonref>, C<allow_unknown>, C<allow_blessed>, C<convert_blessed>,
  C<shrink>, C<max_depth> and C<max_size>.
  
     $boolean = $json->property('utf8');
      => 0
     $json->utf8;
     $boolean = $json->property('utf8');
      => 1
  
  Sets the property with a given boolean value.
  
      $json = $json->property($property_name => $boolean);
  
  With no argumnt, it returns all the above properties as a hash reference.
  
      $flag_hashref = $json->property();
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  The backend module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthese
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the errornous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want ot repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP SUPPORT METHODS
  
  The below methods are JSON::PP own methods, so when C<JSON> works
  with JSON::PP (i.e. the created object is a JSON::PP object), available.
  See to L<JSON::PP/JSON::PP OWN METHODS> in detail.
  
  If you use C<JSON> with additonal C<-support_by_pp>, some methods
  are available even with JSON::XS. See to L<USE PP FEATURES EVEN THOUGH XS BACKEND>.
  
     BEING { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = new JSON;
     $json->allow_nonref->escape_slash->encode("/");
  
     # functional interfaces too.
     print to_json(["/"], {escape_slash => 1});
     print from_json('["foo"]', {utf8 => 1});
  
  If you do not want to all functions but C<-support_by_pp>,
  use C<-no_export>.
  
     use JSON -support_by_pp, -no_export;
     # functional interfaces are not exported.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  any JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<MAPPING> aboout the conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But by default
  JSON backend modules encode strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  With JSON::XS, The indent space length is 3 and cannot be changed.
  With JSON::PP, it sets the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  with 'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded toa JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the leats significant bit.
  
  If the backend is JSON::PP and C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check wether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
  If C<JSON::true> and C<JSON::false> are used as strings or compared as strings,
  they represent as C<true> and C<false> respectively.
  
     print JSON::true . "\n";
      => true
     print JSON::true + 1;
      => 1
  
     ok(JSON::true eq 'true');
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::null> returns C<unddef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same datastructure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  In future, the ordered object feature will be added to JSON::PP using C<tie> mechanism.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  With C<convert_blessed_universally> mode,  C<encode> converts blessed
  hash references or blessed array references (contains other blessed references)
  into JSON members and arrays.
  
     use JSON -convert_blessed_universally;
     JSON->new->allow_blessed->convert_blessed->encode( $blessed_object );
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choise is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  If the backend is JSON::PP and C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 JSON and ECMAscript
  
  See to L<JSON::XS/JSON and ECMAscript>.
  
  =head1 JSON and YAML
  
  JSON is not a subset of YAML.
  See to L<JSON::XS/JSON and YAML>.
  
  
  =head1 BACKEND MODULE DECISION
  
  When you use C<JSON>, C<JSON> tries to C<use> JSON::XS. If this call failed, it will
  C<uses> JSON::PP. The required JSON::XS version is I<2.2> or later.
  
  The C<JSON> constructor method returns an object inherited from the backend module,
  and JSON::XS object is a blessed scaler reference while JSON::PP is a blessed hash
  reference.
  
  So, your program should not depend on the backend module, especially
  returned objects should not be modified.
  
   my $json = JSON->new; # XS or PP?
   $json->{stash} = 'this is xs object'; # this code may raise an error!
  
  To check the backend module, there are some methods - C<backend>, C<is_pp> and C<is_xs>.
  
    JSON->backend; # 'JSON::XS' or 'JSON::PP'
    
    JSON->backend->is_pp: # 0 or 1
    
    JSON->backend->is_xs: # 1 or 0
    
    $json->is_xs; # 1 or 0
    
    $json->is_pp; # 0 or 1
  
  
  If you set an enviornment variable C<PERL_JSON_BACKEND>, The calling action will be changed.
  
  =over
  
  =item PERL_JSON_BACKEND = 0 or PERL_JSON_BACKEND = 'JSON::PP'
  
  Always use JSON::PP
  
  =item PERL_JSON_BACKEND == 1 or PERL_JSON_BACKEND = 'JSON::XS,JSON::PP'
  
  (The default) Use compiled JSON::XS if it is properly compiled & installed,
  otherwise use JSON::PP.
  
  =item PERL_JSON_BACKEND == 2 or PERL_JSON_BACKEND = 'JSON::XS'
  
  Always use compiled JSON::XS, die if it isn't properly compiled & installed.
  
  =item PERL_JSON_BACKEND = 'JSON::backportPP'
  
  Always use JSON::backportPP.
  JSON::backportPP is JSON::PP back port module.
  C<JSON> includs JSON::backportPP instead of JSON::PP.
  
  =back
  
  These ideas come from L<DBI::PurePerl> mechanism.
  
  example:
  
   BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::PP' }
   use JSON; # always uses JSON::PP
  
  In future, it may be able to specify another module.
  
  =head1 USE PP FEATURES EVEN THOUGH XS BACKEND
  
  Many methods are available with either JSON::XS or JSON::PP and
  when the backend module is JSON::XS, if any JSON::PP specific (i.e. JSON::XS unspported)
  method is called, it will C<warn> and be noop.
  
  But If you C<use> C<JSON> passing the optional string C<-support_by_pp>,
  it makes a part of those unupported methods available.
  This feature is achieved by using JSON::PP in C<de/encode>.
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 2 } # with JSON::XS
     use JSON -support_by_pp;
     my $json = new JSON;
     $json->allow_nonref->escape_slash->encode("/");
  
  At this time, the returned object is a C<JSON::Backend::XS::Supportable>
  object (re-blessed XS object), and  by checking JSON::XS unsupported flags
  in de/encoding, can support some unsupported methods - C<loose>, C<allow_bignum>,
  C<allow_barekey>, C<allow_singlequote>, C<escape_slash> and C<indent_length>.
  
  When any unsupported methods are not enable, C<XS de/encode> will be
  used as is. The switch is achieved by changing the symbolic tables.
  
  C<-support_by_pp> is effective only when the backend module is JSON::XS
  and it makes the de/encoding speed down a bit.
  
  See to L<JSON::PP SUPPORT METHODS>.
  
  =head1 INCOMPATIBLE CHANGES TO OLD VERSION
  
  There are big incompatibility between new version (2.00) and old (1.xx).
  If you use old C<JSON> 1.xx in your code, please check it.
  
  See to L<Transition ways from 1.xx to 2.xx.>
  
  =over
  
  =item jsonToObj and objToJson are obsoleted.
  
  Non Perl-style name C<jsonToObj> and C<objToJson> are obsoleted
  (but not yet deleted from the source).
  If you use these functions in your code, please replace them
  with C<from_json> and C<to_json>.
  
  
  =item Global variables are no longer available.
  
  C<JSON> class variables - C<$JSON::AUTOCONVERT>, C<$JSON::BareKey>, etc...
  - are not available any longer.
  Instead, various features can be used through object methods.
  
  
  =item Package JSON::Converter and JSON::Parser are deleted.
  
  Now C<JSON> bundles with JSON::PP which can handle JSON more properly than them.
  
  =item Package JSON::NotString is deleted.
  
  There was C<JSON::NotString> class which represents JSON value C<true>, C<false>, C<null>
  and numbers. It was deleted and replaced by C<JSON::Boolean>.
  
  C<JSON::Boolean> represents C<true> and C<false>.
  
  C<JSON::Boolean> does not represent C<null>.
  
  C<JSON::null> returns C<undef>.
  
  C<JSON> makes L<JSON::XS::Boolean> and L<JSON::PP::Boolean> is-a relation
  to L<JSON::Boolean>.
  
  =item function JSON::Number is obsoleted.
  
  C<JSON::Number> is now needless because JSON::XS and JSON::PP have
  round-trip integrity.
  
  =item JSONRPC modules are deleted.
  
  Perl implementation of JSON-RPC protocol - C<JSONRPC >, C<JSONRPC::Transport::HTTP>
  and C<Apache::JSONRPC > are deleted in this distribution.
  Instead of them, there is L<JSON::RPC> which supports JSON-RPC protocol version 1.1.
  
  =back
  
  =head2 Transition ways from 1.xx to 2.xx.
  
  You should set C<suport_by_pp> mode firstly, because
  it is always successful for the below codes even with JSON::XS.
  
      use JSON -support_by_pp;
  
  =over
  
  =item Exported jsonToObj (simple)
  
    from_json($json_text);
  
  =item Exported objToJson (simple)
  
    to_json($perl_scalar);
  
  =item Exported jsonToObj (advanced)
  
    $flags = {allow_barekey => 1, allow_singlequote => 1};
    from_json($json_text, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    $JSON::QuotApos = 1;
    jsonToObj($json_text);
  
  =item Exported objToJson (advanced)
  
    $flags = {allow_blessed => 1, allow_barekey => 1};
    to_json($perl_scalar, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    objToJson($perl_scalar);
  
  =item jsonToObj as object method
  
    $json->decode($json_text);
  
  =item objToJson as object method
  
    $json->encode($perl_scalar);
  
  =item new method with parameters
  
  The C<new> method in 2.x takes any parameters no longer.
  You can set parameters instead;
  
     $json = JSON->new->pretty;
  
  =item $JSON::Pretty, $JSON::Indent, $JSON::Delimiter
  
  If C<indent> is enable, that means C<$JSON::Pretty> flag set. And
  C<$JSON::Delimiter> was substituted by C<space_before> and C<space_after>.
  In conclusion:
  
     $json->indent->space_before->space_after;
  
  Equivalent to:
  
    $json->pretty;
  
  To change indent length, use C<indent_length>.
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->pretty->indent_length(2)->encode($perl_scalar);
  
  =item $JSON::BareKey
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_barekey->decode($json_text)
  
  =item $JSON::ConvBlessed
  
  use C<-convert_blessed_universally>. See to L<convert_blessed>.
  
  =item $JSON::QuotApos
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_singlequote->decode($json_text)
  
  =item $JSON::SingleQuote
  
  Disable. C<JSON> does not make such a invalid JSON string any longer.
  
  =item $JSON::KeySort
  
    $json->canonical->encode($perl_scalar)
  
  This is the ascii sort.
  
  If you want to use with your own sort routine, check the C<sort_by> method.
  
  (Only with JSON::PP, even if C<-support_by_pp> is used currently.)
  
    $json->sort_by($sort_routine_ref)->encode($perl_scalar)
   
    $json->sort_by(sub { $JSON::PP::a <=> $JSON::PP::b })->encode($perl_scalar)
  
  Can't access C<$a> and C<$b> but C<$JSON::PP::a> and C<$JSON::PP::b>.
  
  =item $JSON::SkipInvalid
  
    $json->allow_unknown
  
  =item $JSON::AUTOCONVERT
  
  Needless. C<JSON> backend modules have the round-trip integrity.
  
  =item $JSON::UTF8
  
  Needless because C<JSON> (JSON::XS/JSON::PP) sets
  the UTF8 flag on properly.
  
      # With UTF8-flagged strings
  
      $json->allow_nonref;
      $str = chr(1000); # UTF8-flagged
  
      $json_text  = $json->utf8(0)->encode($str);
      utf8::is_utf8($json_text);
      # true
      $json_text  = $json->utf8(1)->encode($str);
      utf8::is_utf8($json_text);
      # false
  
      $str = '"' . chr(1000) . '"'; # UTF8-flagged
  
      $perl_scalar  = $json->utf8(0)->decode($str);
      utf8::is_utf8($perl_scalar);
      # true
      $perl_scalar  = $json->utf8(1)->decode($str);
      # died because of 'Wide character in subroutine'
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =item $JSON::UnMapping
  
  Disable. See to L<MAPPING>.
  
  =item $JSON::SelfConvert
  
  This option was deleted.
  Instead of it, if a givien blessed object has the C<TO_JSON> method,
  C<TO_JSON> will be executed with C<convert_blessed>.
  
    $json->convert_blessed->encode($bleesed_hashref_or_arrayref)
    # if need, call allow_blessed
  
  Note that it was C<toJson> in old version, but now not C<toJson> but C<TO_JSON>.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item example programs
  
  =back
  
  =head1 THREADS
  
  No test with JSON::PP. If with JSON::XS, See to L<JSON::XS/THREADS>.
  
  
  =head1 BUGS
  
  Please report bugs relevant to C<JSON> to E<lt>makamaka[at]cpan.orgE<gt>.
  
  
  =head1 SEE ALSO
  
  Most of the document is copied and modified from JSON::XS doc.
  
  L<JSON::XS>, L<JSON::PP>
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
  
  The relese of this new version owes to the courtesy of Marc Lehmann.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2011 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/backportPP.pm"} = <<'JSON_BACKPORTPP';
  package # This is JSON::backportPP
      JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  use base qw(Exporter);
  use overload ();
  
  use Carp ();
  use B ();
  #use Devel::Peek;
  
  $JSON::PP::VERSION = '2.27200';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enable?
      # Helper module sets @JSON::PP::_properties.
      if ($] < 5.008 ) {
          my $helper = $] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $flag_name = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my %encode_allow_method
       = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                            allow_blessed convert_blessed indent indent_length allow_bignum
                            as_nonblessed
                          /;
  my %decode_allow_method
       = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                            allow_barekey max_size relaxed/;
  
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent      => 0,
          FLAGS       => 0,
          fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ > 1) {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $idx = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($idx->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
                  return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
  
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  ) unless ($allow_blessed);
  
                  return 'null';
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, string_to_json( $self, $k )
                            .  $del
                            . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, $self->object_to_json($v) || $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
      }
  
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $b_obj = B::svref_2object(\$value);  # for round trip problem
          my $flags = $b_obj->FLAGS;
  
          return $value # as is 
              if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
          my $type = ref($value);
  
          if(!$type){
              return string_to_json($self, $value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          elsif ($type) {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
               if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                   return 'null';
               }
               else {
                   if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                   }
                   else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                   }
               }
  
          }
          else {
              return $self->{fallback}->($value)
                   if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
              return 'null';
          }
  
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # 1chracter
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest nubmer of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bigint;   # using Math::BigInt
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      # $opt flag
      # 0x00000001 .... decode_prefix
      # 0x10000000 .... incr_parse
  
      sub PP_decode_json {
          my ($self, $opt); # $opt is an effective flag during this decode_json.
  
          ($self, $text, $opt) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $idx = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
              = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
          }
          else {
              utf8::upgrade( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          # Currently no effect
          # should use regexp
          my @octets = unpack('C4', $text);
          $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                      : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                      : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                      : ( $octets[2]                ) ? 'UTF-16LE'
                      : (!$octets[2]                ) ? 'UTF-32LE'
                      : 'unknown';
  
          white(); # remove head white space
  
          my $valid_start = defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
  
          if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          if ( $ch ) {
              return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
              decode_error("garbage after JSON object");
          }
  
          ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my ($i, $s, $t, $u);
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          if ( $utf8 ) {
                              unless( $ch = is_valid_utf8($ch) ) {
                                  $at -= 1;
                                  decode_error("malformed UTF-8 character in JSON string");
                              }
                              else {
                                  $at += $utf8_len - 1;
                              }
                          }
                          else {
                              utf8::encode( $ch );
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch le ' '){
                  next_chr();
              }
              elsif($ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at--;
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
  
          # According to RFC4627, hex or oct digts are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              my $hex  = $peek =~ /[xX]/; # 0 or 1
  
              if($hex){
                  decode_error("malformed number (leading zero must not be followed by another digit)");
                  ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
              }
              else{ # oct
                  ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                  if (defined $n and length $n > 1) {
                      decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
              }
  
              if(defined $n and length($n)){
                  if (!$hex and length($n) == 1) {
                     decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
                  $at += length($n) + $hex;
                  next_chr;
                  return $hex ? hex($n) : oct($n);
              }
          }
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($v !~ /[.eE]/ and length $v > $max_intsize) {
              if ($allow_bigint) { # from Adam Sussman
                  require Math::BigInt;
                  return Math::BigInt->new($v);
              }
              else {
                  return "$v";
              }
          }
          elsif ($allow_bigint) {
              require Math::BigFloat;
              return Math::BigFloat->new($v);
          }
  
          return 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = $] >= 5.008           ? 'U*'
                     : $] <  5.006           ? 'C*'
                     : utf8::is_utf8( $str ) ? 'U*' # 5.6
                     : 'C*'
                     ;
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( $] >= 5.008 ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
      }
  
      if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
          package JSON::PP;
          require subs;
          subs->import('join');
          eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |;
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Sclar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamely copied and modified from JSON::XS code.
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::backportPP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::backportPP::Boolean" };
  
  sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  package JSON::backportPP::Boolean;
  
  @JSON::backportPP::Boolean::ISA = ('JSON::PP::Boolean');
  use overload (
     "0+"     => sub { ${$_[0]} },
     "++"     => sub { $_[0] = ${$_[0]} + 1 },
     "--"     => sub { $_[0] = ${$_[0]} - 1 },
     fallback => 1,
  );
  
  
  ###############################
  
  package
      JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  $JSON::PP::IncrParser::VERSION = '1.01';
  
  my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_parsing => 0,
          incr_p       => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
  
      my $max_size = $coder->get_max_size;
  
      if ( defined wantarray ) {
  
          $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
  
          if ( wantarray ) {
              my @ret;
  
              $self->{incr_parsing} = 1;
  
              do {
                  push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
  
                  unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                  }
  
              } until ( length $self->{incr_text} >= $self->{incr_p} );
  
              $self->{incr_parsing} = 0;
  
              return @ret;
          }
          else { # in scalar context
              $self->{incr_parsing} = 1;
              my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
              $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
              return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
          }
  
      }
  
  }
  
  
  sub _incr_parse {
      my ( $self, $coder, $text, $skip ) = @_;
      my $p = $self->{incr_p};
      my $restore = $p;
  
      my @obj;
      my $len = length $text;
  
      if ( $self->{incr_mode} == INCR_M_WS ) {
          while ( $len > $p ) {
              my $s = substr( $text, $p, 1 );
              $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
              $self->{incr_mode} = INCR_M_JSON;
              last;
         }
      }
  
      while ( $len > $p ) {
          my $s = substr( $text, $p++, 1 );
  
          if ( $s eq '"' ) {
              if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                  next;
              }
  
              if ( $self->{incr_mode} != INCR_M_STR  ) {
                  $self->{incr_mode} = INCR_M_STR;
              }
              else {
                  $self->{incr_mode} = INCR_M_JSON;
                  unless ( $self->{incr_nest} ) {
                      last;
                  }
              }
          }
  
          if ( $self->{incr_mode} == INCR_M_JSON ) {
  
              if ( $s eq '[' or $s eq '{' ) {
                  if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                      Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                  }
              }
              elsif ( $s eq ']' or $s eq '}' ) {
                  last if ( --$self->{incr_nest} <= 0 );
              }
              elsif ( $s eq '#' ) {
                  while ( $len > $p ) {
                      last if substr( $text, $p++, 1 ) eq "\n";
                  }
              }
  
          }
  
      }
  
      $self->{incr_p} = $p;
  
      return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
      return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
  
      return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
  
      local $Carp::CarpLevel = 2;
  
      $self->{incr_p} = $restore;
      $self->{incr_c} = $p;
  
      my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
  
      $self->{incr_text} = substr( $self->{incr_text}, $p );
      $self->{incr_p} = 0;
  
      return $obj or '';
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
      $self->{incr_p} = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_p}       = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
      $self->{incr_parsing} = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.27200
  
  L<JSON::XS> 2.27 (~2.30) compatible.
  
  =head1 DESCRIPTION
  
  This module is L<JSON::XS> compatible pure Perl module.
  (Perl 5.8 or later is recommended)
  
  JSON::XS is the fastest and most proper JSON module on CPAN.
  It is written by Marc Lehmann in C, so must be compiled and
  installed in the used environment.
  
  JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
  
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module knows how to handle Unicode (depending on Perl version).
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and L<UNICODE HANDLING ON PERLS>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security feature).
  But when some options are set, loose chcking features are available.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::PP::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl vresion is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON::PP->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 METHODS
  
  Basically, check to L<JSON> or L<JSON::XS>.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Rturns a new JSON::PP object that can be used to de/encode JSON
  strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
  
  In Perl 5.005, there is no character having high value (more than 255).
  See to L<UNICODE HANDLING ON PERLS>.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  See to L<UNICODE HANDLING ON PERLS>.
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  (In Perl 5.005, any character outside the range 0..255 does not exist.
  See to L<UNICODE HANDLING ON PERLS>.)
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> flags in one call to generate the most readable
  (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  If you want your own sorting routine, you can give a code referece
  or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  In JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible.
  It will also try to downgrade any strings to octet-form if possible.
  
  In JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>.
  See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  When a large value (100 or more) was set and it de/encodes a deep nested object/text,
  it may raise a warning 'Deep recursion on subroutin' at the perl runtime phase.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthese
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the errornous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want ot repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP OWN METHODS
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<JSON::XS/MAPPING> aboout the normal conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But default
  JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  JSON::XS indent space length is 3 and cannot be changed.
  JSON::PP set the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used
  in encoding JSON objects.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  =head1 INTERNAL
  
  For developers.
  
  =over
  
  =item PP_encode_box
  
  Returns
  
          {
              depth        => $depth,
              indent_count => $indent_count,
          }
  
  
  =item PP_decode_box
  
  Returns
  
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
  
  =back
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON::PP>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded toa JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the leats significant bit.
  
  When C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check wether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::PP::true . "\n";
      => true
     print JSON::PP::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::PP::null> returns C<unddef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same datastructure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false, JSON::PP::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::PP::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choise is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  When C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 UNICODE HANDLING ON PERLS
  
  If you do not know about Unicode on Perl well,
  please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =head2 Perl 5.8 and later
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
  
      $json->allow_nonref->encode(chr hex 3042);
      $json->allow_nonref->encode(chr hex 12345);
  
  Reuturns C<"\u3042"> and C<"\ud808\udf45"> respectively.
  
      $json->allow_nonref->decode('"\u3042"');
      $json->allow_nonref->decode('"\ud808\udf45"');
  
  Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
  
  Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
  so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
  
  
  =head2 Perl 5.6
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work.
  
  =head2 Perl 5.005
  
  Perl 5.005 is a byte sementics world -- all strings are sequences of bytes.
  That means the unicode handling is not available.
  
  In encoding,
  
      $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
      $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
  
  Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
  as C<$value % 256>, so the above codes are equivalent to :
  
      $json->allow_nonref->encode(chr 66);
      $json->allow_nonref->encode(chr 69);
  
  In decoding,
  
      $json->decode('"\u00e3\u0081\u0082"');
  
  The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
  japanese character (C<HIRAGANA LETTER A>).
  And if it is represented in Unicode code point, C<U+3042>.
  
  Next, 
  
      $json->decode('"\u3042"');
  
  We ordinary expect the returned value is a Unicode character C<U+3042>.
  But here is 5.005 world. This is C<0xE3 0x81 0x82>.
  
      $json->decode('"\ud808\udf45"');
  
  This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
  
  
  =head1 TODO
  
  =over
  
  =item speed
  
  =item memory saving
  
  =back
  
  
  =head1 SEE ALSO
  
  Most of the document are copied and modified from JSON::XS doc.
  
  L<JSON::XS>
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2011 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = <<'JSON_BACKPORTPP_BOOLEAN';
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules. See
  L<JSON::PP> for more info about this class.
  
  =cut
  
  use JSON::backportPP ();
  use strict;
  
  1;
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = <<'JSON_BACKPORTPP_COMPAT5005';
  package # This is JSON::backportPP
      JSON::backportPP5005;
  
  use 5.005;
  use strict;
  
  my @properties;
  
  $JSON::PP5005::VERSION = '1.10';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          0; # It is considered that UTF8 flag off for Perl 5.005.
      }
  
      sub utf8::upgrade {
      }
  
      sub utf8::downgrade {
          1; # must always return true.
      }
  
      sub utf8::encode  {
      }
  
      sub utf8::decode {
      }
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
      # missing in B module.
      sub B::SVp_IOK () { 0x01000000; }
      sub B::SVp_NOK () { 0x02000000; }
      sub B::SVp_POK () { 0x04000000; }
  
      $INC{'bytes.pm'} = 1; # dummy
  }
  
  
  
  sub _encode_ascii {
      join('', map { $_ <= 127 ? chr($_) : sprintf('\u%04x', $_) } unpack('C*', $_[0]) );
  }
  
  
  sub _encode_latin1 {
      join('', map { chr($_) } unpack('C*', $_[0]) );
  }
  
  
  sub _decode_surrogates { # from http://homepage1.nifty.com/nomenclator/unicode/ucs_utf.htm
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00); # from perlunicode
      my $bit = unpack('B32', pack('N', $uni));
  
      if ( $bit =~ /^00000000000(...)(......)(......)(......)$/ ) {
          my ($w, $x, $y, $z) = ($1, $2, $3, $4);
          return pack('B*', sprintf('11110%s10%s10%s10%s', $w, $x, $y, $z));
      }
      else {
          Carp::croak("Invalid surrogate pair");
      }
  }
  
  
  sub _decode_unicode {
      my ($u) = @_;
      my ($utf8bit);
  
      if ( $u =~ /^00([89a-f][0-9a-f])$/i ) { # 0x80-0xff
           return pack( 'H2', $1 );
      }
  
      my $bit = unpack("B*", pack("H*", $u));
  
      if ( $bit =~ /^00000(.....)(......)$/ ) {
          $utf8bit = sprintf('110%s10%s', $1, $2);
      }
      elsif ( $bit =~ /^(....)(......)(......)$/ ) {
          $utf8bit = sprintf('1110%s10%s10%s', $1, $2, $3);
      }
      else {
          Carp::croak("Invalid escaped unicode");
      }
  
      return pack('B*', $utf8bit);
  }
  
  
  sub JSON::PP::incr_text {
      $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
      if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
  
      $_[0]->{_incr_parser}->{incr_text} = $_[1] if ( @_ > 1 );
      $_[0]->{_incr_parser}->{incr_text};
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP5005 - Helper module in using JSON::PP in Perl 5.005
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2010 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = <<'JSON_BACKPORTPP_COMPAT5006';
  package # This is JSON::backportPP
      JSON::backportPP56;
  
  use 5.006;
  use strict;
  
  my @properties;
  
  $JSON::PP56::VERSION = '1.08';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          my $len =  length $_[0]; # char length
          {
              use bytes; #  byte length;
              return $len != length $_[0]; # if !=, UTF8-flagged on.
          }
      }
  
  
      sub utf8::upgrade {
          ; # noop;
      }
  
  
      sub utf8::downgrade ($;$) {
          return 1 unless ( utf8::is_utf8( $_[0] ) );
  
          if ( _is_valid_utf8( $_[0] ) ) {
              my $downgrade;
              for my $c ( unpack( "U*", $_[0] ) ) {
                  if ( $c < 256 ) {
                      $downgrade .= pack("C", $c);
                  }
                  else {
                      $downgrade .= pack("U", $c);
                  }
              }
              $_[0] = $downgrade;
              return 1;
          }
          else {
              Carp::croak("Wide character in subroutine entry") unless ( $_[1] );
              0;
          }
      }
  
  
      sub utf8::encode ($) { # UTF8 flag off
          if ( utf8::is_utf8( $_[0] ) ) {
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
          else {
              $_[0] = pack( "U*", unpack( "C*", $_[0] ) );
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
      }
  
  
      sub utf8::decode ($) { # UTF8 flag on
          if ( _is_valid_utf8( $_[0] ) ) {
              utf8::downgrade( $_[0] );
              $_[0] = pack( "U*", unpack( "U*", $_[0] ) );
          }
      }
  
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&JSON::PP::_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&JSON::PP::_decode_unicode;
  
      unless ( defined &B::SVp_NOK ) { # missing in B module.
          eval q{ sub B::SVp_NOK () { 0x02000000; } };
      }
  
  }
  
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _unpack_emu { # for Perl 5.6 unpack warnings
      return   !utf8::is_utf8($_[0]) ? unpack('C*', $_[0]) 
             : _is_valid_utf8($_[0]) ? unpack('U*', $_[0])
             : unpack('C*', $_[0]);
  }
  
  
  sub _is_valid_utf8 {
      my $str = $_[0];
      my $is_utf8;
  
      while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg)
      {
          if (defined $1) {
              $is_utf8 = 1 if (!defined $is_utf8);
          }
          else {
              $is_utf8 = 0 if (!defined $is_utf8);
              if ($is_utf8) { # eventually, not utf8
                  return;
              }
          }
      }
  
      return $is_utf8;
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP56 - Helper module in using JSON::PP in Perl 5.6
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2009 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"Method/Generate/Accessor.pm"} = <<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use strictures 1;
  use Moo::_Utils;
  use base qw(Moo::Object);
  use Sub::Quote;
  use B 'perlstring';
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor};
    } elsif ($is eq 'lazy') {
      $spec->{init_arg} = undef unless exists $spec->{init_arg};
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless $spec->{default};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    my %methods;
    if (my $reader = $spec->{reader}) {
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      $methods{$pred} =
        quote_sub "${into}::${pred}" =>
          '    '.$self->_generate_simple_has('$_[0]', $name)."\n"
        ;
    }
    if (my $cl = $spec->{clearer}) {
      $methods{$cl} =
        quote_sub "${into}::${cl}" => 
          "    delete \$_[0]->{${\perlstring $name}}\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], Role::Tiny->methods_provided_by($hspec);
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $spec (@specs) {
        my ($proxy, $target, @args) = @$spec;
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" =>
          'do { '.$self->_generate_get($name, $spec).qq! }||die "Attempted to access '${name}' but it is not set"!,
          delete $self->{captures}
        ;
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and ($spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and ($spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      'do { '.$self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name),
      ).'; '.$simple.' }';
    }
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\perlstring $name}}";
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    $self->_generate_simple_set(
      $me, $name, $spec, $self->_generate_get_default($me, $name, $spec)
    ).' unless '.$test;
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    $spec->{default}
      ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
      : "${me}->${\$spec->{builder}}"
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->_generate_simple_get(@args);
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $simple = $self->_generate_simple_set('$self', $name, $spec, '$value');
      my $code = "do { my (\$self, \$value) = \@_;\n";
      if ($coerce) {
        $code .=
          "        \$value = "
          .$self->_generate_coerce($name, '$self', '$value', $coerce).";\n";
      }
      if ($isa_check) {
        $code .= 
          "        ".$self->_generate_isa_check($name, '$value', $isa_check).";\n";
      }
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', '$value', $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        \$value;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_coerce {
    my ($self, $name, $obj, $value, $coerce) = @_;
    $self->_generate_call_code($name, 'coerce', "${value}", $coerce);
  }
   
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check) = @_;
    $self->_generate_call_code($name, 'isa_check', $value, $check);
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    if (my $quoted = quoted_from_sub($sub)) {
      my $code = $quoted->[1];
      my $at_ = '@_ = ('.$values.');';
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_${name}};
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify(
          $code, $values, Sub::Quote::capture_unroll($cap_name, $captures, 6)
        );
      } else {
        Sub::Quote::inlinify($code, $values);
      }
    } else {
      my $cap_name = qq{\$${type}_for_${name}};
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $_, $spec
                        );
      my $get_value = 
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ( $spec->{coerce} ) {
          $get_value = $self->_generate_coerce(
              $name, $me, $get_value,
              $spec->{coerce}
            )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $me, $source,
              $spec->{coerce}
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub generate_multi_set {
    my ($self, $me, $to_set, $from) = @_;
    "\@{${me}}{qw(${\join ' ', @$to_set})} = $from";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    my $simple = "${me}->{${name_str}} = ${value}";
  
    if ($spec->{weak_ref}) {
      { local $@; require Scalar::Util; }
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      #Internals::SetReadWrite($foo);
      #Scalar::Util::weaken ($foo);
      #Internals::SetReadOnly($foo);
      #
      # but requires XS and is just too damn crazy
      # so simply throw a better exception
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : "Scalar::Util::weaken(${simple})";
  
        eval { Scalar::Util::weaken($simple); 1 } or do {
          if( \$@ =~ /Modification of a read-only value attempted/) {
            { local \$@; require Carp; }
            Carp::croak( sprintf (
              'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
              $name_str,
            ) );
          } else {
            die \$@;
          }
        };
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using perlstring
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot }
    );
    $into->can($name);
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = <<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B 'perlstring';
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @builds;
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = <<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use strictures 1;
  use Sub::Quote;
  use base qw(Moo::Object);
  use Sub::Defer;
  use B 'perlstring';
  
  sub register_attribute_specs {
    my ($self, %spec) = @_;
    @{$self->{attribute_specs}||={}}{keys %spec} = values %spec;
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string} or 'bless({}, $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    my $package = $self->{package};
    defer_sub "${package}::new" => sub {
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      { local $@; require Method::Generate::BuildAll; }
      $body .= Method::Generate::BuildAll->new->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      { local $@; require Method::Generate::DemolishAll; }
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_generator}) {
      '    if ($class ne '.perlstring($into).') {'."\n".
      '      '.$gen.";\n".
      '      return $class->'.$name.'(@_)'.";\n".
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my (@init, @slots, %test);
    my $ag = $self->accessor_generator;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      unless ($ag->is_simple_attribute($name, $attr_spec)) {
        next NAME unless defined($attr_spec->{init_arg})
                           or $ag->has_eager_default($name, $attr_spec);
        $test{$name} = $attr_spec->{init_arg};
        next NAME;
      }
      next NAME unless defined(my $i = $attr_spec->{init_arg});
      push @init, $i;
      push @slots, $name;
    }
    return '' unless @init or %test;
    join '', (
      @init
        ? '    '.$self->_cap_call($ag->generate_multi_set(
            '$new', [ @slots ], '@{$args}{qw('.join(' ',@init).')}'
          )).";\n"
        : ''
    ), map {
      my $arg_key = perlstring($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep $spec->{$_}{required},
          sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, qw('
      .join(' ',@required_init).')) {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  sub _check_isa {
    my ($self, $spec) = @_;
    my $acc = $self->accessor_generator;
    my $captures = $self->{captures};
    my $check = '';
    foreach my $name (sort keys %$spec) {
      my ($init, $isa) = @{$spec->{$name}}{qw(init_arg isa)};
      next unless $init and $isa;
      my $init_str = perlstring($init);
      my ($code, $add_captures) = $acc->generate_isa_check(
        $name, "\$args->{${init_str}}", $isa
      );
      @{$captures}{keys %$add_captures} = values %$add_captures;
      $check .= "    ${code}".(
        (not($spec->{lazy}) and ($spec->{default} or $spec->{builder})
          ? ";\n"
          : "if exists \$args->{${init_str}};\n"
        )
      );
    }
    return $check;
  }
  
  sub _fire_triggers {
    my ($self, $spec) = @_;
    my $acc = $self->accessor_generator;
    my $captures = $self->{captures};
    my $fire = '';
    foreach my $name (sort keys %$spec) {
      my ($init, $trigger) = @{$spec->{$name}}{qw(init_arg trigger)};
      next unless $init && $trigger;
      my ($code, $add_captures) = $acc->generate_trigger(
        $name, '$new', $acc->generate_simple_get('$new', $name), $trigger
      );
      @{$captures}{keys %$add_captures} = values %$add_captures;
      $fire .= "    ${code} if exists \$args->{${\perlstring $init}};\n";
    }
    return $fire;
  }
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = <<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B qw(perlstring);
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL($Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = <<'METHOD_INLINER';
  package Method::Inliner;
  
  use strictures 1;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
  	$fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Moo.pm"} = <<'MOO';
  package Moo;
  
  use strictures 1;
  use Moo::_Utils;
  use B 'perlstring';
  
  our $VERSION = '0.009013'; # 0.9.13
  $VERSION = eval $VERSION;
  
  our %MAKERS;
  
  sub import {
    my $target = caller;
    my $class = shift;
    strictures->import;
    return if $MAKERS{$target}; # already exported into this package
    *{_getglob("${target}::extends")} = sub {
      _load_module($_) for @_;
      # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
      @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    };
    *{_getglob("${target}::with")} = sub {
      { local $@; require Moo::Role; }
      die "Only one role supported at a time by with" if @_ > 1;
      Moo::Role->apply_role_to_package($target, $_[0]);
    };
    $MAKERS{$target} = {};
    *{_getglob("${target}::has")} = sub {
      my ($name, %spec) = @_;
      ($MAKERS{$target}{accessor} ||= do {
        { local $@; require Method::Generate::Accessor; }
        Method::Generate::Accessor->new
      })->generate_method($target, $name, \%spec);
      $class->_constructor_maker_for($target)
            ->register_attribute_specs($name, \%spec);
    };
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        { local $@; require Class::Method::Modifiers; }
        _install_modifier($target, $type, @_);
      };
    }
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        { local $@; require Moo::Object; } ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target, $select_super) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      {
        local $@;
        require Method::Generate::Constructor;
        require Sub::Defer;
      }
      my ($moo_constructor, $con);
  
      if ($select_super && $MAKERS{$select_super}) {
        $moo_constructor = 1;
        $con = $MAKERS{$select_super}{constructor};
      } else {
        my $t_new = $target->can('new');
        if ($t_new) {
          if ($t_new == Moo::Object->can('new')) {
            $moo_constructor = 1;
          } elsif (my $defer_target = (Sub::Defer::defer_info($t_new)||[])->[0]) {
            my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
            if ($MAKERS{$pkg}) {
              $moo_constructor = 1;
              $con = $MAKERS{$pkg}{constructor};
            }
          }
        } else {
          $moo_constructor = 1; # no other constructor, make a Moo one
        }
      };
      Method::Generate::Constructor
        ->new(
          package => $target,
          accessor_generator => do {
            { local $@; require Method::Generate::Accessor; }
            Method::Generate::Accessor->new;
          },
          construction_string => (
            $moo_constructor
              ? ($con ? $con->construction_string : undef)
              : ('$class->'.$target.'::SUPER::new(@_)')
          ),
          subconstructor_generator => (
            $class.'->_constructor_maker_for($class,'.perlstring($target).')'
          ),
        )
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  1;
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatiblity)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
   use Sub::Quote;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
  );
  
   has pounds => (
     is  => 'rw',
     isa => quote_sub q{ die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  and else where
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  This module is an extremely light-weight, high-performance L<Moose> replacement.
  It also avoids depending on any XS modules to allow simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -but not quite- two
  thirds of L<Moose>.
  
  Unlike C<Mouse> this module does not aim at full L<Moose> compatibility.  See
  L</INCOMPATIBILITIES> for more details.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  I've tried several times to use L<Mouse> but it's 3x the size of Moo and
  takes longer to load than most of my Moo based CGI scripts take to run.
  
  If you don't want L<Moose>, you don't want "less metaprotocol" like L<Mouse>,
  you want "as little as possible" - which means "no metaprotocol", which is
  what Moo provides.
  
  By Moo 1.0 I intend to have Moo's equivalent of L<Any::Moose> built in -
  if Moose gets loaded, any Moo class or role will act as a Moose equivalent
  if treated as such.
  
  Hence - Moo exists as its name - Minimal Object Orientation - with a pledge
  to make it smooth to upgrade to L<Moose> when you need more than minimal
  features.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   around BUILDARGS => sub {
     my $orig = shift;
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return $class->$orig(@args);
   };
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares base class. Multiple superclasses can be passed for multiple
  inheritance (but please use roles instead).
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  Composes a L<Role::Tiny> into current class.  Only one role may be composed in
  at a time to allow the code to remain as simple as possible.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * is
  
  B<required>, must be C<ro> or C<rw>.  Unsurprisingly, C<ro> generates an
  accessor that will not respond to arguments; to be clear: a getter only. C<rw>
  will create a perlish getter/setter.
  
  =item * isa
  
  Takes a coderef which is meant to validate the attribute.  Unlike L<Moose> Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   isa => quote_sub q{
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * coerce
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => quote_sub q{
     $_[0] + 1 unless $_[0] % 2
   },
  
  Coerce does not require C<isa> to be defined.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * handles
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a role (L<Moo::Role>) that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * trigger
  
  Takes a coderef which will get called any time the attribute is set. Coderef
  will be invoked against the object with the new value as an argument.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * default
  
  Takes a coderef which will get called with $self as its only argument
  to populate an attribute if no value is supplied to the constructor - or
  if the attribute is lazy, when the attribute is first retrieved if no
  value has yet been provided.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * predicate
  
  Takes a method name which will return true if an attribute has a value.
  
  A common example of this would be to call it C<has_$foo>, implying that the
  object has a C<$foo> set.
  
  =item * builder
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  =item * clearer
  
  Takes a method name which will clear the attribute.
  
  =item * lazy
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * required
  
  B<Boolean>.  Set this if the attribute must be passed on instantiation.
  
  =item * reader
  
  The value of this attribute will be the name of the method to get the value of
  the attribute.  If you like Java style methods, you might set this to
  C<get_foo>
  
  =item * writer
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>
  
  =item * weak_ref
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened; use this when circular references are possible, which will cause
  leaks.
  
  =item * init_arg
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  You can only compose one role at a time.  If your application is large or
  complex enough to warrant complex composition, you wanted L<Moose>.
  
  There is no complex type system.  C<isa> is verified with a coderef, if you
  need complex types, just make a library of coderefs, or better yet, functions
  that return quoted subs.
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea but may be supported by an extension in future.
  
  There is no meta object.  If you need this level of complexity you wanted
  L<Moose> - Moo succeeds at being small because it explicitly does not
  provide a metaprotocol.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - override can
  be handled by around albeit with a little more typing, and the author considers
  augment to be a bad idea.
  
  L</default> only supports coderefs, because doing otherwise is usually a
  mistake anyway.
  
  C<lazy_build> is not supported per se, but of course it will work if you
  manually set all the options it implies.
  
  C<auto_deref> is not supported since the author considers it a bad idea.
  
  C<documentation> is not supported since it's a very poor replacement for POD.
  
  Handling of warnings: when you C<use Moo> we enable FATAL warnings.  The nearest
  similar invocation for L<Moose> would be:
  
    use Moose;
    use warnings FATAL => "all";
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts>.  So if you:
  
      package MyClass;
      use Moo;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2011 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
MOO

$fatpacked{"Moo/Object.pm"} = <<'MOO_OBJECT';
  package Moo::Object;
  
  use strictures 1;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          { local $@; require Method::Generate::DemolishAll; }
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    $NO_BUILD{$class} and
      return bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class)
      : do {
          my $proto = ref($_[0]) eq 'HASH' ? $_[0] : { @_ };
          bless({ %$proto }, $class)->BUILDALL($proto);
        };
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      { local $@; require Method::Generate::BuildAll; }
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      { local $@; require Method::Generate::DemolishAll; }
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    { local $@; require Role::Tiny; }
    { no warnings 'redefine'; *does = \&Role::Tiny::does_role }
    goto &Role::Tiny::does_role;
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = <<'MOO_ROLE';
  package Moo::Role;
  
  use strictures 1;
  use Moo::_Utils;
  use base qw(Role::Tiny);
  
  BEGIN { *INFO = \%Role::Tiny::INFO }
  
  our %INFO;
  
  sub import {
    my $target = caller;
    strictures->import;
    return if $INFO{$target}; # already exported into this package
    # get symbol table reference
    my $stash = do { no strict 'refs'; \%{"${target}::"} };
    *{_getglob "${target}::has"} = sub {
      my ($name, %spec) = @_;
      ($INFO{$target}{accessor_maker} ||= do {
        { local $@; require Method::Generate::Accessor; }
        Method::Generate::Accessor->new
      })->generate_method($target, $name, \%spec);
      $INFO{$target}{attributes}{$name} = \%spec;
    };
    goto &Role::Tiny::import;
  }
  
  sub apply_role_to_package {
    my ($me, $to, $role) = @_;
    $me->SUPER::apply_role_to_package($to, $role);
    $me->_handle_constructor($to, $INFO{$role}{attributes});
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    { local $@; require Sub::Quote; }
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Role::Tiny" unless my $info = $INFO{$role};
    }
  
    $Moo::MAKERS{$new_name} = {};
  
    $me->_handle_constructor(
      $new_name, { map %{$INFO{$_}{attributes}||{}}, @roles }, $superclass
    );
  
    return $new_name;
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _handle_constructor {
    my ($me, $to, $attr_info, $superclass) = @_;
    return unless $attr_info && keys %$attr_info;
    if ($INFO{$to}) {
      @{$INFO{$to}{attributes}||={}}{keys %$attr_info} = values %$attr_info;
    } else {
      # only fiddle with the constructor if the target is a Moo class
      if ($INC{"Moo.pm"}
          and my $con = Moo->_constructor_maker_for($to, $superclass)) {
        $con->register_attribute_specs(%$attr_info);
      }
    }
  }
  
  1;
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  else where
  
   package Some::Class;
  
   use Moo;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = <<'MOO__UTILS';
  package Moo::_Utils;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  BEGIN {
    *lt_5_8_3 = $] < 5.008003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  use strictures 1;
  use base qw(Exporter);
  use Moo::_mro;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa
  );
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      { local $@; require Sub::Defer; }
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  # _load_module is inlined in Role::Tiny - make sure to copy if you update it.
  
  sub _load_module {
    (my $proto = $_[0]) =~ s/::/\//g;
    return 1 if $INC{"${proto}.pm"};
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1 if grep !/::$/, keys %{_getstash($_[0])||{}};
    { local $@; require "${proto}.pm"; }
    return 1;
  }
  
  sub _maybe_load_module {
    return $MAYBE_LOADED{$_[0]} if exists $MAYBE_LOADED{$_[0]};
    (my $proto = $_[0]) =~ s/::/\//g;
    local $@;
    if (eval { require "${proto}.pm"; 1 }) {
      $MAYBE_LOADED{$_[0]} = 1;
    } else {
      if (exists $INC{"${proto}.pm"}) {
        warn "$_[0] exists but failed to load with error: $@";
      }
      $MAYBE_LOADED{$_[0]} = 0;
    }
    return $MAYBE_LOADED{$_[0]};
  }
  
  sub _get_linear_isa {
      return mro::get_linear_isa($_[0]);
  }
  
  our $_in_global_destruction = 0;
  END { $_in_global_destruction = 1 }
  
  sub STANDARD_DESTROY {
    my $self = shift;
  
    my $e = do {
      local $?;
      local $@;
      eval {
        $self->DEMOLISHALL($_in_global_destruction);
      };
      $@;
    };
  
    no warnings 'misc';
    die $e if $e; # rethrow
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = <<'MOO__MRO';
  package Moo::_mro;
  
  local $@;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Plack.pm"} = <<'PLACK';
  package Plack;
  
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack - Perl Superglue for Web frameworks and Web Servers (PSGI toolkit)
  
  =head1 DESCRIPTION
  
  Plack is a set of tools for using the PSGI stack. It contains
  middleware components, a reference server and utilities for Web
  application frameworks. Plack is like Ruby's Rack or Python's Paste
  for WSGI.
  
  See L<PSGI> for the PSGI specification and L<PSGI::FAQ> to know what
  PSGI and Plack are and why we need them.
  
  =head1 MODULES AND UTILITIES
  
  =head2 Plack::Handler
  
  L<Plack::Handler> and its subclasses contains adapters for web
  servers. We have adapters for the built-in standalone web server
  L<HTTP::Server::PSGI>, L<CGI|Plack::Handler::CGI>,
  L<FCGI|Plack::Handler::FCGI>, L<Apache1|Plack::Handler::Apache1>,
  L<Apache2|Plack::Handler::Apache2> and
  L<HTTP::Server::Simple|Plack::Handler::HTTP::Server::Simple> included
  in the core Plack distribution.
  
  There are also many HTTP server implementations on CPAN that have Plack
  handlers.
  
  See L<Plack::Handler> when writing your own adapters.
  
  =head2 Plack::Loader
  
  L<Plack::Loader> is a loader to load one L<Plack::Handler> adapter
  and run a PSGI application code reference with it.
  
  =head2 Plack::Util
  
  L<Plack::Util> contains a lot of utility functions for server
  implementors as well as middleware authors.
  
  =head2 .psgi files
  
  A PSGI application is a code reference but it's not easy to pass code
  reference via the command line or configuration files, so Plack uses a
  convention that you need a file named C<app.psgi> or similar, which
  would be loaded (via perl's core function C<do>) to return the PSGI
  application code reference.
  
    # Hello.psgi
    my $app = sub {
        my $env = shift;
        # ...
        return [ $status, $headers, $body ];
    };
  
  If you use a web framework, chances are that they provide a helper
  utility to automatically generate these C<.psgi> files for you, such
  as:
  
    # MyApp.psgi
    use MyApp;
    my $app = sub { MyApp->run_psgi(@_) };
  
  It's important that the return value of C<.psgi> file is the code
  reference. See C<eg/dot-psgi> directory for more examples of C<.psgi>
  files.
  
  =head2 plackup, Plack::Runner
  
  L<plackup> is a command line launcher to run PSGI applications from
  command line using L<Plack::Loader> to load PSGI backends. It can be
  used to run standalone servers and FastCGI daemon processes. Other
  server backends like Apache2 needs a separate configuration but
  C<.psgi> application file can still be the same.
  
  If you want to write your own frontend that replaces, or adds
  functionalities to L<plackup>, take a look at the L<Plack::Runner> module.
  
  =head2 Plack::Middleware
  
  PSGI middleware is a PSGI application that wraps an existing PSGI
  application and plays both side of application and servers. From the
  servers the wrapped code reference still looks like and behaves
  exactly the same as PSGI applications.
  
  L<Plack::Middleware> gives you an easy way to wrap PSGI applications
  with a clean API, and compatibility with L<Plack::Builder> DSL.
  
  =head2 Plack::Builder
  
  L<Plack::Builder> gives you a DSL that you can enable Middleware in
  C<.psgi> files to wrap existent PSGI applications.
  
  =head2 Plack::Request, Plack::Response
  
  L<Plack::Request> gives you a nice wrapper API around PSGI C<$env>
  hash to get headers, cookies and query parameters much like
  L<Apache::Request> in mod_perl.
  
  L<Plack::Response> does the same to construct the response array
  reference.
  
  =head2 Plack::Test
  
  L<Plack::Test> is a unified interface to test your PSGI application
  using standard L<HTTP::Request> and L<HTTP::Response> pair with simple
  callbacks.
  
  =head2 Plack::Test::Suite
  
  L<Plack::Test::Suite> is a test suite to test a new PSGI server backend.
  
  =head1 CONTRIBUTING
  
  =head2 Patches and Bug Fixes
  
  Small patches and bug fixes can be either submitted via nopaste on IRC
  L<irc://irc.perl.org/#plack> or L<the github issue
  tracker|http://github.com/miyagawa/Plack/issues>.  Forking on
  L<github|http://github.com/miyagawa/Plack> is another good way if you
  intend to make larger fixes.
  
  See also L<http://contributing.appspot.com/plack> when you think this
  document is terribly outdated.
  
  =head2 Module Namespaces
  
  Modules added to the Plack:: sub-namespaces should be reasonably generic
  components which are useful as building blocks and not just simply using
  Plack.
  
  Middleware authors are free to use the Plack::Middleware:: namespace for
  their middleware components. Middleware must be written in the pipeline
  style such that they can chained together with other middleware components.
  The Plack::Middleware:: modules in the core distribution are good examples
  of such modules. It is recommended that you inherit from L<Plack::Middleware>
  for these types of modules.
  
  Not all middleware components are wrappers, but instead are more like
  endpoints in a middleware chain. These types of components should use the
  Plack::App:: namespace. Again, look in the core modules to see excellent
  examples of these (L<Plack::App::File>, L<Plack::App::Directory>, etc.).
  It is recommended that you inherit from L<Plack::Component> for these
  types of modules.
  
  B<DO NOT USE> Plack:: namespace to build a new web application or a
  framework. It's like naming your application under CGI:: namespace if
  it's supposed to run on CGI and that is a really bad choice and
  would confuse people badly.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 COPYRIGHT
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  Copyright 2009-2011 Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Yuval Kogman (nothingmuch)
  
  Tokuhiro Matsuno (tokuhirom)
  
  Kazuhiro Osawa (Yappo)
  
  Kazuho Oku
  
  Florian Ragwitz (rafl)
  
  Chia-liang Kao (clkao)
  
  Masahiro Honma (hiratara)
  
  Daisuke Murase (typester)
  
  John Beppu
  
  Matt S Trout (mst)
  
  Shawn M Moore (Sartak)
  
  Stevan Little
  
  Hans Dieter Pearcey (confound)
  
  Tomas Doran (t0m)
  
  mala
  
  Mark Stosberg
  
  Aaron Trevena
  
  =head1 SEE ALSO
  
  The L<PSGI> specification upon which Plack is based.
  
  L<http://plackperl.org/>
  
  The Plack wiki: L<https://github.com/miyagawa/Plack/wiki>
  
  The Plack FAQ: L<https://github.com/miyagawa/Plack/wiki/Faq>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK

$fatpacked{"Plack/App/CGIBin.pm"} = <<'PLACK_APP_CGIBIN';
  package Plack::App::CGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util::Accessor qw( exec_cb );
  use Plack::App::WrapCGI;
  
  sub allow_path_info { 1 }
  
  my %exec_cache;
  
  sub would_exec {
      my($self, $file) = @_;
  
      return $exec_cache{$file} if exists $exec_cache{$file};
  
      my $exec_cb = $self->exec_cb || sub { $self->exec_cb_default(@_) };
  
      return $exec_cache{$file} = $exec_cb->($file);
  }
  
  sub exec_cb_default {
      my($self, $file) = @_;
  
      if ($file =~ /\.pl$/i) {
          return 0;
      } elsif ($self->shebang_for($file) =~ /^\#\!.*perl/) {
          return 0;
      } else {
          return 1;
      }
  }
  
  sub shebang_for {
      my($self, $file) = @_;
  
      open my $fh, "<", $file or return '';
      my $line = <$fh>;
      return $line;
  }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::App::WrapCGI->new(
          script => $file, execute => $self->would_exec($file),
      );
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::CGIBin - cgi-bin replacement for Plack servers
  
  =head1 SYNOPSIS
  
    use Plack::App::CGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app;
    builder {
        mount "/cgi-bin" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::CGIBin -e 'Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app'
  
  =head1 DESCRIPTION
  
  Plack::App::CGIBin allows you to load CGI scripts from a directory and
  convert them into a PSGI application.
  
  This would give you the extreme easiness when you have bunch of old
  CGI scripts that is loaded using I<cgi-bin> of Apache web server.
  
  =head1 HOW IT WORKS
  
  This application checks if a given file path is a perl script and if
  so, uses L<CGI::Compile> to compile a CGI script into a sub (like
  L<ModPerl::Registry>) and then run it as a persistent application
  using L<CGI::Emulate::PSGI>.
  
  If the give file is not a perl script, it executes the script just
  like a normal CGI script with fork & exec. This is like a normal web
  server mode and no performance benefit is achieved.
  
  The default mechanism to determine if a given file is a Perl script is
  as follows:
  
  =over 4
  
  =item *
  
  Check if the filename ends with C<.pl>
  
  =item *
  
  Open the file and see if the shebang (first line of the file) contains the word C<perl>
  
  =back
  
  You can customize this behavior by passing C<exec_cb> callback, which
  takes a file path to its first argument.
  
  For example, if your perl-based CGI script uses lots of global
  variables and such and are not ready to run on a persistent
  environment, you can do:
  
    my $app = Plack::App::CGIBin->new(
        root => "/path/to/cgi-bin",
        exec_cb => sub { 1 },
    )->to_app;
  
  to always force the execute option for any files.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File> L<CGI::Emulate::PSGI> L<CGI::Compile> L<Plack::App::WrapCGI>
  
  See also L<Plack::App::WrapCGI> if you compile one CGI script into a
  PSGI application without serving CGI scripts from a directory, to
  remove overhead of filesystem lookups, etc.
  
  =cut
PLACK_APP_CGIBIN

$fatpacked{"Plack/App/Cascade.pm"} = <<'PLACK_APP_CASCADE';
  package Plack::App::Cascade;
  use strict;
  use base qw(Plack::Component);
  
  use Plack::Util;
  use Plack::Util::Accessor qw(apps catch codes);
  
  sub add {
      my $self = shift;
      $self->apps([]) unless $self->apps;
      push @{$self->apps}, @_;
  }
  
  sub prepare_app {
      my $self = shift;
      my %codes = map { $_ => 1 } @{ $self->catch || [ 404 ] };
      $self->codes(\%codes);
  }
  
  sub call {
      my($self, $env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $res = [ 404, [ 'Content-Type' => 'text/html' ], [ '404 Not Found' ] ];
  
          my $done;
          my $respond_wrapper = sub {
              my $res = shift;
              if ($self->codes->{$res->[0]}) {
                  return Plack::Util::inline_object
                      write => sub { }, close => sub { };
              } else {
                  $done = 1;
                  return $respond->($res);
              }
          };
  
          for my $app (@{$self->apps || []}) {
              my $res = $app->($env);
              if (ref $res eq 'CODE') {
                  $res->($respond_wrapper);
              } else {
                  $respond_wrapper->($res);
              }
              return if $done;
          }
  
          $respond->($res);
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Cascade - Cascadable compound application
  
  =head1 SYNOPSIS
  
    use Plack::App::Cascade;
    use Plack::App::URLMap;
    use Plack::App::File;
  
    # Serve static files from multiple search paths
    my $cascade = Plack::App::Cascade->new;
    $cascade->add( Plack::App::File->new(root => "/www/example.com/foo")->to_app );
    $cascade->add( Plack::App::File->new(root => "/www/example.com/bar")->to_app );
  
    my $app = Plack::App::URLMap->new;
    $app->map("/static", $cascade);
    $app->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::Cascade is a Plack middleware component that compounds
  several apps and tries them to return the first response that is not
  404.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $app = Plack::App::Cascade->new(apps => [ $app1, $app2 ]);
  
  Creates a new Cascade application.
  
  =item add
  
    $app->add($app1);
    $app->add($app2, $app3);
  
  Appends a new application to the list of apps to try. You can pass the
  multiple apps to the one C<add> call.
  
  =item catch
  
    $app->catch([ 403, 404 ]);
  
  Sets which error codes to catch and process onwards. Defaults to C<404>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::URLMap> Rack::Cascade
  
  =cut
PLACK_APP_CASCADE

$fatpacked{"Plack/App/Directory.pm"} = <<'PLACK_APP_DIRECTORY';
  package Plack::App::Directory;
  use parent qw(Plack::App::File);
  use strict;
  use warnings;
  use Plack::Util;
  use HTTP::Date;
  use Plack::MIME;
  use DirHandle;
  use URI::Escape;
  use Plack::Request;
  
  # Stolen from rack/directory.rb
  my $dir_file = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>";
  my $dir_page = <<PAGE;
  <html><head>
    <title>%s</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style type='text/css'>
  table { width:100%%; }
  .name { text-align:left; }
  .size, .mtime { text-align:right; }
  .type { width:11em; }
  .mtime { width:15em; }
    </style>
  </head><body>
  <h1>%s</h1>
  <hr />
  <table>
    <tr>
      <th class='name'>Name</th>
      <th class='size'>Size</th>
      <th class='type'>Type</th>
      <th class='mtime'>Last Modified</th>
    </tr>
  %s
  </table>
  <hr />
  </body></html>
  PAGE
  
  sub should_handle {
      my($self, $file) = @_;
      return -d $file || -f $file;
  }
  
  sub return_dir_redirect {
      my ($self, $env) = @_;
      my $uri = Plack::Request->new($env)->uri;
      return [ 301,
          [
              'Location' => $uri . '/',
              'Content-Type' => 'text/plain',
              'Content-Length' => 8,
          ],
          [ 'Redirect' ],
      ];
  }
  
  sub serve_path {
      my($self, $env, $dir, $fullpath) = @_;
  
      if (-f $dir) {
          return $self->SUPER::serve_path($env, $dir, $fullpath);
      }
  
      my $dir_url = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
  
      if ($dir_url !~ m{/$}) {
          return $self->return_dir_redirect($env);
      }
  
      my @files = ([ "../", "Parent Directory", '', '', '' ]);
  
      my $dh = DirHandle->new($dir);
      my @children;
      while (defined(my $ent = $dh->read)) {
          next if $ent eq '.';
          push @children, $ent;
      }
  
      for my $basename (sort { $a cmp $b } @children) {
          my $file = "$dir/$basename";
          my $url = $dir_url . $basename;
  
          my $is_dir = -d $file;
          my @stat = stat _;
  
          $url = join '/', map {uri_escape($_)} split m{/}, $url;
  
          if ($is_dir) {
              $basename .= "/";
              $url      .= "/";
          }
  
          my $mime_type = $is_dir ? 'directory' : ( Plack::MIME->mime_type($file) || 'text/plain' );
          push @files, [ $url, $basename, $stat[7], $mime_type, HTTP::Date::time2str($stat[9]) ];
      }
  
      my $path  = Plack::Util::encode_html("Index of $env->{PATH_INFO}");
      my $files = join "\n", map {
          my $f = $_;
          sprintf $dir_file, map Plack::Util::encode_html($_), @$f;
      } @files;
      my $page  = sprintf $dir_page, $path, $path, $files;
  
      return [ 200, ['Content-Type' => 'text/html; charset=utf-8'], [ $page ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Directory - Serve static files from document root with directory index
  
  =head1 SYNOPSIS
  
    # app.psgi
    use Plack::App::Directory;
    my $app = Plack::App::Directory->new({ root => "/path/to/htdocs" })->to_app;
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application with directory index a la Apache's mod_autoindex.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to the current directory.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File>
  
  =cut
PLACK_APP_DIRECTORY

$fatpacked{"Plack/App/File.pm"} = <<'PLACK_APP_FILE';
  package Plack::App::File;
  use strict;
  use warnings;
  use parent qw/Plack::Component/;
  use File::Spec::Unix;
  use Cwd ();
  use Plack::Util;
  use Plack::MIME;
  use HTTP::Date;
  
  use Plack::Util::Accessor qw( root file content_type encoding );
  
  sub should_handle {
      my($self, $file) = @_;
      return -f $file;
  }
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my($file, $path_info) = $self->file || $self->locate_file($env);
      return $file if ref $file eq 'ARRAY';
  
      if ($path_info) {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.SCRIPT_NAME'} =~ s/\Q$path_info\E$//;
          $env->{'plack.file.PATH_INFO'}   = $path_info;
      } else {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.PATH_INFO'}   = '';
      }
  
      return $self->serve_path($env, $file);
  }
  
  sub locate_file {
      my($self, $env) = @_;
  
      my $path = $env->{PATH_INFO} || '';
  
      if ($path =~ /\0/) {
          return $self->return_400;
      }
  
      my $docroot = $self->root || ".";
      my @path = split '/', $path;
      if (@path) {
          shift @path if $path[0] eq '';
      } else {
          @path = ('.');
      }
  
      if (grep $_ eq '..', @path) {
          return $self->return_403;
      }
  
      my($file, @path_info);
      while (@path) {
          my $try = File::Spec::Unix->catfile($docroot, @path);
          if ($self->should_handle($try)) {
              $file = $try;
              last;
          } elsif (!$self->allow_path_info) {
              last;
          }
          unshift @path_info, pop @path;
      }
  
      if (!$file) {
          return $self->return_404;
      }
  
      if (!-r $file) {
          return $self->return_403;
      }
  
      return $file, join("/", "", @path_info);
  }
  
  sub allow_path_info { 0 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $content_type = $self->content_type || Plack::MIME->mime_type($file)
                         || 'text/plain';
  
      if ($content_type =~ m!^text/!) {
          $content_type .= "; charset=" . ($self->encoding || "utf-8");
      }
  
      open my $fh, "<:raw", $file
          or return $self->return_403;
  
      my @stat = stat $file;
  
      Plack::Util::set_io_path($fh, Cwd::realpath($file));
  
      return [
          200,
          [
              'Content-Type'   => $content_type,
              'Content-Length' => $stat[7],
              'Last-Modified'  => HTTP::Date::time2str( $stat[9] )
          ],
          $fh,
      ];
  }
  
  sub return_403 {
      my $self = shift;
      return [403, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['forbidden']];
  }
  
  sub return_400 {
      my $self = shift;
      return [400, ['Content-Type' => 'text/plain', 'Content-Length' => 11], ['Bad Request']];
  }
  
  # Hint: subclasses can override this to return undef to pass through 404
  sub return_404 {
      my $self = shift;
      return [404, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['not found']];
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::App::File - Serve static files from root directory
  
  =head1 SYNOPSIS
  
    use Plack::App::File;
    my $app = Plack::App::File->new(root => "/path/to/htdocs")->to_app;
  
    # Or map the path to a specific file
    use Plack::Builder;
    builder {
        mount "/favicon.ico" => Plack::App::File->new(file => '/path/to/favicon.ico');
    };
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application, and internally used by
  L<Plack::Middleware::Static>. This application serves file from
  document root if the path matches with the local file. Use
  L<Plack::App::Directory> if you want to list files in the directory
  as well.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to C<.> (current directory)
  
  =item file
  
  The file path to create responses from. Optional.
  
  If it's set the application would B<ALWAYS> create a response out of
  the file and there will be no security check etc. (hence fast). If
  it's not set, the application uses C<root> to find the matching file.
  
  =item encoding
  
  Set the file encoding for text files. Defaults to C<utf-8>.
  
  =item content_type
  
  Set the file content type. If not set L<Plack::MIME> will try to detect it
  based on the file extension or fall back to C<text/plain>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::Static> L<Plack::App::Directory>
  
  =cut
  
  
PLACK_APP_FILE

$fatpacked{"Plack/App/PSGIBin.pm"} = <<'PLACK_APP_PSGIBIN';
  package Plack::App::PSGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util;
  
  sub allow_path_info { 1 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::Util::load_psgi($file);
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::PSGIBin - Run .psgi files from a directory
  
  =head1 SYNOPSIS
  
    use Plack::App::PSGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::PSGIBin->new(root => "/path/to/psgi/scripts")->to_app;
    builder {
        mount "/psgi" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::PSGIBin -e 'Plack::App::PSGIBin->new(root => "/path/psgi/scripts")->to_app'
  
  =head1 DESCRIPTION
  
  This application loads I<.psgi> files (or actually whichever filename
  extensions) from the root directory and run it as a PSGI
  application. Suppose you have a directory containing C<foo.psgi> and
  C<bar.psgi>, map this application to C</app> with
  L<Plack::App::URLMap> and you can access them via the URL:
  
    http://example.com/app/foo.psgi
    http://example.com/app/bar.psgi
  
  to load them. You can rename the file to the one without C<.psgi>
  extension to make the URL look nicer, or use the URL rewriting tools
  like L<Plack::Middleware::Rewrite> to do the same thing.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
PLACK_APP_PSGIBIN

$fatpacked{"Plack/App/URLMap.pm"} = <<'PLACK_APP_URLMAP';
  package Plack::App::URLMap;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use constant DEBUG => $ENV{PLACK_URLMAP_DEBUG};
  
  use Carp ();
  
  sub mount { shift->map(@_) }
  
  sub map {
      my $self = shift;
      my($location, $app) = @_;
  
      my $host;
      if ($location =~ m!^https?://(.*?)(/.*)!) {
          $host     = $1;
          $location = $2;
      }
  
      if ($location !~ m!^/!) {
          Carp::croak("Paths need to start with /");
      }
      $location =~ s!/$!!;
  
      push @{$self->{_mapping}}, [ $host, $location, $app ];
  }
  
  sub prepare_app {
      my $self = shift;
      # sort by path length
      $self->{_sorted_mapping} = [
          map  { [ @{$_}[2..4] ] }
          sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] }
          map  { [ ($_->[0] ? length $_->[0] : 0), length($_->[1]), @$_ ] } @{$self->{_mapping}},
      ];
  }
  
  sub call {
      my ($self, $env) = @_;
  
      my $path_info   = $env->{PATH_INFO};
      my $script_name = $env->{SCRIPT_NAME};
  
      my($http_host, $server_name) = @{$env}{qw( HTTP_HOST SERVER_NAME )};
  
      if ($http_host and my $port = $env->{SERVER_PORT}) {
          $http_host =~ s/:$port$//;
      }
  
      for my $map (@{ $self->{_sorted_mapping} }) {
          my($host, $location, $app) = @$map;
          my $path = $path_info; # copy
          no warnings 'uninitialized';
          DEBUG && warn "Matching request (Host=$http_host Path=$path) and the map (Host=$host Path=$location)\n";
          next unless not defined $host     or
                      $http_host   eq $host or
                      $server_name eq $host;
          next unless $location eq '' or $path =~ s!^\Q$location\E!!;
          next unless $path eq '' or $path =~ m!^/!;
          DEBUG && warn "-> Matched!\n";
  
          my $orig_path_info   = $env->{PATH_INFO};
          my $orig_script_name = $env->{SCRIPT_NAME};
  
          $env->{PATH_INFO}  = $path;
          $env->{SCRIPT_NAME} = $script_name . $location;
          return $self->response_cb($app->($env), sub {
              $env->{PATH_INFO} = $orig_path_info;
              $env->{SCRIPT_NAME} = $orig_script_name;
          });
      }
  
      DEBUG && warn "All matching failed.\n";
  
      return [404, [ 'Content-Type' => 'text/plain' ], [ "Not Found" ]];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::URLMap - Map multiple apps in different paths
  
  =head1 SYNOPSIS
  
    use Plack::App::URLMap;
  
    my $app1 = sub { ... };
    my $app2 = sub { ... };
    my $app3 = sub { ... };
  
    my $urlmap = Plack::App::URLMap->new;
    $urlmap->map("/" => $app1);
    $urlmap->map("/foo" => $app2);
    $urlmap->map("http://bar.example.com/" => $app3);
  
    my $app = $urlmap->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::URLMap is a PSGI application that can dispatch multiple
  applications based on URL path and hostnames (a.k.a "virtual hosting")
  and takes care of rewriting C<SCRIPT_NAME> and C<PATH_INFO> (See
  L</"HOW THIS WORKS"> for details). This module is inspired by
  Rack::URLMap.
  
  =head1 METHODS
  
  =over 4
  
  =item map
  
    $urlmap->map("/foo" => $app);
    $urlmap->map("http://bar.example.com/" => $another_app);
  
  Maps URL path or an absolute URL to a PSGI application. The match
  order is sorted by host name length and then path length.
  
  URL paths need to match from the beginning and should match completely
  till the path separator (or the end of the path). For example, if you
  register the path C</foo>, it B<will> match with the request C</foo>,
  C</foo/> or C</foo/bar> but it B<won't> match with C</foox>.
  
  Mapping URL with host names is also possible, and in that case the URL
  mapping works like a virtual host.
  
  Mappings will nest.  If $app is already mapped to C</baz> it will
  match a request for C</foo/baz> but not C</foo>. See L</"HOW THIS
  WORKS"> for more details.
  
  =item mount
  
  Alias for C<map>.
  
  =item to_app
  
    my $handler = $urlmap->to_app;
  
  Returns the PSGI application code reference. Note that the
  Plack::App::URLMap object is callable (by overloading the code
  dereference), so returning the object itself as a PSGI application
  should also work.
  
  =back
  
  =head1 DEBUGGING
  
  You can set the environment variable C<PLACK_URLMAP_DEBUG> to see how
  this application matches with the incoming request host names and
  paths.
  
  =head1 HOW THIS WORKS
  
  This application works by I<fixing> C<SCRIPT_NAME> and C<PATH_INFO>
  before dispatching the incoming request to the relocated
  applications.
  
  Say you have a Wiki application that takes C</index> and C</page/*>
  and makes a PSGI application C<$wiki_app> out of it, using one of
  supported web frameworks, you can put the whole application under
  C</wiki> by:
  
    # MyWikiApp looks at PATH_INFO and handles /index and /page/*
    my $wiki_app = sub { MyWikiApp->run(@_) };
    
    use Plack::App::URLMap;
    my $app = Plack::App::URLMap->new;
    $app->mount("/wiki" => $wiki_app);
  
  When a request comes in with C<PATH_INFO> set to C</wiki/page/foo>,
  the URLMap application C<$app> strips the C</wiki> part from
  C<PATH_INFO> and B<appends> that to C<SCRIPT_NAME>.
  
  That way, if the C<$app> is mounted under the root
  (i.e. C<SCRIPT_NAME> is C<"">) with standalone web servers like
  L<Starman>, C<SCRIPT_NAME> is now locally set to C</wiki> and
  C<PATH_INFO> is changed to C</page/foo> when C<$wiki_app> gets called.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_APP_URLMAP

$fatpacked{"Plack/App/WrapCGI.pm"} = <<'PLACK_APP_WRAPCGI';
  package Plack::App::WrapCGI;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use Plack::Util::Accessor qw(script execute _app);
  use CGI::Emulate::PSGI;
  use CGI::Compile;
  use Carp;
  use POSIX ":sys_wait_h";
  
  sub prepare_app {
      my $self = shift;
      my $script = $self->script
          or croak "'script' is not set";
  
      if ($self->execute) {
          my $app = sub {
              my $env = shift;
  
              pipe( my $stdoutr, my $stdoutw );
              pipe( my $stdinr,  my $stdinw );
  
  
              my $pid = fork();
              Carp::croak("fork failed: $!") unless defined $pid;
  
  
              if ($pid == 0) { # child
                  local $SIG{__DIE__} = sub {
                      print STDERR @_;
                      exit(1);
                  };
  
                  close $stdoutr;
                  close $stdinw;
  
                  local %ENV = (%ENV, CGI::Emulate::PSGI->emulate_environment($env));
  
                  open( STDOUT, ">&=" . fileno($stdoutw) )
                    or Carp::croak "Cannot dup STDOUT: $!";
                  open( STDIN, "<&=" . fileno($stdinr) )
                    or Carp::croak "Cannot dup STDIN: $!";
  
                  exec($script) or Carp::croak("cannot exec: $!");
  
                  exit(2);
              }
  
              close $stdoutw;
              close $stdinr;
  
              syswrite($stdinw, do {
                  local $/;
                  my $fh = $env->{'psgi.input'};
                  <$fh>;
              });
              # close STDIN so child will stop waiting
              close $stdinw;
  
              my $res = '';
              while (waitpid($pid, WNOHANG) <= 0) {
                  $res .= do { local $/; <$stdoutr> };
              }
              $res .= do { local $/; <$stdoutr> };
  
              if (POSIX::WIFEXITED($?)) {
                  return CGI::Parse::PSGI::parse_cgi_output(\$res);
              } else {
                  Carp::croak("Error at run_on_shell CGI: $!");
              }
          };
          $self->_app($app);
      } else {
          my $sub = CGI::Compile->compile($script);
          my $app = CGI::Emulate::PSGI->handler($sub);
  
          $self->_app($app);
      }
  }
  
  sub call {
      my($self, $env) = @_;
      $self->_app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::WrapCGI - Compiles a CGI script as PSGI application
  
  =head1 SYNOPSIS
  
    use Plack::App::WrapCGI;
  
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.pl")->to_app;
  
    # if you want to execute as a real CGI script
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.rb", execute => 1)->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::WrapCGI compiles a CGI script into a PSGI application
  using L<CGI::Compile> and L<CGI::Emulate::PSGI>, and runs it with any
  PSGI server as a PSGI application.
  
  See also L<Plack::App::CGIBin> if you have a directory that contains a
  lot of CGI scripts and serve them like Apache's mod_cgi.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    my $app = Plack::App::WrapCGI->new(%args);
  
  Creates a new PSGI application using the given script. I<%args> has two
  parameters:
  
  =over 8
  
  =item script
  
  The path to a CGI-style program. This is a required parameter.
  
  =item execute
  
  An optional parameter. When set to a true value, this app will run the script
  with a CGI-style C<fork>/C<exec> model. Note that you may run programs written
  in other languages with this approach.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
  
  =cut
PLACK_APP_WRAPCGI

$fatpacked{"Plack/Builder.pm"} = <<'PLACK_BUILDER';
  package Plack::Builder;
  use strict;
  use parent qw( Exporter );
  our @EXPORT = qw( builder add enable enable_if mount );
  
  use Carp ();
  use Plack::App::URLMap;
  use Plack::Middleware::Conditional; # TODO delayed load?
  
  sub new {
      my $class = shift;
      bless { middlewares => [ ] }, $class;
  }
  
  sub add_middleware {
      my($self, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, $mw;
  }
  
  sub add_middleware_if {
      my($self, $cond, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, sub {
          Plack::Middleware::Conditional->wrap($_[0], condition => $cond, builder => $mw);
      };
  }
  
  # do you want remove_middleware() etc.?
  
  sub _mount {
      my ($self, $location, $app) = @_;
  
      if (!$self->{_urlmap}) {
          $self->{_urlmap} = Plack::App::URLMap->new;
      }
  
      $self->{_urlmap}->map($location => $app);
      $self->{_urlmap};
  }
  
  sub to_app {
      my($self, $app) = @_;
  
      for my $mw (reverse @{$self->{middlewares}}) {
          $app = $mw->($app);
      }
  
      $app;
  }
  
  # DSL goes here
  our $_add = our $_add_if = our $_mount = sub {
      Carp::croak("enable/mount should be called inside builder {} block");
  };
  
  sub add      { Carp::carp("add is deprecated. Use 'enable'"); $_add->(@_) }
  sub enable         { $_add->(@_) }
  sub enable_if(&$@) { $_add_if->(@_) }
  
  sub mount {
      my $self = shift;
      if (Scalar::Util::blessed($self)) {
          $self->_mount(@_);
      }else{
          $_mount->($self, @_);
      }
  }
  
  sub builder(&) {
      my $block = shift;
  
      my $self = __PACKAGE__->new;
  
      my $mount_is_called;
      my $urlmap = Plack::App::URLMap->new;
      local $_mount = sub {
          $mount_is_called++;
          $urlmap->map(@_);
          $urlmap;
      };
      local $_add = sub {
          $self->add_middleware(@_);
      };
      local $_add_if = sub {
          $self->add_middleware_if(@_);
      };
  
      my $app = $block->();
  
      if ($mount_is_called) {
          if ($app ne $urlmap) {
              Carp::carp("You used mount() in a builder block, but the last line (app) isn't using mount().\n" .
                         "This causes all mount() mappings to be ignored. See perldoc Plack::Builder for details.");
          } else {
              $app = $app->to_app;
          }
      }
  
      $self->to_app($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Builder - OO and DSL to enable Plack Middlewares
  
  =head1 SYNOPSIS
  
    # in .psgi
    use Plack::Builder;
  
    my $app = sub { ... };
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", opt => "val";
        enable "Plack::Middleware::Baz";
        $app;
    };
  
    # use URLMap
  
    builder {
        mount "/foo" => builder {
            enable "Plack::Middleware::Foo";
            $app;
        };
  
        mount "/bar" => $app2;
        mount "http://example.com/" => builder { $app3 };
    };
  
    # using OO interface
  
    my $builder = Plack::Builder->new();
    $builder->add_middleware('Foo', opt => 1);
    $app = $builder->mount('/app' => $app);
    $app = $builder->to_app($app);
  
  =head1 DESCRIPTION
  
  Plack::Builder gives you a quick domain specific language (DSL) to
  wrap your application with Plack::Middleware subclasses. The
  middleware you're trying to use should use L<Plack::Middleware> as a
  base class to use this DSL, inspired by Rack::Builder.
  
  Whenever you call C<enable> on any middleware, the middleware app is
  pushed to the stack inside the builder, and then reversed when it
  actually creates a wrapped application handler, so:
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", opt => "val";
        $app;
    };
  
  is syntactically equal to:
  
    $app = Plack::Middleware::Bar->wrap($app, opt => "val");
    $app = Plack::Middleware::Foo->wrap($app);
  
  In other words, you're supposed to C<enable> middleware from outer to inner.
  
  =head1 INLINE MIDDLEWARE
  
  Plack::Builder allows you to code middleware inline using a nested
  code reference.
  
  If the first argument to C<enable> is a code reference, it will be
  passed an C<$app> and is supposed to return another code reference
  which is PSGI application that consumes C<$env> in runtime. So:
  
    builder {
        enable sub {
            my $app = shift;
            sub {
                my $env = shift;
                # do preprocessing
                my $res = $app->($env);
                # do postprocessing
                return $res;
            };
        };
        $app;
    };
  
  is equal to:
  
    my $mw = sub {
        my $app = shift;
        sub { my $env = shift; $app->($env) };
    };
  
    $app = $mw->($app);
  
  =head1 URLMap support
  
  Plack::Builder has a native support for L<Plack::App::URLMap> with C<mount> method.
  
    use Plack::Builder;
    my $app = builder {
        mount "/foo" => $app1;
        mount "/bar" => builder {
            enable "Plack::Middleware::Foo";
            $app2;
        };
    };
  
  See L<Plack::App::URLMap>'s C<map> method to see what they mean. With
  builder you can't use C<map> as a DSL, for the obvious reason :)
  
  B<NOTE>: Once you use C<mount> in your builder code, you have to use
  C<mount> for all the paths, including the root path (C</>). You can't
  have the default app in the last line of C<builder> like:
  
    my $app = sub {
        my $env = shift;
        ...
    };
  
    builder {
        mount "/foo" => sub { ... };
        $app; # THIS DOESN'T WORK
    };
  
  You'll get warnings saying that your mount configuration will be
  ignored. Instead you should use C<< mount "/" => ... >> in the last
  line to set the default fallback app.
  
    builder {
        mount "/foo" => sub { ... };
        mount "/" => $app;
    }
  
  Note that the C<builder> DSL returns a whole new PSGI application, which means
  
  =over 4
  
  =item *
  
  C<builder { ... }> should normally the last statement of a C<.psgi>
  file, because the return value of C<builder> is the application that
  actually is executed.
  
  =item *
  
  You can nest your C<builder> block, mixed with C<mount> (see URLMap
  support above):
  
    builder {
        mount "/foo" => builder {
            mount "/bar" => $app;
        }
    }
  
  will locate the C<$app> under C</foo/bar> since the inner C<builder>
  block puts it under C</bar> and it results a new PSGI application
  which is located under C</foo> because of the outer C<builder> block.
  
  =back
  
  =head1 CONDITIONAL MIDDLEWARE SUPPORT
  
  You can use C<enable_if> to conditionally enable middleware based on
  the runtime environment. See L<Plack::Middleware::Conditional> for
  details.
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::App::URLMap> L<Plack::Middleware::Conditional>
  
  =cut
  
  
  
PLACK_BUILDER

$fatpacked{"Plack/Component.pm"} = <<'PLACK_COMPONENT';
  package Plack::Component;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use overload '&{}' => sub { shift->to_app(@_) }, fallback => 1;
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self;
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          $self = bless {%{$_[0]}}, $class;
      } else {
          $self = bless {@_}, $class;
      }
  
      $self;
  }
  
  # NOTE:
  # this is for back-compat only,
  # future modules should use
  # Plack::Util::Accessor directly
  # or their own favorite accessor
  # generator.
  # - SL
  sub mk_accessors {
      my $self = shift;
      Plack::Util::Accessor::mk_accessors( ref( $self ) || $self, @_ )
  }
  
  sub prepare_app { return }
  
  sub to_app {
      my $self = shift;
      $self->prepare_app;
      return sub { $self->call(@_) };
  }
  
  
  sub response_cb {
      my($self, $res, $cb) = @_;
      Plack::Util::response_cb($res, $cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Component - Base class for PSGI endpoints
  
  =head1 SYNOPSIS
  
    package Plack::App::Foo;
    use parent qw( Plack::Component );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        my $res = ...; # create a response ...
  
        # return the response
        return $res;
    }
  
  =head1 DESCRIPTION
  
  Plack::Component is the base class shared between Plack::Middleware
  and Plack::App::* modules. If you are writing middleware, you should
  inherit from L<Plack::Middleware>, but if you are writing a
  Plack::App::* you should inherit from this directly.
  
  =head1 REQUIRED METHOD
  
  =over 4
  
  =item call ($env)
  
  You are expected to implement a C<call> method in your component. This
  is where all the work gets done. It receives the PSGI C<$env> hash-ref
  as an argument and is expected to return a proper PSGI response value.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new (%opts | \%opts)
  
  The constructor accepts either a hash or a hash-ref and uses that to
  create the instance with. It will call no other methods and simply return
  the instance that is created.
  
  =item prepare_app
  
  This method is called by C<to_app> and is meant as a hook to be used to
  prepare your component before it is packaged as a PSGI C<$app>.
  
  =item to_app
  
  This is the method used in several parts of the Plack infrastructure to
  convert your component into a PSGI C<$app>. You should not ever need to
  override this method, it is recommended to use C<prepare_app> and C<call>
  instead.
  
  =item response_cb
  
  This is a wrapper for C<response_cb> in L<Plack::Util>. See
  L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =head1 OBJECT LIFECYCLE
  
  Objects for the derived classes (Plack::App::* or
  Plack::Middleware::*) are created at the PSGI application compile
  phase using C<new>, C<prepare_app> and C<to_app>, and the created
  object persists during the web server lifecycle, unless it is running
  on the non-persistent environment like CGI. C<call> is invoked against
  the same object whenever a new request comes in.
  
  You can check if it is running in a persistent environment by checking
  C<psgi.run_once> key in the C<$env> being true (non-persistent) or
  false (persistent), but it is best for you to write your middleware
  safely for a persistent environment. To accomplish that, you should
  avoid saving per-request data like C<$env> in your object.
  
  =head1 BACKWARDS COMPATIBILITY
  
  The L<Plack::Middleware> module used to inherit from L<Class::Accessor::Fast>,
  which has been removed in favor of the L<Plack::Util::Accessor> module. When
  developing new components it is recommended to use L<Plack::Util::Accessor>
  like so:
  
    use Plack::Util::Accessor qw( foo bar baz );
  
  However, in order to keep backwards compatibility this module provides a
  C<mk_accessors> method similar to L<Class::Accessor::Fast>. New code should
  not use this and use L<Plack::Util::Accessor> instead.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Middleware>
  
  =cut
PLACK_COMPONENT

$fatpacked{"Plack/HTTPParser.pm"} = <<'PLACK_HTTPPARSER';
  package Plack::HTTPParser;
  use strict;
  use parent qw(Exporter);
  
  our @EXPORT = qw( parse_http_request );
  
  use Try::Tiny;
  
  {
      if (!$ENV{PLACK_HTTP_PARSER_PP} && try { require HTTP::Parser::XS; 1 }) {
          *parse_http_request = \&HTTP::Parser::XS::parse_http_request;
      } else {
          require Plack::HTTPParser::PP;
          *parse_http_request = \&Plack::HTTPParser::PP::parse_http_request;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser - Parse HTTP headers
  
  =head1 SYNOPSIS
  
    use Plack::HTTPParser qw(parse_http_request);
  
    my $ret = parse_http_request($header_str, \%env);
    # see HTTP::Parser::XS docs
  
  =head1 DESCRIPTION
  
  Plack::HTTPParser is a wrapper class to dispatch C<parse_http_request>
  to Kazuho Oku's XS based HTTP::Parser::XS or pure perl fallback based
  on David Robins HTTP::Parser.
  
  If you want to force the use of the slower pure perl version even if the
  fast XS version is available, set the environment variable
  C<PLACK_HTTP_PARSER_PP> to 1.
  
  =head1 SEE ALSO
  
  L<HTTP::Parser::XS> L<HTTP::Parser>
  
  =cut
PLACK_HTTPPARSER

$fatpacked{"Plack/HTTPParser/PP.pm"} = <<'PLACK_HTTPPARSER_PP';
  package Plack::HTTPParser::PP;
  use strict;
  use warnings;
  use URI::Escape;
  
  sub parse_http_request {
      my($chunk, $env) = @_;
      $env ||= {};
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my ($major, $minor);
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/(\d+)\.(\d+)$/i;
      ($major, $minor) = ($1, $2);
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{SERVER_PROTOCOL} = "HTTP/$major.$minor";
      $env->{REQUEST_URI}     = $uri;
  
      my($path, $query) = ( $uri =~ /^([^?]*)(?:\?(.*))?$/s );
      for ($path, $query) { s/\#.*$// if defined && length } # dumb clients sending URI fragments
  
      $env->{PATH_INFO}    = URI::Escape::uri_unescape($path);
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser::PP - Pure perl fallback of HTTP::Parser::XS
  
  =head1 DESCRIPTION
  
  Do not use this module directly. Use L<Plack::HTTPParser> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
  
PLACK_HTTPPARSER_PP

$fatpacked{"Plack/Handler.pm"} = <<'PLACK_HANDLER';
  package Plack::Handler;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler - Connects PSGI applications and Web servers
  
  =head1 SYNOPSIS
  
    package Plack::Handler::AwesomeWebServer;
    sub new {
        my($class, %opt) = @_;
        ...
        return $self;
    }
  
    sub run {
        my($self, $app) = @_;
        # launch the AwesomeWebServer and run $app in the loop
    }
  
    # then from command line
    plackup -s AwesomeWebServer -a app.psgi
  
  =head1 DESCRIPTION
  
  Plack::Handler defines an adapter (connector) interface to adapt
  L<plackup> and L<Plack::Runner> to various PSGI web servers, such as
  Apache2 for mod_perl and Standalone for L<HTTP::Server::PSGI>.
  
  It is an empty class, and as long as they implement the methods
  defined as an Server adapter interface, they do not need to inherit
  Plack::Handler.
  
  If you write a new handler for existing web servers, I recommend you
  to include the full name of the server module after I<Plack::Handler>
  prefix, like L<Plack::Handler::Net::Server::Coro> if you write a
  handler for L<Net::Server::Coro>. That way you'll be using plackup
  command line option like:
  
    plackup -s Net::Server::Coro
  
  that makes it easy to figure out which web server you're going to use.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $server = FooBarServer->new(%args);
  
  Creates a new adapter object. I<%args> can take arbitrary parameters
  to configure server environments but common parameters are:
  
  =over 8
  
  =item port
  
  Port number the server listens to.
  
  =item host
  
  Address the server listens to. Set to undef to listen any interface.
  
  =back
  
  =item run
  
    $server->run($app);
  
  Starts the server process and when a request comes in, run the PSGI
  application passed in C<$app> in the loop.
  
  =item register_service
  
    $server->register_service($app);
  
  Optional interface if your server should run in parallel with other
  event loop, particularly L<AnyEvent>. This is the same as C<run> but
  doesn't run the main loop.
  
  =back
  
  =head1 SEE ALSO
  
  rackup
  
  =cut
  
PLACK_HANDLER

$fatpacked{"Plack/Handler/Apache1.pm"} = <<'PLACK_HANDLER_APACHE1';
  package Plack::Handler::Apache1;
  use strict;
  use Apache::Request;
  use Apache::Constants qw(:common :response);
  
  use Plack::Util;
  use Scalar::Util;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          local $ENV{MOD_PERL}; # trick Catalyst/CGI.pm etc.
          Plack::Util::load_psgi $app;
      };
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      my $vpath    = $env->{SCRIPT_NAME} . ($env->{PATH_INFO} || '');
  
      my $location = $r->location || "/";
         $location =~ s{/$}{};
      (my $path_info = $vpath) =~ s/^\Q$location\E//;
  
      $env->{SCRIPT_NAME} = $location;
      $env->{PATH_INFO}   = $path_info;
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return OK;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
      $r->send_http_header;
  
      if (defined $body) {
          if (Plack::Util::is_real_fh($body)) {
              $r->send_fd($body);
          } else {
              Plack::Util::foreach($body, sub { $r->print(@_) });
          }
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_) },
              close => sub { };
      }
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Plack::Handler::Apache1 - Apache 1.3.x handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlHandler Plack::Handler::Apache1
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    <Perl>
    use Plack::Handler::Apache1;
    Plack::Handler::Apache1->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application with mod_perl on Apache 1.3.x.
  
  =head1 AUTHOR
  
  Aaron Trevena
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_APACHE1

$fatpacked{"Plack/Handler/Apache2.pm"} = <<'PLACK_HANDLER_APACHE2';
  package Plack::Handler::Apache2;
  use strict;
  use warnings;
  use Apache2::RequestRec;
  use Apache2::RequestIO;
  use Apache2::RequestUtil;
  use Apache2::Response;
  use Apache2::Const -compile => qw(OK);
  use Apache2::Log;
  use APR::Table;
  use IO::Handle;
  use Plack::Util;
  use Scalar::Util;
  use URI;
  use URI::Escape;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          local $ENV{MOD_PERL}; # trick Catalyst/CGI.pm etc.
          Plack::Util::load_psgi $app;
      };
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      # Actually, we can not trust PATH_INFO from mod_perl because mod_perl squeezes multiple slashes into one slash.
      my $uri = URI->new("http://".$r->hostname.$r->unparsed_uri);
  
      $env->{PATH_INFO} = uri_unescape($uri->path);
  
      $class->fixup_path($r, $env);
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return Apache2::Const::OK;
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  # The method for PH::Apache2::Registry to override.
  sub fixup_path {
      my ($class, $r, $env) = @_;
  
      # $env->{PATH_INFO} is created from unparsed_uri so it is raw.
      my $path_info = $env->{PATH_INFO} || '';
  
      # Get argument of <Location> or <LocationMatch> directive
      # This may be string or regexp and we can't know either.
      my $location = $r->location;
  
      # Let's *guess* if we're in a LocationMatch directive
      if ($location eq '/') {
          # <Location /> could be handled as a 'root' case where we make
          # everything PATH_INFO and empty SCRIPT_NAME as in the PSGI spec
          $env->{SCRIPT_NAME} = '';
      } elsif ($path_info =~ s{^($location)/?}{/}) {
          $env->{SCRIPT_NAME} = $1 || '';
      } else {
          # Apache's <Location> is matched but here is not.
          # This is something wrong. We can only respect original.
          $r->server->log_error(
              "Your request path is '$path_info' and it doesn't match your Location(Match) '$location'. " .
              "This should be due to the configuration error. See perldoc Plack::Handler::Apache2 for details."
          );
      }
  
      $env->{PATH_INFO}   = $path_info;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
  
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } elsif (lc $h eq 'content-length') {
              $r->set_content_length($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
  
      if (Scalar::Util::blessed($body) and $body->can('path') and my $path = $body->path) {
          $r->sendfile($path);
      } elsif (defined $body) {
          Plack::Util::foreach($body, sub { $r->print(@_) });
          $r->rflush;
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_); $r->rflush },
              close => sub { $r->rflush };
      }
  
      return Apache2::Const::OK;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2 - Apache 2.0 handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlResponseHandler Plack::Handler::Apache2
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    # Optional, preload the application in the parent like startup.pl
    <Perl>
    use Plack::Handler::Apache2;
    Plack::Handler::Apache2->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application with mod_perl on Apache 2.x.
  
  =head1 CREATING CUSTOM HANDLER
  
  If you want to create a custom handler that loads or creates PSGI
  applications using other means than loading from C<.psgi> files, you
  can create your own handler class and use C<call_app> class method to
  run your application.
  
    package My::ModPerl::Handler;
    use Plack::Handler::Apache2;
  
    sub get_app {
      # magic!
    }
  
    sub handler {
      my $r = shift;
      my $app = get_app();
      Plack::Handler::Apache2->call_app($r, $app);
    }
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Paul Driver
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_HANDLER_APACHE2

$fatpacked{"Plack/Handler/Apache2/Registry.pm"} = <<'PLACK_HANDLER_APACHE2_REGISTRY';
  package Plack::Handler::Apache2::Registry;
  use strict;
  use warnings;
  use Try::Tiny;
  use Apache2::Const;
  use Apache2::Log;
  use parent qw/Plack::Handler::Apache2/;
  
  sub handler {
      my $class = __PACKAGE__;
      my ($r) = @_;
  
      return try {
          my $app = $class->load_app( $r->filename );
          $class->call_app( $r, $app );
      }catch{
          if(/no such file/i){
              $r->log_error( $_ );
              return Apache2::Const::NOT_FOUND;
          }else{
              $r->log_error( $_ );
              return Apache2::Const::SERVER_ERROR;
          }
      };
  }
  
  # Overriding
  sub fixup_path {
      my ($class, $r, $env) = @_;
      $env->{PATH_INFO} =~ s{^$env->{SCRIPT_NAME}}{};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2::Registry - Runs .psgi files.
  
  =head1 SYNOPSIS
  
    PerlModule Plack::Handler::Apache2::Registry;
    <Location /psgi-bin>
    SetHandler modperl
    PerlHandler Plack::Handler::Apache2::Registry
    </Location>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any *.psgi files with mod_perl2,
  just like ModPerl::Registry.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Apache2>
  
  =cut
  
PLACK_HANDLER_APACHE2_REGISTRY

$fatpacked{"Plack/Handler/CGI.pm"} = <<'PLACK_HANDLER_CGI';
  package Plack::Handler::CGI;
  use strict;
  use warnings;
  use IO::Handle;
  
  # copied from HTTP::Status
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  sub new { bless {}, shift }
  
  sub run {
      my ($self, $app) = @_;
  
      my $env = $self->setup_env();
  
      my $res = $app->($env);
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  }
  
  sub setup_env {
      my ( $self, $override_env ) = @_;
  
      $override_env ||= {};
  
      binmode STDIN;
      binmode STDERR;
  
      my $env = {
          %ENV,
          'psgi.version'    => [ 1, 1 ],
          'psgi.url_scheme' => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'      => *STDIN,
          'psgi.errors'     => *STDERR,
          'psgi.multithread'  => 0,
          'psgi.multiprocess' => 1,
          'psgi.run_once'     => 1,
          'psgi.streaming'    => 1,
          'psgi.nonblocking'  => 1,
          %{ $override_env },
      };
  
      delete $env->{HTTP_CONTENT_TYPE};
      delete $env->{HTTP_CONTENT_LENGTH};
      $env->{'HTTP_COOKIE'} ||= $ENV{COOKIE}; # O'Reilly server bug
  
      if (!exists $env->{PATH_INFO}) {
          $env->{PATH_INFO} = '';
      }
  
      if ($env->{SCRIPT_NAME} eq '/') {
          $env->{SCRIPT_NAME} = '';
          $env->{PATH_INFO}   = '/' . $env->{PATH_INFO};
      }
  
      return $env;
  }
  
  
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = $StatusCode{$res->[0]};
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice(@$headers, 0, 2)) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $body = $res->[2];
      my $cb = sub { print STDOUT $_[0] };
  
      # inline Plack::Util::foreach here
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      }
      elsif (defined $body) {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
      else {
          return Plack::Handler::CGI::Writer->new;
      }
  }
  
  package Plack::Handler::CGI::Writer;
  sub new   { bless \do { my $x }, $_[0] }
  sub write { print STDOUT $_[1] }
  sub close { }
  
  package Plack::Handler::CGI;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::CGI - CGI handler for Plack
  
  =head1 SYNOPSIS
  
  Want to run PSGI application as a CGI script? Rename .psgi to .cgi and
  change the shebang line like:
  
    #!/usr/bin/env plackup
    # rest of the file can be the same as other .psgi file
  
  You can alternatively create a .cgi file that contains something like:
  
    #!/usr/bin/perl
    use Plack::Loader;
    my $app = Plack::Util::load_psgi("/path/to/app.psgi");
    Plack::Loader->auto->run($app);
  
  This will auto-recognize the CGI environment variable to load this class.
  
  If you really want to explicitly load the CGI handler, you can. For instance
  you might do this when you want to embed a PSGI application server built into
  CGI-compatible perl-based web server:
  
    use Plack::Handler::CGI;
    Plack::Handler::CGI->new->run($app);
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a CGI script.
  
  =head1 UTILITY METHODS
  
  =head2 setup_env()
  
    my $env = Plack::Handler::CGI->setup_env();
    my $env = Plack::Handler::CGI->setup_env(\%override_env);
  
  Sets up the PSGI environment hash for a CGI request from C<< %ENV >>> and returns it.
  You can can provide a hashref of key/value pairs to override the defaults if you would like.
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
  
PLACK_HANDLER_CGI

$fatpacked{"Plack/Handler/FCGI.pm"} = <<'PLACK_HANDLER_FCGI';
  package Plack::Handler::FCGI;
  use strict;
  use warnings;
  use constant RUNNING_IN_HELL => $^O eq 'MSWin32';
  
  use Scalar::Util qw(blessed);
  use Plack::Util;
  use FCGI;
  use HTTP::Status qw(status_message);
  use URI;
  use URI::Escape;
  
  sub new {
      my $class = shift;
      my $self  = bless {@_}, $class;
  
      $self->{leave_umask} ||= 0;
      $self->{keep_stderr} ||= 0;
      $self->{nointr}      ||= 0;
      $self->{daemonize}   ||= $self->{detach}; # compatibility
      $self->{nproc}       ||= 1 unless blessed $self->{manager};
      $self->{pid}         ||= $self->{pidfile}; # compatibility
      $self->{listen}      ||= [ ":$self->{port}" ] if $self->{port}; # compatibility
      $self->{manager}     = 'FCGI::ProcManager' unless exists $self->{manager};
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $sock = 0;
      if (-S STDIN) {
          # running from web server. Do nothing
          # Note it should come before listen check because of plackup's default
      } elsif ($self->{listen}) {
          my $old_umask = umask;
          unless ($self->{leave_umask}) {
              umask(0);
          }
          $sock = FCGI::OpenSocket( $self->{listen}->[0], 100 )
              or die "failed to open FastCGI socket: $!";
          unless ($self->{leave_umask}) {
              umask($old_umask);
          }
      } elsif (!RUNNING_IN_HELL) {
          die "STDIN is not a socket: specify a listen location";
      }
  
      my %env;
      my $request = FCGI::Request(
          \*STDIN, \*STDOUT,
          ($self->{keep_stderr} ? \*STDOUT : \*STDERR), \%env, $sock,
          ($self->{nointr} ? 0 : &FCGI::FAIL_ACCEPT_ON_INTR),
      );
  
      my $proc_manager;
  
      if ($self->{listen}) {
          $self->daemon_fork if $self->{daemonize};
  
          if ($self->{manager}) {
              if (blessed $self->{manager}) {
                  for (qw(nproc pid)) {
                      die "Don't use '$_' when passing in a 'manager' object"
                          if $self->{$_};
                  }
                  $proc_manager = $self->{manager};
              } else {
                  Plack::Util::load_class($self->{manager});
                  $proc_manager = $self->{manager}->new({
                      n_processes => $self->{nproc},
                      pid_fname   => $self->{pid},
                      (exists $self->{proc_title}
                           ? (pm_title => $self->{proc_title}) : ()),
                  });
              }
  
              # detach *before* the ProcManager inits
              $self->daemon_detach if $self->{daemonize};
  
              $proc_manager->pm_manage;
          }
          elsif ($self->{daemonize}) {
              $self->daemon_detach;
          }
      }
  
      while ($request->Accept >= 0) {
          $proc_manager && $proc_manager->pm_pre_dispatch;
  
          my $env = {
              %env,
              'psgi.version'      => [1,1],
              'psgi.url_scheme'   => ($env{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
              'psgi.input'        => *STDIN,
              'psgi.errors'       => *STDERR, # FCGI.pm redirects STDERR in Accept() loop, so just print STDERR
                                              # print to the correct error handle based on keep_stderr
              'psgi.multithread'  => Plack::Util::FALSE,
              'psgi.multiprocess' => Plack::Util::TRUE,
              'psgi.run_once'     => Plack::Util::FALSE,
              'psgi.streaming'    => Plack::Util::TRUE,
              'psgi.nonblocking'  => Plack::Util::FALSE,
              'psgix.harakiri'    => defined $proc_manager,
          };
  
          delete $env->{HTTP_CONTENT_TYPE};
          delete $env->{HTTP_CONTENT_LENGTH};
  
          # lighttpd munges multiple slashes in PATH_INFO into one. Try recovering it
          my $uri = URI->new("http://localhost" .  $env->{REQUEST_URI});
          $env->{PATH_INFO} = uri_unescape($uri->path);
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E//;
  
          if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ m!lighttpd[-/]1\.(\d+\.\d+)!) {
              no warnings;
              if ($ENV{PLACK_ENV} eq 'development' && $1 < 4.23 && $env->{PATH_INFO} eq '') {
                  warn "You're using lighttpd 1.$1 and appear to mount your FastCGI handler under the root ('/'). ",
                       "It's known to be causing issues because of the lighttpd bug. You're recommended to enable ",
                       "LighttpdScriptNameFix middleware, or upgrade lighttpd to 1.4.23 or later and include ",
                       "'fix-root-scriptname' flag in 'fastcgi.server'. See perldoc Plack::Handler::FCGI for details. ",
                       "This friendly warning will go away in the next major release of Plack.";
              }
              $env->{SERVER_NAME} =~ s/:\d+$//; # cut off port number
          }
  
          # root access for mod_fastcgi
          if (!exists $env->{PATH_INFO}) {
              $env->{PATH_INFO} = '';
          }
  
          my $res = Plack::Util::run_app $app, $env;
  
          if (ref $res eq 'ARRAY') {
              $self->_handle_response($res);
          }
          elsif (ref $res eq 'CODE') {
              $res->(sub {
                  $self->_handle_response($_[0]);
              });
          }
          else {
              die "Bad response $res";
          }
  
          # give pm_post_dispatch the chance to do things after the client thinks
          # the request is done
          $request->Finish;
  
          $proc_manager && $proc_manager->pm_post_dispatch();
  
          if ($proc_manager && $env->{'psgix.harakiri.commit'}) {
              $proc_manager->pm_exit("safe exit with harakiri");
          }
      }
  }
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = status_message($res->[0]);
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice @$headers, 0, 2) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $cb = sub { print STDOUT $_[0] };
      my $body = $res->[2];
      if (defined $body) {
          Plack::Util::foreach($body, $cb);
      }
      else {
          return Plack::Util::inline_object
              write => $cb,
              close => sub { };
      }
  }
  
  sub daemon_fork {
      require POSIX;
      fork && exit;
  }
  
  sub daemon_detach {
      my $self = shift;
      print "FastCGI daemon started (pid $$)\n";
      open STDIN,  "+</dev/null" or die $!; ## no critic
      open STDOUT, ">&STDIN"     or die $!;
      open STDERR, ">&STDIN"     or die $!;
      POSIX::setsid();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::FCGI - FastCGI handler for Plack
  
  =head1 SYNOPSIS
  
    # Run as a standalone daemon
    plackup -s FCGI --listen /tmp/fcgi.sock --daemonize --nproc 10
  
    # Run from your web server like mod_fastcgi
    #!/usr/bin/env plackup -s FCGI
    my $app = sub { ... };
  
    # Roll your own
    my $server = Plack::Handler::FCGI->new(
        nproc  => $num_proc,
        listen => [ $port_or_socket ],
        detach => 1,
    );
    $server->run($app);
  
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a standalone
  FastCGI daemon or a .fcgi script.
  
  =head2 OPTIONS
  
  =over 4
  
  =item listen
  
      listen => [ '/path/to/socket' ]
      listen => [ ':8080' ]
  
  Listen on a socket path, hostname:port, or :port.
  
  =item port
  
  listen via TCP on port on all interfaces (Same as C<< listen => ":$port" >>)
  
  =item leave-umask
  
  Set to 1 to disable setting umask to 0 for socket open
  
  =item nointr
  
  Do not allow the listener to be interrupted by Ctrl+C
  
  =item nproc
  
  Specify a number of processes for FCGI::ProcManager
  
  =item pid
  
  Specify a filename for the pid file
  
  =item manager
  
  Specify a FCGI::ProcManager sub-class
  
  =item daemonize
  
  Daemonize the process.
  
  =item keep-stderr
  
  Send STDERR to STDOUT instead of the webserver
  
  =back
  
  =head2 WEB SERVER CONFIGURATIONS
  
  =head3 nginx
  
  This is an example nginx configuration to run your FCGI daemon on a
  Unix domain socket and run it at the server's root URL (/).
  
    http {
      server {
        listen 3001;
        location / {
          set $script "";
          set $path_info $uri;
          fastcgi_pass unix:/tmp/fastcgi.sock;
          fastcgi_param  SCRIPT_NAME      $script;
          fastcgi_param  PATH_INFO        $path_info;
          fastcgi_param  QUERY_STRING     $query_string;
          fastcgi_param  REQUEST_METHOD   $request_method;
          fastcgi_param  CONTENT_TYPE     $content_type;
          fastcgi_param  CONTENT_LENGTH   $content_length;
          fastcgi_param  REQUEST_URI      $request_uri;
          fastcgi_param  SERVER_PROTOCOL  $server_protocol;
          fastcgi_param  REMOTE_ADDR      $remote_addr;
          fastcgi_param  REMOTE_PORT      $remote_port;
          fastcgi_param  SERVER_ADDR      $server_addr;
          fastcgi_param  SERVER_PORT      $server_port;
          fastcgi_param  SERVER_NAME      $server_name;
        }
      }
    }
  
  If you want to host your application in a non-root path, then you
  should mangle this configuration to set the path to C<SCRIPT_NAME> and
  the rest of the path in C<PATH_INFO>.
  
  See L<http://wiki.nginx.org/NginxFcgiExample> for more details.
  
  =head3 Apache mod_fastcgi
  
  You can use C<FastCgiExternalServer> as normal.
  
    FastCgiExternalServer /tmp/myapp.fcgi -socket /tmp/fcgi.sock
  
  See L<http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html#FastCgiExternalServer> for more details.
  
  =head3 lighttpd
  
  To host the app in the root path, you're recommended to use lighttpd
  1.4.23 or newer with C<fix-root-scriptname> flag like below.
  
    fastcgi.server = ( "/" =>
       ((
         "socket" => "/tmp/fcgi.sock",
         "check-local" => "disable"
         "fix-root-scriptname" => "enable",
       ))
  
  If you use lighttpd older than 1.4.22 where you don't have
  C<fix-root-scriptname>, mouting apps under the root causes wrong
  C<SCRIPT_NAME> and C<PATH_INFO> set. Also, mouting under the empty
  root (C<"">) or a path that has a trailing slash would still cause
  weird values set even with C<fix-root-scriptname>. In such cases you
  can use L<Plack::Middleware::LighttpdScriptNameFix> to fix it.
  
  To mount in the non-root path over TCP:
  
    fastcgi.server = ( "/foo" =>
       ((
         "host" = "127.0.0.1"
         "port" = "5000"
         "check-local" => "disable"
       ))
  
  It's recommended that your mount path does B<NOT> have the trailing
  slash. If you I<really> need to have one, you should consider using
  L<Plack::Middleware::LighttpdScriptNameFix> to fix the wrong
  B<PATH_INFO> values set by lighttpd.
  
  =cut
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_FCGI

$fatpacked{"Plack/Handler/Fliggy.pm"} = <<'PLACK_HANDLER_FLIGGY';
  package Plack::Handler::Fliggy;
  
  use strict;
  use warnings;
  
  sub new {
      my $class = shift;
      bless {@_}, $class;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $class = 'Fliggy::Server';
      eval "require $class";
      die if $@;
  
      $class->new(%{$self})->run($app);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::Fliggy - Adapter for Fliggy
  
  =head1 SYNOPSIS
  
    plackup -s Fliggy --port 9090
  
  =head1 DESCRIPTION
  
  This is an adapter to run L<PSGI> apps on L<Fliggy> via L<plackup>.
  
  =head1 METHODS
  
  =head2 C<new>
  
      my $handler = Plack::Handler::Fliggy->new;
  
  Create new instance.
  
  =head2 C<run>
  
      $handler->run;
  
  Run the server.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_HANDLER_FLIGGY

$fatpacked{"Plack/Handler/HTTP/Server/PSGI.pm"} = <<'PLACK_HANDLER_HTTP_SERVER_PSGI';
  package Plack::Handler::HTTP::Server::PSGI;
  use strict;
  
  # for temporary backward compat
  use parent qw( HTTP::Server::PSGI );
  
  sub new {
      my($class, %args) = @_;
      bless { %args }, $class;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->_server->run($app);
  }
  
  sub _server {
      my $self = shift;
      HTTP::Server::PSGI->new(%$self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::PSGI - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s HTTP::Server::PSGI \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 BACKWARD COMPATIBLITY
  
  Since Plack 0.99_22 this handler doesn't support preforking
  configuration i.e. C<--max-workers>. Use L<Starman> or L<Starlet> if
  you need preforking PSGI web server.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item host
  
  Host the server binds to. Defaults to all interfaces.
  
  =item port
  
  Port number the server listens on. Defaults to 8080.
  
  =item timeout
  
  Number of seconds a request times out. Defaults to 300.
  
  =item max-reqs-per-child
  
  Number of requests per worker to process. Defaults to 100.
  
  =back
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack> L<HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_HTTP_SERVER_PSGI

$fatpacked{"Plack/Handler/HTTP/Server/Simple.pm"} = <<'PLACK_HANDLER_HTTP_SERVER_SIMPLE';
  package Plack::Handler::HTTP::Server::Simple;
  use strict;
  
  sub new {
      my($class, %args) = @_;
      bless {%args}, $class;
  }
  
  sub run {
      my($self, $app) = @_;
  
      my $server = Plack::Handler::HTTP::Server::Simple::PSGIServer->new($self->{port});
      $server->host($self->{host}) if $self->{host};
      $server->app($app);
      $server->{_server_ready} = delete $self->{server_ready} || sub {};
  
      $server->run;
  }
  
  package Plack::Handler::HTTP::Server::Simple::PSGIServer;
  use parent qw(HTTP::Server::Simple::PSGI);
  
  sub print_banner {
      my $self = shift;
  
      $self->{_server_ready}->({
          host => $self->host,
          port => $self->port,
          server_software => 'HTTP::Server::Simple::PSGI',
      });
  }
  
  package Plack::Handler::HTTP::Server::Simple;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::Simple - Adapter for HTTP::Server::Simple
  
  =head1 SYNOPSIS
  
    plackup -s HTTP::Server::Simple --port 9090
  
  =head1 DESCRIPTION
  
  Plack::Handler::HTTP::Server::Simple is an adapter to run PSGI
  applications on L<HTTP::Server::Simple>.
  
  =head1 SEE ALSO
  
  L<Plack>, L<HTTP::Server::Simple::PSGI>
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  
  =cut
PLACK_HANDLER_HTTP_SERVER_SIMPLE

$fatpacked{"Plack/Handler/Standalone.pm"} = <<'PLACK_HANDLER_STANDALONE';
  package Plack::Handler::Standalone;
  use strict;
  use warnings;
  use parent qw( Plack::Handler::HTTP::Server::PSGI );
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Standalone - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s Standalone \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 DESCRIPTION
  
  Plack::Handler::Standalone is an adapter for default Plack server
  implementation L<HTTP::Server::PSGI>. This is just an alias for
  L<Plack::Handler::HTTP::Server::PSGI>.
  
  =head1 SEE ALSO
  
  L<Plack::Handler::HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_STANDALONE

$fatpacked{"Plack/Handler/Twiggy.pm"} = <<'PLACK_HANDLER_TWIGGY';
  package Plack::Handler::Twiggy;
  use strict;
  
  sub new {
      my $class = shift;
      bless {@_}, $class;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $class = $ENV{SERVER_STARTER_PORT} ?
          'Twiggy::Server::SS' : 'Twiggy::Server';
      eval "require $class";
      die if $@;
  
      $class->new(%{$self})->run($app);
  }
      
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Twiggy - Adapter for Twiggy
  
  =head1 SYNOPSIS
  
    plackup -s Twiggy --port 9090
  
    # with start_server
    start_server --port=9090 plackup -s Twiggy 
  
  =head1 DESCRIPTION
  
  This is an adapter to run PSGI apps on Twiggy via L<plackup>.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_HANDLER_TWIGGY

$fatpacked{"Plack/Loader.pm"} = <<'PLACK_LOADER';
  package Plack::Loader;
  use strict;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {}, $class;
  }
  
  sub watch {
      # do nothing. Override in subclass
  }
  
  sub auto {
      my($class, @args) = @_;
  
      my $backend = $class->guess
          or Carp::croak("Couldn't auto-guess server server implementation. Set it with PLACK_SERVER");
  
      my $server = try {
          $class->load($backend, @args);
      } catch {
          if (($ENV{PLACK_ENV}||'') eq 'development' or !/^Can't locate /) {
              warn "Autoloading '$backend' backend failed. Falling back to the Standalone. ",
                  "(You might need to install Plack::Handler::$backend from CPAN.  Caught error was: $_)\n"
                      if $ENV{PLACK_ENV} && $ENV{PLACK_ENV} eq 'development';
          }
          $class->load('Standalone' => @args);
      };
  
      return $server;
  }
  
  sub load {
      my($class, $server, @args) = @_;
  
      my($server_class, $error);
      for my $prefix (qw( Plack::Handler Plack::Server )) {
          try {
              $server_class = Plack::Util::load_class($server, $prefix);
          } catch {
              $error ||= $_;
          };
          last if $server_class;
          last if $error && $error !~ /^Can't locate Plack\/Handler\//;
      }
  
      if ($server_class) {
          $server_class->new(@args);
      } else {
          die $error;
      }
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{app} = $builder->();
  }
  
  sub guess {
      my $class = shift;
  
      my $env = $class->env;
  
      return $env->{PLACK_SERVER} if $env->{PLACK_SERVER};
  
      if ($env->{PHP_FCGI_CHILDREN} || $env->{FCGI_ROLE} || $env->{FCGI_SOCKET_PATH}) {
          return "FCGI";
      } elsif ($env->{GATEWAY_INTERFACE}) {
          return "CGI";
      } elsif (exists $INC{"Coro.pm"}) {
          return "Corona";
      } elsif (exists $INC{"AnyEvent.pm"}) {
          return "Twiggy";
      } elsif (exists $INC{"POE.pm"}) {
          return "POE";
      } else {
          return "Standalone";
      }
  }
  
  sub env { \%ENV }
  
  sub run {
      my($self, $server, $builder) = @_;
      $server->run($self->{app});
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader - (auto)load Plack Servers
  
  =head1 SYNOPSIS
  
    # auto-select server backends based on env vars
    use Plack::Loader;
    Plack::Loader->auto(%args)->run($app);
  
    # specify the implementation with a name
    Plack::Loader->load('FCGI', %args)->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Loader is a factory class to load one of Plack::Handler subclasses based on the environment.
  
  =head1 AUTOLOADING
  
  C<< Plack::Loader->auto(%args) >> will autoload the most correct
  server implementation by guessing from environment variables and Perl INC
  hashes.
  
  =over 4
  
  =item PLACK_SERVER
  
    env PLACK_SERVER=AnyEvent ...
  
  Plack users can specify the specific implementation they want to load
  using the C<PLACK_SERVER> environment variable.
  
  =item PHP_FCGI_CHILDREN, GATEWAY_INTERFACE
  
  If there's one of FastCGI or CGI specific environment variables set,
  use the corresponding server implementation.
  
  =item %INC
  
  If one of L<AnyEvent>, L<Coro> or L<POE> is loaded, the relevant
  server implementation such as L<Twiggy>, L<Corona> or
  L<POE::Component::Server::PSGI> will be loaded, if they're available.
  
  =back
  
  =cut
  
  
PLACK_LOADER

$fatpacked{"Plack/Loader/Delayed.pm"} = <<'PLACK_LOADER_DELAYED';
  package Plack::Loader::Delayed;
  use strict;
  use parent qw(Plack::Loader);
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $compiled;
      my $app = sub {
          $compiled ||= $self->{builder}->();
          $compiled->(@_);
      };
  
      $server->{psgi_app_builder} = $self->{builder};
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Delayed - Delay the loading of .psgi until the first run
  
  =head1 SYNOPSIS
  
    plackup -s Starlet -L Delayed myapp.psgi
  
  =head1 DESCRIPTION
  
  This loader delays the compilation of specified PSGI application until
  the first request time. This prevents bad things from happening with
  preforking web servers like L<Starlet>, when your application
  manipulates resources such as sockets or database connections in the
  master startup process and then shared by children.
  
  You can combine this loader with C<-M> command line option, like:
  
    plackup -s Starlet -MCatalyst -L Delayed myapp.psgi
  
  loads the module Catalyst in the master process for the better process
  management with copy-on-write, however the application C<myapp.psgi>
  is loaded per children.
  
  L<Starman> since version 0.2000 loads this loader by default unless
  you specify the command line option C<--preload-app> for the
  L<starman> executable.
  
  =head1 DEVELOPERS
  
  Web server developers can make use of C<psgi_app_builder> attribute
  callback set in Plack::Handler, to load the application earlier than
  the first request time.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_LOADER_DELAYED

$fatpacked{"Plack/Loader/Restarter.pm"} = <<'PLACK_LOADER_RESTARTER';
  package Plack::Loader::Restarter;
  use strict;
  use warnings;
  use parent qw(Plack::Loader);
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my($class, $runner) = @_;
      bless { watch => [] }, $class;
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub watch {
      my($self, @dir) = @_;
      push @{$self->{watch}}, @dir;
  }
  
  sub _fork_and_start {
      my($self, $server) = @_;
  
      delete $self->{pid}; # re-init in case it's a restart
  
      my $pid = fork;
      die "Can't fork: $!" unless defined $pid;
  
      if ($pid == 0) { # child
          return $server->run($self->{builder}->());
      } else {
          $self->{pid} = $pid;
      }
  }
  
  sub _kill_child {
      my $self = shift;
  
      my $pid = $self->{pid} or return;
      warn "Killing the existing server (pid:$pid)\n";
      kill 'TERM' => $pid;
      waitpid($pid, 0);
  }
  
  sub valid_file {
      my($self, $file) = @_;
      $file->{path} !~ m![/\\][\._]|\.bak$|~$|_flymake\.p[lm]!;
  }
  
  sub run {
      my($self, $server, $builder) = @_;
  
      $self->_fork_and_start($server, $builder);
      return unless $self->{pid};
  
      require Filesys::Notify::Simple;
      my $watcher = Filesys::Notify::Simple->new($self->{watch});
      warn "Watching @{$self->{watch}} for file updates.\n";
      local $SIG{TERM} = sub { $self->_kill_child; exit(0); };
  
      while (1) {
          my @restart;
  
          # this is blocking
          $watcher->wait(sub {
              my @events = @_;
              @events = grep $self->valid_file($_), @events;
              return unless @events;
  
              @restart = @events;
          });
  
          next unless @restart;
  
          for my $ev (@restart) {
              warn "-- $ev->{path} updated.\n";
          }
  
          $self->_kill_child;
          warn "Successfully killed! Restarting the new server process.\n";
          $self->_fork_and_start($server, $builder);
          return unless $self->{pid};
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Restarter - Restarting loader
  
  =head1 SYNOPSIS
  
    plackup -r -R paths
  
  =head1 DESCRIPTION
  
  Plack::Loader::Restarter is a loader backend that implements C<-r> and
  C<-R> option for the L<plackup> script. It forks the server as a child
  process and the parent watches the directories for file updates, and
  whenever it receives the notification, kills the child server and
  restart.
  
  =head1 SEE ALSO
  
  L<Plack::Runner>, L<Catalyst::Restarter>
  
  =cut
PLACK_LOADER_RESTARTER

$fatpacked{"Plack/Loader/Shotgun.pm"} = <<'PLACK_LOADER_SHOTGUN';
  package Plack::Loader::Shotgun;
  use strict;
  use parent qw(Plack::Loader);
  use Storable;
  use Try::Tiny;
  use Plack::Middleware::BufferedStreaming;
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = sub { Plack::Middleware::BufferedStreaming->wrap($builder->()) };
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $app = sub {
          my $env = shift;
  
          pipe my $read, my $write;
  
          my $pid = fork;
          if ($pid) {
              # parent
              close $write;
              my $res = Storable::thaw(join '', <$read>);
              close $read;
              waitpid($pid, 0);
  
              return $res;
          } else {
              # child
              close $read;
  
              my $res;
              try {
                  $env->{'psgi.streaming'} = 0;
                  $res = $self->{builder}->()->($env);
                  my @body;
                  Plack::Util::foreach($res->[2], sub { push @body, $_[0] });
                  $res->[2] = \@body;
              } catch {
                  $env->{'psgi.errors'}->print($_);
                  $res = [ 500, [ "Content-Type", "text/plain" ], [ "Internal Server Error" ] ];
              };
  
              print {$write} Storable::freeze($res);
              close $write;
              exit;
          }
      };
  
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Shotgun - forking implementation of plackup
  
  =head1 SYNOPSIS
  
    plackup -L Shotgun
  
  =head1 DESCRIPTION
  
  Shotgun loader delays the compilation and execution of your
  application until the runtime. When a new request comes in, this forks
  a new child, compiles your code and runs the application.
  
  This should be an ultimate alternative solution when reloading with
  L<Plack::Middleware::Refresh> doesn't work, or plackup's default C<-r>
  filesystem watcher causes problems. I can imagine this is useful for
  applications which expects their application is only evaluated once
  (like in-file templates) or on operating systems with broken fork
  implementation, etc.
  
  This is much like good old CGI's fork and run but you don't need a web
  server, and there's a benefit of preloading modules that are not
  likely to change. For instance if you develop a web application using
  Moose and DBIx::Class,
  
    plackup -MMoose -MDBIx::Class -L Shotgun yourapp.psgi
  
  would preload those modules and only re-evaluates your code in every
  request.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa with an inspiration from L<http://github.com/rtomayko/shotgun>
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_LOADER_SHOTGUN

$fatpacked{"Plack/MIME.pm"} = <<'PLACK_MIME';
  package Plack::MIME;
  use strict;
  
  # stolen from rack.mime.rb
  our $MIME_TYPES = {
      ".3gp"     => "video/3gpp",
      ".a"       => "application/octet-stream",
      ".ai"      => "application/postscript",
      ".aif"     => "audio/x-aiff",
      ".aiff"    => "audio/x-aiff",
      ".asc"     => "application/pgp-signature",
      ".asf"     => "video/x-ms-asf",
      ".asm"     => "text/x-asm",
      ".asx"     => "video/x-ms-asf",
      ".atom"    => "application/atom+xml",
      ".au"      => "audio/basic",
      ".avi"     => "video/x-msvideo",
      ".bat"     => "application/x-msdownload",
      ".bin"     => "application/octet-stream",
      ".bmp"     => "image/bmp",
      ".bz2"     => "application/x-bzip2",
      ".c"       => "text/x-c",
      ".cab"     => "application/vnd.ms-cab-compressed",
      ".cc"      => "text/x-c",
      ".chm"     => "application/vnd.ms-htmlhelp",
      ".class"   => "application/octet-stream",
      ".com"     => "application/x-msdownload",
      ".conf"    => "text/plain",
      ".cpp"     => "text/x-c",
      ".crt"     => "application/x-x509-ca-cert",
      ".css"     => "text/css",
      ".csv"     => "text/csv",
      ".cxx"     => "text/x-c",
      ".deb"     => "application/x-debian-package",
      ".der"     => "application/x-x509-ca-cert",
      ".diff"    => "text/x-diff",
      ".djv"     => "image/vnd.djvu",
      ".djvu"    => "image/vnd.djvu",
      ".dll"     => "application/x-msdownload",
      ".dmg"     => "application/octet-stream",
      ".doc"     => "application/msword",
      ".dot"     => "application/msword",
      ".dtd"     => "application/xml-dtd",
      ".dvi"     => "application/x-dvi",
      ".ear"     => "application/java-archive",
      ".eml"     => "message/rfc822",
      ".eps"     => "application/postscript",
      ".exe"     => "application/x-msdownload",
      ".f"       => "text/x-fortran",
      ".f77"     => "text/x-fortran",
      ".f90"     => "text/x-fortran",
      ".flv"     => "video/x-flv",
      ".for"     => "text/x-fortran",
      ".gem"     => "application/octet-stream",
      ".gemspec" => "text/x-script.ruby",
      ".gif"     => "image/gif",
      ".gz"      => "application/x-gzip",
      ".h"       => "text/x-c",
      ".hh"      => "text/x-c",
      ".htm"     => "text/html",
      ".html"    => "text/html",
      ".ico"     => "image/vnd.microsoft.icon",
      ".ics"     => "text/calendar",
      ".ifb"     => "text/calendar",
      ".iso"     => "application/octet-stream",
      ".jar"     => "application/java-archive",
      ".java"    => "text/x-java-source",
      ".jnlp"    => "application/x-java-jnlp-file",
      ".jpeg"    => "image/jpeg",
      ".jpg"     => "image/jpeg",
      ".js"      => "application/javascript",
      ".json"    => "application/json",
      ".log"     => "text/plain",
      ".m3u"     => "audio/x-mpegurl",
      ".m4v"     => "video/mp4",
      ".man"     => "text/troff",
      ".manifest"=> "text/cache-manifest",
      ".mathml"  => "application/mathml+xml",
      ".mbox"    => "application/mbox",
      ".mdoc"    => "text/troff",
      ".me"      => "text/troff",
      ".mid"     => "audio/midi",
      ".midi"    => "audio/midi",
      ".mime"    => "message/rfc822",
      ".mml"     => "application/mathml+xml",
      ".mng"     => "video/x-mng",
      ".mov"     => "video/quicktime",
      ".mp3"     => "audio/mpeg",
      ".mp4"     => "video/mp4",
      ".mp4v"    => "video/mp4",
      ".mpeg"    => "video/mpeg",
      ".mpg"     => "video/mpeg",
      ".ms"      => "text/troff",
      ".msi"     => "application/x-msdownload",
      ".odp"     => "application/vnd.oasis.opendocument.presentation",
      ".ods"     => "application/vnd.oasis.opendocument.spreadsheet",
      ".odt"     => "application/vnd.oasis.opendocument.text",
      ".ogg"     => "application/ogg",
      ".ogv"     => "video/ogg",
      ".p"       => "text/x-pascal",
      ".pas"     => "text/x-pascal",
      ".pbm"     => "image/x-portable-bitmap",
      ".pdf"     => "application/pdf",
      ".pem"     => "application/x-x509-ca-cert",
      ".pgm"     => "image/x-portable-graymap",
      ".pgp"     => "application/pgp-encrypted",
      ".pkg"     => "application/octet-stream",
      ".pl"      => "text/x-script.perl",
      ".pm"      => "text/x-script.perl-module",
      ".png"     => "image/png",
      ".pnm"     => "image/x-portable-anymap",
      ".ppm"     => "image/x-portable-pixmap",
      ".pps"     => "application/vnd.ms-powerpoint",
      ".ppt"     => "application/vnd.ms-powerpoint",
      ".ps"      => "application/postscript",
      ".psd"     => "image/vnd.adobe.photoshop",
      ".py"      => "text/x-script.python",
      ".qt"      => "video/quicktime",
      ".ra"      => "audio/x-pn-realaudio",
      ".rake"    => "text/x-script.ruby",
      ".ram"     => "audio/x-pn-realaudio",
      ".rar"     => "application/x-rar-compressed",
      ".rb"      => "text/x-script.ruby",
      ".rdf"     => "application/rdf+xml",
      ".roff"    => "text/troff",
      ".rpm"     => "application/x-redhat-package-manager",
      ".rss"     => "application/rss+xml",
      ".rtf"     => "application/rtf",
      ".ru"      => "text/x-script.ruby",
      ".s"       => "text/x-asm",
      ".sgm"     => "text/sgml",
      ".sgml"    => "text/sgml",
      ".sh"      => "application/x-sh",
      ".sig"     => "application/pgp-signature",
      ".snd"     => "audio/basic",
      ".so"      => "application/octet-stream",
      ".svg"     => "image/svg+xml",
      ".svgz"    => "image/svg+xml",
      ".swf"     => "application/x-shockwave-flash",
      ".t"       => "text/troff",
      ".tar"     => "application/x-tar",
      ".tbz"     => "application/x-bzip-compressed-tar",
      ".tcl"     => "application/x-tcl",
      ".tex"     => "application/x-tex",
      ".texi"    => "application/x-texinfo",
      ".texinfo" => "application/x-texinfo",
      ".text"    => "text/plain",
      ".tif"     => "image/tiff",
      ".tiff"    => "image/tiff",
      ".torrent" => "application/x-bittorrent",
      ".tr"      => "text/troff",
      ".txt"     => "text/plain",
      ".vcf"     => "text/x-vcard",
      ".vcs"     => "text/x-vcalendar",
      ".vrml"    => "model/vrml",
      ".war"     => "application/java-archive",
      ".wav"     => "audio/x-wav",
      ".wma"     => "audio/x-ms-wma",
      ".wmv"     => "video/x-ms-wmv",
      ".wmx"     => "video/x-ms-wmx",
      ".wrl"     => "model/vrml",
      ".wsdl"    => "application/wsdl+xml",
      ".xbm"     => "image/x-xbitmap",
      ".xhtml"   => "application/xhtml+xml",
      ".xls"     => "application/vnd.ms-excel",
      ".xml"     => "application/xml",
      ".xpm"     => "image/x-xpixmap",
      ".xsl"     => "application/xml",
      ".xslt"    => "application/xslt+xml",
      ".yaml"    => "text/yaml",
      ".yml"     => "text/yaml",
      ".zip"     => "application/zip",
  };
  
  my $fallback = sub { };
  
  sub mime_type {
      my($class, $file) = @_;
      $file =~ /(\.[a-zA-Z0-9]+)$/ or return;
      $MIME_TYPES->{lc $1} || $fallback->(lc $1);
  }
  
  sub add_type {
      my $class = shift;
      while (my($ext, $type) = splice @_, 0, 2) {
          $MIME_TYPES->{lc $ext} = $type;
      }
  }
  
  sub set_fallback {
      my($class, $cb) = @_;
      $fallback = $cb;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::MIME - MIME type registry
  
  =head1 SYNOPSIS
  
    use Plack::MIME;
  
    my $mime = Plack::MIME->mime_type(".png"); # image/png
  
    # register new type(s)
    Plack::MIME->add_type(".foo" => "application/x-foo");
  
    # Use MIME::Types as a fallback
    use MIME::Types 'by_suffix';
    Plack::MIME->set_fallback(sub { (by_suffix $_[0])[0] });
  
  =head1 DESCRIPTION
  
  Plack::MIME is a simple MIME type registry for Plack applications. The
  selection of MIME types is based on Rack's Rack::Mime module.
  
  =head1 SEE ALSO
  
  Rack::Mime L<MIME::Types>
  
  =cut
  
  
PLACK_MIME

$fatpacked{"Plack/Middleware.pm"} = <<'PLACK_MIDDLEWARE';
  package Plack::Middleware;
  use strict;
  use warnings;
  use Carp ();
  use parent qw(Plack::Component);
  use Plack::Util;
  use Plack::Util::Accessor qw( app );
  
  sub import {
      my $class = shift;
      if (@_) {
          Carp::carp("use Plack::Middleware qw(Foo) is deprecated. See perldoc Plack::Builder");
      }
  }
  
  sub wrap {
      my($self, $app, @args) = @_;
      if (ref $self) {
          $self->{app} = $app;
      } else {
          $self = $self->new({ app => $app, @args });
      }
      return $self->to_app;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware - Base class for easy-to-use PSGI middleware
  
  =head1 SYNOPSIS
  
    package Plack::Middleware::Foo;
    use parent qw( Plack::Middleware );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        # $self->app is the original app
        my $res = $self->app->($env);
  
        # Do something with $res
        return $res;
    }
  
    # then in app.psgi
    use Plack::Builder;
  
    my $app = sub { ... } # as usual
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", %options;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware is a utility base class to write PSGI
  middleware. All you have to do is to inherit from Plack::Middleware
  and then implement the callback C<call> method (or C<to_app> method
  that would return the PSGI code reference) to do the actual work. You
  can use C<< $self->app >> to call the original (wrapped) application.
  
  Your middleware object is created at a PSGI application compile time
  and is persistent during the web server life cycle (unless it is a
  non-persistent environment such as CGI), so you should never set or
  cache per-request data like C<$env> in your middleware object. See
  also L<Plack::Component/"OBJECT LIFECYCLE">.
  
  See L<Plack::Builder> how to actually enable middleware in your
  I<.psgi> application file using the DSL. If you do not like our
  builder DSL, you can also use C<wrap> method to wrap your application
  with a middleware:
  
    use Plack::Middleware::Foo;
  
    my $app = sub { ... };
    $app = Plack::Middleware::Foo->wrap($app, %options);
    $app = Plack::Middleware::Bar->wrap($app, %options);
  
  =head1 RESPONSE CALLBACK
  
  The typical middleware is written like this:
  
    package Plack::Middleware::Something;
    use parent qw(Plack::Middleware);
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $self->app->($env);
        # post-processing $res
        return $res;
    }
  
  The tricky thing about post processing the response is that it could
  either be an immediate 3 element array ref, or a code reference that
  implements the delayed (streaming) interface.
  
  Dealing with these two types of response in each piece of middleware
  is pointless, so you're recommended to use the C<response_cb> wrapper
  function in L<Plack::Util> when implementing a post processing
  middleware.
  
    my $res = $app->($env);
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        # do something with $res;
    });
  
  The callback function gets a PSGI response as a 3 element array
  reference, and you can update the reference to implement the post
  processing.
  
    package Plack::Middleware::Always500;
    use parent qw(Plack::Middleware);
    use Plack::Util;
  
    sub call {
        my($self, $env) = @_;
        my $res  = $self->app->($env);
        Plack::Util::response_cb($res, sub {
            my $res = shift;
            $res->[0] = 500;
            return;
        });
    }
  
  In this example, the callback gets the C<$res> and updates its first
  element (status code) to 500. Using C<response_cb> makes sure that
  this works with the delayed response too.
  
  You're not required (and not recommended either) to return a new array
  reference - they will be simply ignored. You're suggested to
  explicitly return, unless you fiddle with the content filter callback
  (see below).
  
  Similarly, note that you have to keep the C<$res> reference when you
  swap the entire response.
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        $res = [ $new_status, $new_headers, $new_body ]; # THIS DOES NOT WORK
        return;
    });
  
  This does not work, since assigning a new anonymous array to C<$res>
  doesn't update the original PSGI response value. You should instead
  do:
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        @$res = ($new_status, $new_headers, $new_body); # THIS WORKS
        return;
    });
  
  The third element of PSGI response array ref is a body, and it could
  be either array ref or IO::Handle-ish object. The application could
  also make use of C<$writer> object if C<psgi.streaming> is in
  effect. Dealing with these variants is again really painful, and
  C<response_cb> can take care of that too, by allowing you to return a
  content filter as a code reference.
  
    # replace all "Foo" in content body with "Bar"
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        return sub {
            my $chunk = shift;
            return unless defined $chunk;
            $chunk =~ s/Foo/Bar/g;
            return $chunk;
        }
    });
  
  The callback takes one argument C<$chunk> and your callback is
  expected to return the updated chunk. If the given C<$chunk> is undef,
  it means the stream has reached the end, so your callback should also
  return undef, or return the final chunk and return undef when called
  next time.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Component>
  
  =cut
PLACK_MIDDLEWARE

$fatpacked{"Plack/Middleware/AccessLog.pm"} = <<'PLACK_MIDDLEWARE_ACCESSLOG';
  package Plack::Middleware::AccessLog;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  use Plack::Util::Accessor qw( logger format );
  
  use Carp ();
  use Plack::Util;
  
  my %formats = (
      common => "%h %l %u %t \"%r\" %>s %b",
      combined => "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"",
  );
  
  use POSIX ();
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
          my $content_length = Plack::Util::content_length($res->[2]);
          $logger->( $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length }) );
      });
  }
  
  sub log_line {
      my($self, $status, $headers, $env, $opts) = @_;
  
      my $h = Plack::Util::headers($headers);
  
      my $strftime = sub {
          my $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
          POSIX::setlocale(&POSIX::LC_ALL, 'en');
          my $out = POSIX::strftime(@_);
          POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
          return $out;
      };
  
      my $block_handler = sub {
          my($block, $type) = @_;
          if ($type eq 'i') {
              $block =~ s/-/_/g;
              my $val = _safe($env->{"HTTP_" . uc($block)});
              return defined $val ? $val : "-";
          } elsif ($type eq 'o') {
              return scalar $h->get($block) || "-";
          } elsif ($type eq 't') {
              return "[" . $strftime->($block, localtime) . "]";
          } else {
              Carp::carp("{$block}$type not supported");
              return "-";
          }
      };
  
  
      my %char_handler = (
          '%' => sub { '%' },
          h => sub { $env->{REMOTE_ADDR} || '-' },
          l => sub { '-' },
          u => sub { $env->{REMOTE_USER} || '-' },
          t => sub { "[" . $strftime->("%d/%b/%Y:%H:%M:%S %z", localtime) . "]" },
          r => sub { _safe($env->{REQUEST_METHOD}) . " " . _safe($env->{REQUEST_URI}) .
                     " " . $env->{SERVER_PROTOCOL} },
          s => sub { $status },
          b => sub { $opts->{content_length} || $h->get('Content-Length') || "-" },
          T => sub { $opts->{time} ? int($opts->{time}) : "-" },
          D => sub { $opts->{time} ? $opts->{time} * 1000000 : "-" },
          v => sub { $env->{SERVER_NAME} || '-' },
          V => sub { $env->{HTTP_HOST} || $env->{SERVER_NAME} || '-' },
      );
  
      my $char_handler = sub {
          my $char = shift;
  
          my $cb = $char_handler{$char};
          unless ($cb) {
              Carp::carp "\%$char not supported.";
              return "-";
          }
          $cb->($char);
      };
  
      my $fmt = $self->format || "combined";
      $fmt = $formats{$fmt} if exists $formats{$fmt};
  
      $fmt =~ s{
          (?:
           \%\{(.+?)\}([a-z]) |
           \%(?:[<>])?([a-zA-Z\%])
          )
      }{ $1 ? $block_handler->($1, $2) : $char_handler->($3) }egx;
  
      return $fmt . "\n";
  }
  
  sub _safe {
      my $string = shift;
      $string =~ s/([^[:print:]])/"\\x" . unpack("H*", $1)/eg
          if defined $string;
      $string;
  }
  
  
  __END__
  
  =for stopwords
  LogFormat
  
  =head1 NAME
  
  Plack::Middleware::AccessLog - Logs requests like Apache's log format
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog", format => "combined";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog forwards the request to the given app and
  logs request and response details to the logger callback. The format
  can be specified using Apache-like format strings (or C<combined> or
  C<common> for the default formats). If none is specified C<combined> is
  used.
  
  This middleware uses calculable content-length by checking body type,
  and can not log the time taken to serve requests. It also logs the
  request B<before> the response is actually sent to the client. Use
  L<Plack::Middleware::AccessLog::Timed> if you want to log details
  B<after> the response is transmitted (more like a real web server) to
  the client.
  
  This middleware is enabled by default when you run L<plackup> as a
  default C<development> environment.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item format
  
    enable "Plack::Middleware::AccessLog",
        format => "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"";
  
  Takes a format string (or a preset template C<combined> or C<custom>)
  to specify the log format. This middleware implements subset of
  Apache's LogFormat templates.
  
  =item logger
  
    my $logger = Log::Dispatch->new(...);
    enable "Plack::Middleware::AccessLog",
        logger => sub { $logger->log(debug => @_) };
  
  Sets a callback to print log message to. It prints to C<psgi.errors>
  output stream by default.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://httpd.apache.org/docs/2.2/mod/mod_log_config.html> Rack::CustomLogger
  
  =cut
  
PLACK_MIDDLEWARE_ACCESSLOG

$fatpacked{"Plack/Middleware/AccessLog/Timed.pm"} = <<'PLACK_MIDDLEWARE_ACCESSLOG_TIMED';
  package Plack::Middleware::AccessLog::Timed;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware::AccessLog );
  
  use Time::HiRes;
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $time = Time::HiRes::gettimeofday;
      my $length = 0;
      my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my($status, $header, $body) = @$res;
  
          if (!defined $body) {
              $logger->( $self->log_line($status, $header, $env) );
              return;
          }
  
          my $getline = ref $body eq 'ARRAY' ? sub { shift @$body } : sub { $body->getline };
  
          my $timer_body = Plack::Util::inline_object(
              getline => sub {
                  my $line = $getline->();
                  $length += length $line if defined $line;
                  return $line;
              },
              close => sub {
                  $body->close if ref $body ne 'ARRAY';
  
                  my $now = Time::HiRes::gettimeofday;
                  $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
              },
          );
  
          @$res = ($status, $header, $timer_body);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::AccessLog::Timed - Logs requests with time and accurate body size
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog::Timed",
            format => "%v %h %l %u %t \"%r\" %>s %b %D";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog::Timed is a subclass of
  Plack::Middleware::AccessLog but uses a wrapped body handle to get the
  actual response body size C<%b> (even if it's not a chunk of array or
  a real filehandle) and the time taken to serve the request: C<%T> or
  C<%D>.
  
  This wraps the response body output stream so some server
  optimizations like sendfile(2) will be disabled if you use this
  middleware.
  
  =head1 CONFIGURATION
  
  Same as L<Plack::Middleware::AccessLog>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::AccessLog>
  
  =cut
PLACK_MIDDLEWARE_ACCESSLOG_TIMED

$fatpacked{"Plack/Middleware/Auth/Basic.pm"} = <<'PLACK_MIDDLEWARE_AUTH_BASIC';
  package Plack::Middleware::Auth::Basic;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw( realm authenticator );
  use Scalar::Util;
  use MIME::Base64;
  
  sub prepare_app {
      my $self = shift;
  
      my $auth = $self->authenticator or die 'authenticator is not set';
      if (Scalar::Util::blessed($auth) && $auth->can('authenticate')) {
          $self->authenticator(sub { $auth->authenticate(@_[0,1]) }); # because Authen::Simple barfs on 3 params
      } elsif (ref $auth ne 'CODE') {
          die 'authenticator should be a code reference or an object that responds to authenticate()';
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $auth = $env->{HTTP_AUTHORIZATION}
          or return $self->unauthorized;
  
      if ($auth =~ /^Basic (.*)$/) {
          my($user, $pass) = split /:/, (MIME::Base64::decode($1) || ":");
          $pass = '' unless defined $pass;
          if ($self->authenticator->($user, $pass, $env)) {
              $env->{REMOTE_USER} = $user;
              return $self->app->($env);
          }
      }
  
      return $self->unauthorized;
  }
  
  sub unauthorized {
      my $self = shift;
      my $body = 'Authorization required';
      return [
          401,
          [ 'Content-Type' => 'text/plain',
            'Content-Length' => length $body,
            'WWW-Authenticate' => 'Basic realm="' . ($self->realm || "restricted area") . '"' ],
          [ $body ],
      ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Auth::Basic - Simple basic authentication middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    my $app = sub { ... };
  
    builder {
        enable "Auth::Basic", authenticator => \&authen_cb;
        $app;
    };
  
    sub authen_cb {
        my($username, $password) = @_;
        return $username eq 'admin' && $password eq 's3cr3t';
    }
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Auth::Basic is a basic authentication handler for Plack.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item authenticator
  
  A callback function that takes username and password supplied and
  returns whether the authentication succeeds. Required.
  
  Authenticator can also be an object that responds to C<authenticate>
  method that takes username and password and returns boolean, so
  backends for L<Authen::Simple> is perfect to use:
  
    use Authen::Simple::LDAP;
    enable "Auth::Basic", authenticator => Authen::Simple::LDAP->new(...);
  
  =item realm
  
  Realm name to display in the basic authentication dialog. Defaults to I<restricted area>.
  
  =back
  
  =head1 LIMITATIONS
  
  This middleware expects that the application has a full access to the
  headers sent by clients in PSGI environment. That is normally the case
  with standalone Perl PSGI web servers such as L<Starman> or
  L<HTTP::Server::Simple::PSGI>.
  
  However, in a web server configuration where you can't achieve this
  (i.e. using your application via Apache's mod_cgi), this middleware
  does not work since your application can't know the value of
  C<Authorization:> header.
  
  If you use Apache as a web server and CGI to run your PSGI
  application, you can either a) compile Apache with
  C<-DSECURITY_HOLE_PASS_AUTHORIZATION> option, or b) use mod_rewrite to
  pass the Authorization header to the application with the rewrite rule
  like following.
  
    RewriteEngine on
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_MIDDLEWARE_AUTH_BASIC

$fatpacked{"Plack/Middleware/BufferedStreaming.pm"} = <<'PLACK_MIDDLEWARE_BUFFEREDSTREAMING';
  package Plack::Middleware::BufferedStreaming;
  use strict;
  no warnings;
  use Carp;
  use Plack::Util;
  use Scalar::Util qw(weaken);
  use parent qw(Plack::Middleware);
  
  sub call {
      my ( $self, $env ) = @_;
  
      my $caller_supports_streaming = $env->{'psgi.streaming'};
      $env->{'psgi.streaming'} = Plack::Util::TRUE;
  
      my $res = $self->app->($env);
      return $res if $caller_supports_streaming;
  
      if ( ref($res) eq 'CODE' ) {
          my $ret;
  
          $res->(sub {
              my $write = shift;
  
              if ( @$write == 2 ) {
                  my @body;
  
                  $ret = [ @$write, \@body ];
  
                  return Plack::Util::inline_object(
                      write => sub { push @body, $_[0] },
                      close => sub { },
                  );
              } else {
                  $ret = $write;
                  return;
              }
          });
  
          return $ret;
      } else {
          return $res;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::BufferedStreaming - Enable buffering for non-streaming aware servers
  
  =head1 SYNOPSIS
  
    enable "BufferedStreaming";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::BufferedStreaming is a PSGI middleware component
  that wraps the application that uses C<psgi.streaming> interface to
  run on the servers that do not support the interface, by buffering the
  writer output to a temporary buffer.
  
  This middleware doesn't do anything and bypass the application if the
  server supports C<psgi.streaming> interface.
  
  =head1 AUTHOR
  
  Yuval Kogman
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_BUFFEREDSTREAMING

$fatpacked{"Plack/Middleware/Chunked.pm"} = <<'PLACK_MIDDLEWARE_CHUNKED';
  package Plack::Middleware::Chunked;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($env->{'SERVER_PROTOCOL'} ne 'HTTP/1.0' and
              ! Plack::Util::status_with_no_entity_body($res->[0]) and
              ! $h->exists('Content-Length') and
              ! $h->exists('Transfer-Encoding')
          ) {
              $h->set('Transfer-Encoding' => 'chunked');
              my $done;
              return sub {
                  my $chunk = shift;
                  return if $done;
                  unless (defined $chunk) {
                      $done = 1;
                      return "0\015\012\015\012";
                  }
                  return '' unless length $chunk;
                  return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Chunked - Applies chunked encoding to the response body
  
  =head1 SYNOPSIS
  
    # Mostly from server implemenations
    $app = Plack::Middeware::Chunked->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middeware::Chunked is a middleware, or rather a library for
  PSGI server to automatically add chunked encoding to the response body
  when Content-Length is not set in the response header.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Chunked
  
  =cut
PLACK_MIDDLEWARE_CHUNKED

$fatpacked{"Plack/Middleware/Conditional.pm"} = <<'PLACK_MIDDLEWARE_CONDITIONAL';
  package Plack::Middleware::Conditional;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util::Accessor qw( condition middleware builder );
  
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
  
      $self->middleware( $self->builder->($self->app) );
      $self;
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $app = $self->condition->($env) ? $self->middleware : $self->app;
      return $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Conditional - Conditional wrapper for Plack middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace';
        $app;
    };
  
    # Or more raw version of it
    $app = Plack::Middleware::Conditional->wrap(
        $app,
        condition  => sub { my $env = shift; $env->{HTTP_USER_AGENT} =~ /WebKit/ },
        builder => sub { Plack::Middleware::SuperAdminConsole->wrap($_[0], @args) },
    );
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Conditional is a piece of meta-middleware, to run a
  specific middleware component under the runtime condition. The goal of
  this middleware is to avoid baking runtime configuration options in
  individual middleware components, and rather share them as another
  middleware component.
  
  =head1 EXAMPLES
  
  Note that some of the middleware component names are just made up for
  the explanation and might not exist.
  
    # Minify JavaScript if the browser is Firefox
    enable_if { $_[0]->{HTTP_USER_AGENT} =~ /Firefox/ } 'JavaScriptMinifier';
  
    # Enable Stacktrace when being accessed from the local network
    enable_if { $_[0]->{REMOTE_ADDR} =~ /^10\.0\.1\.*/ } 'StackTrace';
  
    # Work with other conditional setter middleware:
    # Transcode Jpeg on the fly for mobile clients
    builder {
        enable 'MobileDetector';
        enable_if { $_[0]->{'plack.mobile_detected'} }
          'TranscodeJpeg', max_size => 30_000;
        $app;
    };
  
  Note that in the last example I<MobileDetector> should come first
  because the conditional check runs in I<pre-run> condition, which is
  from outer to inner and that is from the top to the bottom in the
  Builder DSL code.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Steve Cook
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_MIDDLEWARE_CONDITIONAL

$fatpacked{"Plack/Middleware/ConditionalGET.pm"} = <<'PLACK_MIDDLEWARE_CONDITIONALGET';
  package Plack::Middleware::ConditionalGET;
  use strict;
  use parent qw( Plack::Middleware );
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      return $res unless $env->{REQUEST_METHOD} =~ /^(GET|HEAD)$/;
  
      $self->response_cb($res, sub {
          my $res = shift;
          return unless $res->[2]; # do not support streaming interface
  
          my $h = Plack::Util::headers($res->[1]);
          if ( $self->etag_matches($h, $env) || $self->not_modified_since($h, $env) ) {
              $res->[0] = 304;
              $h->remove($_) for qw( Content-Type Content-Length Content-Disposition );
              $res->[2] = [];
          }
      });
  }
  
  no warnings 'uninitialized';
  
  # RFC 2616 14.25 says it's OK and expected to use 'eq' :)
  # > Note: When handling an If-Modified-Since header field, some
  # > servers will use an exact date comparison function, rather than a
  # > less-than function, for deciding whether to send a 304 ...
  
  sub etag_matches {
      my($self, $h, $env) = @_;
      $h->exists('ETag') && $h->get('ETag') eq _value($env->{HTTP_IF_NONE_MATCH});
  }
  
  sub not_modified_since {
      my($self, $h, $env) = @_;
      $h->exists('Last-Modified') && $h->get('Last-Modified') eq _value($env->{HTTP_IF_MODIFIED_SINCE});
  }
  
  sub _value {
      my $str = shift;
      # IE sends wrong formatted value(i.e. "Thu, 03 Dec 2009 01:46:32 GMT; length=17936")
      $str =~ s/;.*$//;
      return $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ConditionalGET - Middleware to enable conditional GET
  
  =head1 SYNOPSIS
  
    builder {
        enable "ConditionalGET";
        ....
    };
  
  =head1 DESCRIPTION
  
  This middleware enables conditional GET and HEAD using
  C<If-None-Match> and C<If-Modified-Since> header. The application
  should set either or both of C<Last-Modified> or C<ETag> response
  headers per RFC 2616. When either of the conditions is met, the
  response body is set to be zero length and the status is set to 304
  Not Modified.
  
  =head1 SEE ALSO
  
  Rack::ConditionalGet
  
  =cut
PLACK_MIDDLEWARE_CONDITIONALGET

$fatpacked{"Plack/Middleware/ContentLength.pm"} = <<'PLACK_MIDDLEWARE_CONTENTLENGTH';
  package Plack::Middleware::ContentLength;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if (!Plack::Util::status_with_no_entity_body($res->[0]) &&
              !$h->exists('Content-Length') &&
              !$h->exists('Transfer-Encoding') &&
              defined(my $content_length = Plack::Util::content_length($res->[2]))) {
              $h->push('Content-Length' => $content_length);
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentLength - Adds Content-Length header automatically
  
  =head1 SYNOPSIS
  
    # in app.psgi
  
    builder {
        enable "Plack::Middleware::ContentLength";
        $app;
    }
  
    # Or in Plack::Handler::*
    $app = Plack::Middleware::ContentLength->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ContentLength is a middleware that automatically
  adds C<Content-Length> header when it's appropriate i.e. the response
  has a content body with calculable size (array of chunks or a real
  filehandle).
  
  This middleware can also be used as a library from PSGI server
  implementations to automatically set C<Content-Length> rather than in
  the end user level.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::ContentLength
  
  =cut
  
PLACK_MIDDLEWARE_CONTENTLENGTH

$fatpacked{"Plack/Middleware/ContentMD5.pm"} = <<'PLACK_MIDDLEWARE_CONTENTMD5';
  package Plack::Middleware::ContentMD5;
  
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Digest::MD5 qw/md5_hex/;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
      
      $self->response_cb($res, sub {
          my $res = shift;
  
          return unless defined $res->[2];
          return if (Plack::Util::status_with_no_entity_body($res->[0]));
          
          my $h = Plack::Util::headers($res->[1]);
          return if ( $h->exists('Content-MD5') );
          
          my $body = $res->[2];
          if (ref $body eq 'ARRAY') {
              $h->set('Content-MD5', md5_hex(@$body));
          }
          # Do we need support $fh?
  
          return;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentMD5 - Automatically sets the Content-MD5 header on all String bodies
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::ContentMD5";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Automatically sets the Content-MD5 header on all String bodies
  
  =head1 AUTHOR
  
  Fayland Lam
  
  =cut
PLACK_MIDDLEWARE_CONTENTMD5

$fatpacked{"Plack/Middleware/ErrorDocument.pm"} = <<'PLACK_MIDDLEWARE_ERRORDOCUMENT';
  package Plack::Middleware::ErrorDocument;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  use Plack::MIME;
  use Plack::Util;
  use Plack::Util::Accessor qw( subrequest );
  
  use HTTP::Status qw(is_error);
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $r = $self->app->($env);
  
      $self->response_cb($r, sub {
          my $r = shift;
          unless (is_error($r->[0]) && exists $self->{$r->[0]}) {
              return;
          }
  
          my $path = $self->{$r->[0]};
          if ($self->subrequest) {
              for my $key (keys %$env) {
                  unless ($key =~ /^psgi/) {
                      $env->{'psgix.errordocument.' . $key} = $env->{$key};
                  }
              }
  
              # TODO: What if SCRIPT_NAME is not empty?
              $env->{REQUEST_METHOD} = 'GET';
              $env->{REQUEST_URI}    = $path;
              $env->{PATH_INFO}      = $path;
              $env->{QUERY_STRING}   = '';
              delete $env->{CONTENT_LENGTH};
  
              my $sub_r = $self->app->($env);
              if ($sub_r->[0] == 200) {
                  $r->[1] = $sub_r->[1];
                  $r->[2] = $sub_r->[2];
              }
              # TODO: allow 302 here?
          } else {
              open my $fh, "<", $path or die "$path: $!";
              $r->[2] = $fh;
              my $h = Plack::Util::headers($r->[1]);
              $h->remove('Content-Length');
              $h->set('Content-Type', Plack::MIME->mime_type($path));
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ErrorDocument - Set Error Document based on HTTP status code
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            500 => '/uri/errors/500.html', 404 => '/uri/errors/404.html',
            subrequest => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ErrorDocument allows you to customize error screen
  by setting paths (file system path or URI path) of error pages per
  status code.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item subrequest
  
  A boolean flag to serve error pages using a new GET sub request.
  Defaults to false, which means it serves error pages using file
  system path.
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            502 => '/home/www/htdocs/errors/maint.html';
        enable "Plack::Middleware::ErrorDocument",
            404 => '/static/404.html', 403 => '/static/403.html', subrequest => 1;
        $app;
    };
  
  This configuration serves 502 error pages from file system directly
  assuming that's when you probably maintain database etc. but serves
  404 and 403 pages using a sub request so your application can do some
  logic there like logging or doing suggestions.
  
  When using a subrequest, the subrequest should return a regular '200' response.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  =cut
PLACK_MIDDLEWARE_ERRORDOCUMENT

$fatpacked{"Plack/Middleware/HTTPExceptions.pm"} = <<'PLACK_MIDDLEWARE_HTTPEXCEPTIONS';
  package Plack::Middleware::HTTPExceptions;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(rethrow);
  
  use Carp ();
  use Try::Tiny;
  use Scalar::Util 'blessed';
  use HTTP::Status ();
  
  sub prepare_app {
      my $self = shift;
      $self->rethrow(1) if ($ENV{PLACK_ENV} || '') eq 'development';
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $res = try {
          $self->app->($env);
      } catch {
          $self->transform_error($_, $env);
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if ($writer) {
                  Carp::cluck $_;
                  $writer->close;
              } else {
                  my $res = $self->transform_error($_, $env);
                  $respond->($res);
              }
          };
      };
  }
  
  sub transform_error {
      my($self, $e, $env) = @_;
  
      my($code, $message);
      if (blessed $e && $e->can('as_psgi')) {
          return $e->as_psgi;
      }
      if (blessed $e && $e->can('code')) {
          $code = $e->code;
          $message =
              $e->can('as_string')       ? $e->as_string :
              overload::Method($e, '""') ? "$e"          : undef;
      } else {
          if ($self->rethrow) {
              die $e;
          }
          else {
              $code = 500;
              $env->{'psgi.errors'}->print($e);
          }
      }
  
      if ($code !~ /^[3-5]\d\d$/) {
          die $e; # rethrow
      }
  
      $message ||= HTTP::Status::status_message($code);
  
      my @headers = (
           'Content-Type'   => 'text/plain',
           'Content-Length' => length($message),
      );
  
      if ($code =~ /^3/ && (my $loc = eval { $e->location })) {
          push(@headers, Location => $loc);
      }
  
      return [ $code, \@headers, [ $message ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::HTTPExceptions - Catch HTTP exceptions
  
  =head1 SYNOPSIS
  
    use HTTP::Exception;
  
    my $app = sub {
        # ...
        HTTP::Exception::500->throw;
    };
  
    builder {
        enable "HTTPExceptions", rethrow => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::HTTPExceptions is a PSGI middleware component to
  catch exceptions from applications that can be translated into HTTP
  status codes.
  
  Your application is supposed to throw an object that implements a
  C<code> method which returns the HTTP status code, such as 501 or
  404. This middleware catches them and creates a valid response out of
  the code. If the C<code> method returns a code that is not an HTTP
  redirect or error code (3xx, 4xx, or 5xx), the exception will be
  rethrown.
  
  The exception object may also implement C<as_string> or overload
  stringification to represent the text of the error. The text defaults to
  the status message of the error code, such as I<Service Unavailable> for
  C<503>.
  
  Finally, the exception object may implement C<as_psgi>, and the result
  of this will be returned directly as the PSGI response.
  
  If the code is in the 3xx range and the exception implements the 'location'
  method (HTTP::Exception::3xx does), the Location header will be set in the
  response, so you can do redirects this way.
  
  There are CPAN modules L<HTTP::Exception> and L<HTTP::Throwable>, and
  they are perfect to throw from your application to let this middleware
  catch and display, but you can also implement your own exception class
  to throw.
  
  If the thrown exception is not an object that implements either a
  C<code> or an C<as_psgi> method, a 500 error will be returned.
  Alternatively, you can pass a true value for the C<rethrow> parameter
  for this middleware, and the exception will instead be rethrown. This is
  enabled by default when C<PLACK_ENV> is set to C<development>, so that
  the L<StackTrace|Plack::Middleware::StackTrace> middleware can catch it
  instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  paste.httpexceptions L<HTTP::Exception> L<HTTP::Throwable>
  
  =cut
PLACK_MIDDLEWARE_HTTPEXCEPTIONS

$fatpacked{"Plack/Middleware/Head.pm"} = <<'PLACK_MIDDLEWARE_HEAD';
  package Plack::Middleware::Head;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  sub call {
      my($self, $env) = @_;
  
      return $self->app->($env)
          unless $env->{REQUEST_METHOD} eq 'HEAD';
  
      $self->response_cb($self->app->($env), sub {
          my $res = shift;
          $res->[2] = [];
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Head - auto delete response body in HEAD requests
  
  =head1 SYNOPSIS
  
    enable "Head";
  
  =head1 DESCRIPTION
  
  This middleware deletes response body in HEAD requests.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Head
  
  =cut
  
PLACK_MIDDLEWARE_HEAD

$fatpacked{"Plack/Middleware/IIS6ScriptNameFix.pm"} = <<'PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX';
  package Plack::Middleware::IIS6ScriptNameFix;
  
  use strict;
  use parent 'Plack::Middleware';
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /IIS\/[6-9]\.[0-9]/) {
          my @script_name = split(m!/!, $env->{PATH_INFO});
          my @path_translated = split(m!/|\\\\?!, $env->{PATH_TRANSLATED});
          my @path_info;
  
          while ($script_name[$#script_name] eq $path_translated[$#path_translated]) {
              pop(@path_translated);
              unshift(@path_info, pop(@script_name));
          }
  
          unshift(@path_info, '', '');
  
          $env->{PATH_INFO} = join('/', @path_info);
          $env->{SCRIPT_NAME} = join('/', @script_name);
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS6ScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that IIS6 sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS6ScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS6ScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by IIS6.
  
  =head1 AUTHORS
  
  Florian Ragwitz
  
  =cut
PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/JSONP.pm"} = <<'PLACK_MIDDLEWARE_JSONP';
  package Plack::Middleware::JSONP;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use URI::Escape ();
  
  use Plack::Util::Accessor qw/callback_key/;
  
  sub prepare_app {
      my $self = shift;
      unless (defined $self->callback_key) {
          $self->callback_key('callback');
      }
  }
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          if (defined $res->[2]) {
              my $h = Plack::Util::headers($res->[1]);
              my $callback_key = $self->callback_key;
              if ($h->get('Content-Type') =~ m!/(?:json|javascript)! &&
                  $env->{QUERY_STRING} =~ /(?:^|&)$callback_key=([^&]+)/) {
                  my $cb = URI::Escape::uri_unescape($1);
                  if ($cb =~ /^[\w\.\[\]]+$/) {
                      my $body;
                      Plack::Util::foreach($res->[2], sub { $body .= $_[0] });
                      my $jsonp = "$cb($body)";
                      $res->[2] = [ $jsonp ];
                      $h->set('Content-Length', length $jsonp);
                      $h->set('Content-Type', 'text/javascript');
                  }
              }
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::JSONP - Wraps JSON response in JSONP if callback parameter is specified
  
  =head1 SYNOPSIS
  
      enable "JSONP", callback_key => 'jsonp';
  
  =head1 DESCRIPTION
  
  Plack::Middleware::JSONP wraps JSON response, which has Content-Type
  value either C<text/javascript> or C<application/json> as a JSONP
  response which is specified with the C<callback> query parameter. The
  name of the parameter can be set while enabling the middleware.
  
  This middleware only works with a non-streaming response, and doesn't
  touch the response otherwise.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_JSONP

$fatpacked{"Plack/Middleware/LighttpdScriptNameFix.pm"} = <<'PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX';
  package Plack::Middleware::LighttpdScriptNameFix;
  use strict;
  use parent qw/Plack::Middleware/;
  use Plack::Util::Accessor qw(script_name);
  
  sub prepare_app {
      my $self = shift;
  
      my $script_name = $self->script_name;
      $script_name = '' unless defined($script_name);
      $script_name =~ s!/$!!;
      $self->script_name($script_name);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /lighttpd/) {
          $env->{PATH_INFO}   = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{SCRIPT_NAME} = $self->script_name;
          $env->{PATH_INFO}  =~ s/^\Q$env->{SCRIPT_NAME}\E//;
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LighttpdScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that lighttpd sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "LighttpdScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "LighttpdScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by
  lighttpd when you mount your app under the root path ("/"). If you use
  lighttpd 1.4.23 or later you can instead enable C<fix-root-scriptname>
  flag inside C<fastcgi.server> instead of using this middleware.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item script_name
  
  Even with C<fix-root-scriptname>, lighttpd I<still> sets weird
  C<SCRIPT_NAME> and C<PATH_INFO> if you mount your application at C<"">
  or something that ends with C</>. Setting C<script_name> option tells
  the middleware how to reconstruct the new correct C<SCRIPT_NAME> and
  C<PATH_INFO>.
  
  If you mount the app under C</something/>, you should set:
  
    enable "LighttpdScriptNameFix", script_name => "/something";
  
  and when a request for C</something/a/b?param=1> comes, C<SCRIPT_NAME>
  becomes C</something> and C<PATH_INFO> becomes C</a/b>.
  
  C<script_name> option is set to empty by default, which means all the
  request path is set to C<PATH_INFO> and it behaves like your fastcgi
  application is mounted in the root path.
  
  =back
  
  =head1 AUTHORS
  
  Yury Zavarin
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::FCGI>
  L<http://github.com/miyagawa/Plack/issues#issue/68>
  L<https://redmine.lighttpd.net/issues/729>
  
  =cut
  
PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/Lint.pm"} = <<'PLACK_MIDDLEWARE_LINT';
  package Plack::Middleware::Lint;
  use strict;
  no warnings;
  use Carp ();
  use parent qw(Plack::Middleware);
  use Scalar::Util qw(blessed);
  use Plack::Util;
  
  sub wrap {
      my($self, $app) = @_;
  
      unless (ref $app eq 'CODE' or overload::Method($app, '&{}')) {
          die("PSGI app should be a code reference: ", (defined $app ? $app : "undef"));
      }
  
      $self->SUPER::wrap($app);
  }
  
  sub call {
      my $self = shift;
      my $env = shift;
  
      $self->validate_env($env);
      my $res = $self->app->($env);
      return $self->validate_res($res);
  }
  
  sub validate_env {
      my ($self, $env) = @_;
      unless ($env->{REQUEST_METHOD}) {
          die('Missing env param: REQUEST_METHOD');
      }
      unless ($env->{REQUEST_METHOD} =~ /^[A-Z]+$/) {
          die("Invalid env param: REQUEST_METHOD($env->{REQUEST_METHOD})");
      }
      unless (defined($env->{SCRIPT_NAME})) { # allows empty string
          die('Missing mandatory env param: SCRIPT_NAME');
      }
      if ($env->{SCRIPT_NAME} eq '/') {
          die('SCRIPT_NAME must not be /');
      }
      unless (defined($env->{PATH_INFO})) { # allows empty string
          die('Missing mandatory env param: PATH_INFO');
      }
      unless (defined($env->{SERVER_NAME})) {
          die('Missing mandatory env param: SERVER_NAME');
      }
      if ($env->{SERVER_NAME} eq '') {
          die('SERVER_NAME must not be empty string');
      }
      unless (defined($env->{SERVER_PORT})) {
          die('Missing mandatory env param: SERVER_PORT');
      }
      if ($env->{SERVER_PORT} eq '') {
          die('SERVER_PORT must not be empty string');
      }
      if (defined($env->{SERVER_PROTOCOL}) and $env->{SERVER_PROTOCOL} !~ m{^HTTP/1.\d$}) {
          die("Invalid SERVER_PROTOCOL: $env->{SEREVR_PROTOCOL}");
      }
      for my $param (qw/version url_scheme input errors multithread multiprocess/) {
          unless (exists $env->{"psgi.$param"}) {
              die("Missing psgi.$param");
          }
      }
      unless (ref($env->{'psgi.version'}) eq 'ARRAY') {
          die("psgi.version should be ArrayRef: $env->{'psgi.version'}");
      }
      unless (scalar(@{$env->{'psgi.version'}}) == 2) {
          die('psgi.version should contain 2 elements, not ', scalar(@{$env->{'psgi.version'}}));
      }
      unless ($env->{'psgi.url_scheme'} =~ /^https?$/) {
          die("psgi.url_scheme should be 'http' or 'https': ", $env->{'psgi.url_scheme'});
      }
      if ($env->{"psgi.version"}->[1] == 1) { # 1.1
          for my $param (qw(streaming nonblocking run_once)) {
              unless (exists $env->{"psgi.$param"}) {
                  die("Missing psgi.$param");
              }
          }
      }
      if ($env->{HTTP_CONTENT_TYPE}) {
          die('HTTP_CONTENT_TYPE should not exist');
      }
      if ($env->{HTTP_CONTENT_LENGTH}) {
          die('HTTP_CONTENT_LENGTH should not exist');
      }
  }
  
  sub is_possibly_fh {
      my $fh = shift;
  
      ref $fh eq 'GLOB' &&
      *{$fh}{IO} &&
      *{$fh}{IO}->can('getline');
  }
  
  sub validate_res {
      my ($self, $res, $streaming) = @_;
  
      unless (ref($res) eq 'ARRAY' or ref($res) eq 'CODE') {
          die("Response should be array ref or code ref: $res");
      }
  
      if (ref $res eq 'CODE') {
          return $self->response_cb($res, sub { $self->validate_res(@_, 1) });
      }
  
      unless (@$res == 3 || ($streaming && @$res == 2)) {
          die('Response needs to be 3 element array, or 2 element in streaming');
      }
  
      unless ($res->[0] =~ /^\d+$/ && $res->[0] >= 100) {
          die("Status code needs to be an integer greater than or equal to 100: $res->[0]");
      }
  
      unless (ref $res->[1] eq 'ARRAY') {
          die("Headers needs to be an array ref: $res->[1]");
      }
  
      my @copy = @{$res->[1]};
      unless (@copy % 2 == 0) {
          die('The number of response headers needs to be even, not odd(', scalar(@copy), ')');
      }
  
      while(my($key, $val) = splice(@copy, 0, 2)) {
          if (lc $key eq 'status') {
              die('Response headers MUST NOT contain a key named Status');
          }
          if ($key =~ /[:\r\n]|[-_]$/) {
              die("Response headers MUST NOT contain a key with : or newlines, or that end in - or _: $key");
          }
          unless ($key =~ /^[a-zA-Z][0-9a-zA-Z\-_]*$/) {
              die("Response headers MUST consist only of letters, digits, _ or - and MUST start with a letter: $key");
          }
          if ($val =~ /[\000-\037]/) {
              die("Response headers MUST NOT contain characters below octal \037: $val");
          }
          if (!defined $val) {
              die("Response headers MUST be a defined string");
          }
      }
  
      # @$res == 2 is only right in psgi.streaming, and it's already checked.
      unless (@$res == 2 ||
              ref $res->[2] eq 'ARRAY' ||
              Plack::Util::is_real_fh($res->[2]) ||
              is_possibly_fh($res->[2]) ||
              (blessed($res->[2]) && $res->[2]->can('getline'))) {
          die("Body should be an array ref or filehandle: $res->[2]");
      }
  
      if (ref $res->[2] eq 'ARRAY' && grep _is_really_utf8($_), @{$res->[2]}) {
          die("Body must be bytes and should not contain wide characters (UTF-8 strings)");
      }
  
      return $res;
  }
  
  # NOTE: Some modules like HTML:: or XML:: could possibly generate
  # ASCII only strings with utf8 flags on. They're actually safe to
  # print, so there's no need to give warnings about it.
  sub _is_really_utf8 {
      my $str = shift;
      utf8::is_utf8($str) && $str =~ /[^\x00-\x7f]/;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Lint - Validate request and response
  
  =head1 SYNOPSIS
  
    use Plack::Middleware::Lint;
  
    my $app = sub { ... }; # your app or middleware
    $app = Plack::Middleware::Lint->wrap($app);
  
    # Or from plackup
    plackup -e 'enable "Lint"' myapp.psgi
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Lint is a middleware component to validate request
  and response environment formats. You are strongly suggested to use
  this middleware when you develop a new framework adapter or a new PSGI
  web server that implements the PSGI interface.
  
  This middleware is enabled by default when you run plackup or other
  launcher tools with the default environment I<development> value.
  
  =head1 DEBUGGING
  
  Because of how this middleware works, it may not be easy to debug Lint
  errors when you encounter one, unless you're writing a PSGI web server
  or a framework.
  
  For example, when you're an application developer (user of some
  framework) and see errors like:
  
    Body should be an array ref or filehandle at lib/Plack/Middleware/Lint.pm line XXXX
  
  there's no clue about which line of I<your application> produces that
  error.
  
  We're aware of the issue, and have a plan to spit out more helpful
  errors to diagnose the issue. But until then, currently there are some
  workarounds to make this easier. For now, the easiest one would be to
  enable L<Plack::Middleware::REPL> outside of the Lint middleware,
  like:
  
    plackup -e 'enable "REPL"; enable "Lint"' app.psgi
  
  so that the Lint errors are caught by the REPL shell, where you can
  inspect all the variables in the response.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_LINT

$fatpacked{"Plack/Middleware/Log4perl.pm"} = <<'PLACK_MIDDLEWARE_LOG4PERL';
  package Plack::Middleware::Log4perl;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(category logger conf);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
  
      if ($self->conf) {
          require Log::Log4perl;
          Log::Log4perl::init($self->conf);
      }
  
      $self->logger( Log::Log4perl->get_logger($self->category || '') );
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          my $level = $args->{level};
          local $Log::Log4perl::caller_depth
              = $Log::Log4perl::caller_depth + 1;
          $self->logger->$level($args->{message});
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Log4perl - Uses Log::Log4perl to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
    Log::Log4perl::init('/path/to/log4perl.conf');
  
    builder {
        enable "Log4perl", category => "plack";
        $app;
    }
  
    # in log4perl.conf
    log4perl.logger.plack = INFO, Logfile
    log4perl.appender.Logfile = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = /path/to/logfile.log
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::SimpleLayout
  
    # Or let middleware to configure log4perl
    enable "Log4perl", category => "plack", conf => '/path/to/log.conf';
  
  =head1 DESCRIPTION
  
  Log4perl is a Plack::Middleware component that allows you to use
  L<Log::Log4perl> to configure logging object.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item category
  
  The log4perl category to send logs to. Defaults to C<''> which means
  it send to the root logger.
  
  =item conf
  
  The configuration file path (or a scalar ref containing the config
  string) for Log::Log4perl to automatically configure.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOG4PERL

$fatpacked{"Plack/Middleware/LogDispatch.pm"} = <<'PLACK_MIDDLEWARE_LOGDISPATCH';
  package Plack::Middleware::LogDispatch;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(logger);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
      unless ($self->logger) {
          Carp::croak "logger is not defined";
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          $args->{level} = 'critical' if $args->{level} eq 'fatal';
          $self->logger->log(%$args);
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LogDispatch - Uses Log::Dispatch to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Dispatch;
  
    my $logger = Log::Dispatch->new;
    $logger->add( Log::Dispatch::File->new(...) );
    $logger->add( Log::Dispatch::DesktopNotification->new(...) );
  
    builder {
        enable "LogDispatch", logger => $logger;
        $app;
    }
  
    # use with Log::Dispatch::Config
    use Log::Dispatch::Config;
    Log::Dispatch::Config->configure('/path/to/log.conf');
  
    builder {
        enable "LogDispatch", logger => Log::Dispatch::Config->instance;
        ...
    }
  
  =head1 DESCRIPTION
  
  LogDispatch is a Plack::Middleware component that allows you to use
  L<Log::Dispatch> to configure logging object.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item logger
  
  Log::Dispatch object to send logs to. Required.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOGDISPATCH

$fatpacked{"Plack/Middleware/NullLogger.pm"} = <<'PLACK_MIDDLEWARE_NULLLOGGER';
  package Plack::Middleware::NullLogger;
  use strict;
  use parent qw/Plack::Middleware/;
  
  sub call {
      my($self, $env) = @_;
      $env->{'psgix.logger'} = sub { };
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::NullLogger - Send logs to /dev/null
  
  =head1 SYNOPSIS
  
    enable "NullLogger";
  
  =head1 DESCRIPTION
  
  NullLogger is a middleware component that receives logs and does
  nothing but discarding them. Might be useful to shut up all the logs
  from frameworks in one shot.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_NULLLOGGER

$fatpacked{"Plack/Middleware/RearrangeHeaders.pm"} = <<'PLACK_MIDDLEWARE_REARRANGEHEADERS';
  package Plack::Middleware::RearrangeHeaders;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use HTTP::Headers;
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = HTTP::Headers->new(@{$res->[1]});
          my @new_headers;
          $h->scan(sub { push @new_headers, @_ });
  
          $res->[1] = \@new_headers;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::RearrangeHeaders - Reorder HTTP headers for buggy clients
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [
            'Last-Modified' => 'Wed, 23 Sep 2009 13:36:33 GMT',
            'Content-Type' => 'text/plain',
            'ETag' => 'foo bar',
        ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::RearrangeHeaders";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::RearrangeHeaders sorts HTTP headers based on "Good Practice" i.e.:
  
    # "Good Practice" order of HTTP message headers:
    #    - Response-Headers
    #    - Entity-Headers
  
  to work around buggy clients like very old MSIE or broken HTTP proxy
  servers. Most clients today don't (and shouldn't) care about HTTP
  header order but if you're too pedantic or have some environments
  where you need to deal with buggy clients like above, this might be
  useful.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =cut
PLACK_MIDDLEWARE_REARRANGEHEADERS

$fatpacked{"Plack/Middleware/Recursive.pm"} = <<'PLACK_MIDDLEWARE_RECURSIVE';
  package Plack::Middleware::Recursive;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Try::Tiny;
  use Scalar::Util qw(blessed);
  
  open my $null_io, "<", \"";
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'plack.recursive.include'} = $self->recurse_callback($env, 1);
  
      my $res = try {
          $self->app->($env);
      } catch {
          if (blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
              return $self->recurse_callback($env)->($_->path);
          } else {
              die $_; # rethrow
          }
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if (!$writer && blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
                  $res = $self->recurse_callback($env)->($_->path);
                  return ref $res eq 'CODE' ? $res->($respond) : $respond->($res);
              } else {
                  die $_;
              }
          };
      };
  }
  
  sub recurse_callback {
      my($self, $env, $include) = @_;
  
      my $old_path_info = $env->{PATH_INFO};
  
      return sub {
          my $new_path_info = shift;
          my($path, $query) = split /\?/, $new_path_info, 2;
  
          Scalar::Util::weaken($env);
  
          $env->{PATH_INFO}      = $path;
          $env->{QUERY_STRING}   = $query;
          $env->{REQUEST_METHOD} = 'GET';
          $env->{CONTENT_LENGTH} = 0;
          $env->{CONTENT_TYPE}   = '';
          $env->{'psgi.input'}   = $null_io;
          push @{$env->{'plack.recursive.old_path_info'}}, $old_path_info;
  
          $include ? $self->app->($env) : $self->call($env);
      };
  }
  
  package Plack::Recursive::ForwardRequest;
  use overload q("") => \&as_string, fallback => 1;
  
  sub new {
      my($class, $path) = @_;
      bless { path => $path }, $class;
  }
  
  sub path { $_[0]->{path} }
  
  sub throw {
      my($class, @args) = @_;
      die $class->new(@args);
  }
  
  sub as_string {
      my $self = shift;
      return "Forwarding to $self->{path}: Your application should be wrapped with Plack::Middleware::Recursive.";
  }
  
  package Plack::Middleware::Recursive;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Recursive - Allows PSGI apps to include or forward requests recursively
  
  =head1 SYNOPSIS
  
    # with Builder
    enable "Recursive";
  
    # in apps
    my $res = $env->{'plack.recursive.include'}->("/new_path");
  
    # Or, use exceptions
    my $app = sub {
        # ...
        Plack::Recursive::ForwardRequest->throw("/new_path");
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Recursive allows PSGI applications to recursively
  include or forward requests to other paths. Applications can make use
  of callbacks stored in C<< $env->{'plack.recursive.include'} >> to
  I<include> another path to get the response (whether it's an array ref
  or a code ref depending on your application), or throw an exception
  Plack::Recursive::ForwardRequest anywhere in the code to I<forward>
  the current request (i.e. abort the current and redo the request).
  
  =head1 EXCEPTIONS
  
  This middleware passes through unknown exceptions to the outside
  middleware stack, so if you use this middleware with other exception
  handlers such as L<Plack::Middleware::StackTrace> or
  L<Plack::Middleware::HTTPExceptions>, be sure to wrap this so
  L<Plack::Middleware::Recursive> gets as inner as possible.
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Honma
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Middleware::HTTPExceptions>
  
  The idea, code and interface are stolen from Rack::Recursive and paste.recursive.
  
  =cut
  
  
PLACK_MIDDLEWARE_RECURSIVE

$fatpacked{"Plack/Middleware/Refresh.pm"} = <<'PLACK_MIDDLEWARE_REFRESH';
  package Plack::Middleware::Refresh;
  use strict;
  use parent qw(Plack::Middleware);
  use Module::Refresh;
  use Plack::Util::Accessor qw(last cooldown);
  
  sub prepare_app {
      my $self = shift;
      $self->cooldown(10) unless defined $self->cooldown;
  
      Module::Refresh->new;
      $self->last(time - $self->cooldown);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if (time > $self->last + $self->cooldown) {
          Module::Refresh->refresh;
          $self->last(time);
      }
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Refresh - Refresh all modules in %INC
  
  =head1 SYNOPSIS
  
    enable "Refresh", cooldown => 3;
    $app;
  
  =head1 DESCRIPTION
  
  This is I<yet another> approach to refresh modules in C<%INC> during
  the development cycle, without the need to have a forking process to
  watch for filesystem updates. This middleware, in a request time,
  compares the last refresh time and the current time and if the
  difference is bigger than I<cooldown> seconds which defaults to 10,
  call L<Module::Refresh> to reload all Perl modules in C<%INC> if the
  files have been modified.
  
  Note that this only reloads modules and not other files such as
  templates.
  
  This middleware is quite similar to what Rack::Reoader does. If you
  have issues with this reloading technique, for instance when you have
  in-file templates that needs to be recompiled, or Moose classes that
  has C<make_immutable>, take a look at L<plackup>'s default -r option
  or L<Plack::Loader::Shotgun> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Module::Refresh> Rack::Reloader
  
  =cut
  
PLACK_MIDDLEWARE_REFRESH

$fatpacked{"Plack/Middleware/Runtime.pm"} = <<'PLACK_MIDDLEWARE_RUNTIME';
  package Plack::Middleware::Runtime;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use Plack::Util::Accessor qw(header_name);
  use Time::HiRes;
  
  sub call {
      my($self, $env) = @_;
  
      my $start = [ Time::HiRes::gettimeofday ];
      my $res = $self->app->($env);
  
      $self->response_cb($res, sub {
          my $res = shift;
          my $req_time = sprintf '%.6f', Time::HiRes::tv_interval($start);
          Plack::Util::header_set($res->[1], 'X-Runtime', $req_time);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Runtime - Sets an X-Runtime response header
  
  =head1 SYNOPSIS
  
    enable "Runtime";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Runtime is a Plack middleware component that sets
  application's response time, in seconds to I<X-Runtime> HTTP response
  header.
  
  =head1 OPTIONS
  
  =over 4
  
  =item header_name
  
  Name of the header. Defaults to I<X-Runtime>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Time::HiRes> Rack::Runtime
  
  =cut
PLACK_MIDDLEWARE_RUNTIME

$fatpacked{"Plack/Middleware/SimpleContentFilter.pm"} = <<'PLACK_MIDDLEWARE_SIMPLECONTENTFILTER';
  package Plack::Middleware::SimpleContentFilter;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Plack::Util::Accessor qw( filter );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($h->get('Content-Type') =~ m!^text/!) {
              return sub {
                  my $chunk = shift;
                  return unless defined $chunk;
                  local $_ = $chunk;
                  $self->filter->();
                  return $_;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleContentFilter - Filters response content
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::SimpleContentFilter",
            filter => sub { s/Foo/Bar/g; };
        $app;
    };
  
  =head1 DESCRIPTION
  
  B<This middleware should be considered as a demo. Running this against
  your application might break your HTML unless you code the filter
  callback carefully>.
  
  Plack::Middleware::SimpleContentFilter is a simple content text filter
  to run against response body. This middleware is only enabled against
  responses with C<text/*> Content-Type.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLECONTENTFILTER

$fatpacked{"Plack/Middleware/SimpleLogger.pm"} = <<'PLACK_MIDDLEWARE_SIMPLELOGGER';
  package Plack::Middleware::SimpleLogger;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(level);
  use POSIX ();
  use Scalar::Util ();
  
  # Should this be in Plack::Util?
  my $i = 0;
  my %level_numbers = map { $_ => $i++ } qw(debug info warn error fatal);
  
  sub call {
      my($self, $env) = @_;
  
      my $min = $level_numbers{ $self->level || "debug" };
  
      my $env_ref = $env;
      Scalar::Util::weaken($env_ref);
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
  
          if ($level_numbers{$args->{level}} >= $min) {
              $env_ref->{'psgi.errors'}->print($self->format_message($args->{level}, $args->{message}));
          }
      };
  
      $self->app->($env);
  }
  
  sub format_time {
      my $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
      POSIX::setlocale(&POSIX::LC_ALL, 'en');
      my $out = POSIX::strftime(@_);
      POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
      return $out;
  }
  
  sub format_message {
      my($self, $level, $message) = @_;
  
      my $time = format_time("%Y-%m-%dT%H:%M:%S", localtime);
      sprintf "%s [%s #%d] %s: %s\n", uc substr($level, 0, 1), $time, $$, uc $level, $message;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleLogger - Simple logger that prints to psgi.errors
  
  =head1 SYNOPSIS
  
    enable "SimpleLogger", level => "warn";
  
  =head1 DESCRIPTION
  
  SimpleLogger is a middleware component that formats the log message
  with information such as the time and PID and prints them to
  I<psgi.errors> stream, which is mostly STDERR or server log output.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLELOGGER

$fatpacked{"Plack/Middleware/StackTrace.pm"} = <<'PLACK_MIDDLEWARE_STACKTRACE';
  package Plack::Middleware::StackTrace;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Devel::StackTrace;
  use Devel::StackTrace::AsHTML;
  use Try::Tiny;
  use Plack::Util::Accessor qw( force no_print_errors );
  
  our $StackTraceClass = "Devel::StackTrace";
  
  # Optional since it needs PadWalker
  if (try { require Devel::StackTrace::WithLexicals; Devel::StackTrace::WithLexicals->VERSION(0.08); 1 }) {
      $StackTraceClass = "Devel::StackTrace::WithLexicals";
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $trace;
      local $SIG{__DIE__} = sub {
          $trace = $StackTraceClass->new(
              indent => 1, message => munge_error($_[0], [ caller ]),
              ignore_package => __PACKAGE__,
          );
          die @_;
      };
  
      my $caught;
      my $res = try {
          $self->app->($env);
      } catch {
          $caught = $_;
          [ 500, [ "Content-Type", "text/plain; charset=utf-8" ], [ no_trace_error(utf8_safe($caught)) ] ];
      };
  
      if ($trace && ($caught || ($self->force && ref $res eq 'ARRAY' && $res->[0] == 500)) ) {
          my $text = $trace->as_string;
          my $html = $trace->as_html;
          $env->{'plack.stacktrace.text'} = $text;
          $env->{'plack.stacktrace.html'} = $html;
          $env->{'psgi.errors'}->print($text) unless $self->no_print_errors;
          if (($env->{HTTP_ACCEPT} || '*/*') =~ /html/) {
              $res = [500, ['Content-Type' => 'text/html; charset=utf-8'], [ utf8_safe($html) ]];
          } else {
              $res = [500, ['Content-Type' => 'text/plain; charset=utf-8'], [ utf8_safe($text) ]];
          }
      }
  
      # break $trace here since $SIG{__DIE__} holds the ref to it, and
      # $trace has refs to Standalone.pm's args ($conn etc.) and
      # prevents garbage collection to be happening.
      undef $trace;
  
      return $res;
  }
  
  sub no_trace_error {
      my $msg = shift;
      chomp($msg);
  
      return <<EOF;
  The application raised the following error:
  
    $msg
  
  and the StackTrace middleware couldn't catch its stack trace, possibly because your application overrides \$SIG{__DIE__} by itself, preventing the middleware from working correctly. Remove the offending code or module that does it: known examples are CGI::Carp and Carp::Always.
  EOF
  }
  
  sub munge_error {
      my($err, $caller) = @_;
      return $err if ref $err;
  
      # Ugly hack to remove " at ... line ..." automatically appended by perl
      # If there's a proper way to do this, please let me know.
      $err =~ s/ at \Q$caller->[1]\E line $caller->[2]\.\n$//;
  
      return $err;
  }
  
  sub utf8_safe {
      my $str = shift;
  
      # NOTE: I know messing with utf8:: in the code is WRONG, but
      # because we're running someone else's code that we can't
      # guarnatee which encoding an exception is encoded, there's no
      # better way than doing this. The latest Devel::StackTrace::AsHTML
      # (0.08 or later) encodes high-bit chars as HTML entities, so this
      # path won't be executed.
      if (utf8::is_utf8($str)) {
          utf8::encode($str);
      }
  
      $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::StackTrace - Displays stack trace when your app dies
  
  =head1 SYNOPSIS
  
    enable "StackTrace";
  
  =head1 DESCRIPTION
  
  This middleware catches exceptions (run-time errors) happening in your
  application and displays nice stack trace screen. The stack trace is
  also stored in the environment as a plaintext and HTML under the key
  C<plack.stacktrace.text> and C<plack.stacktrace.html> respectively, so
  that middleware futher up the stack can reference it.
  
  This middleware is enabled by default when you run L<plackup> in the
  default I<development> mode.
  
  You're recommended to use this middleware during the development and
  use L<Plack::Middleware::HTTPExceptions> in the deployment mode as a
  replacement, so that all the exceptions thrown from your application
  still get caught and rendered as a 500 error response, rather than
  crashing the web server.
  
  Catching errors in streaming response is not supported.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item force
  
    enable "StackTrace", force => 1;
  
  Force display the stack trace when an error occurs within your
  application and the response code from your application is
  500. Defaults to off.
  
  The use case of this option is that when your framework catches all
  the exceptions in the main handler and returns all failures in your
  code as a normal 500 PSGI error response. In such cases, this
  middleware would never have a chance to display errors because it
  can't tell if it's an application error or just random C<eval> in your
  code. This option enforces the middleware to display stack trace even
  if it's not the direct error thrown by the application.
  
  =item no_print_errors
  
    enable "StackTrace", no_print_errors => 1;
  
  Skips printing the text stacktrace to console
  (C<psgi.errors>). Defaults to 0, which means the text version of the
  stack trace error is printed to the errors handle, which usually is a
  standard error.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace::AsHTML> L<Plack::Middleware> L<Plack::Middleware::HTTPExceptions>
  
  =cut
  
PLACK_MIDDLEWARE_STACKTRACE

$fatpacked{"Plack/Middleware/Static.pm"} = <<'PLACK_MIDDLEWARE_STATIC';
  package Plack::Middleware::Static;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Plack::App::File;
  
  use Plack::Util::Accessor qw( path root encoding pass_through );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->_handle_static($env);
      if ($res && not ($self->pass_through and $res->[0] == 404)) {
          return $res;
      }
  
      return $self->app->($env);
  }
  
  sub _handle_static {
      my($self, $env) = @_;
  
      my $path_match = $self->path or return;
      my $path = $env->{PATH_INFO};
  
      for ($path) {
          my $matched = 'CODE' eq ref $path_match ? $path_match->($_) : $_ =~ $path_match;
          return unless $matched;
      }
  
      $self->{file} ||= Plack::App::File->new({ root => $self->root || '.', encoding => $self->encoding });
      local $env->{PATH_INFO} = $path; # rewrite PATH
      return $self->{file}->call($env);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Static - serve static files with Plack
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::Static",
            path => qr{^/(images|js|css)/}, root => './htdocs/';
        $app;
    };
  
  =head1 DESCRIPTION
  
  Enable this middleware to allow your Plack-based application to serve
  static files.
  
  If the given request matches with the pattern defined in C<path>, this
  middleware will try to locate the file in C<root>. If the file exists
  it will be served but otherwise C<404> response will be returned. See
  C<pass_through> option below to change this behavior.
  
  If the requested document is not within the C<root> (i.e. directory
  traversal) or the file is there but not readable, a 403 Forbidden
  response will be returned.
  
  The content type returned will be determined from the file extension
  based on L<Plack::MIME>.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item path, root
  
    enable "Plack::Middleware::Static",
        path => qr{^/static/}, root => 'htdocs/';
  
  C<path> specifies the URL pattern (regular expression) or a callback
  to match with requests to serve static files for. C<root> specifies
  the root directory to serve those static files from. The default value
  of C<root> is the current directory.
  
  This examples configuration serves C</static/foo.jpg> from
  C<htdocs/static/foo.jpg>. Note that the matched C</static/> portion is
  still appears in the local mapped path. If you don't like it, use a
  callback instead to munge C<$_>:
  
    enable "Plack::Middleware::Static",
        path => sub { s!^/static/!! }, root => 'static-files/';
  
  This configuration would serve C</static/foo.png> from
  C<static-files/foo.png> (not C<static-files/static/foo.png>). The
  callback specified in C<path> option matches against C<$_> and then
  updates the value since it does s///, and returns the number of
  matches, so it will pass through when C</static/> doesn't match.
  
  If you want to map multiple static directories from different root,
  simply add "this", middleware multiple times with different
  configuration options.
  
  =item pass_through
  
  By turning on this option, this middleware will pass the request
  back to the application for further processing, if the incoming
  request path matches with the C<path> but the requested file is not
  found on the file system.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno, Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::Builder>
  
  =cut
  
  
PLACK_MIDDLEWARE_STATIC

$fatpacked{"Plack/Middleware/Writer.pm"} = <<'PLACK_MIDDLEWARE_WRITER';
  package Plack::Middleware::Writer;
  use strict;
  use parent qw(Plack::Middleware::BufferedStreaming);
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Writer - DEPRECATED
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::BufferedStreaming>
  
  =cut
PLACK_MIDDLEWARE_WRITER

$fatpacked{"Plack/Middleware/XFramework.pm"} = <<'PLACK_MIDDLEWARE_XFRAMEWORK';
  package Plack::Middleware::XFramework;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  
  use Plack::Util;
  use Plack::Util::Accessor qw( framework );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->( @_ );
      $self->response_cb($res, sub {
          my $res = shift;
          if ($self->framework) {
              Plack::Util::header_set $res->[1], 'X-Framework' => $self->framework;
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XFramework - Sample middleware to add X-Framework
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XFramework", framework => "Catalyst";
  
  =head1 DESCRIPTION
  
  This middleware adds C<X-Framework> header to the HTTP response.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item framework
  
  Sets the string value of C<X-Framework> header. If not set, the header is not set to the response.
  
  =back
  
  =head1 SEE ALSO
  
  L<Plack::Middleware>
  
  =cut
  
PLACK_MIDDLEWARE_XFRAMEWORK

$fatpacked{"Plack/Middleware/XSendfile.pm"} = <<'PLACK_MIDDLEWARE_XSENDFILE';
  package Plack::Middleware::XSendfile;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  use Scalar::Util;
  use Plack::Util::Accessor qw( variation );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my($status, $headers, $body) = @$res;
          return unless defined $body;
  
          if (Scalar::Util::blessed($body) && $body->can('path')) {
              my $type = $self->_variation($env) || '';
              my $h = Plack::Util::headers($headers);
              if ($type && !$h->exists($type)) {
                  if ($type eq 'X-Accel-Redirect') {
                      my $path = $body->path;
                      my $url = $self->map_accel_path($env, $path);
                      $h->set($type => $url) if $url;
                      $body = [];
                  } elsif ($type eq 'X-Sendfile' or $type eq 'X-Lighttpd-Send-File') {
                      my $path = $body->path;
                      $h->set($type => $path) if defined $path;
                      $body = [];
                  } else {
                      $env->{'psgi.errors'}->print("Unknown x-sendfile variation: $type");
                  }
              }
          }
  
          @$res = ( $status, $headers, $body );
      });
  }
  
  sub map_accel_path {
      my($self, $env, $path) = @_;
  
      if (my $mapping = $env->{HTTP_X_ACCEL_MAPPING}) {
          my($internal, $external) = split /=/, $mapping, 2;
          $path =~ s!^\Q$internal\E!$external!i;
      }
  
      return $path;
  }
  
  sub _variation {
      my($self, $env) = @_;
      $self->variation || $env->{'plack.xsendfile.type'} || $env->{HTTP_X_SENDFILE_TYPE};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XSendfile - Sets X-Sendfile (or a like) header for frontends
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XSendfile";
  
  =head1 DESCRIPTION
  
  You should use L<IO::File::WithPath> or L<Plack::Util>'s
  C<set_io_path> to add C<path> method to an IO object in the body.
  
  See L<http://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/sendfile.rb>
  for the frontend configuration.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_XSENDFILE

$fatpacked{"Plack/Request.pm"} = <<'PLACK_REQUEST';
  package Plack::Request;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  use HTTP::Headers;
  use Carp ();
  use Hash::MultiValue;
  use HTTP::Body;
  
  use Plack::Request::Upload;
  use Plack::TempBuffer;
  use URI;
  use URI::Escape ();
  
  sub _deprecated {
      my $alt = shift;
      my $method = (caller(1))[3];
      Carp::carp("$method is deprecated. Use '$alt' instead.");
  }
  
  sub new {
      my($class, $env) = @_;
      Carp::croak(q{$env is required})
          unless defined $env && ref($env) eq 'HASH';
  
      bless { env => $env }, $class;
  }
  
  sub env { $_[0]->{env} }
  
  sub address     { $_[0]->env->{REMOTE_ADDR} }
  sub remote_host { $_[0]->env->{REMOTE_HOST} }
  sub protocol    { $_[0]->env->{SERVER_PROTOCOL} }
  sub method      { $_[0]->env->{REQUEST_METHOD} }
  sub port        { $_[0]->env->{SERVER_PORT} }
  sub user        { $_[0]->env->{REMOTE_USER} }
  sub request_uri { $_[0]->env->{REQUEST_URI} }
  sub path_info   { $_[0]->env->{PATH_INFO} }
  sub path        { $_[0]->env->{PATH_INFO} || '/' }
  sub script_name { $_[0]->env->{SCRIPT_NAME} }
  sub scheme      { $_[0]->env->{'psgi.url_scheme'} }
  sub secure      { $_[0]->scheme eq 'https' }
  sub body        { $_[0]->env->{'psgi.input'} }
  sub input       { $_[0]->env->{'psgi.input'} }
  
  sub content_length   { $_[0]->env->{CONTENT_LENGTH} }
  sub content_type     { $_[0]->env->{CONTENT_TYPE} }
  
  sub session         { $_[0]->env->{'psgix.session'} }
  sub session_options { $_[0]->env->{'psgix.session.options'} }
  sub logger          { $_[0]->env->{'psgix.logger'} }
  
  sub cookies {
      my $self = shift;
  
      return {} unless $self->env->{HTTP_COOKIE};
  
      # HTTP_COOKIE hasn't changed: reuse the parsed cookie
      if (   $self->env->{'plack.cookie.parsed'}
          && $self->env->{'plack.cookie.string'} eq $self->env->{HTTP_COOKIE}) {
          return $self->env->{'plack.cookie.parsed'};
      }
  
      $self->env->{'plack.cookie.string'} = $self->env->{HTTP_COOKIE};
  
      my %results;
      my @pairs = grep /=/, split "[;,] ?", $self->env->{'plack.cookie.string'};
      for my $pair ( @pairs ) {
          # trim leading trailing whitespace
          $pair =~ s/^\s+//; $pair =~ s/\s+$//;
  
          my ($key, $value) = map URI::Escape::uri_unescape($_), split( "=", $pair, 2 );
  
          # Take the first one like CGI.pm or rack do
          $results{$key} = $value unless exists $results{$key};
      }
  
      $self->env->{'plack.cookie.parsed'} = \%results;
  }
  
  sub query_parameters {
      my $self = shift;
      $self->env->{'plack.request.query'} ||= Hash::MultiValue->new($self->uri->query_form);
  }
  
  sub content {
      my $self = shift;
  
      unless ($self->env->{'psgix.input.buffered'}) {
          $self->_parse_request_body;
      }
  
      my $fh = $self->input                 or return '';
      my $cl = $self->env->{CONTENT_LENGTH} or return'';
      $fh->read(my($content), $cl, 0);
      $fh->seek(0, 0);
  
      return $content;
  }
  
  sub raw_body { $_[0]->content }
  
  # XXX you can mutate headers with ->headers but it's not written through to the env
  
  sub headers {
      my $self = shift;
      if (!defined $self->{headers}) {
          my $env = $self->env;
          $self->{headers} = HTTP::Headers->new(
              map {
                  (my $field = $_) =~ s/^HTTPS?_//;
                  ( $field => $env->{$_} );
              }
                  grep { /^(?:HTTP|CONTENT|COOKIE)/i } keys %$env
              );
      }
      $self->{headers};
  }
  
  sub content_encoding { shift->headers->content_encoding(@_) }
  sub header           { shift->headers->header(@_) }
  sub referer          { shift->headers->referer(@_) }
  sub user_agent       { shift->headers->user_agent(@_) }
  
  sub body_parameters {
      my $self = shift;
  
      unless ($self->env->{'plack.request.body'}) {
          $self->_parse_request_body;
      }
  
      return $self->env->{'plack.request.body'};
  }
  
  # contains body + query
  sub parameters {
      my $self = shift;
  
      $self->env->{'plack.request.merged'} ||= do {
          my $query = $self->query_parameters;
          my $body  = $self->body_parameters;
          Hash::MultiValue->new($query->flatten, $body->flatten);
      };
  }
  
  sub uploads {
      my $self = shift;
  
      if ($self->env->{'plack.request.upload'}) {
          return $self->env->{'plack.request.upload'};
      }
  
      $self->_parse_request_body;
      return $self->env->{'plack.request.upload'};
  }
  
  sub hostname     { _deprecated 'remote_host';      $_[0]->remote_host || $_[0]->address }
  sub url_scheme   { _deprecated 'scheme';           $_[0]->scheme }
  sub params       { _deprecated 'parameters';       shift->parameters(@_) }
  sub query_params { _deprecated 'query_parameters'; shift->query_parameters(@_) }
  sub body_params  { _deprecated 'body_parameters';  shift->body_parameters(@_) }
  
  sub cookie {
      my $self = shift;
      _deprecated 'cookies';
  
      return keys %{ $self->cookies } if @_ == 0;
  
      my $name = shift;
      return $self->cookies->{$name};
  }
  
  sub param {
      my $self = shift;
  
      return keys %{ $self->parameters } if @_ == 0;
  
      my $key = shift;
      return $self->parameters->{$key} unless wantarray;
      return $self->parameters->get_all($key);
  }
  
  sub upload {
      my $self = shift;
  
      return keys %{ $self->uploads } if @_ == 0;
  
      my $key = shift;
      return $self->uploads->{$key} unless wantarray;
      return $self->uploads->get_all($key);
  }
  
  sub raw_uri {
      my $self = shift;
      _deprecated 'base';
  
      my $base = $self->base;
      $base->path_query($self->env->{REQUEST_URI});
  
      $base;
  }
  
  sub uri {
      my $self = shift;
  
      my $base = $self->_uri_base;
  
      # We have to escape back PATH_INFO in case they include stuff like
      # ? or # so that the URI parser won't be tricked. However we should
      # preserve '/' since encoding them into %2f doesn't make sense.
      # This means when a request like /foo%2fbar comes in, we recognize
      # it as /foo/bar which is not ideal, but that's how the PSGI PATH_INFO
      # spec goes and we can't do anything about it. See PSGI::FAQ for details.
      # http://github.com/miyagawa/Plack/issues#issue/118
      my $path_escape_class = '^A-Za-z0-9\-\._~/';
  
      my $path = URI::Escape::uri_escape($self->env->{PATH_INFO} || '', $path_escape_class);
      $path .= '?' . $self->env->{QUERY_STRING}
          if defined $self->env->{QUERY_STRING} && $self->env->{QUERY_STRING} ne '';
  
      $base =~ s!/$!! if $path =~ m!^/!;
  
      return URI->new($base . $path)->canonical;
  }
  
  sub base {
      my $self = shift;
      URI->new($self->_uri_base)->canonical;
  }
  
  sub _uri_base {
      my $self = shift;
  
      my $env = $self->env;
  
      my $uri = ($env->{'psgi.url_scheme'} || "http") .
          "://" .
          ($env->{HTTP_HOST} || (($env->{SERVER_NAME} || "") . ":" . ($env->{SERVER_PORT} || 80))) .
          ($env->{SCRIPT_NAME} || '/');
  
      return $uri;
  }
  
  sub new_response {
      my $self = shift;
      require Plack::Response;
      Plack::Response->new(@_);
  }
  
  sub _parse_request_body {
      my $self = shift;
  
      my $ct = $self->env->{CONTENT_TYPE};
      my $cl = $self->env->{CONTENT_LENGTH};
      if (!$ct && !$cl) {
          # No Content-Type nor Content-Length -> GET/HEAD
          $self->env->{'plack.request.body'}   = Hash::MultiValue->new;
          $self->env->{'plack.request.upload'} = Hash::MultiValue->new;
          return;
      }
  
      my $body = HTTP::Body->new($ct, $cl);
  
      # HTTP::Body will create temporary files in case there was an
      # upload.  Those temporary files can be cleaned up by telling
      # HTTP::Body to do so. It will run the cleanup when the request
      # env is destroyed. That the object will not go out of scope by
      # the end of this sub we will store a reference here.
      $self->env->{'plack.request.http.body'} = $body;
      $body->cleanup(1);
  
      my $input = $self->input;
  
      my $buffer;
      if ($self->env->{'psgix.input.buffered'}) {
          # Just in case if input is read by middleware/apps beforehand
          $input->seek(0, 0);
      } else {
          $buffer = Plack::TempBuffer->new($cl);
      }
  
      my $spin = 0;
      while ($cl) {
          $input->read(my $chunk, $cl < 8192 ? $cl : 8192);
          my $read = length $chunk;
          $cl -= $read;
          $body->add($chunk);
          $buffer->print($chunk) if $buffer;
  
          if ($read == 0 && $spin++ > 2000) {
              Carp::croak "Bad Content-Length: maybe client disconnect? ($cl bytes remaining)";
          }
      }
  
      if ($buffer) {
          $self->env->{'psgix.input.buffered'} = 1;
          $self->env->{'psgi.input'} = $buffer->rewind;
      } else {
          $input->seek(0, 0);
      }
  
      $self->env->{'plack.request.body'}   = Hash::MultiValue->from_mixed($body->param);
  
      my @uploads = Hash::MultiValue->from_mixed($body->upload)->flatten;
      my @obj;
      while (my($k, $v) = splice @uploads, 0, 2) {
          push @obj, $k, $self->_make_upload($v);
      }
  
      $self->env->{'plack.request.upload'} = Hash::MultiValue->new(@obj);
  
      1;
  }
  
  sub _make_upload {
      my($self, $upload) = @_;
      my %copy = %$upload;
      $copy{headers} = HTTP::Headers->new(%{$upload->{headers}});
      Plack::Request::Upload->new(%copy);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request - Portable HTTP request object from PSGI env hash
  
  =head1 SYNOPSIS
  
    use Plack::Request;
  
    my $app_or_middleware = sub {
        my $env = shift; # PSGI env
  
        my $req = Plack::Request->new($env);
  
        my $path_info = $req->path_info;
        my $query     = $req->param('query');
  
        my $res = $req->new_response(200); # new Plack::Response
        $res->finalize;
    };
  
  =head1 DESCRIPTION
  
  L<Plack::Request> provides a consistent API for request objects across
  web server environments.
  
  =head1 CAVEAT
  
  Note that this module is intended to be used by Plack middleware
  developers and web application framework developers rather than
  application developers (end users).
  
  Writing your web application directly using Plack::Request is
  certainly possible but not recommended: it's like doing so with
  mod_perl's Apache::Request: yet too low level.
  
  If you're writing a web application, not a framework, then you're
  encouraged to use one of the web application frameworks that support PSGI (L<http://plackperl.org/#frameworks>),
  or see modules like L<HTTP::Engine> to provide higher level
  Request and Response API on top of PSGI.
  
  =head1 METHODS
  
  Some of the methods defined in the earlier versions are deprecated in
  version 0.99. Take a look at L</"INCOMPATIBILITIES">.
  
  Unless otherwise noted, all methods and attributes are B<read-only>,
  and passing values to the method like an accessor doesn't work like
  you expect it to.
  
  =head2 new
  
      Plack::Request->new( $env );
  
  Creates a new request object.
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item env
  
  Returns the shared PSGI environment hash reference. This is a
  reference, so writing to this environment passes through during the
  whole PSGI request/response cycle.
  
  =item address
  
  Returns the IP address of the client (C<REMOTE_ADDR>).
  
  =item remote_host
  
  Returns the remote host (C<REMOTE_HOST>) of the client. It may be
  empty, in which case you have to get the IP address using C<address>
  method and resolve on your own.
  
  =item method
  
  Contains the request method (C<GET>, C<POST>, C<HEAD>, etc).
  
  =item protocol
  
  Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.
  
  =item request_uri
  
  Returns the raw, undecoded request URI path. You probably do B<NOT>
  want to use this to dispatch requests.
  
  =item path_info
  
  Returns B<PATH_INFO> in the environment. Use this to get the local
  path for the requests.
  
  =item path
  
  Similar to C<path_info> but returns C</> in case it is empty. In other
  words, it returns the virtual path of the request URI after C<<
  $req->base >>. See L</"DISPATCHING"> for details.
  
  =item script_name
  
  Returns B<SCRIPT_NAME> in the environment. This is the absolute path
  where your application is hosted.
  
  =item scheme
  
  Returns the scheme (C<http> or C<https>) of the request.
  
  =item secure
  
  Returns true or false, indicating whether the connection is secure (https).
  
  =item body, input
  
  Returns C<psgi.input> handle.
  
  =item session
  
  Returns (optional) C<psgix.session> hash. When it exists, you can
  retrieve and store per-session data from and to this hash.
  
  =item session_options
  
  Returns (optional) C<psgix.session.options> hash.
  
  =item logger
  
  Returns (optional) C<psgix.logger> code reference. When it exists,
  your application is supposed to send the log message to this logger,
  using:
  
    $req->logger->({ level => 'debug', message => "This is a debug message" });
  
  =item cookies
  
  Returns a reference to a hash containing the cookies. Values are
  strings that are sent by clients and are URI decoded.
  
  =item query_parameters
  
  Returns a reference to a hash containing query string (GET)
  parameters. This hash reference is L<Hash::MultiValue> object.
  
  =item body_parameters
  
  Returns a reference to a hash containing posted parameters in the
  request body (POST). As with C<query_parameters>, the hash
  reference is a L<Hash::MultiValue> object.
  
  =item parameters
  
  Returns a L<Hash::MultiValue> hash reference containing (merged) GET
  and POST parameters.
  
  =item content, raw_body
  
  Returns the request content in an undecoded byte string for POST requests.
  
  =item uri
  
  Returns an URI object for the current request. The URI is constructed
  using various environment values such as C<SCRIPT_NAME>, C<PATH_INFO>,
  C<QUERY_STRING>, C<HTTP_HOST>, C<SERVER_NAME> and C<SERVER_PORT>.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item base
  
  Returns an URI object for the base path of current request. This is
  like C<uri> but only contains up to C<SCRIPT_NAME> where your
  application is hosted at.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item user
  
  Returns C<REMOTE_USER> if it's set.
  
  =item headers
  
  Returns an L<HTTP::Headers> object containing the headers for the current request.
  
  =item uploads
  
  Returns a reference to a hash containing uploads. The hash reference
  is a L<Hash::MultiValue> object and values are L<Plack::Request::Upload>
  objects.
  
  =item content_encoding
  
  Shortcut to $req->headers->content_encoding.
  
  =item content_length
  
  Shortcut to $req->headers->content_length.
  
  =item content_type
  
  Shortcut to $req->headers->content_type.
  
  =item header
  
  Shortcut to $req->headers->header.
  
  =item referer
  
  Shortcut to $req->headers->referer.
  
  =item user_agent
  
  Shortcut to $req->headers->user_agent.
  
  =item param
  
  Returns GET and POST parameters with a CGI.pm-compatible param
  method. This is an alternative method for accessing parameters in
  $req->parameters. Unlike CGI.pm, it does I<not> allow
  setting or modifying query parameters.
  
      $value  = $req->param( 'foo' );
      @values = $req->param( 'foo' );
      @params = $req->param;
  
  =item upload
  
  A convenient method to access $req->uploads.
  
      $upload  = $req->upload('field');
      @uploads = $req->upload('field');
      @fields  = $req->upload;
  
      for my $upload ( $req->upload('field') ) {
          print $upload->filename;
      }
  
  =item new_response
  
    my $res = $req->new_response;
  
  Creates a new L<Plack::Response> object. Handy to remove dependency on
  L<Plack::Response> in your code for easy subclassing and duck typing
  in web application frameworks, as well as overriding Response
  generation in middlewares.
  
  =back
  
  =head2 Hash::MultiValue parameters
  
  Parameters that can take one or multiple values (i.e. C<parameters>,
  C<query_parameters>, C<body_parameters> and C<uploads>) store the
  hash reference as a L<Hash::MultiValue> object. This means you can use
  the hash reference as a plain hash where values are B<always> scalars
  (B<NOT> array references), so you don't need to code ugly and unsafe
  C<< ref ... eq 'ARRAY' >> anymore.
  
  And if you explicitly want to get multiple values of the same key, you
  can call the C<get_all> method on it, such as:
  
    my @foo = $req->query_parameters->get_all('foo');
  
  You can also call C<get_one> to always get one parameter independent
  of the context (unlike C<param>), and even call C<mixed> (with
  Hash::MultiValue 0.05 or later) to get the I<traditional> hash
  reference,
  
    my $params = $req->parameters->mixed;
  
  where values are either a scalar or an array reference depending on
  input, so it might be useful if you already have the code to deal with
  that ugliness.
  
  =head2 PARSING POST BODY and MULTIPLE OBJECTS
  
  The methods to parse request body (C<content>, C<body_parameters> and
  C<uploads>) are carefully coded to save the parsed body in the
  environment hash as well as in the temporary buffer, so you can call
  them multiple times and create Plack::Request objects multiple times
  in a request and they should work safely, and won't parse request body
  more than twice for the efficiency.
  
  =head1 DISPATCHING
  
  If your application or framework wants to dispatch (or route) actions
  based on request paths, be sure to use C<< $req->path_info >> not C<<
  $req->uri->path >>.
  
  This is because C<path_info> gives you the virtual path of the request,
  regardless of how your application is mounted. If your application is
  hosted with mod_perl or CGI scripts, or even multiplexed with tools
  like L<Plack::App::URLMap>, request's C<path_info> always gives you
  the action path.
  
  Note that C<path_info> might give you an empty string, in which case
  you should assume that the path is C</>.
  
  You will also want to use C<< $req->base >> as a base prefix when
  building URLs in your templates or in redirections. It's a good idea
  for you to subclass Plack::Request and define methods such as:
  
    sub uri_for {
        my($self, $path, $args) = @_;
        my $uri = $self->base;
        $uri->path($uri->path . $path);
        $uri->query_form(@$args) if $args;
        $uri;
    }
  
  So you can say:
  
    my $link = $req->uri_for('/logout', [ signoff => 1 ]);
  
  and if C<< $req->base >> is C</app> you'll get the full URI for
  C</app/logout?signoff=1>.
  
  =head1 INCOMPATIBILITIES
  
  In version 0.99, many utility methods are removed or deprecated, and
  most methods are made read-only.
  
  The following methods are deprecated: C<hostname>, C<url_scheme>,
  C<params>, C<query_params>, C<body_params>, C<cookie> and
  C<raw_uri>. They will be removed in the next major release.
  
  All parameter-related methods such as C<parameters>,
  C<body_parameters>, C<query_parameters> and C<uploads> now contains
  L<Hash::MultiValue> objects, rather than I<scalar or an array
  reference depending on the user input> which is insecure. See
  L<Hash::MultiValue> for more about this change.
  
  C<< $req->path >> method had a bug, where the code and the document
  was mismatching. The document was suggesting it returns the sub
  request path after C<< $req->base >> but the code was always returning
  the absolute URI path. The code is now updated to be an alias of C<<
  $req->path_info >> but returns C</> in case it's empty. If you need
  the older behavior, just call C<< $req->uri->path >> instead.
  
  Cookie handling is simplified, and doesn't use L<CGI::Simple::Cookie>
  anymore, which means you B<CAN NOT> set array reference or hash
  reference as a cookie value and expect it be serialized. You're always
  required to set string value, and encoding or decoding them is totally
  up to your application or framework. Also, C<cookies> hash reference
  now returns I<strings> for the cookies rather than CGI::Simple::Cookie
  objects, which means you no longer have to write a wacky code such as:
  
    $v = $req->cookie->{foo} ? $req->cookie->{foo}->value : undef;
  
  and instead, simply do:
  
    $v = $req->cookie->{foo};
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Kazuhiro Osawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Response> L<HTTP::Request>, L<Catalyst::Request>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_REQUEST

$fatpacked{"Plack/Request/Upload.pm"} = <<'PLACK_REQUEST_UPLOAD';
  package Plack::Request::Upload;
  use strict;
  use warnings;
  use Carp ();
  
  sub new {
      my($class, %args) = @_;
  
      bless {
          headers  => $args{headers},
          tempname => $args{tempname},
          size     => $args{size},
          filename => $args{filename},
      }, $class;
  }
  
  sub filename { $_[0]->{filename} }
  sub headers  { $_[0]->{headers} }
  sub size     { $_[0]->{size} }
  sub tempname { $_[0]->{tempname} }
  sub path     { $_[0]->{tempname} }
  
  sub content_type {
      my $self = shift;
      $self->{headers}->content_type(@_);
  }
  
  sub type { shift->content_type(@_) }
  
  sub basename {
      my $self = shift;
      unless (defined $self->{basename}) {
          require File::Spec::Unix;
          my $basename = $self->{filename};
          $basename =~ s|\\|/|g;
          $basename = ( File::Spec::Unix->splitpath($basename) )[2];
          $basename =~ s|[^\w\.-]+|_|g;
          $self->{basename} = $basename;
      }
      $self->{basename};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request::Upload - handles file upload requests
  
  =head1 SYNOPSIS
  
    # $req is Plack::Request
    my $upload = $req->uploads->{field};
  
    $upload->size;
    $upload->path;
    $upload->content_type;
    $upload->basename;
  
  =head1 METHODS
  
  =over 4
  
  =item size
  
  Returns the size of Uploaded file.
  
  =item path
  
  Returns the path to the temporary file where uploaded file is saved.
  
  =item content_type
  
  Returns the content type of the uploaded file.
  
  =item filename
  
  Returns the original filename in the client.
  
  =item basename
  
  Returns basename for "filename".
  
  =back
  
  =head1 AUTHORS
  
  Kazuhiro Osawa
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>, L<Catalyst::Request::Upload>
  
  =cut
PLACK_REQUEST_UPLOAD

$fatpacked{"Plack/Response.pm"} = <<'PLACK_RESPONSE';
  package Plack::Response;
  use strict;
  use warnings;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  use Plack::Util::Accessor qw(body status);
  use Carp ();
  use Scalar::Util ();
  use HTTP::Headers;
  use URI::Escape ();
  
  sub code    { shift->status(@_) }
  sub content { shift->body(@_)   }
  
  sub new {
      my($class, $rc, $headers, $content) = @_;
  
      my $self = bless {}, $class;
      $self->status($rc)       if defined $rc;
      $self->headers($headers) if defined $headers;
      $self->body($content)    if defined $content;
  
      $self;
  }
  
  sub headers {
      my $self = shift;
  
      if (@_) {
          my $headers = shift;
          if (ref $headers eq 'ARRAY') {
              Carp::carp("Odd number of headers") if @$headers % 2 != 0;
              $headers = HTTP::Headers->new(@$headers);
          } elsif (ref $headers eq 'HASH') {
              $headers = HTTP::Headers->new(%$headers);
          }
          return $self->{headers} = $headers;
      } else {
          return $self->{headers} ||= HTTP::Headers->new();
      }
  }
  
  sub cookies {
      my $self = shift;
      if (@_) {
          $self->{cookies} = shift;
      } else {
          return $self->{cookies} ||= +{ };
      }
  }
  
  sub header { shift->headers->header(@_) } # shortcut
  
  sub content_length {
      shift->headers->content_length(@_);
  }
  
  sub content_type {
      shift->headers->content_type(@_);
  }
  
  sub content_encoding {
      shift->headers->content_encoding(@_);
  }
  
  sub location {
      my $self = shift;
      return $self->headers->header('Location' => @_);
  }
  
  sub redirect {
      my $self = shift;
  
      if (@_) {
          my $url = shift;
          my $status = shift || 302;
          $self->location($url);
          $self->status($status);
      }
  
      return $self->location;
  }
  
  sub finalize {
      my $self = shift;
      Carp::croak "missing status" unless $self->status();
  
      my $headers = $self->headers->clone;
      $self->_finalize_cookies($headers);
  
      return [
          $self->status,
          +[
              map {
                  my $k = $_;
                  map {
                      my $v = $_;
                      $v =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
                      $v =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
  
                      ( $k => $v )
                  } $headers->header($_);
  
              } $headers->header_field_names
          ],
          $self->_body,
      ];
  }
  
  sub _body {
      my $self = shift;
      my $body = $self->body;
         $body = [] unless defined $body;
      if (!ref $body or Scalar::Util::blessed($body) && overload::Method($body, q("")) && !$body->can('getline')) {
          return [ $body ];
      } else {
          return $body;
      }
  }
  
  sub _finalize_cookies {
      my($self, $headers) = @_;
  
      while (my($name, $val) = each %{$self->cookies}) {
          my $cookie = $self->_bake_cookie($name, $val);
          $headers->push_header('Set-Cookie' => $cookie);
      }
  }
  
  sub _bake_cookie {
      my($self, $name, $val) = @_;
  
      return '' unless defined $val;
      $val = { value => $val } unless ref $val eq 'HASH';
  
      my @cookie = ( URI::Escape::uri_escape($name) . "=" . URI::Escape::uri_escape($val->{value}) );
      push @cookie, "domain=" . $val->{domain}   if $val->{domain};
      push @cookie, "path=" . $val->{path}       if $val->{path};
      push @cookie, "expires=" . $self->_date($val->{expires}) if $val->{expires};
      push @cookie, "secure"                     if $val->{secure};
      push @cookie, "HttpOnly"                   if $val->{httponly};
  
      return join "; ", @cookie;
  }
  
  my @MON  = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
  my @WDAY = qw( Sun Mon Tue Wed Thu Fri Sat );
  
  sub _date {
      my($self, $expires) = @_;
  
      if ($expires =~ /^\d+$/) {
          # all numbers -> epoch date
          # (cookies use '-' as date separator, HTTP uses ' ')
          my($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($expires);
          $year += 1900;
  
          return sprintf("%s, %02d-%s-%04d %02d:%02d:%02d GMT",
                         $WDAY[$wday], $mday, $MON[$mon], $year, $hour, $min, $sec);
  
      }
  
      return $expires;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Response - Portable HTTP Response object for PSGI response
  
  =head1 SYNOPSIS
  
    use Plack::Response;
  
    sub psgi_handler {
        my $env = shift;
  
        my $res = Plack::Response->new(200);
        $res->content_type('text/html');
        $res->body("Hello World");
  
        return $res->finalize;
    }
  
  =head1 DESCRIPTION
  
  Plack::Response allows you a way to create PSGI response array ref through a simple API.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $res = Plack::Response->new;
    $res = Plack::Response->new($status);
    $res = Plack::Response->new($status, $headers);
    $res = Plack::Response->new($status, $headers, $body);
  
  Creates a new Plack::Response object.
  
  =item status
  
    $res->status(200);
    $status = $res->status;
  
  Sets and gets HTTP status code. C<code> is an alias.
  
  =item headers
  
    $headers = $res->headers;
    $res->headers([ 'Content-Type' => 'text/html' ]);
    $res->headers({ 'Content-Type' => 'text/html' });
    $res->headers( HTTP::Headers->new );
  
  Sets and gets HTTP headers of the response. Setter can take either an
  array ref, a hash ref or L<HTTP::Headers> object containing a list of
  headers.
  
  =item body
  
    $res->body($body_str);
    $res->body([ "Hello", "World" ]);
    $res->body($io);
  
  Gets and sets HTTP response body. Setter can take either a string, an
  array ref, or an IO::Handle-like object. C<content> is an alias.
  
  Note that this method doesn't automatically set I<Content-Length> for
  the response. You have to set it manually if you want, with the
  C<content_length> method (see below).
  
  =item header
  
    $res->header('X-Foo' => 'bar');
    my $val = $res->header('X-Foo');
  
  Shortcut for C<< $res->headers->header >>.
  
  =item content_type, content_length, content_encoding
  
    $res->content_type('text/plain');
    $res->content_length(123);
    $res->content_encoding('gzip');
  
  Shortcut for the equivalent get/set methods in C<< $res->headers >>.
  
  =item redirect
  
    $res->redirect($url);
    $res->redirect($url, 301);
  
  Sets redirect URL with an optional status code, which defaults to 302.
  
  Note that this method doesn't normalize the given URI string. Users of
  this module have to be responsible about properly encoding URI paths
  and parameters.
  
  =item location
  
  Gets and sets C<Location> header.
  
  Note that this method doesn't normalize the given URI string in the
  setter. See above in C<redirect> for details.
  
  =item cookies
  
    $res->cookies->{foo} = 123;
    $res->cookies->{foo} = { value => '123' };
  
  Returns a hash reference containing cookies to be set in the
  response. The keys of the hash are the cookies' names, and their
  corresponding values are a plain string (for C<value> with everything
  else defaults) or a hash reference that can contain keys such as
  C<value>, C<domain>, C<expires>, C<path>, C<httponly>, C<secure>.
  
  C<expires> can take a string or an integer (as an epoch time) and
  B<does not> convert string formats such as C<+3M>.
  
    $res->cookies->{foo} = {
        value => 'test',
        path  => "/",
        domain => '.example.com',
        expires => time + 24 * 60 * 60,
    };
  
  =item finalize
  
    $res->finalize;
  
  Returns the status code, headers, and body of this response as a PSGI
  response array reference.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>
  
  =cut
PLACK_RESPONSE

$fatpacked{"Plack/Runner.pm"} = <<'PLACK_RUNNER';
  package Plack::Runner;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {
          env      => $ENV{PLACK_ENV},
          loader   => 'Plack::Loader',
          includes => [],
          modules  => [],
          @_,
      }, $class;
  }
  
  # delay the build process for reloader
  sub build(&;$) {
      my $block = shift;
      my $app   = shift || sub { };
      return sub { $block->($app->()) };
  }
  
  sub parse_options {
      my $self = shift;
  
      local @ARGV = @_;
  
      # From 'prove': Allow cuddling the paths with -I, -M and -e
      @ARGV = map { /^(-[IMe])(.+)/ ? ($1,$2) : $_ } @ARGV;
  
      my($host, $port, $socket, @listen);
  
      require Getopt::Long;
      my $parser = Getopt::Long::Parser->new(
          config => [ "no_ignore_case", "pass_through" ],
      );
  
      $parser->getoptions(
          "a|app=s"      => \$self->{app},
          "o|host=s"     => \$host,
          "p|port=i"     => \$port,
          "s|server=s"   => \$self->{server},
          "S|socket=s"   => \$socket,
          'l|listen=s@'  => \@listen,
          'D|daemonize'  => \$self->{daemonize},
          "E|env=s"      => \$self->{env},
          "e=s"          => \$self->{eval},
          'I=s@'         => $self->{includes},
          'M=s@'         => $self->{modules},
          'r|reload'     => sub { $self->{loader} = "Restarter" },
          'R|Reload=s'   => sub { $self->{loader} = "Restarter"; $self->loader->watch(split ",", $_[1]) },
          'L|loader=s'   => \$self->{loader},
          "access-log=s" => \$self->{access_log},
          "h|help"       => \$self->{help},
          "v|version"    => \$self->{version},
      );
  
      my(@options, @argv);
      while (defined(my $arg = shift @ARGV)) {
          if ($arg =~ s/^--?//) {
              my @v = split '=', $arg, 2;
              $v[0] =~ tr/-/_/;
              if (@v == 2) {
                  push @options, @v;
              } elsif ($v[0] =~ s/^(disable|enable)_//) {
                  push @options, $v[0], $1 eq 'enable';
              } else {
                  push @options, $v[0], shift @ARGV;
              }
          } else {
              push @argv, $arg;
          }
      }
  
      push @options, $self->mangle_host_port_socket($host, $port, $socket, @listen);
      push @options, daemonize => 1 if $self->{daemonize};
  
      $self->{options} = \@options;
      $self->{argv}    = \@argv;
  }
  
  sub set_options {
      my $self = shift;
      push @{$self->{options}}, @_;
  }
  
  sub mangle_host_port_socket {
      my($self, $host, $port, $socket, @listen) = @_;
  
      for my $listen (reverse @listen) {
          if ($listen =~ /:\d+$/) {
              ($host, $port) = split /:/, $listen, 2;
              $host = undef if $host eq '';
          } else {
              $socket ||= $listen;
          }
      }
  
      unless (@listen) {
          if ($socket) {
              @listen = ($socket);
          } else {
              $port ||= 5000;
              @listen = ($host ? "$host:$port" : ":$port");
          }
      }
  
      return host => $host, port => $port, listen => \@listen, socket => $socket;
  }
  
  sub version_cb {
      my $self = shift;
      $self->{version_cb} || sub {
          require Plack;
          print "Plack $Plack::VERSION\n";
      };
  }
  
  sub setup {
      my $self = shift;
  
      if ($self->{help}) {
          require Pod::Usage;
          Pod::Usage::pod2usage(0);
      }
  
      if ($self->{version}) {
          $self->version_cb->();
          exit;
      }
  
      if (@{$self->{includes}}) {
          require lib;
          lib->import(@{$self->{includes}});
      }
  
      if ($self->{eval}) {
          push @{$self->{modules}}, 'Plack::Builder';
      }
  
      for (@{$self->{modules}}) {
          my($module, @import) = split /[=,]/;
          eval "require $module" or die $@;
          $module->import(@import);
      }
  }
  
  sub locate_app {
      my($self, @args) = @_;
  
      my $psgi = $self->{app} || $args[0];
  
      if (ref $psgi eq 'CODE') {
          return sub { $psgi };
      }
  
      if ($self->{eval}) {
          $self->loader->watch("lib");
          return build {
              no strict;
              no warnings;
              my $eval = "builder { $self->{eval};";
              $eval .= "Plack::Util::load_psgi(\$psgi);" if $psgi;
              $eval .= "}";
              eval $eval or die $@;
          };
      }
  
      $psgi ||= "app.psgi";
  
      require File::Basename;
      $self->loader->watch( File::Basename::dirname($psgi) . "/lib", $psgi );
      build { Plack::Util::load_psgi $psgi };
  }
  
  sub watch {
      my($self, @dir) = @_;
  
      push @{$self->{watch}}, @dir
          if $self->{loader} eq 'Restarter';
  }
  
  sub apply_middleware {
      my($self, $app, $class, @args) = @_;
  
      my $mw_class = Plack::Util::load_class($class, 'Plack::Middleware');
      build { $mw_class->wrap($_[0], @args) } $app;
  }
  
  sub prepare_devel {
      my($self, $app) = @_;
  
      $app = $self->apply_middleware($app, 'Lint');
      $app = $self->apply_middleware($app, 'StackTrace');
      if (!$ENV{GATEWAY_INTERFACE} and !$self->{access_log}) {
          $app = $self->apply_middleware($app, 'AccessLog');
      }
  
      push @{$self->{options}}, server_ready => sub {
          my($args) = @_;
          my $name  = $args->{server_software} || ref($args); # $args is $server
          my $host  = $args->{host} || 0;
          my $proto = $args->{proto} || 'http';
          print STDERR "$name: Accepting connections at $proto://$host:$args->{port}/\n";
      };
  
      $app;
  }
  
  sub loader {
      my $self = shift;
      $self->{_loader} ||= Plack::Util::load_class($self->{loader}, 'Plack::Loader')->new;
  }
  
  sub load_server {
      my($self, $loader) = @_;
  
      if ($self->{server}) {
          return $loader->load($self->{server}, @{$self->{options}});
      } else {
          return $loader->auto(@{$self->{options}});
      }
  }
  
  sub run {
      my $self = shift;
  
      unless (ref $self) {
          $self = $self->new;
          $self->parse_options(@_);
          return $self->run;
      }
  
      unless ($self->{options}) {
          $self->parse_options();
      }
  
      my @args = @_ ? @_ : @{$self->{argv}};
  
      $self->setup;
  
      my $app = $self->locate_app(@args);
  
      $ENV{PLACK_ENV} ||= $self->{env} || 'development';
      if ($ENV{PLACK_ENV} eq 'development') {
          $app = $self->prepare_devel($app);
      }
  
      if ($self->{access_log}) {
          open my $logfh, ">>", $self->{access_log}
              or die "open($self->{access_log}): $!";
          $logfh->autoflush(1);
          $app = $self->apply_middleware($app, 'AccessLog', logger => sub { $logfh->print( @_ ) });
      }
  
      my $loader = $self->loader;
      $loader->preload_app($app);
  
      my $server = $self->load_server($loader);
      $loader->run($server);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Runner - plackup core
  
  =head1 SYNOPSIS
  
    # Your bootstrap script
    use Plack::Runner;
    my $app = sub { ... };
  
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Runner is the core of L<plackup> runner script. You can create
  your own frontend to run your application or framework, munge command
  line options and pass that to C<run> method of this class.
  
  C<run> method does exactly the same thing as the L<plackup> script
  does, but one notable addition is that you can pass a PSGI application
  code reference directly with C<--app> option, rather than via C<.psgi>
  file path or with C<-e> switch. This would be useful if you want to
  make an installable PSGI application.
  
  Also, when C<-h> or C<--help> switch is passed, the usage text is
  automatically extracted from your own script using L<Pod::Usage>.
  
  =head1 NOTES
  
  Do not directly call this module from your C<.psgi>, since that makes
  your PSGI application unnecessarily depend on L<plackup> and won't run
  other backends like L<Plack::Handler::Apache2> or mod_psgi.
  
  If you I<really> want to make your C<.psgi> runnable as a standalone
  script, you can do this:
  
    my $app = sub { ... };
  
    unless (caller) {
        require Plack::Runner;
        my $runner = Plack::Runner->new;
        $runner->parse_options(@ARGV);
        return $runner->run($app);
    }
  
    return $app;
  
  B<WARNING>: this section used to recommend C<if (__FILE__ eq $0)> but
  it's known to be broken since Plack 0.9971, since C<$0> is now
  I<always> set to the .psgi file path even when you run it from
  plackup.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
  
PLACK_RUNNER

$fatpacked{"Plack/Server.pm"} = <<'PLACK_SERVER';
  package Plack::Server;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server - DEPRECATED. See Plack::Handler
  
  =head1 SEE ALSO
  
  L<Plack::Handler>
  
  =cut
  
PLACK_SERVER

$fatpacked{"Plack/Server/Apache1.pm"} = <<'PLACK_SERVER_APACHE1';
  package Plack::Server::Apache1;
  use strict;
  use parent qw(Plack::Handler::Apache1);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Apache1 or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Apache1 - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Apache1>.
  
  =cut
PLACK_SERVER_APACHE1

$fatpacked{"Plack/Server/Apache2.pm"} = <<'PLACK_SERVER_APACHE2';
  package Plack::Server::Apache2;
  use strict;
  use parent qw(Plack::Handler::Apache2);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Apache2 or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Apache2 - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Apache2>.
  
  =cut
PLACK_SERVER_APACHE2

$fatpacked{"Plack/Server/CGI.pm"} = <<'PLACK_SERVER_CGI';
  package Plack::Server::CGI;
  use strict;
  use parent qw(Plack::Handler::CGI);
  
  sub new {
      my $class = shift;
      print STDERR "Use of $class is deprecated. Use Plack::Handler::CGI or Plack::Loader to upgrade.\n";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::CGI - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::CGI>.
  
  =cut
PLACK_SERVER_CGI

$fatpacked{"Plack/Server/FCGI.pm"} = <<'PLACK_SERVER_FCGI';
  package Plack::Server::FCGI;
  use strict;
  use parent qw(Plack::Handler::FCGI);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::FCGI or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::FCGI - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::FCGI>.
  
  =cut
PLACK_SERVER_FCGI

$fatpacked{"Plack/Server/ServerSimple.pm"} = <<'PLACK_SERVER_SERVERSIMPLE';
  package Plack::Server::ServerSimple;
  use strict;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  use parent qw(Plack::Handler::HTTP::Server::Simple);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "$class is deprecated. Use -s HTTP::Server::Simple";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::ServerSimple - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<DEPRECATED>. Use Plack::Handler::HTTP::Server::Simple.
  
  =cut
PLACK_SERVER_SERVERSIMPLE

$fatpacked{"Plack/Server/Standalone.pm"} = <<'PLACK_SERVER_STANDALONE';
  package Plack::Server::Standalone;
  use strict;
  use parent qw(Plack::Handler::Standalone);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Standalone or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Standalone - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Standalone>.
  
  =cut
PLACK_SERVER_STANDALONE

$fatpacked{"Plack/Server/Standalone/Prefork.pm"} = <<'PLACK_SERVER_STANDALONE_PREFORK';
  package Plack::Server::Standalone::Prefork;
  use strict;
  use parent qw(HTTP::Server::PSGI); # because Standalone is a wrapper
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Starman or Starlet for preforking servers.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Standalone::Prefork - DEPRECATED use Starman or Starlet instead
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>.
  
  =head1 SEE ALSO
  
  L<HTTP::Server::PSGI> L<Starman> L<Starlet>
  
  =cut
PLACK_SERVER_STANDALONE_PREFORK

$fatpacked{"Plack/TempBuffer.pm"} = <<'PLACK_TEMPBUFFER';
  package Plack::TempBuffer;
  use strict;
  use warnings;
  use Plack::Util;
  use FileHandle; # for seek etc.
  
  our $MaxMemoryBufferSize = 1024 * 1024;
  
  sub new {
      my($class, $length) = @_;
  
      # $MaxMemoryBufferSize = 0  -> Always temp file
      # $MaxMemoryBufferSize = -1 -> Always PerlIO
      my $backend;
      if ($MaxMemoryBufferSize < 0) {
          $backend = "PerlIO";
      } elsif ($MaxMemoryBufferSize == 0) {
          $backend = "File";
      } elsif (!$length) {
          $backend = "Auto";
      } elsif ($length > $MaxMemoryBufferSize) {
          $backend = "File";
      } else {
          $backend = "PerlIO";
      }
  
      $class->create($backend, $length, $MaxMemoryBufferSize);
  }
  
  sub create {
      my($class, $backend, $length, $max) = @_;
      Plack::Util::load_class($backend, $class)->new($length, $max);
  }
  
  sub print;
  sub rewind;
  sub size;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::TempBuffer - temporary buffer to save bytes
  
  =head1 SYNOPSIS
  
    my $buf = Plack::TempBuffer->new($length);
    $buf->print($bytes);
  
    my $size = $buf->size;
    my $fh   = $buf->rewind;
  
  =head1 DESCRIPTION
  
  Plack::TempBuffer is a buffer class to store arbitrary length of byte
  strings and then get a seekable filehandle once everything is
  buffered. It uses PerlIO and/or temporary file to save the buffer
  depending on the length of the size.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Request>
  
  =cut
  
PLACK_TEMPBUFFER

$fatpacked{"Plack/TempBuffer/Auto.pm"} = <<'PLACK_TEMPBUFFER_AUTO';
  package Plack::TempBuffer::Auto;
  use strict;
  use parent 'Plack::TempBuffer';
  
  sub new {
      my($class, undef, $max_memory_size) = @_;
      bless {
          _buffer => Plack::TempBuffer->create('PerlIO'),
          _max => $max_memory_size,
      }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{_buffer}->print(@_);
  
      if ($self->{_max} && $self->{_buffer}->size > $self->{_max}) {
          my $buf = $self->{_buffer}->{buffer};
          $self->{_buffer} = Plack::TempBuffer->create('File'),
          $self->{_buffer}->print($buf);
          delete $self->{_max};
      }
  }
  
  sub size {
      my $self = shift;
      $self->{_buffer}->size;
  }
  
  sub rewind {
      my $self = shift;
      $self->{_buffer}->rewind;
  }
  
  1;
PLACK_TEMPBUFFER_AUTO

$fatpacked{"Plack/TempBuffer/File.pm"} = <<'PLACK_TEMPBUFFER_FILE';
  package Plack::TempBuffer::File;
  use strict;
  use parent 'Plack::TempBuffer';
  
  use IO::File;
  
  sub new {
      my $class = shift;
  
      my $fh = IO::File->new_tmpfile;
      $fh->binmode;
  
      bless { fh => $fh }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{fh}->print(@_);
  }
  
  sub size {
      my $self = shift;
      $self->{fh}->flush;
      -s $self->{fh};
  }
  
  sub rewind {
      my $self = shift;
      $self->{fh}->seek(0, 0);
      $self->{fh};
  }
  
  1;
PLACK_TEMPBUFFER_FILE

$fatpacked{"Plack/TempBuffer/PerlIO.pm"} = <<'PLACK_TEMPBUFFER_PERLIO';
  package Plack::TempBuffer::PerlIO;
  use strict;
  use parent 'Plack::TempBuffer';
  
  sub new {
      my $class = shift;
      bless { buffer => '' }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{buffer} .= "@_";
  }
  
  sub size {
      my $self = shift;
      length $self->{buffer};
  }
  
  sub rewind {
      my $self = shift;
      my $buffer = $self->{buffer};
      open my $io, "<", \$buffer;
      bless $io, 'FileHandle'; # This makes $io work as FileHandle under 5.8, .10 and .11 :/
      return $io;
  }
  
  1;
PLACK_TEMPBUFFER_PERLIO

$fatpacked{"Plack/Test.pm"} = <<'PLACK_TEST';
  package Plack::Test;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw(test_psgi);
  
  our $Impl;
  $Impl ||= $ENV{PLACK_TEST_IMPL} || "MockHTTP";
  
  sub test_psgi {
      eval "require Plack::Test::$Impl;";
      die $@ if $@;
      no strict 'refs';
      if (ref $_[0] && @_ == 2) {
          @_ = (app => $_[0], client => $_[1]);
      }
      &{"Plack::Test::$Impl\::test_psgi"}(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test - Test PSGI applications with various backends
  
  =head1 SYNOPSIS
  
    use Plack::Test;
  
    # named params
    test_psgi
        app => sub {
            my $env = shift;
            return [ 200, [ 'Content-Type' => 'text/plain' ], [ "Hello World" ] ],
        },
        client => sub {
            my $cb  = shift;
            my $req = HTTP::Request->new(GET => "http://localhost/hello");
            my $res = $cb->($req);
            like $res->content, qr/Hello World/;
        };
  
     use HTTP::Request::Common;
  
     # positional params (app, client)
     my $app = sub { return [ 200, [], [ "Hello "] ] };
     test_psgi $app, sub {
         my $cb  = shift;
         my $res = $cb->(GET "/");
         is $res->content, "Hello";
     };
  
  
  =head1 DESCRIPTION
  
  Plack::Test is a unified interface to test PSGI applications using
  L<HTTP::Request> and L<HTTP::Response> objects. It also allows you to run PSGI
  applications in various ways. The default backend is C<Plack::Test::MockHTTP>,
  but you may also use any L<Plack::Handler> implementation to run live HTTP
  requests against at web server
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item test_psgi
  
    test_psgi $app, $client;
    test_psgi app => $app, client => $client;
  
  Runs the client test code C<$client> against a PSGI application
  C<$app>. The client callback gets one argument C<$cb>, a
  callback that accepts an C<HTTP::Request> object and returns an
  C<HTTP::Response> object.
  
  Use L<HTTP::Request::Common> to import shortcuts for creating requests for
  C<GET>, C<POST>, C<DELETE>, and C<PUT> operations.
  
  For your convenience, the C<HTTP::Request> given to the callback automatically
  uses the HTTP protocol and the localhost (I<127.0.0.1> by default), so the
  following code just works:
  
    use HTTP::Request::Common;
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/hello");
    };
  
  Note that however, it is not a good idea to pass an arbitrary
  (i.e. user-input) string to C<GET> or even C<<
  HTTP::Request->new >> by assuming that it always represents a path,
  because:
  
    my $req = GET "//foo/bar";
  
  would represent a request for a URL that has no scheme, has a hostname
  I<foo> and a path I</bar>, instead of a path I<//foo/bar> which you
  might actually want.
  
  =back
  
  =head1 OPTIONS
  
  Specify the L<Plack::Test> backend using the environment
  variable C<PLACK_TEST_IMPL> or C<$Plack::Test::Impl> package variable.
  
  The available values for the backend are:
  
  =over 4
  
  =item MockHTTP
  
  (Default) Creates a PSGI env hash out of HTTP::Request object, runs
  the PSGI application in-process and returns HTTP::Response.
  
  =item Server
  
  Runs one of Plack::Handler backends (C<Standalone> by default) and
  sends live HTTP requests to test.
  
  =item ExternalServer
  
  Runs tests against an external server specified in the
  C<PLACK_TEST_EXTERNALSERVER_URI> environment variable instead of spawning the
  application in a server locally.
  
  =back
  
  For instance, test your application with the C<HTTP::Server::ServerSimple>
  server backend with:
  
    > env PLACK_TEST_IMPL=Server PLACK_SERVER=HTTP::Server::ServerSimple \
      prove -l t/test.t
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_TEST

$fatpacked{"Plack/Test/MockHTTP.pm"} = <<'PLACK_TEST_MOCKHTTP';
  package Plack::Test::MockHTTP;
  use strict;
  use warnings;
  
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use HTTP::Message::PSGI;
  use Try::Tiny;
  
  sub test_psgi {
      my %args = @_;
  
      my $client = delete $args{client} or croak "client test code needed";
      my $app    = delete $args{app}    or croak "app needed";
  
      my $cb = sub {
          my $req = shift;
          $req->uri->scheme('http')    unless defined $req->uri->scheme;
          $req->uri->host('localhost') unless defined $req->uri->host;
          my $env = $req->to_psgi;
  
          my $res = try {
              HTTP::Response->from_psgi($app->($env));
          } catch {
              HTTP::Response->from_psgi([ 500, [ 'Content-Type' => 'text/plain' ], [ $_ ] ]);
          };
  
          $res->request($req);
          return $res;
      };
  
      $client->($cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::MockHTTP - Run mocked HTTP tests through PSGI applications
  
  =head1 DESCRIPTION
  
  Plack::Test::MockHTTP is a utility to run PSGI application given
  HTTP::Request objects and return HTTP::Response object out of PSGI
  application response. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Test>
  
  =cut
  
  
PLACK_TEST_MOCKHTTP

$fatpacked{"Plack/Test/Server.pm"} = <<'PLACK_TEST_SERVER';
  package Plack::Test::Server;
  use strict;
  use warnings;
  use Carp;
  use LWP::UserAgent;
  use Test::TCP;
  use Plack::Loader;
  
  sub test_psgi {
      my %args = @_;
  
      my $client = delete $args{client} or croak "client test code needed";
      my $app    = delete $args{app}    or croak "app needed";
      my $ua     = delete $args{ua} || LWP::UserAgent->new;
  
      test_tcp(
          client => sub {
              my $port = shift;
              my $cb = sub {
                  my $req = shift;
                  $req->uri->scheme('http');
                  $req->uri->host($args{host} || '127.0.0.1');
                  $req->uri->port($port);
                  return $ua->request($req);
              };
              $client->($cb);
          },
          server => $args{server} || sub {
              my $port = shift;
              my $server = Plack::Loader->auto(port => $port, host => ($args{host} || '127.0.0.1'));
              $server->run($app);
          },
      );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::Server - Run HTTP tests through live Plack servers
  
  =head1 DESCRIPTION
  
  Plack::Test::Server is a utility to run PSGI application with Plack
  server implementations, and run the live HTTP tests with the server
  using a callback. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Loader> L<Test::TCP> L<Plack::Test>
  
  =cut
  
PLACK_TEST_SERVER

$fatpacked{"Plack/Test/Suite.pm"} = <<'PLACK_TEST_SUITE';
  package Plack::Test::Suite;
  use strict;
  use warnings;
  use Digest::MD5;
  use File::ShareDir;
  use HTTP::Request;
  use HTTP::Request::Common;
  use LWP::UserAgent;
  use Test::More;
  use Test::TCP;
  use Plack::Loader;
  use Plack::Middleware::Lint;
  use Plack::Util;
  use Plack::Request;
  use Try::Tiny;
  
  my $share_dir = try { File::ShareDir::dist_dir('Plack') } || 'share';
  
  $ENV{PLACK_TEST_SCRIPT_NAME} = '';
  
  # 0: test name
  # 1: request generator coderef.
  # 2: request handler
  # 3: test case for response
  our @TEST = (
      [
          'SCRIPT_NAME',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME};
          },
          sub {
              my $env = shift;
              return [ 200, ["Content-Type", "text/plain"], [ $env->{SCRIPT_NAME} ] ];
          },
      ],
      [
          'GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ 'Hello, ' . $env->{QUERY_STRING} ],
              ];
          },
      ],
      [
          'POST',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/", [name => 'tatsuhiko']);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), 14;
              is $res->header('Client-Content-Type'), 'application/x-www-form-urlencoded';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=tatsuhiko';
          },
          sub {
              my $env = shift;
              my $body;
              $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH});
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ 'Hello, ' . $body ],
              ];
          },
      ],
      [
          'big POST',
          sub {
              my $cb = shift;
              my $chunk = "abcdefgh" x 12000;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content_length(length $chunk);
              $req->content_type('application/octet-stream');
              $req->content($chunk);
  
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), length $chunk;
              is length $res->content, length $chunk;
              is Digest::MD5::md5_hex($res->content), Digest::MD5::md5_hex($chunk);
          },
          sub {
              my $env = shift;
              my $len = $env->{CONTENT_LENGTH};
              my $body = '';
              my $spin;
              while ($len > 0) {
                  my $rc = $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH}, length $body);
                  $len -= $rc;
                  last if $spin++ > 2000;
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ $body ],
              ];
          },
      ],
      [
          'psgi.url_scheme',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'http';
          },
          sub {
              my $env = $_[0];
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{'psgi.url_scheme'} ],
              ];
          },
      ],
      [
          'return glob',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr/^package /;
              like $res->content, qr/END_MARK_FOR_TESTING$/;
          },
          sub {
              my $env = shift;
              open my $fh, '<', __FILE__ or die $!;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  $fh,
              ];
          },
      ],
      [
          'filehandle',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'bigger file',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/baybridge.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 79838;
              is Digest::MD5::md5_hex($res->content), '983726ae0e4ce5081bef5fb2b7216950';
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/baybridge.jpg";
              binmode $fh;
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'handle HTTP-Header',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Foo => "Bar");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_FOO}],
              ];
          },
      ],
      [
          'handle HTTP-Cookie',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Cookie => "foo");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'foo';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_COOKIE}],
              ];
          },
      ],
      [
          'validate env',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, join("\n",
                  'REQUEST_METHOD:GET',
                  "SCRIPT_NAME:$ENV{PLACK_TEST_SCRIPT_NAME}",
                  'PATH_INFO:/foo/',
                  'QUERY_STRING:dankogai=kogaidan',
                  'SERVER_NAME:127.0.0.1',
                  "SERVER_PORT:" . $res->request->uri->port,
              )."\n";
          },
          sub {
              my $env = shift;
              my $body;
              $body .= $_ . ':' . $env->{$_} . "\n" for qw/REQUEST_METHOD SCRIPT_NAME PATH_INFO QUERY_STRING SERVER_NAME SERVER_PORT/;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$body],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%2cbaz");
              is $res->content, "/foo/bar,baz", "PATH_INFO should be decoded per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% double encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%252cbaz");
              is $res->content, "/foo/bar%2cbaz", "PATH_INFO should be decoded only once, per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO (outside of URI characters)',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo%E3%81%82");
              is $res->content, "/foo\x{e3}\x{81}\x{82}";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          'SERVER_PROTOCOL is required',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr{^HTTP/1\.[01]$};
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{SERVER_PROTOCOL}],
              ];
          },
      ],
      [
          'SCRIPT_NAME should not be undef',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $cont = defined $env->{'SCRIPT_NAME'};
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$cont],
              ];
          },
      ],
      [
          'call close after read IO::Handle-like',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/call_close");
              is($res->content, '1234');
          },
          sub {
              my $env = shift;
              {
                  our $closed = -1;
                  sub CalledClose::new { $closed = 0; my $i=0; bless \$i, 'CalledClose' }
                  sub CalledClose::getline {
                      my $self = shift;
                      return $$self++ < 4 ? $$self : undef;
                  }
                  sub CalledClose::close { ::ok(1, 'closed') if defined &::ok }
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  CalledClose->new(),
              ];
          },
      ],
      [
          'has errors',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/has_errors");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $err = $env->{'psgi.errors'};
              my $has_errors = defined $err;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$has_errors]
              ];
          },
      ],
      [
          'status line',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is($res->status_line, '200 OK');
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [1]
              ];
          },
      ],
      [
          'Do not crash when the app dies',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 500;
              is $res->message, 'Internal Server Error';
          },
          sub {
              my $env = shift;
              open my $io, '>', \my $error;
              $env->{'psgi.errors'} = $io;
              die "Throwing an exception from app handler. Server shouldn't crash.";
          },
      ],
      [
          'multi headers (request)',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Foo => "bar");
              $req->push_header(Foo => "baz");
              my $res = $cb->($req);
              like($res->content, qr/^bar,\s*baz$/);
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{HTTP_FOO} ]
              ];
          },
      ],
      [
          'multi headers (response)',
          sub {
              my $cb  = shift;
              my $res = $cb->(HTTP::Request->new(GET => "http://127.0.0.1/"));
              my $foo = $res->header('X-Foo');
              like $foo, qr/foo,\s*bar,\s*baz/;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Foo', 'foo', 'X-Foo', 'bar, baz' ],
                  [ 'hi' ]
              ];
          },
      ],
      [
          'Do not set $env->{COOKIE}',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Cookie => "foo=bar");
              my $res = $cb->($req);
              is($res->header('X-Cookie'), 0);
              is $res->content, 'foo=bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Cookie' => $env->{COOKIE} ? 1 : 0 ],
                  [ $env->{HTTP_COOKIE} ]
              ];
          },
      ],
      [
          'no entity headers on 304',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 304;
              is $res->message, 'Not Modified';
              is $res->content, '';
              ok ! defined $res->header('content_type'), "No Content-Type";
              ok ! defined $res->header('content_length'), "No Content-Length";
              ok ! defined $res->header('transfer_encoding'), "No Transfer-Encoding";
          },
          sub {
              my $env = shift;
              return [ 304, [], [] ];
          },
      ],
      [
          'REQUEST_URI is set',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%20baz%73?x=a");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME} . "/foo/bar%20baz%73?x=a";
          },
          sub {
              my $env = shift;
              return [ 200, [ 'Content-Type' => 'text/plain' ], [ $env->{REQUEST_URI} ] ];
          },
      ],
      [
          'filehandle with path()',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              Plack::Util::set_io_path($fh, "$share_dir/face.jpg");
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'a big header value > 128 bytes',
          sub {
              my $cb  = shift;
              my $req = GET "http://127.0.0.1/";
              my $v = ("abcdefgh" x 16);
              $req->header('X-Foo' => $v);
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->content, $v;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain' ],
                  [ $env->{HTTP_X_FOO} ],
              ];
          },
      ],
      [
          'coderef res',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
              return sub {
                  my $respond = shift;
                  $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                      [ 'Hello, ' . $env->{QUERY_STRING} ],
                  ]);
              }
          },
      ],
      [
          'coderef streaming',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
  
              return sub {
                  my $respond = shift;
  
                  my $writer = $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                  ]);
  
                  $writer->write("Hello, ");
                  $writer->write($env->{QUERY_STRING});
                  $writer->close();
              }
          },
      ],
      [
          'CRLF output and FCGI parse bug',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
  
              is $res->header("Foo"), undef;
              is $res->content, "Foo: Bar\r\n\r\nHello World";
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Foo: Bar\r\n\r\nHello World" ] ];
          },
      ],
      [
          'newlines',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is length($res->content), 7;
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Bar\nBaz" ] ];
          },
      ],
      [
          'test 404',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 404;
              is $res->message, 'Not Found';
              is $res->content, 'Not Found';
          },
          sub {
              return [ 404, [ "Content-Type", "text/plain" ], [ "Not Found" ] ];
          },
      ],
      [
          'request->input seekable',
          sub {
              my $cb = shift;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content("body");
              $req->content_type('text/plain');
              $req->content_length(4);
              my $res = $cb->($req);
              is $res->content, 'body';
          },
          sub {
              my $req = Plack::Request->new(shift);
              return [ 200, [ "Content-Type", "text/plain" ], [ $req->content ] ];
          },
      ],
      [
          'request->content on GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              ok $res->is_success;
          },
          sub {
              my $req = Plack::Request->new(shift);
              $req->content;
              return [ 200, [ "Content-Type", "text/plain" ], [ "OK" ] ];
          },
      ],
      [
          'handle Authorization header',
          sub {
              my $cb  = shift;
              SKIP: {
                  skip "Authorization header is unsupported under CGI", 4 if ($ENV{PLACK_TEST_HANDLER} || "") eq "CGI";
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      $req->push_header(Authorization => 'Basic XXXX');
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 1;
                      is $res->content, 'Basic XXXX';
                  };
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 0;
                      is $res->content, '';
                  };
              };
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-AUTHORIZATION' => exists($env->{HTTP_AUTHORIZATION}) ? 1 : 0 ],
                  [ $env->{HTTP_AUTHORIZATION} || '' ],
              ];
          },
      ],
      [
          'repeated slashes',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1//foo///bar/baz");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, '//foo///bar/baz';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
  );
  
  sub runtests {
      my($class, $runner) = @_;
      for my $test (@TEST) {
          $runner->(@$test);
      }
  }
  
  sub run_server_tests {
      my($class, $server, $server_port, $http_port, %args) = @_;
  
      if (ref $server ne 'CODE') {
          my $server_class = $server;
          $server = sub {
              my($port, $app) = @_;
              my $server = Plack::Loader->load($server_class, port => $port, host => "127.0.0.1", %args);
              $app = Plack::Middleware::Lint->wrap($app);
              $server->run($app);
          }
      }
  
      test_tcp(
          client => sub {
              my $port = shift;
  
              my $ua = LWP::UserAgent->new;
              for my $i (0..$#TEST) {
                  my $test = $TEST[$i];
                  note $test->[0];
                  my $cb = sub {
                      my $req = shift;
                      $req->uri->port($http_port || $port);
                      $req->uri->path(($ENV{PLACK_TEST_SCRIPT_NAME}||"") . $req->uri->path);
                      $req->header('X-Plack-Test' => $i);
                      return $ua->request($req);
                  };
  
                  $test->[1]->($cb);
              }
          },
          server => sub {
              my $port = shift;
              my $app  = $class->test_app_handler;
              $server->($port, $app);
              exit(0); # for Test::TCP
          },
          port => $server_port,
      );
  }
  
  sub test_app_handler {
      return sub {
          my $env = shift;
          $TEST[$env->{HTTP_X_PLACK_TEST}][2]->($env);
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Test::Suite - Test suite for Plack handlers
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Plack::Test::Suite;
    Plack::Test::Suite->run_server_tests('Your::Handler');
    done_testing;
  
  =head1 DESCRIPTION
  
  Plack::Test::Suite is a test suite to test a new PSGI server
  implementation. It automatically loads a new handler environment and
  uses LWP to send HTTP requests to the local server to make sure your
  handler implements the PSGI specification correctly.
  
  Note that the handler name doesn't include the C<Plack::Handler::>
  prefix, i.e. if you have a new Plack handler Plack::Handler::Foo, your
  test script would look like:
  
    Plack::Test::Suite->run_server_tests('Foo');
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  Kazuho Oku
  
  =cut
  
  END_MARK_FOR_TESTING
PLACK_TEST_SUITE

$fatpacked{"Plack/Util.pm"} = <<'PLACK_UTIL';
  package Plack::Util;
  use strict;
  use Carp ();
  use Scalar::Util;
  use IO::Handle;
  use overload ();
  
  sub TRUE()  { 1==1 }
  sub FALSE() { !TRUE }
  
  sub load_class {
      my($class, $prefix) = @_;
  
      if ($prefix) {
          unless ($class =~ s/^\+// || $class =~ /^$prefix/) {
              $class = "$prefix\::$class";
          }
      }
  
      my $file = $class;
      $file =~ s!::!/!g;
      require "$file.pm"; ## no critic
  
      return $class;
  }
  
  sub is_real_fh ($) {
      my $fh = shift;
  
      {
          no warnings 'uninitialized';
          return FALSE if -p $fh or -c _ or -b _;
      }
  
      my $reftype = Scalar::Util::reftype($fh) or return;
      if (   $reftype eq 'IO'
          or $reftype eq 'GLOB' && *{$fh}{IO}
      ) {
          # if it's a blessed glob make sure to not break encapsulation with
          # fileno($fh) (e.g. if you are filtering output then file descriptor
          # based operations might no longer be valid).
          # then ensure that the fileno *opcode* agrees too, that there is a
          # valid IO object inside $fh either directly or indirectly and that it
          # corresponds to a real file descriptor.
          my $m_fileno = $fh->fileno;
          return FALSE unless defined $m_fileno;
          return FALSE unless $m_fileno >= 0;
  
          my $f_fileno = fileno($fh);
          return FALSE unless defined $f_fileno;
          return FALSE unless $f_fileno >= 0;
          return TRUE;
      } else {
          # anything else, including GLOBS without IO (even if they are blessed)
          # and non GLOB objects that look like filehandle objects cannot have a
          # valid file descriptor in fileno($fh) context so may break.
          return FALSE;
      }
  }
  
  sub set_io_path {
      my($fh, $path) = @_;
      bless $fh, 'Plack::Util::IOWithPath';
      $fh->path($path);
  }
  
  sub content_length {
      my $body = shift;
  
      return unless defined $body;
  
      if (ref $body eq 'ARRAY') {
          my $cl = 0;
          for my $chunk (@$body) {
              $cl += length $chunk;
          }
          return $cl;
      } elsif ( is_real_fh($body) ) {
          return (-s $body) - tell($body);
      }
  
      return;
  }
  
  sub foreach {
      my($body, $cb) = @_;
  
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      } else {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
  }
  
  sub class_to_file {
      my $class = shift;
      $class =~ s!::!/!g;
      $class . ".pm";
  }
  
  sub _load_sandbox {
      my $_file = shift;
  
      my $_package = $_file;
      $_package =~ s/([^A-Za-z0-9_])/sprintf("_%2x", unpack("C", $1))/eg;
  
      _file_zero_check($_file) if $ENV{PLACK_ENV} eq 'development';
  
      local $0 = $_file; # so FindBin etc. works
      local @ARGV = ();  # Some frameworks might try to parse @ARGV
  
      return eval sprintf <<'END_EVAL', $_package;
  package Plack::Sandbox::%s;
  {
      my $app = do $_file;
      if ( !$app && ( my $error = $@ || $! )) { die $error; }
      $app;
  }
  END_EVAL
  }
  
  sub _file_zero_check {
      my $file = shift;
      open my $fh, "<", $file or return;
  
      my $code = join '', <$fh>;
      if ($code =~ /(__FILE__\s+eq\s+\$0|\$0\s+eq\s+__FILE__)/) {
          warn <<WARNING
  Your PSGI file ($file) seems to use the following idiom, which is known to be broken since Plack 0.9971:
  
    if ($1) {
        called_from_cmdline();
    }
  
  because now \$0 is _always_ localized to the PSGI file path you're evaluating. You should switch to other alternatives such as `unless (caller) {}`. See http://bit.ly/psgi-file-0 for details.
  
  This friendly warning and the code to generate this runs only when the Plack environment (-E) is set to 'development', and will go away in the next major release of Plack.
  
  WARNING
      }
  }
  
  sub load_psgi {
      my $stuff = shift;
  
      local $ENV{PLACK_ENV} = $ENV{PLACK_ENV} || 'development';
  
      my $file = $stuff =~ /^[a-zA-Z0-9\_\:]+$/ ? class_to_file($stuff) : $stuff;
      my $app = _load_sandbox($file);
      die "Error while loading $file: $@" if $@;
  
      return $app->to_app if $app and Scalar::Util::blessed($app) and $app->can('to_app');
      return $app;
  }
  
  sub run_app($$) {
      my($app, $env) = @_;
  
      return eval { $app->($env) } || do {
          my $body = "Internal Server Error";
          $env->{'psgi.errors'}->print($@);
          [ 500, [ 'Content-Type' => 'text/plain', 'Content-Length' => length($body) ], [ $body ] ];
      };
  }
  
  sub headers {
      my $headers = shift;
      inline_object(
          iter   => sub { header_iter($headers, @_) },
          get    => sub { header_get($headers, @_) },
          set    => sub { header_set($headers, @_) },
          push   => sub { header_push($headers, @_) },
          exists => sub { header_exists($headers, @_) },
          remove => sub { header_remove($headers, @_) },
          headers => sub { $headers },
      );
  }
  
  sub header_iter {
      my($headers, $code) = @_;
  
      my @headers = @$headers; # copy
      while (my($key, $val) = splice @headers, 0, 2) {
          $code->($key, $val);
      }
  }
  
  sub header_get {
      my($headers, $key) = (shift, lc shift);
  
      my @val;
      header_iter $headers, sub {
          push @val, $_[1] if lc $_[0] eq $key;
      };
  
      return wantarray ? @val : $val[0];
  }
  
  sub header_set {
      my($headers, $key, $val) = @_;
  
      my($set, @new_headers);
      header_iter $headers, sub {
          if (lc $key eq lc $_[0]) {
              return if $set;
              $_[1] = $val;
              $set++;
          }
          push @new_headers, $_[0], $_[1];
      };
  
      push @new_headers, $key, $val unless $set;
      @$headers = @new_headers;
  }
  
  sub header_push {
      my($headers, $key, $val) = @_;
      push @$headers, $key, $val;
  }
  
  sub header_exists {
      my($headers, $key) = (shift, lc shift);
  
      my $exists;
      header_iter $headers, sub {
          $exists = 1 if lc $_[0] eq $key;
      };
  
      return $exists;
  }
  
  sub header_remove {
      my($headers, $key) = (shift, lc shift);
  
      my @new_headers;
      header_iter $headers, sub {
          push @new_headers, $_[0], $_[1]
              unless lc $_[0] eq $key;
      };
  
      @$headers = @new_headers;
  }
  
  sub status_with_no_entity_body {
      my $status = shift;
      return $status < 200 || $status == 204 || $status == 304;
  }
  
  sub encode_html {
      my $str = shift;
      $str =~ s/&/&amp;/g;
      $str =~ s/>/&gt;/g;
      $str =~ s/</&lt;/g;
      $str =~ s/"/&quot;/g;
      $str =~ s/'/&#39;/g;
      return $str;
  }
  
  sub inline_object {
      my %args = @_;
      bless \%args, 'Plack::Util::Prototype';
  }
  
  sub response_cb {
      my($res, $cb) = @_;
  
      my $body_filter = sub {
          my($cb, $res) = @_;
          my $filter_cb = $cb->($res);
          # If response_cb returns a callback, treat it as a $body filter
          if (defined $filter_cb && ref $filter_cb eq 'CODE') {
              Plack::Util::header_remove($res->[1], 'Content-Length');
              if (defined $res->[2]) {
                  if (ref $res->[2] eq 'ARRAY') {
                      for my $line (@{$res->[2]}) {
                          $line = $filter_cb->($line);
                      }
                      # Send EOF.
                      my $eof = $filter_cb->( undef );
                      push @{ $res->[2] }, $eof if defined $eof;
                  } else {
                      my $body    = $res->[2];
                      my $getline = sub { $body->getline };
                      $res->[2] = Plack::Util::inline_object
                          getline => sub { $filter_cb->($getline->()) },
                          close => sub { $body->close };
                  }
              } else {
                  return $filter_cb;
              }
          }
      };
  
      if (ref $res eq 'ARRAY') {
          $body_filter->($cb, $res);
          return $res;
      } elsif (ref $res eq 'CODE') {
          return sub {
              my $respond = shift;
              my $cb = $cb;  # To avoid the nested closure leak for 5.8.x
              $res->(sub {
                  my $res = shift;
                  my $filter_cb = $body_filter->($cb, $res);
                  if ($filter_cb) {
                      my $writer = $respond->($res);
                      if ($writer) {
                          return Plack::Util::inline_object
                              write => sub { $writer->write($filter_cb->(@_)) },
                              close => sub {
                                  my $chunk = $filter_cb->(undef);
                                  $writer->write($chunk) if defined $chunk;
                                  $writer->close;
                              };
                      }
                  } else {
                      return $respond->($res);
                  }
              });
          };
      }
  
      return $res;
  }
  
  package Plack::Util::Prototype;
  
  our $AUTOLOAD;
  sub can {
      $_[0]->{$_[1]};
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $attr = $AUTOLOAD;
      $attr =~ s/.*://;
      if (ref($self->{$attr}) eq 'CODE') {
          $self->{$attr}->(@_);
      } else {
          Carp::croak(qq/Can't locate object method "$attr" via package "Plack::Util::Prototype"/);
      }
  }
  
  sub DESTROY { }
  
  package Plack::Util::IOWithPath;
  use parent qw(IO::Handle);
  
  sub path {
      my $self = shift;
      if (@_) {
          ${*$self}{+__PACKAGE__} = shift;
      }
      ${*$self}{+__PACKAGE__};
  }
  
  package Plack::Util;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util - Utility subroutines for Plack server and framework developers
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item TRUE, FALSE
  
    my $true  = Plack::Util::TRUE;
    my $false = Plack::Util::FALSE;
  
  Utility constants to include when you specify boolean variables in C<$env> hash (e.g. C<psgi.multithread>).
  
  =item load_class
  
    my $class = Plack::Util::load_class($class [, $prefix ]);
  
  Constructs a class name and C<require> the class. Throws an exception
  if the .pm file for the class is not found, just with the built-in
  C<require>.
  
  If C<$prefix> is set, the class name is prepended to the C<$class>
  unless C<$class> begins with C<+> sign, which means the class name is
  already fully qualified.
  
    my $class = Plack::Util::load_class("Foo");                   # Foo
    my $class = Plack::Util::load_class("Baz", "Foo::Bar");       # Foo::Bar::Baz
    my $class = Plack::Util::load_class("+XYZ::ZZZ", "Foo::Bar"); # XYZ::ZZZ
  
  =item is_real_fh
  
    if ( Plack::Util::is_real_fh($fh) ) { }
  
  returns true if a given C<$fh> is a real file handle that has a file
  descriptor. It returns false if C<$fh> is PerlIO handle that is not
  really related to the underlying file etc.
  
  =item content_length
  
    my $cl = Plack::Util::content_length($body);
  
  Returns the length of content from body if it can be calculated. If
  C<$body> is an array ref it's a sum of length of each chunk, if
  C<$body> is a real filehandle it's a remaining size of the filehandle,
  otherwise returns undef.
  
  =item set_io_path
  
    Plack::Util::set_io_path($fh, "/path/to/foobar.txt");
  
  Sets the (absolute) file path to C<$fh> filehandle object, so you can
  call C<< $fh->path >> on it. As a side effect C<$fh> is blessed to an
  internal package but it can still be treated as a normal file
  handle.
  
  This module doesn't normalize or absolutize the given path, and is
  intended to be used from Server or Middleware implementations. See
  also L<IO::File::WithPath>.
  
  =item foreach
  
    Plack::Util::foreach($body, $cb);
  
  Iterate through I<$body> which is an array reference or
  IO::Handle-like object and pass each line (which is NOT really
  guaranteed to be a I<line>) to the callback function.
  
  It internally sets the buffer length C<$/> to 4096 in case it reads
  the binary file, unless otherwise set in the caller's code.
  
  =item load_psgi
  
    my $app = Plack::Util::load_psgi $psgi_file_or_class;
  
  Load C<app.psgi> file or a class name (like C<MyApp::PSGI>) and
  require the file to get PSGI application handler. If the file can't be
  loaded (e.g. file doesn't exist or has a perl syntax error), it will
  throw an exception.
  
  B<Security>: If you give this function a class name or module name
  that is loadable from your system, it will load the module. This could
  lead to a security hole:
  
    my $psgi = ...; # user-input: consider "Moose.pm"
    $app = Plack::Util::load_psgi($psgi); # this does 'require "Moose.pm"'!
  
  Generally speaking, passing an external input to this function is
  considered very insecure. But if you really want to do that, be sure
  to validate the argument passed to this function. Also, if you do not
  want to accept an arbitrary class name but only load from a file path,
  make sure that the argument C<$psgi_file_or_class> begins with C</> so
  that Perl's built-in do function won't search the include path.
  
  =item run_app
  
    my $res = Plack::Util::run_app $app, $env;
  
  Runs the I<$app> by wrapping errors with I<eval> and if an error is
  found, logs it to C<< $env->{'psgi.errors'} >> and returns the
  template 500 Error response.
  
  =item header_get, header_exists, header_set, header_push, header_remove
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
  
    my $v = Plack::Util::header_get($hdrs, $key); # First found only
    my @v = Plack::Util::header_get($hdrs, $key);
    my $bool = Plack::Util::header_exists($hdrs, $key);
    Plack::Util::header_set($hdrs, $key, $val);   # overwrites existent header
    Plack::Util::header_push($hdrs, $key, $val);
    Plack::Util::header_remove($hdrs, $key);
  
  Utility functions to manipulate PSGI response headers array
  reference. The methods that read existent header value handles header
  name as case insensitive.
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
    my $v = Plack::Util::header_get($hdrs, 'content-type'); # 'text/plain'
  
  =item headers
  
    my $headers = [ 'Content-Type' => 'text/plain' ];
  
    my $h = Plack::Util::headers($headers);
    $h->get($key);
    if ($h->exists($key)) { ... }
    $h->set($key => $val);
    $h->push($key => $val);
    $h->remove($key);
    $h->headers; # same reference as $headers
  
  Given a header array reference, returns a convenient object that has
  an instance methods to access C<header_*> functions with an OO
  interface. The object holds a reference to the original given
  C<$headers> argument and updates the reference accordingly when called
  write methods like C<set>, C<push> or C<remove>. It also has C<headers>
  method that would return the same reference.
  
  =item status_with_no_entity_body
  
    if (status_with_no_entity_body($res->[0])) { }
  
  Returns true if the given status code doesn't have any Entity body in
  HTTP response, i.e. it's 100, 101, 204 or 304.
  
  =item inline_object
  
    my $o = Plack::Util::inline_object(
        write => sub { $h->push_write(@_) },
        close => sub { $h->push_shutdown },
    );
    $o->write(@stuff);
    $o->close;
  
  Creates an instant object that can react to methods passed in the
  constructor. Handy to create when you need to create an IO stream
  object for input or errors.
  
  =item response_cb
  
  See L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =cut
  
  
  
PLACK_UTIL

$fatpacked{"Plack/Util/Accessor.pm"} = <<'PLACK_UTIL_ACCESSOR';
  package Plack::Util::Accessor;
  use strict;
  use warnings;
  
  sub import {
      shift;
      return unless @_;
      my $package = caller();
      mk_accessors( $package, @_ );
  }
  
  sub mk_accessors {
      my $package = shift;
      no strict 'refs';
      foreach my $field ( @_ ) {
          *{ $package . '::' . $field } = sub {
              return $_[0]->{ $field } if scalar( @_ ) == 1;
              return $_[0]->{ $field }  = scalar( @_ ) == 2 ? $_[1] : [ @_[1..$#_] ];
          };
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util::Accessor - Accessor generation utility for Plack
  
  =head1 DESCRIPTION
  
  This module is just a simple accessor generator for Plack to replace
  the Class::Accessor::Fast usage and so our classes don't have to inherit
  from their accessor generator.
  
  =head1 SEE ALSO
  
  L<PSGI> L<http://plackperl.org/>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_UTIL_ACCESSOR

$fatpacked{"Protocol/WebSocket.pm"} = <<'PROTOCOL_WEBSOCKET';
  package Protocol::WebSocket;
  
  use strict;
  use warnings;
  
  our $VERSION = 0.00906;
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket - WebSocket protocol
  
  =head1 SYNOPSIS
  
      # Server side
      my $hs = Protocol::WebSocket::Handshake::Server->new;
  
      $hs->parse('some data from the client');
  
      $hs->is_done; # tells us when handshake is done
  
      # Passing version is important for backwards compatibility
      my $frame = Protocol::WebSocket::Frame->new(version => $hs->version);
  
      $frame->append('some data from the client');
  
      while (defined(my $message = $frame->next)) {
          if ($frame->is_close) {
  
              # Send close frame back
              send(
                  Protocol::WebSocket::Frame->new(
                      type    => 'close',
                      version => $version
                  )
              );
  
              return;
          }
  
          # We got a message!
      }
  
  =head1 DESCRIPTION
  
  Client/server WebSocket message and frame parser/constructor. This module does
  not provide a WebSocket server or client, but is made for using in http servers
  or clients to provide WebSocket support.
  
  L<Protocol::WebSocket> supports the following WebSocket protocol versions:
  
      draft-ietf-hybi-17 (latest)
      draft-ietf-hybi-10
      draft-ietf-hybi-00
      draft-hixie-75
  
  By default the latest version is used. The WebSocket version is detected
  automatically on the server side. On the client side you have set a C<version>
  attribute to an appropriate value.
  
  L<Protocol::WebSocket> itself does not contain any code and cannot be used
  directly. Instead the following modules should be used:
  
  =head2 L<Protocol::WebSocket::Handshake::Server>
  
  Server handshake parser and constructor.
  
  =head2 L<Protocol::WebSocket::Handshake::Client>
  
  Client handshake parser and constructor.
  
  =head2 L<Protocol::WebSocket::Frame>
  
  WebSocket frame parser and constructor.
  
  =head2 L<Protocol::WebSocket::Request>
  
  Low level WebSocket request parser and constructor.
  
  =head2 L<Protocol::WebSocket::Response>
  
  Low level WebSocket response parser and constructor.
  
  =head2 L<Protocol::WebSocket::URL>
  
  Low level WebSocket url parser and constructor.
  
  =head1 EXAMPLES
  
  For examples on how to use L<Protocol::WebSocket> with various event loops see
  C<examples/> directory in the distribution.
  
  =head1 CREDITS
  
  In order of appearance:
  
  Paul "LeoNerd" Evans
  
  Jon Gentle
  
  Lee Aylward
  
  Chia-liang Kao
  
  =head1 AUTHOR
  
  Viacheslav Tykhanovskyi, C<vti@cpan.org>.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2010-2011, Viacheslav Tykhanovskyi.
  
  This program is free software, you can redistribute it and/or modify it under
  the same terms as Perl 5.10.
  
  =cut
PROTOCOL_WEBSOCKET

$fatpacked{"Protocol/WebSocket/Cookie.pm"} = <<'PROTOCOL_WEBSOCKET_COOKIE';
  package Protocol::WebSocket::Cookie;
  
  use strict;
  use warnings;
  
  sub new {
      my $class = shift;
      $class = ref $class if ref $class;
  
      my $self = {@_};
      bless $self, $class;
  
      return $self;
  }
  
  sub pairs { @_ > 1 ? $_[0]->{pairs} = $_[1] : $_[0]->{pairs} }
  
  my $TOKEN         = qr/[^;,\s"]+/;
  my $NAME          = qr/[^;,\s"=]+/;
  my $QUOTED_STRING = qr/"(?:\\"|[^"])+"/;
  my $VALUE         = qr/(?:$TOKEN|$QUOTED_STRING)/;
  
  sub parse {
      my $self   = shift;
      my $string = shift;
  
      $self->{pairs} = [];
  
      return unless defined $string && $string ne '';
  
      while ($string =~ m/\s*($NAME)\s*(?:=\s*($VALUE))?;?/g) {
          my ($attr, $value) = ($1, $2);
          if (defined $value) {
              $value =~ s/^"//;
              $value =~ s/"$//;
              $value =~ s/\\"/"/g;
          }
          push @{$self->{pairs}}, [$attr, $value];
      }
  
      return $self;
  }
  
  sub to_string {
      my $self = shift;
  
      my $string = '';
  
      my @pairs;
      foreach my $pair (@{$self->pairs}) {
          my $string = '';
          $string .= $pair->[0];
  
          if (defined $pair->[1]) {
              $string .= '=';
              $string
                .= $pair->[1] !~ m/^$VALUE$/ ? "\"$pair->[1]\"" : $pair->[1];
          }
  
          push @pairs, $string;
      }
  
      return join '; ' => @pairs;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Cookie - Base class for WebSocket cookies
  
  =head1 DESCRIPTION
  
  A base class for L<Protocol::WebSocket::Cookie::Request> and
  L<Protocol::WebSocket::Cookie::Response>.
  
  =head1 ATTRIBUTES
  
  =head2 C<pairs>
  
  =head1 METHODS
  
  =head2 C<new>
  
  Create a new L<Protocol::WebSocket::Cookie> instance.
  
  =head2 C<parse>
  
  =head2 C<to_string>
  
  =cut
PROTOCOL_WEBSOCKET_COOKIE

$fatpacked{"Protocol/WebSocket/Cookie/Request.pm"} = <<'PROTOCOL_WEBSOCKET_COOKIE_REQUEST';
  package Protocol::WebSocket::Cookie::Request;
  
  use strict;
  use warnings;
  
  use base 'Protocol::WebSocket::Cookie';
  
  sub parse {
      my $self = shift;
  
      $self->SUPER::parse(@_);
  
      my $cookies = [];
  
      my $pair = shift @{$self->pairs};
      my $version = $pair->[1];
  
      my $cookie;
      foreach my $pair (@{$self->pairs}) {
          next unless defined $pair->[0];
  
          if ($pair->[0] =~ m/^[^\$]/) {
              push @$cookies, $cookie if defined $cookie;
  
              $cookie = $self->_build_cookie(
                  name    => $pair->[0],
                  value   => $pair->[1],
                  version => $version
              );
          }
          elsif ($pair->[0] eq '$Path') {
              $cookie->path($pair->[1]);
          }
          elsif ($pair->[0] eq '$Domain') {
              $cookie->domain($pair->[1]);
          }
      }
  
      push @$cookies, $cookie if defined $cookie;
  
      return $cookies;
  }
  
  sub name    { @_ > 1 ? $_[0]->{name}    = $_[1] : $_[0]->{name} }
  sub value   { @_ > 1 ? $_[0]->{value}   = $_[1] : $_[0]->{value} }
  sub version { @_ > 1 ? $_[0]->{version} = $_[1] : $_[0]->{version} }
  sub path    { @_ > 1 ? $_[0]->{path}    = $_[1] : $_[0]->{path} }
  sub domain  { @_ > 1 ? $_[0]->{domain}  = $_[1] : $_[0]->{domain} }
  
  sub _build_cookie { shift; Protocol::WebSocket::Cookie::Request->new(@_) }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Cookie::Request - WebSocket Cookie Request
  
  =head1 SYNOPSIS
  
      # Constructor
  
      # Parser
      my $cookie = Protocol::WebSocket::Cookie::Request->new;
      $cookies = $cookie->parse(
          '$Version=1; foo="bar"; $Path=/; bar=baz; $Domain=.example.com');
  
  =head1 DESCRIPTION
  
  Construct or parse a WebSocket request cookie.
  
  =head1 ATTRIBUTES
  
  =head2 C<name>
  
  =head2 C<value>
  
  =head2 C<version>
  
  =head2 C<path>
  
  =head2 C<domain>
  
  =head1 METHODS
  
  =head2 C<parse>
  
  Parse a WebSocket request cookie.
  
  =head2 C<to_string>
  
  Construct a WebSocket request cookie.
  
  =cut
PROTOCOL_WEBSOCKET_COOKIE_REQUEST

$fatpacked{"Protocol/WebSocket/Cookie/Response.pm"} = <<'PROTOCOL_WEBSOCKET_COOKIE_RESPONSE';
  package Protocol::WebSocket::Cookie::Response;
  
  use strict;
  use warnings;
  
  use base 'Protocol::WebSocket::Cookie';
  
  sub parse {
      my $self = shift;
  
      $self->SUPER::parse(@_);
  }
  
  sub to_string {
      my $self = shift;
  
      my $pairs = [];
  
      push @$pairs, [$self->{name}, $self->{value}];
  
      push @$pairs, ['Comment', $self->{comment}] if defined $self->{comment};
  
      push @$pairs, ['CommentURL', $self->{comment_url}]
        if defined $self->{comment_url};
  
      push @$pairs, ['Discard'] if $self->{discard};
  
      push @$pairs, ['Max-Age' => $self->{max_age}] if defined $self->{max_age};
  
      push @$pairs, ['Path'    => $self->{path}]    if defined $self->{path};
  
      if (defined $self->{portlist}) {
          $self->{portlist} = [$self->{portlist}]
            unless ref $self->{portlist} eq 'ARRAY';
          my $list = join ' ' => @{$self->{portlist}};
          push @$pairs, ['Port' => "\"$list\""];
      }
  
      push @$pairs, ['Secure'] if $self->{secure};
  
      push @$pairs, ['Version' => '1'];
  
      $self->pairs($pairs);
  
      return $self->SUPER::to_string;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Cookie::Response - WebSocket Cookie Response
  
  =head1 SYNOPSIS
  
      # Constructor
      my $cookie = Parser::WebSocket::Cookie::Response->new(
          name    => 'foo',
          value   => 'bar',
          discard => 1,
          max_age => 0
      );
      $cookie->to_string; # foo=bar; Discard; Max-Age=0; Version=1
  
      # Parser
      my $cookie = Parser::WebSocket::Cookie::Response->new;
      $cookie->parse('foo=bar; Discard; Max-Age=0; Version=1');
  
  =head1 DESCRIPTION
  
  Construct or parse a WebSocket response cookie.
  
  =head1 METHODS
  
  =head2 C<parse>
  
  Parse a WebSocket response cookie.
  
  =head2 C<to_string>
  
  Construct a WebSocket response cookie.
  
  =cut
PROTOCOL_WEBSOCKET_COOKIE_RESPONSE

$fatpacked{"Protocol/WebSocket/Frame.pm"} = <<'PROTOCOL_WEBSOCKET_FRAME';
  package Protocol::WebSocket::Frame;
  
  use strict;
  use warnings;
  
  use Config;
  use Encode ();
  use Scalar::Util 'readonly';
  
  use constant MAX_RAND_INT => 2 ** 32;
  use constant MATH_RANDOM_SECURE => eval "require Math::Random::Secure;";
  
  our %TYPES = (
      text   => 0x01,
      binary => 0x02,
      ping   => 0x09,
      pong   => 0x0a,
      close  => 0x08
  );
  
  sub new {
      my $class = shift;
      $class = ref $class if ref $class;
      my $buffer;
  
      if (@_ == 1) {
          $buffer = shift @_;
      }
      else {
          my %args = @_;
          $buffer = delete $args{buffer};
      }
  
      my $self = {@_};
      bless $self, $class;
  
      $buffer = '' unless defined $buffer;
  
      if (Encode::is_utf8($buffer)) {
          $self->{buffer} = Encode::encode('UTF-8', $buffer);
      }
      else {
          $self->{buffer} = $buffer;
      }
  
      $self->{version} ||= 'draft-ietf-hidy-10';
  
      $self->{fragments} = [];
  
      $self->{max_fragments_amount} ||= 128;
      $self->{max_payload_size}     ||= 65536;
  
      return $self;
  }
  
  sub version {
      my $self = shift;
  
      return $self->{version};
  }
  
  sub append {
      my $self = shift;
  
      return unless defined $_[0];
  
      $self->{buffer} .= $_[0];
      $_[0] = '' unless readonly $_[0];
  
      return $self;
  }
  
  sub next {
      my $self = shift;
  
      my $bytes = $self->next_bytes;
      return unless defined $bytes;
  
      return Encode::decode('UTF-8', $bytes);
  }
  
  sub fin    { @_ > 1 ? $_[0]->{fin}    = $_[1] : $_[0]->{fin} }
  sub rsv    { @_ > 1 ? $_[0]->{rsv}    = $_[1] : $_[0]->{rsv} }
  sub opcode { @_ > 1 ? $_[0]->{opcode} = $_[1] : $_[0]->{opcode} || 1 }
  sub masked { @_ > 1 ? $_[0]->{masked} = $_[1] : $_[0]->{masked} }
  
  sub is_ping   { $_[0]->opcode == 9 }
  sub is_pong   { $_[0]->opcode == 10 }
  sub is_close  { $_[0]->opcode == 8 }
  sub is_text   { $_[0]->opcode == 1 }
  sub is_binary { $_[0]->opcode == 2 }
  
  sub next_bytes {
      my $self = shift;
  
      if (   $self->version eq 'draft-hixie-75'
          || $self->version eq 'draft-ietf-hybi-00')
      {
          if ($self->{buffer} =~ s/^\xff\x00//) {
              $self->opcode(8);
              return '';
          }
  
          return unless $self->{buffer} =~ s/^[^\x00]*\x00(.*?)\xff//s;
  
          return $1;
      }
  
      return unless length $self->{buffer} >= 2;
  
      while (length $self->{buffer}) {
          my $hdr = substr($self->{buffer}, 0, 1);
  
          my @bits = split //, unpack("B*", $hdr);
  
          $self->fin($bits[0]);
          $self->rsv([@bits[1 .. 3]]);
  
          my $opcode = unpack('C', $hdr) & 0b00001111;
  
          my $offset = 1;    # FIN,RSV[1-3],OPCODE
  
          my $payload_len = unpack 'C', substr($self->{buffer}, 1, 1);
  
          my $masked = ($payload_len & 0b10000000) >> 7;
          $self->masked($masked);
  
          $offset += 1;      # + MASKED,PAYLOAD_LEN
  
          $payload_len = $payload_len & 0b01111111;
          if ($payload_len == 126) {
              return unless length($self->{buffer}) >= $offset + 2;
  
              $payload_len = unpack 'n', substr($self->{buffer}, $offset, 2);
  
              $offset += 2;
          }
          elsif ($payload_len > 126) {
              return unless length($self->{buffer}) >= $offset + 4;
  
              my $bits = join '', map { unpack 'B*', $_ } split //,
                substr($self->{buffer}, $offset, 8);
  
              # Most significant bit must be 0.
              # And here is a crazy way of doing it %)
              $bits =~ s{^.}{0};
  
              # Can we handle 64bit numbers?
              if ($Config{ivsize} <= 4 || $Config{longsize} < 8) {
                  $bits = substr($bits, 32);
                  $payload_len = unpack 'N', pack 'B*', $bits;
              }
              else {
                  $payload_len = unpack 'Q>', pack 'B*', $bits;
              }
  
              $offset += 8;
          }
  
          if ($payload_len > $self->{max_payload_size}) {
              $self->{buffer} = '';
              die
                "Payload is too big. Deny big message ($payload_len) or increase max_payload_size ($self->{max_payload_size})";
          }
  
          my $mask;
          if ($self->masked) {
              return unless length($self->{buffer}) >= $offset + 4;
  
              $mask = substr($self->{buffer}, $offset, 4);
              $offset += 4;
          }
  
          return if length($self->{buffer}) < $offset + $payload_len;
  
          my $payload = substr($self->{buffer}, $offset, $payload_len);
  
          if ($self->masked) {
              $payload = $self->_mask($payload, $mask);
          }
  
          substr($self->{buffer}, 0, $offset + $payload_len, '');
  
          # Injected control frame
          if (@{$self->{fragments}} && $opcode & 0b1000) {
              $self->opcode($opcode);
              return $payload;
          }
  
          if ($self->fin) {
              if (@{$self->{fragments}}) {
                  $self->opcode(shift @{$self->{fragments}});
              }
              else {
                  $self->opcode($opcode);
              }
              $payload = join '', @{$self->{fragments}}, $payload;
              $self->{fragments} = [];
              return $payload;
          }
          else {
  
              # Remember first fragment opcode
              if (!@{$self->{fragments}}) {
                  push @{$self->{fragments}}, $opcode;
              }
  
              push @{$self->{fragments}}, $payload;
  
              die "Too many fragments"
                if @{$self->{fragments}} > $self->{max_fragments_amount};
          }
      }
  
      return;
  }
  
  sub to_bytes {
      my $self = shift;
  
      if (   $self->version eq 'draft-hixie-75'
          || $self->version eq 'draft-ietf-hybi-00')
      {
          if ($self->{type} && $self->{type} eq 'close') {
              return "\xff\x00";
          }
  
          return "\x00" . $self->{buffer} . "\xff";
      }
  
      if (length $self->{buffer} > $self->{max_payload_size}) {
          die
            "Payload is too big. Send shorter messages or increase max_payload_size";
      }
  
      my $string = '';
  
      my $opcode;
      if (my $type = $self->{type}) {
          $opcode = $TYPES{$type};
      }
      else {
          $opcode = $self->opcode || 1;
      }
  
      $string .= pack 'C', ($opcode + 128);
  
      my $payload_len = length($self->{buffer});
      if ($payload_len <= 125) {
          $payload_len |= 0b10000000 if $self->masked;
          $string .= pack 'C', $payload_len;
      }
      elsif ($payload_len <= 0xffff) {
          $string .= pack 'C', 126 + ($self->masked ? 128 : 0);
          $string .= pack 'n', $payload_len;
      }
      else {
          $string .= pack 'C', 127 + ($self->masked ? 128 : 0);
  
          # Shifting by an amount >= to the system wordsize is undefined
          $string .= pack 'N', $Config{ivsize} <= 4 ? 0 : $payload_len >> 32;
          $string .= pack 'N', ($payload_len & 0xffffffff);
      }
  
      if ($self->masked) {
  
          my $mask = $self->{mask}
            || (
              MATH_RANDOM_SECURE
              ? Math::Random::Secure::irand(MAX_RAND_INT)
              : int(rand(MAX_RAND_INT))
            );
  
          $mask = pack 'N', $mask;
  
          $string .= $mask;
          $string .= $self->_mask($self->{buffer}, $mask);
      }
      else {
          $string .= $self->{buffer};
      }
  
      return $string;
  }
  
  sub to_string {
      my $self = shift;
  
      die 'DO NOT USE';
  
      if (   $self->version eq 'draft-hixie-75'
          || $self->version eq 'draft-ietf-hybi-00')
      {
          return "\x00" . Encode::decode('UTF-8', $self->{buffer}) . "\xff";
      }
  }
  
  sub _mask {
      my $self = shift;
      my ($payload, $mask) = @_;
  
      my @mask = split //, $mask;
  
      my @payload = split //, $payload;
      for (my $i = 0; $i < @payload; $i++) {
          my $j = $i % 4;
          $payload[$i] ^= $mask[$j];
      }
  
      return join '', @payload;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Frame - WebSocket Frame
  
  =head1 SYNOPSIS
  
      # Create frame
      my $frame = Protocol::WebSocket::Frame->new('123');
      $frame->to_bytes;
  
      # Parse frames
      my $frame = Protocol::WebSocket::Frame->new;
      $frame->append(...);
      $f->next; # get next message
      $f->next; # get another next message
  
  =head1 DESCRIPTION
  
  Construct or parse a WebSocket frame.
  
  =head1 RANDOM MASK GENERATION
  
  By default built-in C<rand> is used, this is not secure, so when
  L<Math::Random::Secure> is installed it is used instead.
  
  =head1 ATTRIBUTES
  
  =head2 C<type>
  
  Frame's type. C<text> by default. Other accepted values:
  
      binary
      ping
      pong
      close
  
  =head1 METHODS
  
  =head2 C<new>
  
      Protocol::WebSocket::Frame->new('data');
      Protocol::WebSocket::Frame->new(buffer => 'data', type => 'close');
  
  Create a new L<Protocol::WebSocket::Frame> instance. Automatically detect if the
  passed data is a Perl string or bytes.
  
  =head2 C<is_text>
  
  Check if frame is of text type.
  
  =head2 C<is_binary>
  
  Check if frame is of binary type.
  
  =head2 C<is_ping>
  
  Check if frame is a ping request.
  
  =head2 C<is_pong>
  
  Check if frame is a pong response.
  
  =head2 C<is_close>
  
  Check if frame is of close type.
  
  =head2 C<append>
  
      $frame->append(...);
  
  Append a frame chunk.
  
  =head2 C<next>
  
      $frame->append(...);
  
      $frame->next; # next message
  
  Return the next message as a Perl string.
  
  =head2 C<next_bytes>
  
  Return the next message as a UTF-8 encoded string.
  
  =head2 C<to_bytes>
  
  Construct a WebSocket message as a UTF-8 encoded string.
  
  =cut
PROTOCOL_WEBSOCKET_FRAME

$fatpacked{"Protocol/WebSocket/Handshake.pm"} = <<'PROTOCOL_WEBSOCKET_HANDSHAKE';
  package Protocol::WebSocket::Handshake;
  
  use strict;
  use warnings;
  
  use Protocol::WebSocket::Request;
  use Protocol::WebSocket::Response;
  
  sub new {
      my $class = shift;
      $class = ref $class if ref $class;
  
      my $self = {@_};
      bless $self, $class;
  
      return $self;
  }
  
  sub error { @_ > 1 ? $_[0]->{error} = $_[1] : $_[0]->{error} }
  
  sub version { $_[0]->req->version }
  
  sub req { shift->{req} ||= Protocol::WebSocket::Request->new }
  sub res { shift->{res} ||= Protocol::WebSocket::Response->new }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Handshake - Base WebSocket Handshake class
  
  =head1 DESCRIPTION
  
  This is a base class for L<Protocol::WebSocket::Handshake::Client> and
  L<Protocol::WebSocket::Handshake::Server>.
  
  =head1 ATTRIBUTES
  
  =head2 C<error>
  
      $handshake->error;
  
  Set or get handshake error.
  
  =head2 C<version>
  
      $handshake->version;
  
  Set or get handshake version.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Create a new L<Protocol::WebSocket::Handshake> instance.
  
  =head2 C<req>
  
      $handshake->req;
  
  WebSocket request object.
  
  =head2 C<res>
  
      $handshake->res;
  
  WebSocket response object.
  
  =cut
PROTOCOL_WEBSOCKET_HANDSHAKE

$fatpacked{"Protocol/WebSocket/Handshake/Client.pm"} = <<'PROTOCOL_WEBSOCKET_HANDSHAKE_CLIENT';
  package Protocol::WebSocket::Handshake::Client;
  
  use strict;
  use warnings;
  
  use base 'Protocol::WebSocket::Handshake';
  
  require Carp;
  
  use Protocol::WebSocket::URL;
  
  sub new {
      my $self = shift->SUPER::new(@_);
  
      $self->_set_url($self->{url}) if defined $self->{url};
  
      if (my $version = $self->{version}) {
          $self->req->version($version);
          $self->res->version($version);
      }
  
      return $self;
  }
  
  sub url {
      my $self = shift;
      my $url  = shift;
  
      return $self->{url} unless $url;
  
      $self->_set_url($url);
  
      return $self;
  }
  
  sub parse {
      my $self  = shift;
  
      my $req = $self->req;
      my $res = $self->res;
  
      unless ($res->is_done) {
          unless ($res->parse($_[0])) {
              $self->error($res->error);
              return;
          }
  
          if ($res->is_done) {
              if (   $req->version eq 'draft-ietf-hybi-00'
                  && $req->checksum ne $res->checksum)
              {
                  $self->error('Checksum is wrong.');
                  return;
              }
          }
      }
  
      return 1;
  }
  
  sub is_done   { shift->res->is_done }
  sub to_string { shift->req->to_string }
  
  sub _build_url { Protocol::WebSocket::URL->new }
  
  sub _set_url {
      my $self = shift;
      my $url  = shift;
  
      $url = $self->_build_url->parse($url) unless ref $url;
  
      $self->req->secure(1) if $url->secure;
  
      my $req = $self->req;
  
      my $host = $url->host;
      $host .= ':' . $url->port if defined $url->port;
      $req->host($host);
  
      $req->resource_name($url->resource_name);
  
      return $self;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Handshake::Client - WebSocket Client Handshake
  
  =head1 SYNOPSIS
  
      my $h =
        Protocol::WebSocket::Handshake::Client->new(url => 'ws://example.com');
  
      # Create request
      $h->to_string;
  
      # Parse server response
      $h->parse(<<"EOF");
          WebSocket HTTP message
      EOF
  
      $h->error;   # Check if there were any errors
      $h->is_done; # Returns 1
  
  =head1 DESCRIPTION
  
  Construct or parse a client WebSocket handshake. This module is written for
  convenience, since using request and response directly requires the same code
  again and again.
  
  =head1 ATTRIBUTES
  
  =head2 C<url>
  
      $handshake->url('ws://example.com/demo');
  
  Set or get WebSocket url.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Create a new L<Protocol::WebSocket::Handshake::Client> instance.
  
  =head2 C<parse>
  
      $handshake->parse($buffer);
  
  Parse a WebSocket server response. Returns C<undef> and sets C<error> attribute
  on error. Buffer is modified.
  
  =head2 C<to_string>
  
  Construct a WebSocket client request.
  
  =head2 C<is_done>
  
  Check whether handshake is done.
  
  =cut
PROTOCOL_WEBSOCKET_HANDSHAKE_CLIENT

$fatpacked{"Protocol/WebSocket/Handshake/Server.pm"} = <<'PROTOCOL_WEBSOCKET_HANDSHAKE_SERVER';
  package Protocol::WebSocket::Handshake::Server;
  
  use strict;
  use warnings;
  
  use base 'Protocol::WebSocket::Handshake';
  
  use Protocol::WebSocket::Request;
  
  sub new_from_psgi {
      my $class = shift;
  
      my $req = Protocol::WebSocket::Request->new_from_psgi(@_);
      my $self = $class->new(req => $req);
  
      return $self;
  }
  
  sub parse {
      my $self = shift;
  
      my $req = $self->req;
      my $res = $self->res;
  
      return 1 if $req->is_done;
  
      unless ($req->parse($_[0])) {
          $self->error($req->error);
          return;
      }
  
      return 1 unless $req->is_done;
  
      $res->version($req->version);
      $res->host($req->host);
  
      $res->secure($req->secure);
      $res->resource_name($req->resource_name);
      $res->origin($req->origin);
  
      if ($req->version eq 'draft-ietf-hybi-00') {
          $res->number1($req->number1);
          $res->number2($req->number2);
          $res->challenge($req->challenge);
      }
      elsif ($req->version eq 'draft-ietf-hybi-10'
          || $req->version eq 'draft-ietf-hybi-17')
      {
          $res->key($req->key);
      }
  
      return 1;
  }
  
  sub is_done   { shift->req->is_done }
  sub to_string { shift->res->to_string }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Handshake::Server - WebSocket Server Handshake
  
  =head1 SYNOPSIS
  
      my $h = Protocol::WebSocket::Handshake::Server->new;
  
      # Parse client request
      $h->parse(<<"EOF");
          WebSocket HTTP message
      EOF
  
      $h->error;   # Check if there were any errors
      $h->is_done; # Returns 1
  
      # Create response
      $h->to_string;
  
  =head1 DESCRIPTION
  
  Construct or parse a server WebSocket handshake. This module is written for
  convenience, since using request and response directly requires the same code
  again and again.
  
  =head1 METHODS
  
  =head2 C<new>
  
  Create a new L<Protocol::WebSocket::Handshake::Server> instance.
  
  =head2 C<new_from_psgi>
  
      my $env = {
          HTTP_HOST => 'example.com',
          HTTP_CONNECTION => 'Upgrade',
          ...
      };
      my $handshake = Protocol::WebSocket::Handshake::Server->new_from_psgi($env);
  
  Create a new L<Protocol::WebSocket::Handshake::Server> instance from L<PSGI>
  environment.
  
  =head2 C<parse>
  
      $handshake->parse($buffer);
      $handshake->parse($handle);
  
  Parse a WebSocket client request. Returns C<undef> and sets C<error> attribute
  on error.
  
  When buffer is passed it's modified (unless readonly).
  
  =head2 C<to_string>
  
  Construct a WebSocket server response.
  
  =head2 C<is_done>
  
  Check whether handshake is done.
  
  =cut
PROTOCOL_WEBSOCKET_HANDSHAKE_SERVER

$fatpacked{"Protocol/WebSocket/Message.pm"} = <<'PROTOCOL_WEBSOCKET_MESSAGE';
  package Protocol::WebSocket::Message;
  
  use strict;
  use warnings;
  
  use base 'Protocol::WebSocket::Stateful';
  
  use Scalar::Util qw(readonly);
  require Digest::MD5;
  
  sub new {
      my $class = shift;
      $class = ref $class if ref $class;
  
      my $self = {@_};
      bless $self, $class;
  
      $self->{version} ||= '';
  
      $self->{buffer} = '';
  
      $self->{fields} ||= {};
  
      $self->{max_message_size} ||= 2048;
  
      $self->{cookies} ||= [];
  
      $self->state('first_line');
  
      return $self;
  }
  
  sub secure { @_ > 1 ? $_[0]->{secure} = $_[1] : $_[0]->{secure} }
  
  sub fields { shift->{fields} }
  
  sub field {
      my $self = shift;
      my $name = lc shift;
  
      return $self->fields->{$name} unless @_;
  
      $self->fields->{$name} = $_[0];
  
      return $self;
  }
  
  sub error {
      my $self = shift;
  
      return $self->{error} unless @_;
  
      my $error = shift;
      $self->{error} = $error;
      $self->state('error');
  
      return $self;
  }
  
  sub subprotocol {
      @_ > 1 ? $_[0]->{subprotocol} = $_[1] : $_[0]->{subprotocol};
  }
  
  sub host   { @_ > 1 ? $_[0]->{host}   = $_[1] : $_[0]->{host} }
  sub origin { @_ > 1 ? $_[0]->{origin} = $_[1] : $_[0]->{origin} }
  
  sub version { @_ > 1 ? $_[0]->{version} = $_[1] : $_[0]->{version} }
  
  sub number1   { @_ > 1 ? $_[0]->{number1}   = $_[1] : $_[0]->{number1} }
  sub number2   { @_ > 1 ? $_[0]->{number2}   = $_[1] : $_[0]->{number2} }
  sub challenge { @_ > 1 ? $_[0]->{challenge} = $_[1] : $_[0]->{challenge} }
  
  sub checksum {
      my $self     = shift;
      my $checksum = shift;
  
      if (defined $checksum) {
          $self->{checksum} = $checksum;
          return $self;
      }
  
      return $self->{checksum} if defined $self->{checksum};
  
      Carp::croak(qq/number1 is required/)   unless defined $self->number1;
      Carp::croak(qq/number2 is required/)   unless defined $self->number2;
      Carp::croak(qq/challenge is required/) unless defined $self->challenge;
  
      $checksum = '';
      $checksum .= pack 'N' => $self->number1;
      $checksum .= pack 'N' => $self->number2;
      $checksum .= $self->challenge;
      $checksum = Digest::MD5::md5($checksum);
  
      return $self->{checksum} ||= $checksum;
  }
  
  sub parse {
      my $self = shift;
  
      return 1 unless defined $_[0];
  
      return if $self->error;
  
      return unless $self->_append(@_);
  
      while (!$self->is_state('body') && defined(my $line = $self->_get_line)) {
          if ($self->state eq 'first_line') {
              return unless defined $self->_parse_first_line($line);
  
              $self->state('fields');
          }
          elsif ($line ne '') {
              return unless defined $self->_parse_field($line);
          }
          else {
              $self->state('body');
              last;
          }
      }
  
      return 1 unless $self->is_state('body');
  
      my $rv = $self->_parse_body;
      return unless defined $rv;
  
      # Need more data
      return $rv unless ref $rv;
  
      $_[0] = $self->{buffer} unless readonly $_[0] || ref $_[0];
      return $self->done;
  }
  
  sub _extract_number {
      my $self = shift;
      my $key  = shift;
  
      my $number = join '' => $key =~ m/\d+/g;
      my $spaces = $key =~ s/ / /g;
  
      return if $spaces == 0;
  
      return int($number / $spaces);
  }
  
  sub _append {
      my $self = shift;
  
      return if $self->error;
  
      if (ref $_[0]) {
          $_[0]->read(my $buf, $self->{max_message_size});
          $self->{buffer} .= $buf;
      }
      else {
          $self->{buffer} .= $_[0];
          $_[0] = '' unless readonly $_[0];
      }
  
      if (length $self->{buffer} > $self->{max_message_size}) {
          $self->error('Message is too long');
          return;
      }
  
      return $self;
  }
  
  sub _get_line {
      my $self = shift;
  
      if ($self->{buffer} =~ s/^(.*?)\x0d?\x0a//) {
          return $1;
      }
  
      return;
  }
  
  sub _parse_first_line {shift}
  
  sub _parse_field {
      my $self = shift;
      my $line = shift;
  
      my ($name, $value) = split /:\s*/ => $line => 2;
      unless (defined $name && defined $value) {
          $self->error('Invalid field');
          return;
      }
  
      #$name =~ s/^Sec-WebSocket-Origin$/Origin/i; # FIXME
      $self->field($name => $value);
  
      if ($name =~ m/^x-forwarded-proto$/i) {
          $self->secure(1);
      }
  
      return $self;
  }
  
  sub _parse_body {shift}
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Message - Base class for WebSocket request and response
  
  =head1 DESCRIPTION
  
  A base class for L<Protocol::WebSocket::Request> and
  L<Protocol::WebSocket::Response>.
  
  =head1 ATTRIBUTES
  
  =head2 C<version>
  
  =head2 C<fields>
  
  =head2 C<field>
  
  =head2 C<host>
  
  =head2 C<origin>
  
  =head2 C<secure>
  
  =head2 C<subprotocol>
  
  =head2 C<error>
  
  =head2 C<number1>
  
  =head2 C<number2>
  
  =head2 C<challenge>
  
  =head1 METHODS
  
  =head2 C<new>
  
  Create a new L<Protocol::WebSocket::Message> instance.
  
  =head2 C<checksum>
  
  =head2 C<parse>
  
  =cut
PROTOCOL_WEBSOCKET_MESSAGE

$fatpacked{"Protocol/WebSocket/Request.pm"} = <<'PROTOCOL_WEBSOCKET_REQUEST';
  package Protocol::WebSocket::Request;
  
  use strict;
  use warnings;
  
  use base 'Protocol::WebSocket::Message';
  
  require Carp;
  use MIME::Base64 ();
  
  use Protocol::WebSocket::Cookie::Request;
  
  sub new_from_psgi {
      my $class = shift;
      my $env = @_ > 1 ? {@_} : shift;
  
      Carp::croak('env is required') unless keys %$env;
  
      my $version = '';
  
      my $fields = {
          upgrade    => $env->{HTTP_UPGRADE},
          connection => $env->{HTTP_CONNECTION},
          host       => $env->{HTTP_HOST},
      };
  
      if ($env->{HTTP_WEBSOCKET_PROTOCOL}) {
          $fields->{'websocket-protocol'} =
            $env->{HTTP_WEBSOCKET_PROTOCOL};
      }
      elsif ($env->{HTTP_SEC_WEBSOCKET_PROTOCOL}) {
          $fields->{'sec-websocket-protocol'} =
            $env->{HTTP_SEC_WEBSOCKET_PROTOCOL};
      }
  
      if (exists $env->{HTTP_SEC_WEBSOCKET_VERSION}) {
          $fields->{'sec-websocket-version'} =
            $env->{HTTP_SEC_WEBSOCKET_VERSION};
          if ($env->{HTTP_SEC_WEBSOCKET_VERSION} eq '13') {
              $version = 'draft-ietf-hybi-17';
          }
          else {
              $version = 'draft-ietf-hybi-10';
          }
      }
  
      if ($env->{HTTP_SEC_WEBSOCKET_KEY}) {
          $fields->{'sec-websocket-key'} = $env->{HTTP_SEC_WEBSOCKET_KEY};
      }
      elsif ($env->{HTTP_SEC_WEBSOCKET_KEY1}) {
          $version = 'draft-ietf-hybi-00';
          $fields->{'sec-websocket-key1'} = $env->{HTTP_SEC_WEBSOCKET_KEY1};
          $fields->{'sec-websocket-key2'} = $env->{HTTP_SEC_WEBSOCKET_KEY2};
      }
  
      if ($version eq 'draft-ietf-hybi-10') {
          $fields->{'sec-websocket-origin'} = $env->{HTTP_SEC_WEBSOCKET_ORIGIN};
      }
      else {
          $fields->{origin} = $env->{HTTP_ORIGIN};
      }
  
      my $self = $class->new(
          version       => $version,
          fields        => $fields,
          resource_name => "$env->{SCRIPT_NAME}$env->{PATH_INFO}"
            . ($env->{QUERY_STRING} ? "?$env->{QUERY_STRING}" : "")
      );
      $self->state('body');
  
      if (   $env->{HTTP_X_FORWARDED_PROTO}
          && $env->{HTTP_X_FORWARDED_PROTO} eq 'https')
      {
          $self->secure(1);
      }
  
      return $self;
  }
  
  sub cookies { shift->{cookies} }
  
  sub resource_name {
      @_ > 1 ? $_[0]->{resource_name} = $_[1] : $_[0]->{resource_name} || '/';
  }
  
  sub upgrade    { shift->field('Upgrade') }
  sub connection { shift->field('Connection') }
  
  sub number1 { shift->_number('number1', 'key1', @_) }
  sub number2 { shift->_number('number2', 'key2', @_) }
  
  sub key  { shift->_key('key'  => @_) }
  sub key1 { shift->_key('key1' => @_) }
  sub key2 { shift->_key('key2' => @_) }
  
  sub to_string {
      my $self = shift;
  
      my $version = $self->version || 'draft-ietf-hybi-17';
  
      my $string = '';
  
      Carp::croak(qq/resource_name is required/)
        unless defined $self->resource_name;
      $string .= "GET " . $self->resource_name . " HTTP/1.1\x0d\x0a";
  
      $string .= "Upgrade: WebSocket\x0d\x0a";
      $string .= "Connection: Upgrade\x0d\x0a";
  
      Carp::croak(qq/Host is required/) unless defined $self->host;
      $string .= "Host: " . $self->host . "\x0d\x0a";
  
      my $origin = $self->origin ? $self->origin : 'http://' . $self->host;
      $origin =~ s{^http:}{https:} if $self->secure;
      $string .= (
          $version eq 'draft-ietf-hybi-10'
          ? "Sec-WebSocket-Origin"
          : "Origin"
        )
        . ': '
        . $origin
        . "\x0d\x0a";
  
      if ($version eq 'draft-ietf-hybi-10' || $version eq 'draft-ietf-hybi-17') {
          my $key = $self->key;
  
          if (!$key) {
              $key = '';
              $key .= chr(int(rand(256))) for 1 .. 16;
  
              $key = MIME::Base64::encode_base64($key);
              $key =~ s{\s+}{}g;
          }
  
          $string
            .= 'Sec-WebSocket-Protocol: ' . $self->subprotocol . "\x0d\x0a"
            if defined $self->subprotocol;
  
          $string .= 'Sec-WebSocket-Key: ' . $key . "\x0d\x0a";
          $string
            .= 'Sec-WebSocket-Version: '
            . ($version eq 'draft-ietf-hybi-17' ? 13 : 8)
            . "\x0d\x0a";
      }
      elsif ($version eq 'draft-ietf-hybi-00') {
          $self->_generate_keys;
  
          $string
            .= 'Sec-WebSocket-Protocol: ' . $self->subprotocol . "\x0d\x0a"
            if defined $self->subprotocol;
  
          $string .= 'Sec-WebSocket-Key1: ' . $self->key1 . "\x0d\x0a";
          $string .= 'Sec-WebSocket-Key2: ' . $self->key2 . "\x0d\x0a";
  
          $string .= 'Content-Length: ' . length($self->challenge) . "\x0d\x0a";
      }
      elsif ($version eq 'draft-hixie-75') {
          $string .= 'WebSocket-Protocol: ' . $self->subprotocol . "\x0d\x0a"
            if defined $self->subprotocol;
      }
      else {
          Carp::croak('Version ' . $self->version . ' is not supported');
      }
  
      # TODO cookies
  
      $string .= "\x0d\x0a";
  
      $string .= $self->challenge if $version eq 'draft-ietf-hybi-00';
  
      return $string;
  }
  
  sub _parse_first_line {
      my ($self, $line) = @_;
  
      my ($req, $resource_name, $http) = split ' ' => $line;
  
      unless ($req && $resource_name && $http) {
          $self->error('Wrong request line');
          return;
      }
  
      unless ($req eq 'GET' && $http eq 'HTTP/1.1') {
          $self->error('Wrong method or http version');
          return;
      }
  
      $self->resource_name($resource_name);
  
      return $self;
  }
  
  sub _parse_body {
      my $self = shift;
  
      if ($self->key1 && $self->key2) {
          return 1 if length $self->{buffer} < 8;
  
          my $challenge = substr $self->{buffer}, 0, 8, '';
          $self->challenge($challenge);
  
          $self->version('draft-ietf-hybi-00');
      }
      elsif ($self->key) {
          if ($self->field('sec-websocket-version') eq '13') {
              $self->version('draft-ietf-hybi-17');
          }
          else {
              $self->version('draft-ietf-hybi-10');
          }
      }
      else {
          $self->version('draft-hixie-75');
      }
  
      if (length $self->{buffer}) {
          $self->error('Leftovers');
          return;
      }
  
      return $self if $self->_finalize;
  
      $self->error('Not a valid request');
      return;
  }
  
  sub _number {
      my $self = shift;
      my ($name, $key, $value) = @_;
  
      if (defined $value) {
          $self->{$name} = $value;
          return $self;
      }
  
      return $self->{$name} if defined $self->{$name};
  
      return $self->{$name} ||= $self->_extract_number($self->$key);
  }
  
  sub _key {
      my $self  = shift;
      my $name  = shift;
      my $value = shift;
  
      unless (defined $value) {
          if (my $value = delete $self->{$name}) {
              $self->field("Sec-WebSocket-" . ucfirst($name) => $value);
          }
  
          return $self->field("Sec-WebSocket-" . ucfirst($name));
      }
  
      $self->field("Sec-WebSocket-" . ucfirst($name) => $value);
  
      return $self;
  }
  
  sub _generate_keys {
      my $self = shift;
  
      unless ($self->key1) {
          my ($number, $key) = $self->_generate_key;
          $self->number1($number);
          $self->key1($key);
      }
  
      unless ($self->key2) {
          my ($number, $key) = $self->_generate_key;
          $self->number2($number);
          $self->key2($key);
      }
  
      $self->challenge($self->_generate_challenge) unless $self->challenge;
  
      return $self;
  }
  
  sub _generate_key {
      my $self = shift;
  
      # A random integer from 1 to 12 inclusive
      my $spaces = int(rand(12)) + 1;
  
      # The largest integer not greater than 4,294,967,295 divided by spaces
      my $max = int(4_294_967_295 / $spaces);
  
      # A random integer from 0 to $max inclusive
      my $number = int(rand($max + 1));
  
      # The result of multiplying $number and $spaces together
      my $product = $number * $spaces;
  
      # A string consisting of $product, expressed in base ten
      my $key = "$product";
  
      # Insert between one and twelve random characters from the ranges U+0021
      # to U+002F and U+003A to U+007E into $key at random positions.
      my $random_characters = int(rand(12)) + 1;
  
      for (1 .. $random_characters) {
  
          # From 0 to the last position
          my $random_position = int(rand(length($key) + 1));
  
          # Random character
          my $random_character = chr(
                int(rand(2))
              ? int(rand(0x2f - 0x21 + 1)) + 0x21
              : int(rand(0x7e - 0x3a + 1)) + 0x3a
          );
  
          # Insert random character at random position
          substr $key, $random_position, 0, $random_character;
      }
  
      # Insert $spaces U+0020 SPACE characters into $key at random positions
      # other than the start or end of the string.
      for (1 .. $spaces) {
  
          # From 1 to the last-1 position
          my $random_position = int(rand(length($key) - 1)) + 1;
  
          # Insert
          substr $key, $random_position, 0, ' ';
      }
  
      return ($number, $key);
  }
  
  sub _generate_challenge {
      my $self = shift;
  
      # A string consisting of eight random bytes (or equivalently, a random 64
      # bit integer encoded in big-endian order).
      my $challenge = '';
  
      $challenge .= chr(int(rand(256))) for 1 .. 8;
  
      return $challenge;
  }
  
  sub _finalize {
      my $self = shift;
  
      return unless $self->upgrade && lc $self->upgrade eq 'websocket';
  
      my $connection = $self->connection;
      return unless $connection;
  
      my @connections = split /\s*,\s*/, $connection;
      return unless grep { lc $_ eq 'upgrade' } @connections;
  
      my $origin = $self->field('Sec-WebSocket-Origin') || $self->field('Origin');
      return unless $origin;
      $self->origin($origin);
  
      $self->secure(1) if $self->origin =~ m{^https:};
  
      my $host = $self->field('Host');
      return unless $host;
      $self->host($host);
  
      my $subprotocol = $self->field('Sec-WebSocket-Protocol')
        || $self->field('WebSocket-Protocol');
      $self->subprotocol($subprotocol) if $subprotocol;
  
      my $cookie = $self->_build_cookie;
      if (my $cookies = $cookie->parse($self->field('Cookie'))) {
          $self->{cookies} = $cookies;
      }
  
      return $self;
  }
  
  sub _build_cookie { Protocol::WebSocket::Cookie::Request->new }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Request - WebSocket Request
  
  =head1 SYNOPSIS
  
      # Constructor
      my $req = Protocol::WebSocket::Request->new(
          host          => 'example.com',
          resource_name => '/demo'
      );
      $req->to_string; # GET /demo HTTP/1.1
                       # Upgrade: WebSocket
                       # Connection: Upgrade
                       # Host: example.com
                       # Origin: http://example.com
                       # Sec-WebSocket-Key1: 32 0  3lD& 24+<    i u4  8! -6/4
                       # Sec-WebSocket-Key2: 2q 4  2  54 09064
                       #
                       # x#####
  
      # Parser
      my $req = Protocol::WebSocket::Request->new;
      $req->parse("GET /demo HTTP/1.1\x0d\x0a");
      $req->parse("Upgrade: WebSocket\x0d\x0a");
      $req->parse("Connection: Upgrade\x0d\x0a");
      $req->parse("Host: example.com\x0d\x0a");
      $req->parse("Origin: http://example.com\x0d\x0a");
      $req->parse(
          "Sec-WebSocket-Key1: 18x 6]8vM;54 *(5:  {   U1]8  z [  8\x0d\x0a");
      $req->parse(
          "Sec-WebSocket-Key2: 1_ tx7X d  <  nw  334J702) 7]o}` 0\x0d\x0a");
      $req->parse("\x0d\x0aTm[K T2u");
  
  =head1 DESCRIPTION
  
  Construct or parse a WebSocket request.
  
  =head1 ATTRIBUTES
  
  =head2 C<host>
  
  =head2 C<key1>
  
  =head2 C<key2>
  
  =head2 C<number1>
  
  =head2 C<number2>
  
  =head2 C<origin>
  
  =head2 C<resource_name>
  
  =head1 METHODS
  
  =head2 C<new>
  
  Create a new L<Protocol::WebSocket::Request> instance.
  
  =head2 C<new_from_psgi>
  
      my $env = {
          HTTP_HOST => 'example.com',
          HTTP_CONNECTION => 'Upgrade',
          ...
      };
      my $req = Protocol::WebSocket::Request->new_from_psgi($env);
  
  Create a new L<Protocol::WebSocket::Request> instance from L<PSGI> environment.
  
  =head2 C<parse>
  
      $req->parse($buffer);
      $req->parse($handle);
  
  Parse a WebSocket request. Incoming buffer is modified.
  
  =head2 C<to_string>
  
  Construct a WebSocket request.
  
  =head2 C<connection>
  
      $self->connection;
  
  A shortcut for C<$self->field('Connection')>.
  
  =head2 C<cookies>
  
  =head2 C<upgrade>
  
      $self->upgrade;
  
  A shortcut for C<$self->field('Upgrade')>.
  
  =cut
PROTOCOL_WEBSOCKET_REQUEST

$fatpacked{"Protocol/WebSocket/Response.pm"} = <<'PROTOCOL_WEBSOCKET_RESPONSE';
  package Protocol::WebSocket::Response;
  
  use strict;
  use warnings;
  
  use base 'Protocol::WebSocket::Message';
  
  require Carp;
  use MIME::Base64 ();
  use Digest::SHA1 ();
  
  use Protocol::WebSocket::URL;
  use Protocol::WebSocket::Cookie::Response;
  
  sub location { @_ > 1 ? $_[0]->{location} = $_[1] : $_[0]->{location} }
  
  sub resource_name {
      @_ > 1 ? $_[0]->{resource_name} = $_[1] : $_[0]->{resource_name};
  }
  
  sub cookies { @_ > 1 ? $_[0]->{cookies} = $_[1] : $_[0]->{cookies} }
  
  sub cookie {
      my $self = shift;
  
      push @{$self->{cookies}}, $self->_build_cookie(@_);
  }
  
  sub key { @_ > 1 ? $_[0]->{key} = $_[1] : $_[0]->{key} }
  
  sub number1 { shift->_number('number1', 'key1', @_) }
  sub number2 { shift->_number('number2', 'key2', @_) }
  
  sub _number {
      my $self = shift;
      my ($name, $key, $value) = @_;
  
      my $method = "SUPER::$name";
      return $self->$method($value) if defined $value;
  
      $value = $self->$method();
      $value = $self->_extract_number($self->$key) if not defined $value;
  
      return $value;
  }
  
  sub key1 { @_ > 1 ? $_[0]->{key1} = $_[1] : $_[0]->{key1} }
  sub key2 { @_ > 1 ? $_[0]->{key2} = $_[1] : $_[0]->{key2} }
  
  sub status {
      return '101';
  }
  
  sub headers {
      my $self = shift;
  
      my $version = $self->version || 'draft-ietf-hybi-10';
  
      my $headers = [];
  
      push @$headers, Upgrade => 'WebSocket';
      push @$headers, Connection => 'Upgrade';
  
      if ($version eq 'draft-hixie-75' || $version eq 'draft-ietf-hybi-00') {
          Carp::croak(qq/host is required/) unless defined $self->host;
  
          my $location = $self->_build_url(
              host          => $self->host,
              secure        => $self->secure,
              resource_name => $self->resource_name,
          );
          my $origin =
            $self->origin ? $self->origin : 'http://' . $location->host;
          $origin =~ s{^http:}{https:} if !$self->origin && $self->secure;
  
          if ($version eq 'draft-hixie-75') {
              push @$headers, 'WebSocket-Protocol' => $self->subprotocol
                if defined $self->subprotocol;
              push @$headers, 'WebSocket-Origin'   => $origin;
              push @$headers, 'WebSocket-Location' => $location->to_string;
          }
          elsif ($version eq 'draft-ietf-hybi-00') {
              push @$headers, 'Sec-WebSocket-Protocol' => $self->subprotocol
                if defined $self->subprotocol;
              push @$headers, 'Sec-WebSocket-Origin'   => $origin;
              push @$headers, 'Sec-WebSocket-Location' => $location->to_string;
          }
      }
      elsif ($version eq 'draft-ietf-hybi-10' || $version eq 'draft-ietf-hybi-17') {
          Carp::croak(qq/key is required/) unless defined $self->key;
  
          my $key = $self->key;
          $key .= '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'; # WTF
          $key = Digest::SHA1::sha1($key);
          $key = MIME::Base64::encode_base64($key);
          $key =~ s{\s+}{}g;
  
          push @$headers, 'Sec-WebSocket-Accept' => $key;
  
          push @$headers, 'Sec-WebSocket-Protocol' => $self->subprotocol
            if defined $self->subprotocol;
      }
      else {
          Carp::croak('Version ' . $version . ' is not supported');
      }
  
      if (@{$self->cookies}) {
          my $cookie = join ',' => map { $_->to_string } @{$self->cookies};
          push @$headers, 'Set-Cookie' => $cookie;
      }
  
      return $headers;
  }
  
  sub body {
      my $self = shift;
  
      return $self->checksum if $self->version eq 'draft-ietf-hybi-00';
  
      return '';
  }
  
  sub to_string {
      my $self = shift;
  
      my $status = $self->status;
  
      my $string = '';
      $string .= "HTTP/1.1 $status WebSocket Protocol Handshake\x0d\x0a";
  
      for (my $i = 0; $i < @{$self->headers}; $i += 2) {
          my $key   = $self->headers->[$i];
          my $value = $self->headers->[$i + 1];
  
          $string .= "$key: $value\x0d\x0a";
      }
  
      $string .= "\x0d\x0a";
  
      $string .= $self->body;
  
      return $string;
  }
  
  sub _parse_first_line {
      my ($self, $line) = @_;
  
      my $status = $self->status;
      unless ($line =~ m{^HTTP/1\.1 $status }) {
          $self->error('Wrong response line');
          return;
      }
  
      return $self;
  }
  
  sub _parse_body {
      my $self = shift;
  
      if ($self->field('Sec-WebSocket-Accept')) {
          $self->version('draft-ietf-hybi-10');
      }
      elsif ($self->field('Sec-WebSocket-Origin')) {
          $self->version('draft-ietf-hybi-00');
  
          return 1 if length $self->{buffer} < 16;
  
          my $checksum = substr $self->{buffer}, 0, 16, '';
          $self->checksum($checksum);
      }
      else {
          $self->version('draft-hixie-75');
      }
  
      return $self if $self->_finalize;
  
      $self->error('Not a valid response');
      return;
  }
  
  sub _finalize {
      my $self = shift;
  
      if ($self->version eq 'draft-hixie-75') {
          my $location = $self->field('WebSocket-Location');
          return unless defined $location;
          $self->location($location);
  
          my $url = $self->_build_url;
          return unless $url->parse($self->location);
  
          $self->secure($url->secure);
          $self->host($url->host);
          $self->resource_name($url->resource_name);
  
          $self->origin($self->field('WebSocket-Origin'));
  
          $self->subprotocol($self->field('WebSocket-Protocol'));
      }
      elsif ($self->version eq 'draft-ietf-hybi-00') {
          my $location = $self->field('Sec-WebSocket-Location');
          return unless defined $location;
          $self->location($location);
  
          my $url = $self->_build_url;
          return unless $url->parse($self->location);
  
          $self->secure($url->secure);
          $self->host($url->host);
          $self->resource_name($url->resource_name);
  
          $self->origin($self->field('Sec-WebSocket-Origin'));
          $self->subprotocol($self->field('Sec-WebSocket-Protocol'));
      }
      else {
          $self->subprotocol($self->field('Sec-WebSocket-Protocol'));
      }
  
      return 1;
  }
  
  sub _build_url    { shift; Protocol::WebSocket::URL->new(@_) }
  sub _build_cookie { shift; Protocol::WebSocket::Cookie::Response->new(@_) }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Response - WebSocket Response
  
  =head1 SYNOPSIS
  
      # Constructor
      $res = Protocol::WebSocket::Response->new(
          host          => 'example.com',
          resource_name => '/demo',
          origin        => 'file://',
          number1       => 777_007_543,
          number2       => 114_997_259,
          challenge     => "\x47\x30\x22\x2D\x5A\x3F\x47\x58"
      );
      $res->to_string; # HTTP/1.1 101 WebSocket Protocol Handshake
                       # Upgrade: WebSocket
                       # Connection: Upgrade
                       # Sec-WebSocket-Origin: file://
                       # Sec-WebSocket-Location: ws://example.com/demo
                       #
                       # 0st3Rl&q-2ZU^weu
  
      # Parser
      $res = Protocol::WebSocket::Response->new;
      $res->parse("HTTP/1.1 101 WebSocket Protocol Handshake\x0d\x0a");
      $res->parse("Upgrade: WebSocket\x0d\x0a");
      $res->parse("Connection: Upgrade\x0d\x0a");
      $res->parse("Sec-WebSocket-Origin: file://\x0d\x0a");
      $res->parse("Sec-WebSocket-Location: ws://example.com/demo\x0d\x0a");
      $res->parse("\x0d\x0a");
      $res->parse("0st3Rl&q-2ZU^weu");
  
  =head1 DESCRIPTION
  
  Construct or parse a WebSocket response.
  
  =head1 ATTRIBUTES
  
  =head2 C<host>
  
  =head2 C<location>
  
  =head2 C<origin>
  
  =head2 C<resource_name>
  
  =head2 C<secure>
  
  =head1 METHODS
  
  =head2 C<new>
  
  Create a new L<Protocol::WebSocket::Response> instance.
  
  =head2 C<parse>
  
      $res->parse($buffer);
  
  Parse a WebSocket response. Incoming buffer is modified.
  
  =head2 C<to_string>
  
  Construct a WebSocket response.
  
  =head2 C<cookie>
  
  =head2 C<cookies>
  
  =head2 C<key1>
  
      $self->key1;
  
  Set or get C<Sec-WebSocket-Key1> field.
  
  =head2 C<key2>
  
      $self->key2;
  
  Set or get C<Sec-WebSocket-Key2> field.
  
  =head2 C<number1>
  
      $self->number1;
      $self->number1(123456);
  
  Set or extract from C<Sec-WebSocket-Key1> generated C<number> value.
  
  =head2 C<number2>
  
      $self->number2;
      $self->number2(123456);
  
  Set or extract from C<Sec-WebSocket-Key2> generated C<number> value.
  
  =head2 C<status>
  
      $self->status;
  
  Get response status (101).
  
  =head2 C<body>
  
      $self->body;
  
  Get response body.
  
  =head2 C<headers>
  
      my $arrayref = $self->headers;
  
  Get response headers.
  
  =cut
PROTOCOL_WEBSOCKET_RESPONSE

$fatpacked{"Protocol/WebSocket/Stateful.pm"} = <<'PROTOCOL_WEBSOCKET_STATEFUL';
  package Protocol::WebSocket::Stateful;
  
  use strict;
  use warnings;
  
  sub new {
      my $class = shift;
      $class = ref $class if ref $class;
  
      my $self = {@_};
      bless $self, $class;
  
      return $self;
  }
  
  sub state { @_ > 1 ? $_[0]->{state} = $_[1] : $_[0]->{state} }
  
  sub done     { shift->state('done') }
  sub is_state { shift->state eq shift }
  sub is_done  { shift->is_state('done') }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::Stateful - Base class for all classes with states
  
  =head1 DESCRIPTION
  
  A base class for all classes with states.
  
  =head1 ATTRIBUTES
  
  =head2 C<state>
  
  =head1 METHODS
  
  =head2 C<new>
  
  Create a new L<Protocol::WebSocket::Stateful> instance.
  
  =head2 C<done>
  
  =head2 C<is_state>
  
  =head2 C<is_done>
  
  =cut
PROTOCOL_WEBSOCKET_STATEFUL

$fatpacked{"Protocol/WebSocket/URL.pm"} = <<'PROTOCOL_WEBSOCKET_URL';
  package Protocol::WebSocket::URL;
  
  use strict;
  use warnings;
  
  sub new {
      my $class = shift;
      $class = ref $class if ref $class;
  
      my $self = {@_};
      bless $self, $class;
  
      $self->{secure} ||= 0;
  
      return $self;
  }
  
  sub secure { @_ > 1 ? $_[0]->{secure} = $_[1] : $_[0]->{secure} }
  
  sub host { @_ > 1 ? $_[0]->{host} = $_[1] : $_[0]->{host} }
  sub port { @_ > 1 ? $_[0]->{port} = $_[1] : $_[0]->{port} }
  
  sub resource_name {
      @_ > 1 ? $_[0]->{resource_name} = $_[1] : $_[0]->{resource_name};
  }
  
  sub parse {
      my $self   = shift;
      my $string = shift;
  
      my ($scheme) = $string =~ m{^(wss?)://};
      return unless $scheme;
  
      $self->secure(1) if $scheme =~ m/ss$/;
  
      my ($host, $port) = $string =~ m{^$scheme://([^:\/]+)(?::(\d+))?(?:|\/|$)};
      $host = '/' unless defined $host && $host ne '';
      $self->host($host);
      $self->port($port);
  
      my ($path) = $string =~ m{^$scheme://(?:.*?)(/.*?)(?:\?|$)};
      $path = '/' unless defined $path && $path ne '';
      $self->resource_name($path);
  
      return $self;
  }
  
  sub to_string {
      my $self = shift;
  
      my $string = '';
  
      $string .= 'ws';
      $string .= 's' if $self->secure;
      $string .= '://';
      $string .= $self->host;
      $string .= ':' . $self->port if defined $self->port;
      $string .= $self->resource_name || '/';
  
      return $string;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Protocol::WebSocket::URL - WebSocket URL
  
  =head1 SYNOPSIS
  
      # Construct
      my $url = Protocol::WebSocket::URL->new;
      $url->host('example.com');
      $url->port('3000');
      $url->secure(1);
      $url->to_string; # wss://example.com:3000
  
      # Parse
      my $url = Protocol::WebSocket::URL->new('wss://example.com:3000);
      $url->host;   # example.com
      $url->port;   # 3000
      $url->secure; # 1
  
  =head1 DESCRIPTION
  
  Construct or parse a WebSocket URL.
  
  =head1 ATTRIBUTES
  
  =head2 C<host>
  
  =head2 C<port>
  
  =head2 C<resource_name>
  
  =head2 C<secure>
  
  =head1 METHODS
  
  =head2 C<new>
  
  Create a new L<Protocol::WebSocket::URL> instance.
  
  =head2 C<parse>
  
  Parse a WebSocket URL.
  
  =head2 C<to_string>
  
  Construct a WebSocket URL.
  
  =cut
PROTOCOL_WEBSOCKET_URL

$fatpacked{"Role/Tiny.pm"} = <<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings FATAL => 'all';
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  
  # inlined from Moo::_Utils - update that first.
  
  sub _load_module {
    (my $proto = $_[0]) =~ s/::/\//g;
    return 1 if $INC{"${proto}.pm"};
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1 if grep !/::$/, keys %{_getstash($_[0])||{}};
    { local $@; require "${proto}.pm"; }
    return 1;
  }
  
  { # \[] is REF, not SCALAR. \v1 is VSTRING (thanks to doy for that one)
    my %reftypes = map +($_ => 1), qw(SCALAR REF VSTRING);
    sub _is_scalar_ref { $reftypes{ref($_[0])} }
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strictures->import;
    return if $INFO{$target}; # already exported into this package
    # get symbol table reference
    my $stash = do { no strict 'refs'; \%{"${target}::"} };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        { local $@; require Class::Method::Modifiers; }
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
    };
    *{_getglob "${target}::with"} = sub {
      die "Only one role supported at a time by with" if @_ > 1;
      $me->apply_role_to_package($target, $_[0]);
    };
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later)
    @{$INFO{$target}{not_methods}={}}{
      '', map { *$_{CODE}||() } grep !_is_scalar_ref($_), values %$stash
    } = ();
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
  }
  
  sub apply_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    die "This is apply_role_to_package" if ref($to);
    die "${role} is not a Role::Tiny" unless my $info = $INFO{$role};
  
    $me->_check_requires($to, $role, @{$info->{requires}||[]});
  
    $me->_install_methods($to, $role);
  
    $me->_install_modifiers($to, $info->{modifiers});
  
    # only add does() method to classes and only if they don't have one
    if (not $INFO{$to} and not $to->can('does')) {
      *{_getglob "${to}::does"} = \&does_role;
    }
  
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    die "No roles supplied!" unless @roles;
    my $class = ref($object);
    bless($object, $me->create_class_with_roles($class, @roles));
    $object;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    die "No roles supplied!" unless @roles;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      die "${role} is not a Role::Tiny" unless my $info = $INFO{$role};
    }
  
    if ($] >= 5.010) {
      { local $@; require mro; }
    } else {
      { local $@; require MRO::Compat; }
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    my @info = map +($INFO{$_} ? $INFO{$_} : ()), @roles;
  
    $me->_check_requires(
      $new_name, $compose_name,
      do { my %h; @h{map @{$_->{requires}||[]}, @info} = (); keys %h }
    );
  
    *{_getglob "${new_name}::does"} = \&does_role unless $new_name->can('does');
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    *{_getglob("${composed_name}::ISA")} = [ $base_name ];
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    foreach my $modified (
      do { my %h; @h{map $_->[1], @$modifiers} = (); keys %h }
    ) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      die "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    $me->_install_modifiers($composed_name, $modifiers);
    $COMPOSED{role}{$composed_name} = 1;
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, @requires) = @_;
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        die "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    $info->{methods} ||= do {
      # grab role symbol table
      my $stash = do { no strict 'refs'; \%{"${role}::"}};
      my $not_methods = $info->{not_methods};
      +{
        # grab all code entries that aren't in the not_methods list
        map {
          my $code = *{$stash->{$_}}{CODE};
          # rely on the '' key we added in import for "no code here"
          exists $not_methods->{$code||''} ? () : ($_ => $code)
        } grep !_is_scalar_ref($stash->{$_}), keys %$stash
      };
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    die "${role} is not a Role::Tiny" unless my $info = $INFO{$role};
    (keys %{$me->_concrete_methods_of($role)}, @{$info->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = do { no strict 'refs'; \%{"${to}::"}};
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(_is_scalar_ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      *{_getglob "${to}::${i}"} = $methods->{$i};
    }
  }
  
  sub _install_modifiers {
    my ($me, $to, $modifiers) = @_;
    if (my $info = $INFO{$to}) {
      push @{$info->{modifiers}}, @{$modifiers||[]};
    } else {
      foreach my $modifier (@{$modifiers||[]}) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    return exists $APPLIED_TO{ref($proto)||$proto}{$role};
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cusine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   1;
  
  else where
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where first wins.  In a more complete
  system (see L<Moose>) roles are checked to see if they clash.  The goal of this
  is to be much simpler, hence disallowing composition of multiple roles at once.
  
  =head1 METHODS
  
  =head2 apply_role_to_package
  
   Role::Tiny->apply_role_to_package('Some::Package', 'Some::Role');
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly.  Object is reblessed into the
  resulting class.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does_role('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  Composes another role into the current role.  Only one role may be composed in
  at a time to allow the code to remain as simple as possible.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = <<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings FATAL => 'all';
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_role_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = <<'SUB_DEFER';
  package Sub::Defer;
  
  use strictures 1;
  use base qw(Exporter);
  use Moo::_Utils;
  
  our @EXPORT = qw(defer_sub undefer_sub);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
      *{_getglob($target)} = $made;
    }
    push @{$DEFERRED{$made} = $DEFERRED{$deferred}}, $made;
  
    return $made;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    $DEFERRED{$deferred||''};
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_string;
    my $deferred = sub {
      goto &{$undeferred ||= undefer_sub($deferred_string)};
    };
    $deferred_string = "$deferred";
    $DEFERRED{$deferred} = [ $target, $maker, \$undeferred ];
    *{_getglob $target} = $deferred if defined($target);
    return $deferred;
  }
  
  1;
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
SUB_DEFER

$fatpacked{"Sub/Quote.pm"} = <<'SUB_QUOTE';
  package Sub::Quote;
  
  use strictures 1;
  
  sub _clean_eval { eval $_[0] }
  
  use Sub::Defer;
  use B 'perlstring';
  use Scalar::Util qw(weaken);
  use base qw(Exporter);
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub);
  
  our %QUOTE_OUTSTANDING;
  
  our %QUOTED;
  
  our %WEAK_REFS;
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if (my ($code_args, $body) = $code =~ / +my \(([^)]+)\) = \@_;(.*)$/s) {
      if ($code_args eq $args) {
        $do.$body.' }'
      } else {
        $do.'my ('.$code_args.') = ('.$args.'); '.$body.' }';
      }
    } else {
      $do.($local ? 'local ' : '').'@_ = ('.$args.'); '.$code.' }';
    }
  }
  
  sub _unquote_all_outstanding {
    return unless %QUOTE_OUTSTANDING;
    my ($assembled_code, @assembled_captures, @localize_these) = '';
    # we sort the keys in order to make debugging more predictable
    foreach my $outstanding (sort keys %QUOTE_OUTSTANDING) {
      my ($name, $code, $captures) = @{$QUOTE_OUTSTANDING{$outstanding}};
  
      push @localize_these, $name if $name;
  
      my $make_sub = "{\n";
  
      if (keys %$captures) {
        my $ass_cap_count = @assembled_captures;
        $make_sub .= capture_unroll("\$_[1][${ass_cap_count}]", $captures, 2);
        push @assembled_captures, $captures;
      }
  
      my $o_quoted = perlstring $outstanding;
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$Sub::Quote::QUOTED{${o_quoted}}[3] = sub {\n"
      );
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$Sub::Quote::QUOTED{${o_quoted}}[3] = \\&${name}\n";
      }
      $make_sub .= "}\n";
      $assembled_code .= $make_sub;
    }
    my $debug_code = $assembled_code;
    if (@localize_these) {
      $debug_code =
        "# localizing: ".join(', ', @localize_these)."\n"
        .$assembled_code;
      $assembled_code = join("\n",
        (map { "local *${_};" } @localize_these),
        'eval '.perlstring($assembled_code).'; die $@ if $@;'
      );
    } else {
      $ENV{SUB_QUOTE_DEBUG} && warn $assembled_code;
    }
    $assembled_code .= "\n1;";
    {
      local $@;
      unless (_clean_eval $assembled_code, \@assembled_captures) {
        die "Eval went very, very wrong:\n\n${debug_code}\n\n$@";
      }
    }
    $ENV{SUB_QUOTE_DEBUG} && warn $debug_code;
    %QUOTE_OUTSTANDING = ();
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = pop if ref($_[-1]) eq 'HASH';
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my $outstanding;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      unquote_sub($outstanding);
    };
    $outstanding = "$deferred";
    $QUOTE_OUTSTANDING{$outstanding} = $QUOTED{$outstanding} = [
      $name, $code, $captures
    ];
    weaken($WEAK_REFS{$outstanding} = $deferred);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    $WEAK_REFS{$sub||''} and $QUOTED{$sub||''};
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    _unquote_all_outstanding;
    $QUOTED{$sub}[3];
  }
  
  1;
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  See the L</SYNOPSIS>'s C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.  Note that for performance
  reasons all quoted subs declared so far will be globally unquoted/parsed in
  a single eval. This means that if you have a syntax error in one of your
  quoted subs you may find out when some other sub is unquoted.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll {
     '$x' => 1,
     '$y' => 2,
   };
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll {
     '$x' => 1,
     '$y' => 2,
   };
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  The keys are the names of the variables and the values are (duh)
  the values.  Note that references work as values.
SUB_QUOTE

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  
  use strict;
  #use warnings;
  
  use vars qw(@EXPORT @EXPORT_OK $VERSION @ISA);
  
  BEGIN {
  	require Exporter;
  	@ISA = qw(Exporter);
  }
  
  $VERSION = "0.11";
  
  $VERSION = eval $VERSION;
  
  @EXPORT = @EXPORT_OK = qw(try catch finally);
  
  $Carp::Internal{+__PACKAGE__}++;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
  	my ( $try, @code_refs ) = @_;
  
  	# we need to save this here, the eval block will be in scalar context due
  	# to $failed
  	my $wantarray = wantarray;
  
  	my ( $catch, @finally );
  
  	# find labeled blocks in the argument list.
  	# catch and finally tag the blocks by blessing a scalar reference to them.
  	foreach my $code_ref (@code_refs) {
  		next unless $code_ref;
  
  		my $ref = ref($code_ref);
  
  		if ( $ref eq 'Try::Tiny::Catch' ) {
  			$catch = ${$code_ref};
  		} elsif ( $ref eq 'Try::Tiny::Finally' ) {
  			push @finally, ${$code_ref};
  		} else {
  			use Carp;
  			confess("Unknown code ref type given '${ref}'. Check your usage & try again");
  		}
  	}
  
  	# save the value of $@ so we can set $@ back to it in the beginning of the eval
  	my $prev_error = $@;
  
  	my ( @ret, $error, $failed );
  
  	# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
  	# not perfect, but we could provide a list of additional errors for
  	# $catch->();
  
  	{
  		# localize $@ to prevent clobbering of previous value by a successful
  		# eval.
  		local $@;
  
  		# failed will be true if the eval dies, because 1 will not be returned
  		# from the eval body
  		$failed = not eval {
  			$@ = $prev_error;
  
  			# evaluate the try block in the correct context
  			if ( $wantarray ) {
  				@ret = $try->();
  			} elsif ( defined $wantarray ) {
  				$ret[0] = $try->();
  			} else {
  				$try->();
  			};
  
  			return 1; # properly set $fail to false
  		};
  
  		# copy $@ to $error; when we leave this scope, local $@ will revert $@
  		# back to its previous value
  		$error = $@;
  	}
  
  	# set up a scope guard to invoke the finally block at the end
  	my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
  	# at this point $failed contains a true value if the eval died, even if some
  	# destructor overwrote $@ as the eval was unwinding.
  	if ( $failed ) {
  		# if we got an error, invoke the catch block.
  		if ( $catch ) {
  			# This works like given($error), but is backwards compatible and
  			# sets $_ in the dynamic scope for the body of C<$catch>
  			for ($error) {
  				return $catch->($error);
  			}
  
  			# in case when() was used without an explicit return, the C<for>
  			# loop will be aborted and there's no useful return value
  		}
  
  		return;
  	} else {
  		# no failure, $@ is back to what it was, everything is fine
  		return $wantarray ? @ret : $ret[0];
  	}
  }
  
  sub catch (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Catch'),
  		@rest,
  	);
  }
  
  sub finally (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Finally'),
  		@rest,
  	);
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my @guts = @{ shift() };
      my $code = shift @guts;
      $code->(@guts);
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper localization of $@
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
  	# handle errors with a catch handler
  	try {
  		die "foo";
  	} catch {
  		warn "caught error: $_"; # not $@
  	};
  
  You can also use it like a stanalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
  	# just silence errors
  	try {
  		die "foo";
  	};
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the try block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L<BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the try block dies, it returns the value of the last statement executed in
  the catch block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following two examples both
  assign C<"bar"> to C<$x>.
  
  	my $x = try { die "foo" } catch { "bar" };
  
  	my $x = eval { die "foo" } || "bar";
  
  You can add finally blocks making the following true.
  
  	my $x;
  	try { die 'foo' } finally { $x = 'bar' };
  	try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  Finally blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many finally blocks to a
  given try block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory try subroutine, an optional catch subroutine & finally
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the finally block if given will execute.
  
  =item catch (&;$)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
  	catch { ... }
  
  Inside the catch block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
  	local $@ = $_;
  
  =item finally (&;$)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. Finally blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the finally block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the finally block does not
  localize C<$_> with the error, since unlike in a catch block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the finally block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an eval block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (before
  the localization) in the beginning of the C<eval> block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an eval block C<die> behaves sort of like:
  
  	sub die {
  		$@ = $_[0];
  		return_undef_from_eval();
  	}
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
  	my $error = do {
  		local $@;
  		eval { ... };
  		$@;
  	};
  
  	...
  	die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
  	if ( $@ ) {
  		...
  	}
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
  	sub Object::DESTROY {
  		eval { ... }
  	}
  
  	eval {
  		my $obj = Object->new;
  
  		die "foo";
  	};
  
  	if ( $@ ) {
  
  	}
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the eval was aborted due to an error:
  
  	my $failed = not eval {
  		...
  
  		return 1;
  	};
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
  	try {
  		require Foo;
  	} catch {
  		when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
  		default { die $_ }
  	};
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
  	sub foo {
  		my ( $self, @args ) = @_;
  		try { $self->bar(@args) }
  	}
  
  or
  
  	sub bar_in_place {
  		my $self = shift;
  		my $args = \@_;
  		try { $_ = $self->bar($_) for @$args }
  	}
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
        try {
            die;
        }
        catch {
            return;
        };
  
        say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
        my $success = try {
            die;
            1;
        }
        return unless $success;
  
        say "This text WILL NEVER appear!";
    }
  
  Note that if you have a catch block, it must return undef for this to work,
  since if a catch block exists, its return value is returned in place of undef
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
  	my $obj = try {
  		MightFail->new;
  	} catch {
  		...
  
  		return; # avoid returning a true value;
  	};
  
  	return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
  	given ($foo) {
  		when (...) {
  			try {
  				...
  			} catch {
  				warn $_; # will print $foo, not the error
  				warn $_[0]; # instead, get the error like this
  			}
  		}
  	}
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://nothingmuch.woobling.org/talks/takahashi.xul?data=yapc_asia_2009/try_tiny.txt>
  
  Or read the source:
  
  L<http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/nothingmuch/try-tiny/>
  
  =head1 AUTHOR
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2009 Yuval Kogman. All rights reserved.
  	This program is free software; you can redistribute
  	it and/or modify it under the terms of the MIT license.
  
  =cut
  
TRY_TINY

$fatpacked{"Twiggy.pm"} = <<'TWIGGY';
  package Twiggy;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.1010';
  
  1;
  __END__
  
  =head1 NAME
  
  Twiggy - AnyEvent HTTP server for PSGI (like Thin)
  
  =head1 SYNOPSIS
  
    twiggy --listen :8080
  
  See C<twiggy -h> for more details.
  
    use Twiggy::Server;
  
    my $server = Twiggy::Server->new(
        host => $host,
        port => $port,
    );
    $server->register_service($app);
  
    AE::cv->recv;
  
  =head1 DESCRIPTION
  
  Twiggy is a lightweight and fast HTTP server with unique features such
  as:
  
  =over 4
  
  =item PSGI
  
  Can run any PSGI applications. Fully supports I<psgi.nonblocking> and
  I<psgi.streaming> interfaces.
  
  =item AnyEvent
  
  This server uses AnyEvent and runs in a non-blocking event loop, so
  it's best to run event-driven web applications that runs I/O bound
  jobs or delayed responses such as long-poll, WebSocket or streaming
  content (server push).
  
  This software used to be called Plack::Server::AnyEvent but was
  renamed to Twiggy. See L</NAMING> for details.
  
  =item Fast header parser
  
  Uses XS/C based HTTP header parser for the best performance. (optional)
  
  =item Lightweight and Fast
  
  The memory required to run twiggy is 6MB and it can serve more than
  4500 req/s with a single process on Perl 5.10 with MacBook Pro 13"
  late 2009.
  
  =item Superdaemon aware
  
  Supports L<Server::Starter> for hot deploy and graceful restarts.
  
  =back
  
  =head1 NAMING
  
  =head2 Twiggy?
  
  Because it is like L<Thin|http://code.macournoyer.com/thin/>, Ruby's
  Rack web server using EventMachine. You know, Twiggy is thin :)
  
  =head2 Why the cute name instead of more descriptive namespace? Are you on drugs?
  
  I'm sick of naming Perl software like
  HTTP::Server::PSGI::How::Its::Written::With::What::Module and people
  call it HSPHIWWWM on IRC. It's hard to say on speeches and newbies
  would ask questions what they stand for every day. That's crazy.
  
  This module actually includes the longer alias and an empty subclass
  L<AnyEvent::Server::PSGI> for those who like to type more ::'s. It
  would actually help you find this software by searching for I<PSGI
  Server AnyEvent> on CPAN, which i believe is a good thing.
  
  Yes, maybe I'm on drugs. We'll see.
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  Yuval Kogman
  
  Hideki Yamamura
  
  Daisuke Maki
  
  =head1 SEE ALSO
  
  L<Plack> L<AnyEvent> L<Tatsumaki>
  
  =cut
TWIGGY

$fatpacked{"Twiggy/Server.pm"} = <<'TWIGGY_SERVER';
  package Twiggy::Server;
  use strict;
  use warnings;
  
  use Scalar::Util qw(blessed weaken);
  use Try::Tiny;
  use Carp;
  
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  use Errno qw(EAGAIN EINTR);
  use IO::Handle;
  
  use AnyEvent;
  use AnyEvent::Handle;
  use AnyEvent::Socket;
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  
  use HTTP::Status;
  use Plack::HTTPParser qw(parse_http_request);
  use Plack::Util;
  
  use constant DEBUG => $ENV{TWIGGY_DEBUG};
  use constant HAS_AIO => !$ENV{PLACK_NO_SENDFILE} && try {
      require AnyEvent::AIO;
      require IO::AIO;
      1;
  };
  
  open my $null_io, '<', \'';
  
  sub new {
      my($class, @args) = @_;
  
      return bless {
          no_delay => 1,
          timeout => 300,
          read_chunk_size => 4096,
          @args,
      }, $class;
  }
  
  sub start_listen {
      my ($self, $app) = @_;
      my @listen = @{$self->{listen} || [ ($self->{host} || '') . ":" . ($self->{port} || 0) ]};
      for my $listen (@listen) {
          push @{$self->{listen_guards}}, $self->_create_tcp_server($listen, $app);
      }
  }
  
  sub register_service {
      my($self, $app) = @_;
  
      $self->start_listen($app);
  
      $self->{exit_guard} = AE::cv {
          # Make sure that we are not listening on a socket anymore, while
          # other events are being flushed
          delete $self->{listen_guards};
      };
      $self->{exit_guard}->begin;
  }
  
  sub _create_tcp_server {
      my ( $self, $listen, $app ) = @_;
  
      my($host, $port, $is_tcp);
      if ($listen =~ /:\d+$/) {
          ($host, $port) = split /:/, $listen;
          $host = undef if $host eq '';
          $port = undef if $port == 0;
          $is_tcp = 1;
      } else {
          $host = "unix/";
          $port = $listen;
      }
  
      return tcp_server $host, $port, $self->_accept_handler($app, $is_tcp),
          $self->_accept_prepare_handler;
  }
  
  sub _accept_prepare_handler {
      my $self = shift;
      return sub {
          my ( $fh, $host, $port ) = @_;
          DEBUG && warn "Listening on $host:$port\n";
          $self->{prepared_host} = $host;
          $self->{prepared_port} = $port;
          $self->{server_ready}->({
              host => $host,
              port => $port,
              server_software => 'Twiggy',
          }) if $self->{server_ready};
  
          return $self->{backlog} || 0;
      };
  }
  
  sub _accept_handler {
      my ( $self, $app, $is_tcp ) = @_;
  
      return sub {
          my ( $sock, $peer_host, $peer_port ) = @_;
  
          DEBUG && warn "$sock Accepted connection from $peer_host:$peer_port\n";
          return unless $sock;
          $self->{exit_guard}->begin;
  
          if ( $is_tcp && $self->{no_delay} ) {
              setsockopt($sock, IPPROTO_TCP, TCP_NODELAY, 1)
                  or die "setsockopt(TCP_NODELAY) failed:$!";
          }
  
          my $headers = "";
          my $try_parse = sub {
              if ( $self->_try_read_headers($sock, $headers) ) {
                  my $env = {
                      SERVER_PORT         => $self->{prepared_port},
                      SERVER_NAME         => $self->{prepared_host},
                      SCRIPT_NAME         => '',
                      REMOTE_ADDR         => $peer_host,
                      'psgi.version'      => [ 1, 0 ],
                      'psgi.errors'       => *STDERR,
                      'psgi.url_scheme'   => 'http',
                      'psgi.nonblocking'  => Plack::Util::TRUE,
                      'psgi.streaming'    => Plack::Util::TRUE,
                      'psgi.run_once'     => Plack::Util::FALSE,
                      'psgi.multithread'  => Plack::Util::FALSE,
                      'psgi.multiprocess' => Plack::Util::FALSE,
                      'psgi.input'        => undef, # will be set by _run_app()
                      'psgix.io'          => $sock,
                      'psgix.input.buffered' => Plack::Util::TRUE,
                  };
  
                  my $reqlen = parse_http_request($headers, $env);
                  DEBUG && warn "$sock Parsed HTTP headers: request length=$reqlen\n";
  
                  if ( $reqlen < 0 ) {
                      die "bad request";
                  } else {
                      return $env;
                  }
              }
  
              return;
          };
  
          local $@;
          unless ( eval {
              if ( my $env = $try_parse->() ) {
                  # the request data is already available, no need to parse more
                  $self->_run_app($app, $env, $sock);
              } else {
                  # there's not yet enough data to parse the request,
                  # set up a watcher
                  $self->_create_req_parsing_watcher( $sock, $try_parse, $app );
              };
  
              1;
          }) {
              $self->_bad_request($sock);
          }
      };
  }
  
  # returns a closure that tries to parse
  # this is not a method because it needs a buffer per socket
  sub _try_read_headers {
      my ( $self, $sock, undef ) = @_;
  
      # FIXME add a timer to manage read timeouts
      local $/ = "\012";
  
      read_more: for my $headers ( $_[2] ) {
          if ( defined(my $line = <$sock>) ) {
              $headers .= $line;
  
              if ( $line eq "\015\012" or $line eq "\012" ) {
                  # got an empty line, we're done reading the headers
                  return 1;
              } else {
                  # try to read more lines using buffered IO
                  redo read_more;
              }
          } elsif ($! and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK ) {
              die $!;
          } elsif (!$!) {
              die "client disconnected";
          }
      }
  
      DEBUG && warn "$sock did not read to end of req, wait for more data to arrive\n";
      return;
  }
  
  sub _create_req_parsing_watcher {
      my ( $self, $sock, $try_parse, $app ) = @_;
  
      my $headers_io_watcher;
  
      my $timeout_timer = AE::timer $self->{timeout}, 0, sub {
          DEBUG && warn "$sock Timeout\n";
          undef $headers_io_watcher;
          undef $try_parse;
          undef $sock;
      } if $self->{timeout};
  
      $headers_io_watcher = AE::io $sock, 0, sub {
          try {
              if ( my $env = $try_parse->() ) {
                  undef $headers_io_watcher;
                  undef $timeout_timer;
                  $self->_run_app($app, $env, $sock);
              }
          } catch {
              undef $headers_io_watcher;
              undef $timeout_timer;
              $self->_bad_request($sock);
          }
      };
  }
  
  sub _bad_request {
      my ( $self, $sock ) = @_;
  
      return unless defined $sock and defined fileno $sock;
  
      $self->_write_psgi_response(
          $sock,
          [
              400,
              [ 'Content-Type' => 'text/plain' ],
              [ ],
          ],
      );
  
      return;
  }
  
  sub _read_chunk {
      my ($self, $sock, $remaining, $cb) = @_;
  
      my $data = '';
      my $read_chunk_size = $self->{read_chunk_size};
  
      my $try_read = sub {
          READ_MORE: {
              my $read_size = $remaining > $read_chunk_size ? $read_chunk_size : $remaining;
              my $rlen = read($sock, $data, $read_size, length($data));
  
              if (defined $rlen and $rlen > 0) {
                  $remaining -= $rlen;
  
                  if ($remaining <= 0) {
                      $cb->($data);
                      return 1;
                  } else {
                      redo READ_MORE;
                  }
              } elsif (defined $rlen) {
                  $cb->($data);
                  return 1;
              } elsif ($! and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
                  die $!;
              }
          }
  
          return;
      };
  
      unless ($try_read->()) {
          my $rw; $rw = AE::io($sock, 0, sub {
              try {
                  if ($try_read->()) {
                      undef $rw;
                  }
              } catch {
                  undef $rw;
                  $self->_bad_request($sock);
              };
          });
      }
  }
  
  sub _run_app {
      my($self, $app, $env, $sock) = @_;
  
      unless ($env->{'psgi.input'}) {
          if ($env->{CONTENT_LENGTH} && $env->{REQUEST_METHOD} =~ /^(?:POST|PUT)$/) {
              $self->_read_chunk($sock, $env->{CONTENT_LENGTH}, sub {
                  my ($data) = @_;
                  open my $input, '<', \$data;
                  $env->{'psgi.input'} = $input;
                  $self->_run_app($app, $env, $sock);
              });
              return;
          } else {
              $env->{'psgi.input'} = $null_io;
          }
      }
  
      my $res = Plack::Util::run_app $app, $env;
  
      if ( ref $res eq 'ARRAY' ) {
          $self->_write_psgi_response($sock, $res);
      } elsif ( blessed($res) and $res->isa("AnyEvent::CondVar") ) {
          Carp::carp("Returning AnyEvent condvar is deprecated and will be removed in the next release of Twiggy. Use the streaming callback interface intstead.");
          $res->cb(sub { $self->_write_psgi_response($sock, shift->recv) });
      } elsif ( ref $res eq 'CODE' ) {
          $res->(
              sub {
                  my $res = shift;
  
                  if ( @$res < 2 ) {
                      croak "Insufficient arguments";
                  } elsif ( @$res == 2 ) {
                      my ( $status, $headers ) = @$res;
  
                      $self->_flush($sock);
  
                      my $writer = Twiggy::Writer->new($sock, $self->{exit_guard});
  
                      my $buf = $self->_format_headers($status, $headers);
                      $writer->write($$buf);
  
                      return $writer;
                  } else {
                      my ( $status, $headers, $body, $post ) = @$res;
                      my $cv = $self->_write_psgi_response($sock, [ $status, $headers, $body ]);
                      $cv->cb(sub { $post->() }) if $post;
                  }
              },
              $sock,
          );
      } else {
          croak("Unknown response type: $res");
      }
  }
  
  sub _write_psgi_response {
      my ( $self, $sock, $res ) = @_;
  
      if ( ref $res eq 'ARRAY' ) {
          if ( scalar @$res == 0 ) {
              # no response
              $self->{exit_guard}->end;
              return;
          }
  
          my ( $status, $headers, $body ) = @$res;
  
          my $cv = AE::cv;
  
          $self->_write_headers( $sock, $status, $headers )->cb(sub {
              local $@;
              if ( eval { $_[0]->recv; 1 } ) {
                  $self->_write_body($sock, $body)->cb(sub {
                      shutdown $sock, 1;
                      close $sock;
                      $self->{exit_guard}->end;
                      local $@;
                      eval { $cv->send($_[0]->recv); 1 } or $cv->croak($@);
                  });
              }
          });
  
          return $cv;
      } else {
          no warnings 'uninitialized';
          warn "Unknown response type: $res";
          return $self->_write_psgi_response($sock, [ 204, [], [] ]);
      }
  }
  
  sub _write_headers {
      my ( $self, $sock, $status, $headers ) = @_;
  
      $self->_write_buf( $sock, $self->_format_headers($status, $headers) );
  }
  
  sub _format_headers {
      my ( $self, $status, $headers ) = @_;
  
      my $hdr = sprintf "HTTP/1.0 %d %s\015\012", $status, HTTP::Status::status_message($status);
  
      my $i = 0;
  
      my @delim = ("\015\012", ": ");
  
      foreach my $str ( @$headers ) {
          $hdr .= $str . $delim[++$i % 2];
      }
  
      $hdr .= "\015\012";
  
      return \$hdr;
  }
  
  # this flushes just the output buffer, not the input buffer (unlike
  # $handle->flush)
  sub _flush {
  	my ( $self, $sock ) = @_;
  
      local $| = 1;
      print $sock '';
  }
  
  # helper routine, similar to push write, but respects buffering, and refcounts
  # itself
  sub _write_buf {
      my($self, $socket, $data) = @_;
  
      no warnings 'uninitialized';
  
      # try writing immediately
      if ( (my $written = syswrite($socket, $$data)) < length($$data) ) {
          my $done = defined(wantarray) && AE::cv;
  
          # either the write failed or was incomplete
  
          if ( !defined($written) and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              # a real write error occured, like EPIPE
              $done->croak($!) if $done;
              return $done;
          }
  
          # the write was either incomplete or a non fatal error occured, so we
          # need to set up an IO watcher to wait until we can properly write
  
          my $length = length($$data);
  
          my $write_watcher;
          $write_watcher = AE::io $socket, 1, sub {
              write_more: {
                  my $out = syswrite($socket, $$data, $length - $written, $written);
  
                  if ( defined($out) ) {
                      $written += $out;
  
                      if ( $written == $length ) {
                          undef $write_watcher;
                          $done->send(1) if $done;
                      } else {
                          redo write_more;
                      }
                  } elsif ($! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
                      $done->croak($!) if $done;
                      undef $write_watcher;
                  }
              }
          };
  
          return $done;
      } elsif ( defined wantarray ) {
          my $done = AE::cv;
          $done->send(1);
          return $done;
      }
  }
  
  sub _write_body {
      my ( $self, $sock, $body ) = @_;
  
      if ( ref $body eq 'ARRAY' ) {
          my $buf = join "", @$body;
          return $self->_write_buf($sock, \$buf);
      } elsif ( Plack::Util::is_real_fh($body) ) {
          # real handles use nonblocking IO
          # either AIO or using watchers, with sendfile or with copying IO
          return $self->_write_real_fh($sock, $body);
      } elsif ( blessed($body) and $body->can("string_ref") ) {
          # optimize IO::String to not use its incredibly slow getline
          if ( my $pos = $body->tell ) {
              my $str = substr ${ $body->string_ref }, $pos;
              return $self->_write_buf($sock, \$str);
          } else {
              return $self->_write_buf($sock, $body->string_ref);
          }
      } else {
          return $self->_write_fh($sock, $body);
      }
  }
  
  # like Plack::Util::foreach, but nonblocking on the output
  # handle
  sub _write_fh {
      my ( $self, $sock, $body ) = @_;
  
      my $handle = AnyEvent::Handle->new( fh => $sock );
      my $ret = AE::cv;
  
      $handle->on_error(sub {
          my $err = $_[2];
          $handle->destroy;
          $ret->send($err);
      });
  
      no warnings 'recursion';
      $handle->on_drain( $self->_drain($body, $ret) );
  
      return $ret;
  }
  
  sub _drain {
      my ($self, $body, $ret) = @_;
      return sub {
          my $handle = shift;
          local $/ = \ $self->{read_chunk_size};
          if ( defined( my $buf = $body->getline ) ) {
              if (length($buf)) {
                  $handle->push_write($buf);
              }
              else {
                  # if on_drain is called and we don't do any
                  # push_write, anyevent::handle thinks we are done.
                  # this fails for the deflater mw, since one 4096 chunk
                  # of getline might not generate a deflated packet yet,
                  # which gets us an empty string here.
                  return $self->_drain($body, $ret)->($handle);
              }
          } elsif ( $! ) {
              $ret->croak($!);
              $handle->destroy;
          } else {
              $body->close;
              $handle->on_drain(sub {
                  shutdown $handle->fh, 1;
                  $handle->destroy;
                  $ret->send(1);
              });
          }
  
      }
  }
  
  # when the body handle is a real filehandle we use this routine, which is more
  # careful not to block when reading the response too
  
  # FIXME support only reading $length bytes from $body, instead of until EOF
  # FIXME use len = 0 param to sendfile
  # FIXME use Sys::Sendfile in nonblocking mode if AIO is not available
  # FIXME test sendfile on non file backed handles
  sub _write_real_fh {
      my ( $self, $sock, $body ) = @_;
  
      if ( HAS_AIO and -s $body ) {
          my $cv = AE::cv;
          my $offset = 0;
          my $length = -s $body;
          $sock->blocking(1);
          my $sendfile; $sendfile = sub {
              IO::AIO::aio_sendfile( $sock, $body, $offset, $length - $offset, sub {
                  my $ret = shift;
                  $offset += $ret if $ret > 0;
                  if ($offset >= $length || ($ret == -1 && ! ($! == EAGAIN || $! == EINTR))) {
                      if ( $ret == -1 ) {
                          $cv->croak($!);
                      } else {
                          $cv->send(1);
                      }
  
                      undef $sendfile;
                      undef $sock;
                  } else {
                      $sendfile->();
                  }
              });
          };
          $sendfile->();
          return $cv;
      } else {
          return $self->_write_fh($sock, $body);
      }
  }
  
  sub run {
      my $self = shift;
      $self->register_service(@_);
  
      my $w; $w = AE::signal QUIT => sub { $self->{exit_guard}->end; undef $w };
      $self->{exit_guard}->recv;
  }
  
  package Twiggy::Writer;
  use AnyEvent::Handle;
  
  sub new {
      my ( $class, $socket, $exit ) = @_;
  
      bless { handle => AnyEvent::Handle->new( fh => $socket ), exit_guard => $exit }, $class;
  }
  
  sub write { $_[0]{handle}->push_write($_[1]) }
  
  sub close {
      my $self = shift;
  
      my $exit_guard = delete $self->{exit_guard};
      $exit_guard->end if $exit_guard;
  
      my $handle = delete $self->{handle};
      if ($handle) {
          $handle->on_drain;
          $handle->on_error;
  
          $handle->on_drain(sub {
              shutdown $_[0]->fh, 1;
              $_[0]->destroy;
              undef $handle;
          });
      }
  }
  
  sub DESTROY { $_[0]->close }
  
  package Twiggy::Server;
  
  1;
  __END__
TWIGGY_SERVER

$fatpacked{"Twiggy/Server/SS.pm"} = <<'TWIGGY_SERVER_SS';
  package Twiggy::Server::SS;
  use strict;
  use warnings;
  use base qw(Twiggy::Server);
  use AnyEvent;
  use AnyEvent::Util qw(fh_nonblocking guard);
  use AnyEvent::Socket qw(format_address);
  use Server::Starter qw(server_ports);
  
  sub start_listen {
      my ($self, $app) = @_;
  
      if (Twiggy::Server::DEBUG() && $self->{listen}) {
          warn "'listen' option is currently ignored when used in conjunction with Server::Starter (start_server script)";
      }
  
      my $host = $self->{host} || '';
  
      my @listen;
      my $ports = server_ports();
      while (my ($hostport, $fd) = each %$ports ) {
          push @listen, $hostport;
          $self->_create_ss_tcp_server($hostport, $fd, $app);
      }
  
      # overwrite, just in case somebody wants to refer to it afterwards
      $self->{listen} = \@listen;
  }
  
  sub _create_ss_tcp_server {
      my ($self, $hostport, $fd, $app) = @_;
  
      my $is_tcp = 1; # currently no unix socket support
  
      my ($host, $port);
      if ($hostport =~ /(.*):(\d+)/) {
          $host = $1;
          $port = $2;
      } else {
          $host ||= '0.0.0.0';
          $port = $hostport;
      }
  
      # /WE/ don't care what the address family, type of socket we got, just
      # create a new handle, and perform a fdopen on it. So that part of
      # AE::Socket::tcp_server is stripped out
  
      my %state;
      $state{fh} = IO::Socket::INET->new(
          Proto => 'tcp',
          Listen => 128, 
      );
  
      $state{fh}->fdopen( $fd, 'w' ) or
          Carp::croak "failed to bind to listening socket: $!";
      fh_nonblocking $state{fh}, 1;
  
      my $len;
      my $prepare = $self->_accept_prepare_handler;
      if ($prepare) {
          my ($service, $host) = AnyEvent::Socket::unpack_sockaddr getsockname $state{fh};
          $len = $prepare && $prepare->( $state{fh}, format_address $host, $service );
      }
  
      $len ||= 128;
  
      listen $state{fh}, $len or Carp::croak "listen: $!";
  
      my $accept = $self->_accept_handler($app, $is_tcp);
      $state{aw} = AE::io $state{fh}, 0, sub {
          # this closure keeps $state alive
          while ($state{fh} && (my $peer = accept my $fh, $state{fh})) {
              fh_nonblocking $fh, 1; # POSIX requires inheritance, the outside world does not
  
              my ($service, $host) = AnyEvent::Socket::unpack_sockaddr($peer);
              $accept->($fh, format_address $host, $service);
          }
      };
  
      defined wantarray
          ? guard { %state = () } # clear fh and watcher, which breaks the circular dependency
          : ()
  }
  
  1;
TWIGGY_SERVER_SS

$fatpacked{"URI.pm"} = <<'URI';
  package URI;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "1.59";
  
  use vars qw($ABS_REMOTE_LEADING_DOTS $ABS_ALLOW_RELATIVE_SCHEME $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  use vars qw($reserved $mark $unreserved $uric $scheme_re);
  $reserved   = q(;/?:@&=+$,[]);
  $mark       = q(-_.!~*'());                                    #'; emacs
  $unreserved = "A-Za-z0-9\Q$mark\E";
  $uric       = quotemeta($reserved) . $unreserved . "%";
  
  $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          # Try to load it
          eval "require $ic";
          die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
          return unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return unless defined $scheme;
      lc($scheme);
  }
  
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  *path = \&opaque;  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unknown schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = <<'URI_ESCAPE';
  package URI::Escape;
  use strict;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  require Exporter;
  our @ISA = qw(Exporter);
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  sub escape_char {
      return join '', @URI::Escape::escapes{$_[0] =~ /(\C)/g};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = <<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  
  use vars qw(@EXPORT_OK $VERSION $MY_COUNTRY %LOCAL_GUESSING $DEBUG);
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  $VERSION = "4.20";
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = <<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  sub AUTOLOAD
  {
      use vars qw($AUTOLOAD);
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = <<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my %seen;
  	my @keys;
  	for (my $i = 0; $i < @old; $i += 2) {
  	    push(@keys, $old[$i]) unless $seen{$old[$i]}++;
  	}
  	return @keys;
      }
  
      my $key = shift;
      my @i;
  
      for (my $i = 0; $i < @old; $i += 2) {
  	push(@i, $i) if $old[$i] eq $key;
      }
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	#print "VALS:@vals [@i]\n";
  	while (@new_i > @vals) {
  	    #print "REMOVE $new_i[-1]\n";
  	    splice(@new, pop(@new_i), 2);
  	}
  	while (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    #print "SPLICE $i\n";
  	    splice(@new, $i, 0, $key => pop(@vals));
  	}
  	for (@vals) {
  	    #print "SET $new_i[0]\n";
  	    $new[shift(@new_i)+1] = $_;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      $self->query_form($self->query_form, $key => \@_);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = <<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  
  use vars qw(@ISA @EXPORT_OK);
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = <<'URI_URL';
  package URI::URL;
  
  require URI::WithBase;
  @ISA=qw(URI::WithBase);
  
  use strict;
  use vars qw(@EXPORT $VERSION);
  
  $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without loosing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = <<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use vars qw($AUTOLOAD $VERSION);
  use URI;
  
  $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && ref($base) && UNIVERSAL::isa($base, __PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if UNIVERSAL::isa($other, __PACKAGE__);
      $self->[0]->eq($other);
  }
  
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = <<'URI__FOREIGN';
  package URI::_foreign;
  
  require URI::_generic;
  @ISA=qw(URI::_generic);
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = <<'URI__GENERIC';
  package URI::_generic;
  require URI;
  require URI::_query;
  @ISA=qw(URI URI::_query);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	$abs->fragment($self->fragment);
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = <<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = <<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = "1.12";
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = <<'URI__LOGIN';
  package URI::_login;
  
  require URI::_server;
  require URI::_userpass;
  @ISA = qw(URI::_server URI::_userpass);
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = <<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  our $VERSION = "0.04";
  
  require Exporter;
  our @ISA    = qw(Exporter);
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use URI::_punycode;
    $punycode = encode_punycode($unicode);
    $unicode  = decode_punycode($punycode);
  
  =head1 DESCRIPTION
  
  URI::_punycode is a module to encode / decode Unicode strings into
  Punycode, an efficient encoding of Unicode for use with IDNA.
  
  This module requires Perl 5.6.0 or over to handle UTF8 flagged Unicode
  strings.
  
  =head1 FUNCTIONS
  
  This module exports following functions by default.
  
  =over 4
  
  =item encode_punycode
  
    $punycode = encode_punycode($unicode);
  
  takes Unicode string (UTF8-flagged variable) and returns Punycode
  encoding for it.
  
  =item decode_punycode
  
    $unicode = decode_punycode($punycode)
  
  takes Punycode encoding and returns original Unicode string.
  
  =back
  
  These functions throw exceptions on failure. You can catch 'em via
  C<eval>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt> is the author of
  IDNA::Punycode v0.02 which was the basis for this module.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, RFC 3492
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = <<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  *equery = \&query;
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = <<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = <<'URI__SERVER';
  package URI::_server;
  require URI::_generic;
  @ISA=qw(URI::_generic);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = <<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return unless defined $info;
      return unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = <<'URI_DATA';
  package URI::data;  # RFC 2397
  
  require URI;
  @ISA=qw(URI);
  
  use strict;
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = <<'URI_FILE';
  package URI::file;
  
  use strict;
  use vars qw(@ISA $VERSION $DEFAULT_AUTHORITY %OS_CLASS);
  
  require URI::_generic;
  @ISA = qw(URI::_generic);
  $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = <<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use URI::Escape qw();
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn()) eq $host ||
  	lc(Net::Domain::hostname()) eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = <<'URI_FILE_FAT';
  package URI::file::FAT;
  
  require URI::file::Win32;
  @ISA=qw(URI::file::Win32);
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = <<'URI_FILE_MAC';
  package URI::file::Mac;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = <<'URI_FILE_OS2';
  package URI::file::OS2;
  
  require URI::file::Win32;
  @ISA=qw(URI::file::Win32);
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = <<'URI_FILE_QNX';
  package URI::file::QNX;
  
  require URI::file::Unix;
  @ISA=qw(URI::file::Unix);
  
  use strict;
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = <<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = <<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = <<'URI_FTP';
  package URI::ftp;
  
  require URI::_server;
  require URI::_userpass;
  @ISA=qw(URI::_server URI::_userpass);
  
  use strict;
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = <<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  *gtype = \&gopher_type;  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = <<'URI_HTTP';
  package URI::http;
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = <<'URI_HTTPS';
  package URI::https;
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = <<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  $VERSION = "1.12";
  
  require URI::_server;
  require URI::_ldap;
  @ISA=qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = <<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  
  use vars qw(@ISA);
  
  require URI::_generic;
  require URI::_ldap;
  @ISA=qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = <<'URI_LDAPS';
  package URI::ldaps;
  require URI::ldap;
  @ISA=qw(URI::ldap);
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = <<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  require URI;
  require URI::_query;
  @ISA=qw(URI URI::_query);
  
  use strict;
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = <<'URI_MMS';
  package URI::mms;
  
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = <<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = <<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  require URI::news;
  @ISA=qw(URI::news);
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = <<'URI_POP';
  package URI::pop;   # RFC 2384
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = <<'URI_RLOGIN';
  package URI::rlogin;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = <<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  require URI::_server;
  require URI::_userpass;
  
  @ISA=qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = <<'URI_RTSP';
  package URI::rtsp;
  
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = <<'URI_RTSPU';
  package URI::rtspu;
  
  require URI::rtsp;
  @ISA=qw(URI::rtsp);
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sip.pm"} = <<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  require URI::_server;
  require URI::_userpass;
  @ISA=qw(URI::_server URI::_userpass);
  
  use strict;
  use vars qw(@ISA $VERSION);
  use URI::Escape qw(uri_unescape);
  
  $VERSION = "0.11";
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = <<'URI_SIPS';
  package URI::sips;
  require URI::sip;
  @ISA=qw(URI::sip);
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = <<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  require URI::news;
  @ISA=qw(URI::news);
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = <<'URI_SSH';
  package URI::ssh;
  require URI::_login;
  @ISA=qw(URI::_login);
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = <<'URI_TELNET';
  package URI::telnet;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = <<'URI_TN3270';
  package URI::tn3270;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = <<'URI_URN';
  package URI::urn;  # RFC 2141
  
  require URI;
  @ISA=qw(URI);
  
  use strict;
  use Carp qw(carp);
  
  use vars qw(%implementor);
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
  	    # Try to load it
  	    eval "require $impclass";
  	    die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = <<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  require URI::urn;
  @ISA=qw(URI::urn);
  
  use strict;
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = <<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  require URI::urn;
  @ISA=qw(URI::urn);
  
  use strict;
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

$fatpacked{"Web/Hippie.pm"} = <<'WEB_HIPPIE';
  package Web::Hippie;
  
  use strict;
  use 5.008_001;
  our $VERSION = '0.39';
  use parent 'Plack::Middleware';
  
  use Plack::Util::Accessor qw( on_error on_message trusted_origin );
  use AnyEvent;
  use AnyEvent::Handle;
  use Plack::Request;
  use JSON;
  use HTTP::Date;
  use Digest::MD5 qw(md5);
  
  sub call {
      my ($self, $env) = @_;
  
      my (undef, $type, $arg) = split('/', $env->{PATH_INFO}, 3);
  
      $env->{'hippie.args'} = $arg;
  
      my $code = $self->can("handler_$type");
      unless ($code) {
          $env->{'PATH_INFO'} = "/$type";
          return $self->app->($env);
      }
  
      return $code->($self, $env, $self->app);
  
  }
  
  
  use Encode;
  
  sub handler_pub {
      my ($self, $env, $handler) = @_;
      my $req = Plack::Request->new($env);
      $env->{'hippie.message'} =
          JSON::from_json($req->parameters->mixed->{'message'}, { utf8 => 1 });
      $env->{'PATH_INFO'} = '/message';
  
      $handler->($env);
  }
  
  sub handler_mxhr {
      my ($self, $env, $handler) = @_;
      my $req = Plack::Request->new($env);
      my $client_id = $req->param('client_id') || rand(1);
  
      my $size = 2;
      use MIME::Base64;
      my $boundary = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $boundary =~ s/[\W]/X/g;  # ensure alnum only
  
      use Web::Hippie::Handle::MXHR;
  
      return sub {
          my $respond = shift;
          my $fh = $env->{'psgix.io'}
              or return $respond->([ 501, [ "Content-Type", "text/plain" ], [ "This server does not support psgix.io extension" ] ]);
  
          my $h = AnyEvent::Handle->new( fh => $fh );
          $h->on_eof(   $self->connection_cleanup($env, $handler, $h) );
          $h->on_error( $self->connection_cleanup($env, $handler, $h) );
  
          # XXX: on_error or on_eof are not triggered if there's no rw events registered
          $h->on_read(sub { die "this should not happen" });
  
          my $writer = $respond->
              ([ 200,
                 [ 'Content-Type' => 'multipart/mixed; boundary="' . $boundary . '"',
                   'Cache-Control' => 'no-cache, must-revalidate',
                   'Pragma' => 'no-cache',
                   'Expires' => HTTP::Date::time2str(0),
                   'Last-Modified' => HTTP::Date::time2str(time())
               ]]);
          $writer->write("--" . $boundary. "\n");
          $env->{'hippie.handle'} = Web::Hippie::Handle::MXHR->new
              ({ id       => $client_id,
                 boundary => $boundary,
                 writer   => $writer });
          $env->{'PATH_INFO'} = '/init';
  
          $handler->($env);
      };
  }
  
  use Protocol::WebSocket::Frame;
  use Protocol::WebSocket::Handshake::Server;
  use Web::Hippie::Handle::WebSocket;
  
  sub handler_ws {
      my ($self, $env, $handler) = @_;
  
      my $req = Plack::Request->new($env);
      my $res = $req->new_response(200);
  
      my $hs = Protocol::WebSocket::Handshake::Server->new_from_psgi($env);
      my $client_id = $req->param('client_id') || rand(1);
  
      my $fh = $env->{'psgix.io'}
          or return [ 501, [ "Content-Type", "text/plain" ], [ "This server does not support psgix.io extension" ] ];
  
      return [ 501, [ "Content-Type", "text/plain" ],
               [ "Failed to initialize websocket" ] ]
          unless $hs->parse($fh);
  
      if (my $origin = $hs->req->origin) {
          my $trusted_origin = $self->trusted_origin || '.*';
          if ($origin !~ m/^$trusted_origin/) {
              $env->{'psgi.errors'}->print("Client origin $origin not allowed.\n");
              return [403, ['Content-Type' => 'text/plain'], ['origin not allowed']];
          }
      }
  
      return [ 501, [ "Content-Type", "text/plain" ],
               [ "websocket handshake incomplete" ] ]
          unless $hs->is_done;
  
      my $version = $hs->version;
      my $frame = Protocol::WebSocket::Frame->new(version => $version);
  
      my $h = AnyEvent::Handle->new( fh => $fh, autocork => 1 );
      return sub {
          my $responder = shift;
  
          $h->push_write($hs->to_string);
          $h->on_read(sub {
                          shift->push_read(
                              sub {
                                  $frame->append($_[0]->rbuf);
                                  while (my $message = $frame->next_bytes) {
                                      $env->{'hippie.message'} = eval { JSON::decode_json($message) };
                                      if ($@) {
                                          warn $@;
                                          return $h->on_error();
                                      }
  
                                      $env->{'PATH_INFO'} = '/message';
                                      $handler->($env);
                                  }
                              }
                          );
                      });
          $env->{'hippie.handle'} = Web::Hippie::Handle::WebSocket->new
              ({ id => $client_id,
                 version => $version,
                 h  => $h });
          $h->on_error( $self->connection_cleanup($env, $handler, $h) );
  
          $env->{'PATH_INFO'} = '/init';
          $handler->($env);
  
      };
  }
  
  sub connection_cleanup {
      my ($self, $env, $handler, $h) = @_;
      return sub {
          $env->{'PATH_INFO'} = '/error';
          $handler->($env);
          $h->destroy;
          undef $env->{'hippie.handle'};
      };
  }
  
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Web::Hippie - Web toolkit for the long hair, or comet
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
      mount '/_hippie' => builder {
        enable "+Web::Hippie";
        sub { my $env = shift;
              my $args = $env->{'hippie.args'};
              my $handle = $env->{'hippie.handle'};
              # Your handler based on PATH_INFO: /init, /error, /message
        }
      };
      mount '/' => my $app;
    };
  
  =head1 DESCRIPTION
  
  Web::Hippie provides unified persistent and streamy communication
  channel over HTTP via websocket (bidirectional) or mxhr
  (uni-directional) for your <PSGI> application.  See
  L<Web::Hippie::Pipe> for unified bidirectional abstraction with
  message bus.
  
  =head1 SEE ALSO
  
  L<Web::Hippie::Pipe>, L<Web::Hippie::App::JSFiles>
  
  =head1 AUTHOR
  
  Chia-liang Kao E<lt>clkao@clkao.orgE<gt>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  =cut
WEB_HIPPIE

$fatpacked{"Web/Hippie/App/JSFiles.pm"} = <<'WEB_HIPPIE_APP_JSFILES';
  package Web::Hippie::App::JSFiles;
  use strict;
  use Try::Tiny;
  use File::ShareDir;
  
  use parent 'Plack::App::File';
  
  sub root {
      try { File::ShareDir::dist_dir('Web-Hippie') } || 'share';
  }
  
  sub files {
      qw(DUI.js
         Stream.js
         hippie.js
         hippie.pipe.js
         jquery.ev.js
         json2.js)
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Web::Hippie::App::JSFiles - Serve javascript files for Web::Hippie
  
  =head1 SYNOPSIS
  
    use Web::Hippie::App::JSFiles;
    my $app = Hippie::App::JSFiles->new;
  
  =head1 DESCRIPTION
  
  This PSGI app provides javascript files for Hippie.
  
  =head1 AUTHOR
  
  Chia-liang Kao E<lt>clkao@clkao.orgE<gt>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  =cut
WEB_HIPPIE_APP_JSFILES

$fatpacked{"Web/Hippie/Handle/MXHR.pm"} = <<'WEB_HIPPIE_HANDLE_MXHR';
  package Web::Hippie::Handle::MXHR;
  BEGIN {
      eval "use Class::XSAccessor::Compat 'antlers'; 1" or
      eval "use Class::Accessor::Fast 'antlers'; 1" or die $@;
  }
  has id => (is => "ro");
  has boundary => (is => "ro");
  has writer => (is => "ro");
  
  sub new {
      my $class = shift;
      unless (ref $_[0] eq 'HASH') {
          Carp::carp "use of hash in constructor is deprecated. use hashref please instead.";
          @_ = { @_ };
      }
      return $class->SUPER::new(@_);
  }
  
  sub send_msg {
      my ($self, $msg) = @_;
  
      my $json = JSON::encode_json($msg);
      $self->writer->write( "Content-Type: application/json\n\n$json\n--" . $self->boundary. "\n" );
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Web::Hippie::Handle::MXHR - Multi-part XHR handler
  
  =cut
WEB_HIPPIE_HANDLE_MXHR

$fatpacked{"Web/Hippie/Handle/WebSocket.pm"} = <<'WEB_HIPPIE_HANDLE_WEBSOCKET';
  package Web::Hippie::Handle::WebSocket;
  use strict;
  BEGIN {
      eval "use Class::XSAccessor::Compat 'antlers'; 1" or
      eval "use Class::Accessor::Fast 'antlers'; 1" or die $@;
  }
  
  has id => (is => "ro");
  has h => (is => "ro", isa => "AnyEvent::Handle");
  has version => (is => "rw", isa => "Str");
  
  sub new {
      my $class = shift;
      unless (ref $_[0] eq 'HASH') {
          Carp::carp "use of hash in constructor is deprecated. use hashref please instead.";
          @_ = { @_ };
      }
      return $class->SUPER::new(@_);
  }
  
  sub send_msg {
      my ($self, $msg) = @_;
  
      my $bytes = Protocol::WebSocket::Frame->new
          ( buffer => JSON::encode_json($msg),
            version => $self->version)->to_bytes;
      $self->h->push_write($bytes);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Web::Hippie::Handle::WebSocket - Websocket handler
  
  =cut
  
WEB_HIPPIE_HANDLE_WEBSOCKET

$fatpacked{"Web/Hippie/Pipe.pm"} = <<'WEB_HIPPIE_PIPE';
  package Web::Hippie::Pipe;
  
  use strict;
  use 5.008_001;
  our $VERSION = '0.01';
  use parent 'Plack::Middleware';
  
  use HTTP::Date;
  use Plack::Util::Accessor qw( bus client_mgr );
  use Plack::Request;
  use Plack::Response;
  use AnyMQ;
  
  sub prepare_app {
      my $self = shift;
      $self->client_mgr({});
      $self->bus(AnyMQ->new) unless $self->bus;
  }
  
  sub call {
      my ($self, $env) = @_;
      $env->{'hippie.bus'} = $self->bus;
  
      my $client_id = $env->{'hippie.client_id'} ||=
          Plack::Request->new($env)->param('client_id') || $env->{HTTP_X_HIPPIE_CLIENTID};
      if ($env->{PATH_INFO} eq '/poll') {
          my $args = $env->{'hippie.args'};
  
          # redirect to poll url again with client_id
          unless ($client_id) {
              my $res = Plack::Response->new;
              my $req = Plack::Request->new($env);
              my $uri = $req->uri;
              $uri->path( $uri->path . '/' . $args );
              $uri->query_form(client_id => rand(1));
              $res->redirect($uri);
              return $res->finalize;
          }
  
          # now we are sure there's client_id
          my $sub = $self->get_listener($env);
  
          return sub {
              my $responder = shift;
              my $writer = $responder->
                  ([200,
                    [ 'Content-Type' => 'application/json',
                      'Cache-Control' => 'no-cache, must-revalidate',
                      'Pragma' => 'no-cache',
                      'Expires' => HTTP::Date::time2str(0),
                      'Last-Modified' => HTTP::Date::time2str(time())
                  ]]);
              $sub->poll_once(sub { $writer->write(JSON::encode_json(\@_));
                                    $writer->close });
          }
      }
      elsif ($env->{PATH_INFO} eq '/init') {
          my $h = $env->{'hippie.handle'}
              or return [ '400', [ 'Content-Type' => 'text/plain' ], [ "" ] ];
  
          my $sub = $self->get_listener($env);
          if ($env->{'hippie.handle'} &&
              $env->{'hippie.handle'}->isa('Web::Hippie::Handle::WebSocket')) {
              $sub->timeout(15);
          }
  
          $sub->on_error(sub {
                             my ($queue, $error, @msg) = @_;
                             $queue->persistent(0);
                             $queue->append(@msg);
                         });
          $sub->poll(sub { $h->send_msg($_) for @_ });
      }
      elsif ($env->{PATH_INFO} eq '/error') {
          my $sub = $env->{'hippie.listener'} or die;
          # XXX: AnyMQ should provide unpoll method.
          $sub->cv->cb(undef);
          $sub->persistent(0);
          $sub->{timer} = $sub->_reaper;
      }
      else {
          $self->get_listener($env);
          return $self->app->($env);
      }
  }
  
  sub get_listener {
      my ($self, $env) = @_;
      my $client_id = $env->{'hippie.client_id'} ||= rand(1);
      my $sub = $self->client_mgr->{$client_id};
  
      my $new = !$sub || $sub->destroyed;
      if ($new) {
          $sub = $self->client_mgr->{$client_id} = $self->bus->new_listener();
          $sub->on_timeout(sub { $_[0]->destroyed(1);
                                 $env->{PATH_INFO} = '/error';
                                 $self->app->($env);
                                 delete $self->client_mgr->{$client_id};
                             });
          $env->{'hippie.listener'} = $sub;
          # XXX the recycling should be done in anymq
          $env->{PATH_INFO} = '/new_listener';
          $self->app->($env);
          $sub->append({ type => 'hippie.pipe.set_client_id',
                         client_id => $client_id} );
      }
  
      # XXX: callback to verify we have access to this listener.
      $env->{'hippie.listener'} = $sub;
      return $sub;
  
  }
  
  1;
  
  =head1 NAME
  
  Web::Hippie::Pipe - Persistent Connection Abstraction for Hippie
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    use AnyMQ;
  
    builder {
      mount '/_hippie' => builder {
        enable "+Web::Hippie";
        enable "+Web::Hippie::Pipe", bus => AnyMQ->new;
        sub { my $env = shift;
              my $bus       = $env->{'hippie.bus'}; # AnyMQ bus
              my $listener  = $env->{'hippie.listener'}; # AnyMQ::Queue
              my $client_id = $env->{'hippie.client_id'}; # client id
  
              # Your handler based on PATH_INFO: /new_listener, /error, /message
        }
      };
      mount '/' => my $app;
    };
  
  =head1 DESCRIPTION
  
  Web::Hippie::Pipe provides unified bidirectional communication over
  HTTP via websocket, mxhr, or long-poll, for your C<PSGI> applications.
  
  =head1 SEE ALSO
  
  L<Web::Hippie>
  
  =head1 AUTHOR
  
  Chia-liang Kao E<lt>clkao@clkao.orgE<gt>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  =cut
WEB_HIPPIE_PIPE

$fatpacked{"common/sense.pm"} = <<'COMMON_SENSE';
  
  =head1 NAME
  
  common::sense - save a tree AND a kitten, use common::sense!
  
  =head1 SYNOPSIS
  
   use common::sense;
  
   # supposed to be the same, with much lower memory usage, as:
   #
   # use utf8;
   # use strict qw(vars subs);
   # use feature qw(say state switch);
   # no warnings;
   # use warnings qw(FATAL closed threads internal debugging pack
   #                 portable prototype inplace io pipe unpack malloc
   #                 deprecated glob digit printf layer
   #                 reserved taint closure semicolon);
   # no warnings qw(exec newline unopened);
  
  
  =head1 DESCRIPTION
  
     Nothing is more fairly distributed than common sense: no one thinks
     he needs more of it than he already has.
  
      Ren Descartes
  
  This module implements some sane defaults for Perl programs, as defined by
  two typical (or not so typical - use your common sense) specimens of Perl
  coders. In fact, after working out details on which warnings and strict
  modes to enable and make fatal, we found that we (and our code written so
  far, and others) fully agree on every option, even though we never used
  warnings before, so it seems this module indeed reflects a "common" sense
  among some long-time Perl coders.
  
  The basic philosophy behind the choices made in common::sense can be
  summarised as: "enforcing strict policies to catch as many bugs as
  possible, while at the same time, not limiting the expressive power
  available to the programmer".
  
  Two typical examples of how this philosophy is applied in practise is the
  handling of uninitialised and malloc warnings:
  
  =over 4
  
  =item I<uninitialised>
  
  C<undef> is a well-defined feature of perl, and enabling warnings for
  using it rarely catches any bugs, but considerably limits you in what you
  can do, so uninitialised warnings are disabled.
  
  =item I<malloc>
  
  Freeing something twice on the C level is a serious bug, usually causing
  memory corruption. It often leads to side effects much later in the
  program and there are no advantages to not reporting this, so malloc
  warnings are fatal by default.
  
  =back
  
  Unfortunately, there is no fine-grained warning control in perl, so often
  whole groups of useful warnings had to be excluded because of a single
  useless warning (for example, perl puts an arbitrary limit on the length
  of text you can match with some regexes before emitting a warning, making
  the whole C<regexp> category useless).
  
  What follows is a more thorough discussion of what this module does,
  and why it does it, and what the advantages (and disadvantages) of this
  approach are.
  
  =head1 RATIONALE
  
  =over 4
  
  =item use utf8
  
  While it's not common sense to write your programs in UTF-8, it's quickly
  becoming the most common encoding, is the designated future default
  encoding for perl sources, and the most convenient encoding available
  (you can do really nice quoting tricks...). Experience has shown that our
  programs were either all pure ascii or utf-8, both of which will stay the
  same.
  
  There are few drawbacks to enabling UTF-8 source code by default (mainly
  some speed hits due to bugs in older versions of perl), so this module
  enables UTF-8 source code encoding by default.
  
  
  =item use strict qw(subs vars)
  
  Using C<use strict> is definitely common sense, but C<use strict
  'refs'> definitely overshoots its usefulness. After almost two
  decades of Perl hacking, we decided that it does more harm than being
  useful. Specifically, constructs like these:
  
     @{ $var->[0] }
  
  Must be written like this (or similarly), when C<use strict 'refs'> is in
  scope, and C<$var> can legally be C<undef>:
  
     @{ $var->[0] || [] }
  
  This is annoying, and doesn't shield against obvious mistakes such as
  using C<"">, so one would even have to write (at least for the time
  being):
  
     @{ defined $var->[0] ? $var->[0] : [] }
  
  ... which nobody with a bit of common sense would consider
  writing: clear code is clearly something else.
  
  Curiously enough, sometimes perl is not so strict, as this works even with
  C<use strict> in scope:
  
     for (@{ $var->[0] }) { ...
  
  If that isn't hypocrisy! And all that from a mere program!
  
  
  =item use feature qw(say state given)
  
  We found it annoying that we always have to enable extra features. If
  something breaks because it didn't anticipate future changes, so be
  it. 5.10 broke almost all our XS modules and nobody cared either (or at
  least I know of nobody who really complained about gratuitous changes -
  as opposed to bugs).
  
  Few modules that are not actively maintained work with newer versions of
  Perl, regardless of use feature or not, so a new major perl release means
  changes to many modules - new keywords are just the tip of the iceberg.
  
  If your code isn't alive, it's dead, Jim - be an active maintainer.
  
  But nobody forces you to use those extra features in modules meant for
  older versions of perl - common::sense of course works there as well.
  There is also an important other mode where having additional features by
  default is useful: commandline hacks and internal use scripts: See "much
  reduced typing", below.
  
  
  =item no warnings, but a lot of new errors
  
  Ah, the dreaded warnings. Even worse, the horribly dreaded C<-w>
  switch: Even though we don't care if other people use warnings (and
  certainly there are useful ones), a lot of warnings simply go against the
  spirit of Perl.
  
  Most prominently, the warnings related to C<undef>. There is nothing wrong
  with C<undef>: it has well-defined semantics, it is useful, and spitting
  out warnings you never asked for is just evil.
  
  The result was that every one of our modules did C<no warnings> in the
  past, to avoid somebody accidentally using and forcing his bad standards
  on our code. Of course, this switched off all warnings, even the useful
  ones. Not a good situation. Really, the C<-w> switch should only enable
  warnings for the main program only.
  
  Funnily enough, L<perllexwarn> explicitly mentions C<-w> (and not in a
  favourable way, calling it outright "wrong"), but standard utilities, such
  as L<prove>, or MakeMaker when running C<make test>, still enable them
  blindly.
  
  For version 2 of common::sense, we finally sat down a few hours and went
  through I<every single warning message>, identifiying - according to
  common sense - all the useful ones.
  
  This resulted in the rather impressive list in the SYNOPSIS. When we
  weren't sure, we didn't include the warning, so the list might grow in
  the future (we might have made a mistake, too, so the list might shrink
  as well).
  
  Note the presence of C<FATAL> in the list: we do not think that the
  conditions caught by these warnings are worthy of a warning, we I<insist>
  that they are worthy of I<stopping> your program, I<instantly>. They are
  I<bugs>!
  
  Therefore we consider C<common::sense> to be much stricter than C<use
  warnings>, which is good if you are into strict things (we are not,
  actually, but these things tend to be subjective).
  
  After deciding on the list, we ran the module against all of our code that
  uses C<common::sense> (that is almost all of our code), and found only one
  occurence where one of them caused a problem: one of elmex's (unreleased)
  modules contained:
  
     $fmt =~ s/([^\s\[]*)\[( [^\]]* )\]/\x0$1\x1$2\x0/xgo;
  
  We quickly agreed that indeed the code should be changed, even though it
  happened to do the right thing when the warning was switched off.
  
  
  =item much reduced typing
  
  Especially with version 2.0 of common::sense, the amount of boilerplate
  code you need to add to gte I<this> policy is daunting. Nobody would write
  this out in throwaway scripts, commandline hacks or in quick internal-use
  scripts.
  
  By using common::sense you get a defined set of policies (ours, but maybe
  yours, too, if you accept them), and they are easy to apply to your
  scripts: typing C<use common::sense;> is even shorter than C<use warnings;
  use strict; use feature ...>.
  
  And you can immediately use the features of your installed perl, which
  is more difficult in code you release, but not usually an issue for
  internal-use code (downgrades of your production perl should be rare,
  right?).
  
  
  =item mucho reduced memory usage
  
  Just using all those pragmas mentioned in the SYNOPSIS together wastes
  <blink>I<< B<776> kilobytes >></blink> of precious memory in my perl, for
  I<every single perl process using our code>, which on our machines, is a
  lot. In comparison, this module only uses I<< B<four> >> kilobytes (I even
  had to write it out so it looks like more) of memory on the same platform.
  
  The money/time/effort/electricity invested in these gigabytes (probably
  petabytes globally!) of wasted memory could easily save 42 trees, and a
  kitten!
  
  Unfortunately, until everybods applies more common sense, there will still
  often be modules that pull in the monster pragmas. But one can hope...
  
  =cut
  
  package common::sense;
  
  our $VERSION = '3.4';
  
  # overload should be included
  
  sub import {
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x3c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00";
     # use strict, use utf8;
     $^H |= 0x820600;
     # use feature
     $^H{feature_switch} =
     $^H{feature_say}    =
     $^H{feature_state}  = 1;
  }
  
  1;
  
  =back
  
  =head1 THERE IS NO 'no common::sense'!!!! !!!! !!
  
  This module doesn't offer an unimport. First of all, it wastes even more
  memory, second, and more importantly, who with even a bit of common sense
  would want no common sense?
  
  =head1 STABILITY AND FUTURE VERSIONS
  
  Future versions might change just about everything in this module. We
  might test our modules and upload new ones working with newer versions of
  this module, and leave you standing in the rain because we didn't tell
  you. In fact, we did so when switching from 1.0 to 2.0, which enabled gobs
  of warnings, and made them FATAL on top.
  
  Maybe we will load some nifty modules that try to emulate C<say> or so
  with perls older than 5.10 (this module, of course, should work with older
  perl versions - supporting 5.8 for example is just common sense at this
  time. Maybe not in the future, but of course you can trust our common
  sense to be consistent with, uhm, our opinion).
  
  =head1 WHAT OTHER PEOPLE HAD TO SAY ABOUT THIS MODULE
  
  apeiron
  
     "... wow"
     "I hope common::sense is a joke."
  
  crab
  
     "i wonder how it would be if joerg schilling wrote perl modules."
  
  Adam Kennedy
  
     "Very interesting, efficient, and potentially something I'd use all the time."
     [...]
     "So no common::sense for me, alas."
  
  H.Merijn Brand
  
     "Just one more reason to drop JSON::XS from my distribution list"
  
  Pista Palo
  
     "Something in short supply these days..."
  
  Steffen Schwigon
  
     "This module is quite for sure *not* just a repetition of all the other
     'use strict, use warnings'-approaches, and it's also not the opposite.
     [...] And for its chosen middle-way it's also not the worst name ever.
     And everything is documented."
  
  BKB
  
     "[Deleted - thanks to Steffen Schwigon for pointing out this review was
     in error.]"
  
  Somni
  
     "the arrogance of the guy"
     "I swear he tacked somenoe else's name onto the module
     just so he could use the royal 'we' in the documentation"
  
  Anonymous Monk
  
     "You just gotta love this thing, its got META.json!!!"
  
  dngor
  
     "Heh.  '"<elmex at ta-sa.org>"'  The quotes are semantic
     distancing from that e-mail address."
  
  Jerad Pierce
  
     "Awful name (not a proper pragma), and the SYNOPSIS doesn't tell you
     anything either. Nor is it clear what features have to do with "common
     sense" or discipline."
  
  acme
  
     "THERE IS NO 'no common::sense'!!!! !!!! !!"
  
  apeiron (meta-comment about us commenting^Wquoting his comment)
  
     "How about quoting this: get a clue, you fucktarded amoeba."
  
  quanth
  
     "common sense is beautiful, json::xs is fast, Anyevent, EV are fast and
     furious. I love mlehmannware ;)"
  
  apeiron
  
     "... it's mlehmann's view of what common sense is. His view of common
     sense is certainly uncommon, insofar as anyone with a clue disagrees
     with him."
  
  apeiron (another meta-comment)
  
     "apeiron wonders if his little informant is here to steal more quotes"
  
  ew73
  
     "... I never got past the SYNOPSIS before calling it shit."
     [...]
     How come no one ever quotes me. :("
  
  =head1 FREQUENTLY ASKED QUESTIONS
  
  Or frequently-come-up confusions.
  
  =over 4
  
  =item Is this module meant to be serious?
  
  Yes, we would have put it under the C<Acme::> namespace otherwise.
  
  =item But the manpage is written in a funny/stupid/... way?
  
  This was meant to make it clear that our common sense is a subjective
  thing and other people can use their own notions, taking the steam out
  of anybody who might be offended (as some people are always offended no
  matter what you do).
  
  This was a failure.
  
  But we hope the manpage still is somewhat entertaining even though it
  explains boring rationale.
  
  =item Why do you impose your conventions on my code?
  
  For some reason people keep thinking that C<common::sense> imposes
  process-wide limits, even though the SYNOPSIS makes it clear that it works
  like other similar modules - i.e. only within the scope that C<use>s them.
  
  So, no, we don't - nobody is forced to use this module, and using a module
  that relies on common::sense does not impose anything on you.
  
  =item Why do you think only your notion of common::sense is valid?
  
  Well, we don't, and have clearly written this in the documentation to
  every single release. We were just faster than anybody else w.r.t. to
  grabbing the namespace.
  
  =item But everybody knows that you have to use strict and use warnings,
  why do you disable them?
  
  Well, we don't do this either - we selectively disagree with the
  usefulness of some warnings over others. This module is aimed at
  experienced Perl programmers, not people migrating from other languages
  who might be surprised about stuff such as C<undef>. On the other hand,
  this does not exclude the usefulness of this module for total newbies, due
  to its strictness in enforcing policy, while at the same time not limiting
  the expressive power of perl.
  
  This module is considerably I<more> strict than the canonical C<use
  strict; use warnings>, as it makes all its warnings fatal in nature, so
  you can not get away with as many things as with the canonical approach.
  
  This was not implemented in version 1.0 because of the daunting number
  of warning categories and the difficulty in getting exactly the set of
  warnings you wish (i.e. look at the SYNOPSIS in how complicated it is to
  get a specific set of warnings - it is not reasonable to put this into
  every module, the maintenance effort would be enourmous).
  
  =item But many modules C<use strict> or C<use warnings>, so the memory
  savings do not apply?
  
  I suddenly feel sad...
  
  But yes, that's true. Fortunately C<common::sense> still uses only a
  miniscule amount of RAM.
  
  =item But it adds another dependency to your modules!
  
  It's a fact, yeah. But it's trivial to install, most popular modules have
  many more dependencies and we consider dependencies a good thing - it
  leads to better APIs, more thought about interworking of modules and so
  on.
  
  =item Why do you use JSON and not YAML for your META.yml?
  
  This is not true - YAML supports a large subset of JSON, and this subset
  is what META.yml is written in, so it would be correct to say "the
  META.yml is written in a common subset of YAML and JSON".
  
  The META.yml follows the YAML, JSON and META.yml specifications, and is
  correctly parsed by CPAN, so if you have trouble with it, the problem is
  likely on your side.
  
  =item But! But!
  
  Yeah, we know.
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
   Robin Redeker, "<elmex at ta-sa.org>".
  
  =cut
  
COMMON_SENSE

$fatpacked{"darwin-2level/AE.pm"} = <<'DARWIN-2LEVEL_AE';
  =head1 NAME
  
  AE - simpler/faster/newer/cooler AnyEvent API
  
  =head1 SYNOPSIS
  
    use AnyEvent; # not AE
  
    # file handle or descriptor readable
    my $w = AE::io $fh, 0, sub { ...  };
  
    # one-shot or repeating timers
    my $w = AE::timer $seconds,         0, sub { ... }; # once
    my $w = AE::timer $seconds, $interval, sub { ... }; # repeated
  
    print AE::now;  # prints current event loop time
    print AE::time; # think Time::HiRes::time or simply CORE::time.
  
    # POSIX signal
    my $w = AE::signal TERM => sub { ... };
  
    # child process exit
    my $w = AE::child $pid, sub {
       my ($pid, $status) = @_;
       ...
    };
  
    # called when event loop idle (if applicable)
    my $w = AE::idle sub { ... };
  
    my $cv = AE::cv; # stores whether a condition was flagged
    $cv->send; # wake up current and all future recv's
    $cv->recv; # enters "main loop" till $condvar gets ->send
    # use a condvar in callback mode:
    $cv->cb (sub { $_[0]->recv });
  
  
  =head1 DESCRIPTION
  
  This module documents the new simpler AnyEvent API.
  
  The rationale for the new API is that experience with L<EV> shows that
  this API actually "works", despite its lack of extensibility, leading to
  a shorter, easier and faster API.
  
  The main differences from AnyEvent is that function calls are used
  instead of method calls, and that no named arguments are used.
  
  This makes calls to watcher creation functions really short, which can
  make a program more readable despite the lack of named parameters.
  Function calls also allow more static type checking than method calls, so
  many mistakes are caught at compile-time with this API.
  
  Also, some backends (Perl and EV) are so fast that the method call
  overhead is very noticeable (with EV it increases the execution time five-
  to six-fold, with Perl the method call overhead is about a factor of two).
  
  Note that the C<AE> API is an alternative to, not the future version of,
  the AnyEvent API. Both APIs can be used interchangeably and there are
  no plans to "switch", so if in doubt, feel free to use the L<AnyEvent>
  API in new code.
  
  As the AE API is complementary, not everything in the AnyEvent API is
  available, and you still need to use AnyEvent for the finer stuff. Also,
  you should not C<use AE> directly, C<use AnyEvent> will provide the AE
  namespace.
  
  At the moment, these functions will become slower then their method-call
  counterparts when using L<AnyEvent::Strict> or L<AnyEvent::Debug>::wrap.
  
  =head2 FUNCTIONS
  
  This section briefly describes the alternative watcher constructors and
  other functions available inside the C<AE> namespace. Semantics are not
  described here; please refer to the description of the function or method
  with the same name in the L<AnyEvent> manpage for the details.
  
  =over 4
  
  =cut
  
  package AE;
  
  use AnyEvent (); # BEGIN { AnyEvent::common_sense }
  
  our $VERSION = $AnyEvent::VERSION;
  
  =item $w = AE::io $fh_or_fd, $watch_write, $cb
  
  Creates an I/O watcher that listens for read events (C<$watch_write>
  false) or write events (C<$watch_write> is true) on the file handle or
  file descriptor C<$fh_or_fd>.
  
  The callback C<$cb> is invoked as soon and as long as I/O of the type
  specified by C<$watch_write>) can be done on the file handle/descriptor.
  
  Example: wait until STDIN becomes readable.
  
    $stdin_ready = AE::io *STDIN, 0, sub { scalar <STDIN> };
  
  Example: wait until STDOUT becomes writable and print something.
  
    $stdout_ready = AE::io *STDOUT, 1, sub { print STDOUT "woaw\n" };
  
  =item $w = AE::timer $after, $interval, $cb
  
  Creates a timer watcher that invokes the callback C<$cb> after at least
  C<$after> second have passed (C<$after> can be negative or C<0>).
  
  If C<$interval> is C<0>, then the callback will only be invoked once,
  otherwise it must be a positive number of seconds that specifies the
  interval between successive invocations of the callback.
  
  Example: print "too late" after at least one second has passed.
  
    $timer_once = AE::timer 1, 0, sub { print "too late\n" };
  
  Example: print "blubb" once a second, starting as soon as possible.
  
    $timer_repeated = AE::timer 0, 1, sub { print "blubb\n" };
  
  =item $w = AE::signal $signame, $cb
  
  Invoke the callback C<$cb> each time one or more occurrences of the
  named signal C<$signame> are detected.
  
  =item $w = AE::child $pid, $cb
  
  Invokes the callback C<$cb> when the child with the given C<$pid> exits
  (or all children, when C<$pid> is zero).
  
  The callback will get the actual pid and exit status as arguments.
  
  =item $w = AE::idle $cb
  
  Invoke the callback C<$cb> each time the event loop is "idle" (has no
  events outstanding), but do not prevent the event loop from polling for
  more events.
  
  =item $cv = AE::cv
  
  =item $cv = AE::cv { BLOCK }
  
  Create a new condition variable. The first form is identical to C<<
  AnyEvent->condvar >>, the second form additionally sets the callback (as
  if the C<cb> method is called on the condition variable).
  
  =item AE::now
  
  Returns the current event loop time (may be cached by the event loop).
  
  =item AE::now_update
  
  Ensures that the current event loop time is up to date.
  
  =item AE::time
  
  Return the current time (not cached, always consults a hardware clock).
  
  =item AE::postpone { BLOCK }
  
  Exactly the same as C<AnyEvent:::postpone>.
  
  =item AE::log $level, $msg[, @args]
  
  Exactly the same as C<AnyEvent::log> (or C<AnyEvent::Log::log>).
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
DARWIN-2LEVEL_AE

$fatpacked{"darwin-2level/AnyEvent.pm"} = <<'DARWIN-2LEVEL_ANYEVENT';
  =head1 NAME
  
  AnyEvent - the DBI of event loop programming
  
  EV, Event, Glib, Tk, Perl, Event::Lib, Irssi, rxvt-unicode, IO::Async, Qt,
  FLTK and POE are various supported event loops/environments.
  
  =head1 SYNOPSIS
  
     use AnyEvent;
  
     # if you prefer function calls, look at the AE manpage for
     # an alternative API.
  
     # file handle or descriptor readable
     my $w = AnyEvent->io (fh => $fh, poll => "r", cb => sub { ...  });
  
     # one-shot or repeating timers
     my $w = AnyEvent->timer (after => $seconds, cb => sub { ...  });
     my $w = AnyEvent->timer (after => $seconds, interval => $seconds, cb => ...);
  
     print AnyEvent->now;  # prints current event loop time
     print AnyEvent->time; # think Time::HiRes::time or simply CORE::time.
  
     # POSIX signal
     my $w = AnyEvent->signal (signal => "TERM", cb => sub { ... });
  
     # child process exit
     my $w = AnyEvent->child (pid => $pid, cb => sub {
        my ($pid, $status) = @_;
        ...
     });
  
     # called when event loop idle (if applicable)
     my $w = AnyEvent->idle (cb => sub { ... });
  
     my $w = AnyEvent->condvar; # stores whether a condition was flagged
     $w->send; # wake up current and all future recv's
     $w->recv; # enters "main loop" till $condvar gets ->send
     # use a condvar in callback mode:
     $w->cb (sub { $_[0]->recv });
  
  =head1 INTRODUCTION/TUTORIAL
  
  This manpage is mainly a reference manual. If you are interested
  in a tutorial or some gentle introduction, have a look at the
  L<AnyEvent::Intro> manpage.
  
  =head1 SUPPORT
  
  An FAQ document is available as L<AnyEvent::FAQ>.
  
  There also is a mailinglist for discussing all things AnyEvent, and an IRC
  channel, too.
  
  See the AnyEvent project page at the B<Schmorpforge Ta-Sa Software
  Repository>, at L<http://anyevent.schmorp.de>, for more info.
  
  =head1 WHY YOU SHOULD USE THIS MODULE (OR NOT)
  
  Glib, POE, IO::Async, Event... CPAN offers event models by the dozen
  nowadays. So what is different about AnyEvent?
  
  Executive Summary: AnyEvent is I<compatible>, AnyEvent is I<free of
  policy> and AnyEvent is I<small and efficient>.
  
  First and foremost, I<AnyEvent is not an event model> itself, it only
  interfaces to whatever event model the main program happens to use, in a
  pragmatic way. For event models and certain classes of immortals alike,
  the statement "there can only be one" is a bitter reality: In general,
  only one event loop can be active at the same time in a process. AnyEvent
  cannot change this, but it can hide the differences between those event
  loops.
  
  The goal of AnyEvent is to offer module authors the ability to do event
  programming (waiting for I/O or timer events) without subscribing to a
  religion, a way of living, and most importantly: without forcing your
  module users into the same thing by forcing them to use the same event
  model you use.
  
  For modules like POE or IO::Async (which is a total misnomer as it is
  actually doing all I/O I<synchronously>...), using them in your module is
  like joining a cult: After you join, you are dependent on them and you
  cannot use anything else, as they are simply incompatible to everything
  that isn't them. What's worse, all the potential users of your
  module are I<also> forced to use the same event loop you use.
  
  AnyEvent is different: AnyEvent + POE works fine. AnyEvent + Glib works
  fine. AnyEvent + Tk works fine etc. etc. but none of these work together
  with the rest: POE + EV? No go. Tk + Event? No go. Again: if your module
  uses one of those, every user of your module has to use it, too. But if
  your module uses AnyEvent, it works transparently with all event models it
  supports (including stuff like IO::Async, as long as those use one of the
  supported event loops. It is easy to add new event loops to AnyEvent, too,
  so it is future-proof).
  
  In addition to being free of having to use I<the one and only true event
  model>, AnyEvent also is free of bloat and policy: with POE or similar
  modules, you get an enormous amount of code and strict rules you have to
  follow. AnyEvent, on the other hand, is lean and to the point, by only
  offering the functionality that is necessary, in as thin as a wrapper as
  technically possible.
  
  Of course, AnyEvent comes with a big (and fully optional!) toolbox
  of useful functionality, such as an asynchronous DNS resolver, 100%
  non-blocking connects (even with TLS/SSL, IPv6 and on broken platforms
  such as Windows) and lots of real-world knowledge and workarounds for
  platform bugs and differences.
  
  Now, if you I<do want> lots of policy (this can arguably be somewhat
  useful) and you want to force your users to use the one and only event
  model, you should I<not> use this module.
  
  =head1 DESCRIPTION
  
  L<AnyEvent> provides a uniform interface to various event loops. This
  allows module authors to use event loop functionality without forcing
  module users to use a specific event loop implementation (since more
  than one event loop cannot coexist peacefully).
  
  The interface itself is vaguely similar, but not identical to the L<Event>
  module.
  
  During the first call of any watcher-creation method, the module tries
  to detect the currently loaded event loop by probing whether one of the
  following modules is already loaded: L<EV>, L<AnyEvent::Loop>,
  L<Event>, L<Glib>, L<Tk>, L<Event::Lib>, L<Qt>, L<POE>. The first one
  found is used. If none are detected, the module tries to load the first
  four modules in the order given; but note that if L<EV> is not
  available, the pure-perl L<AnyEvent::Loop> should always work, so
  the other two are not normally tried.
  
  Because AnyEvent first checks for modules that are already loaded, loading
  an event model explicitly before first using AnyEvent will likely make
  that model the default. For example:
  
     use Tk;
     use AnyEvent;
  
     # .. AnyEvent will likely default to Tk
  
  The I<likely> means that, if any module loads another event model and
  starts using it, all bets are off - this case should be very rare though,
  as very few modules hardcode event loops without announcing this very
  loudly.
  
  The pure-perl implementation of AnyEvent is called C<AnyEvent::Loop>. Like
  other event modules you can load it explicitly and enjoy the high
  availability of that event loop :)
  
  =head1 WATCHERS
  
  AnyEvent has the central concept of a I<watcher>, which is an object that
  stores relevant data for each kind of event you are waiting for, such as
  the callback to call, the file handle to watch, etc.
  
  These watchers are normal Perl objects with normal Perl lifetime. After
  creating a watcher it will immediately "watch" for events and invoke the
  callback when the event occurs (of course, only when the event model
  is in control).
  
  Note that B<callbacks must not permanently change global variables>
  potentially in use by the event loop (such as C<$_> or C<$[>) and that B<<
  callbacks must not C<die> >>. The former is good programming practice in
  Perl and the latter stems from the fact that exception handling differs
  widely between event loops.
  
  To disable a watcher you have to destroy it (e.g. by setting the
  variable you store it in to C<undef> or otherwise deleting all references
  to it).
  
  All watchers are created by calling a method on the C<AnyEvent> class.
  
  Many watchers either are used with "recursion" (repeating timers for
  example), or need to refer to their watcher object in other ways.
  
  One way to achieve that is this pattern:
  
     my $w; $w = AnyEvent->type (arg => value ..., cb => sub {
        # you can use $w here, for example to undef it
        undef $w;
     });
  
  Note that C<my $w; $w => combination. This is necessary because in Perl,
  my variables are only visible after the statement in which they are
  declared.
  
  =head2 I/O WATCHERS
  
     $w = AnyEvent->io (
        fh   => <filehandle_or_fileno>,
        poll => <"r" or "w">,
        cb   => <callback>,
     );
  
  You can create an I/O watcher by calling the C<< AnyEvent->io >> method
  with the following mandatory key-value pairs as arguments:
  
  C<fh> is the Perl I<file handle> (or a naked file descriptor) to watch
  for events (AnyEvent might or might not keep a reference to this file
  handle). Note that only file handles pointing to things for which
  non-blocking operation makes sense are allowed. This includes sockets,
  most character devices, pipes, fifos and so on, but not for example files
  or block devices.
  
  C<poll> must be a string that is either C<r> or C<w>, which creates a
  watcher waiting for "r"eadable or "w"ritable events, respectively.
  
  C<cb> is the callback to invoke each time the file handle becomes ready.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to I/O watcher callbacks.
  
  The I/O watcher might use the underlying file descriptor or a copy of it.
  You must not close a file handle as long as any watcher is active on the
  underlying file descriptor.
  
  Some event loops issue spurious readiness notifications, so you should
  always use non-blocking calls when reading/writing from/to your file
  handles.
  
  Example: wait for readability of STDIN, then read a line and disable the
  watcher.
  
     my $w; $w = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
        chomp (my $input = <STDIN>);
        warn "read: $input\n";
        undef $w;
     });
  
  =head2 TIME WATCHERS
  
     $w = AnyEvent->timer (after => <seconds>, cb => <callback>);
  
     $w = AnyEvent->timer (
        after    => <fractional_seconds>,
        interval => <fractional_seconds>,
        cb       => <callback>,
     );
  
  You can create a time watcher by calling the C<< AnyEvent->timer >>
  method with the following mandatory arguments:
  
  C<after> specifies after how many seconds (fractional values are
  supported) the callback should be invoked. C<cb> is the callback to invoke
  in that case.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to time watcher callbacks.
  
  The callback will normally be invoked only once. If you specify another
  parameter, C<interval>, as a strictly positive number (> 0), then the
  callback will be invoked regularly at that interval (in fractional
  seconds) after the first invocation. If C<interval> is specified with a
  false value, then it is treated as if it were not specified at all.
  
  The callback will be rescheduled before invoking the callback, but no
  attempt is made to avoid timer drift in most backends, so the interval is
  only approximate.
  
  Example: fire an event after 7.7 seconds.
  
     my $w = AnyEvent->timer (after => 7.7, cb => sub {
        warn "timeout\n";
     });
  
     # to cancel the timer:
     undef $w;
  
  Example 2: fire an event after 0.5 seconds, then roughly every second.
  
     my $w = AnyEvent->timer (after => 0.5, interval => 1, cb => sub {
        warn "timeout\n";
     };
  
  =head3 TIMING ISSUES
  
  There are two ways to handle timers: based on real time (relative, "fire
  in 10 seconds") and based on wallclock time (absolute, "fire at 12
  o'clock").
  
  While most event loops expect timers to specified in a relative way, they
  use absolute time internally. This makes a difference when your clock
  "jumps", for example, when ntp decides to set your clock backwards from
  the wrong date of 2014-01-01 to 2008-01-01, a watcher that is supposed to
  fire "after a second" might actually take six years to finally fire.
  
  AnyEvent cannot compensate for this. The only event loop that is conscious
  of these issues is L<EV>, which offers both relative (ev_timer, based
  on true relative time) and absolute (ev_periodic, based on wallclock time)
  timers.
  
  AnyEvent always prefers relative timers, if available, matching the
  AnyEvent API.
  
  AnyEvent has two additional methods that return the "current time":
  
  =over 4
  
  =item AnyEvent->time
  
  This returns the "current wallclock time" as a fractional number of
  seconds since the Epoch (the same thing as C<time> or C<Time::HiRes::time>
  return, and the result is guaranteed to be compatible with those).
  
  It progresses independently of any event loop processing, i.e. each call
  will check the system clock, which usually gets updated frequently.
  
  =item AnyEvent->now
  
  This also returns the "current wallclock time", but unlike C<time>, above,
  this value might change only once per event loop iteration, depending on
  the event loop (most return the same time as C<time>, above). This is the
  time that AnyEvent's timers get scheduled against.
  
  I<In almost all cases (in all cases if you don't care), this is the
  function to call when you want to know the current time.>
  
  This function is also often faster then C<< AnyEvent->time >>, and
  thus the preferred method if you want some timestamp (for example,
  L<AnyEvent::Handle> uses this to update its activity timeouts).
  
  The rest of this section is only of relevance if you try to be very exact
  with your timing; you can skip it without a bad conscience.
  
  For a practical example of when these times differ, consider L<Event::Lib>
  and L<EV> and the following set-up:
  
  The event loop is running and has just invoked one of your callbacks at
  time=500 (assume no other callbacks delay processing). In your callback,
  you wait a second by executing C<sleep 1> (blocking the process for a
  second) and then (at time=501) you create a relative timer that fires
  after three seconds.
  
  With L<Event::Lib>, C<< AnyEvent->time >> and C<< AnyEvent->now >> will
  both return C<501>, because that is the current time, and the timer will
  be scheduled to fire at time=504 (C<501> + C<3>).
  
  With L<EV>, C<< AnyEvent->time >> returns C<501> (as that is the current
  time), but C<< AnyEvent->now >> returns C<500>, as that is the time the
  last event processing phase started. With L<EV>, your timer gets scheduled
  to run at time=503 (C<500> + C<3>).
  
  In one sense, L<Event::Lib> is more exact, as it uses the current time
  regardless of any delays introduced by event processing. However, most
  callbacks do not expect large delays in processing, so this causes a
  higher drift (and a lot more system calls to get the current time).
  
  In another sense, L<EV> is more exact, as your timer will be scheduled at
  the same time, regardless of how long event processing actually took.
  
  In either case, if you care (and in most cases, you don't), then you
  can get whatever behaviour you want with any event loop, by taking the
  difference between C<< AnyEvent->time >> and C<< AnyEvent->now >> into
  account.
  
  =item AnyEvent->now_update
  
  Some event loops (such as L<EV> or L<AnyEvent::Loop>) cache the current
  time for each loop iteration (see the discussion of L<< AnyEvent->now >>,
  above).
  
  When a callback runs for a long time (or when the process sleeps), then
  this "current" time will differ substantially from the real time, which
  might affect timers and time-outs.
  
  When this is the case, you can call this method, which will update the
  event loop's idea of "current time".
  
  A typical example would be a script in a web server (e.g. C<mod_perl>) -
  when mod_perl executes the script, then the event loop will have the wrong
  idea about the "current time" (being potentially far in the past, when the
  script ran the last time). In that case you should arrange a call to C<<
  AnyEvent->now_update >> each time the web server process wakes up again
  (e.g. at the start of your script, or in a handler).
  
  Note that updating the time I<might> cause some events to be handled.
  
  =back
  
  =head2 SIGNAL WATCHERS
  
     $w = AnyEvent->signal (signal => <uppercase_signal_name>, cb => <callback>);
  
  You can watch for signals using a signal watcher, C<signal> is the signal
  I<name> in uppercase and without any C<SIG> prefix, C<cb> is the Perl
  callback to be invoked whenever a signal occurs.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to signal watcher callbacks.
  
  Multiple signal occurrences can be clumped together into one callback
  invocation, and callback invocation will be synchronous. Synchronous means
  that it might take a while until the signal gets handled by the process,
  but it is guaranteed not to interrupt any other callbacks.
  
  The main advantage of using these watchers is that you can share a signal
  between multiple watchers, and AnyEvent will ensure that signals will not
  interrupt your program at bad times.
  
  This watcher might use C<%SIG> (depending on the event loop used),
  so programs overwriting those signals directly will likely not work
  correctly.
  
  Example: exit on SIGINT
  
     my $w = AnyEvent->signal (signal => "INT", cb => sub { exit 1 });
  
  =head3 Restart Behaviour
  
  While restart behaviour is up to the event loop implementation, most will
  not restart syscalls (that includes L<Async::Interrupt> and AnyEvent's
  pure perl implementation).
  
  =head3 Safe/Unsafe Signals
  
  Perl signals can be either "safe" (synchronous to opcode handling)
  or "unsafe" (asynchronous) - the former might delay signal delivery
  indefinitely, the latter might corrupt your memory.
  
  AnyEvent signal handlers are, in addition, synchronous to the event loop,
  i.e. they will not interrupt your running perl program but will only be
  called as part of the normal event handling (just like timer, I/O etc.
  callbacks, too).
  
  =head3 Signal Races, Delays and Workarounds
  
  Many event loops (e.g. Glib, Tk, Qt, IO::Async) do not support
  attaching callbacks to signals in a generic way, which is a pity,
  as you cannot do race-free signal handling in perl, requiring
  C libraries for this. AnyEvent will try to do its best, which
  means in some cases, signals will be delayed. The maximum time
  a signal might be delayed is 10 seconds by default, but can
  be overriden via C<$ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY}> or
  C<$AnyEvent::MAX_SIGNAL_LATENCY> - see the <ENVIRONMENT VARIABLES>
  section for details.
  
  All these problems can be avoided by installing the optional
  L<Async::Interrupt> module, which works with most event loops. It will not
  work with inherently broken event loops such as L<Event> or L<Event::Lib>
  (and not with L<POE> currently). For those, you just have to suffer the
  delays.
  
  =head2 CHILD PROCESS WATCHERS
  
     $w = AnyEvent->child (pid => <process id>, cb => <callback>);
  
  You can also watch for a child process exit and catch its exit status.
  
  The child process is specified by the C<pid> argument (on some backends,
  using C<0> watches for any child process exit, on others this will
  croak). The watcher will be triggered only when the child process has
  finished and an exit status is available, not on any trace events
  (stopped/continued).
  
  The callback will be called with the pid and exit status (as returned by
  waitpid), so unlike other watcher types, you I<can> rely on child watcher
  callback arguments.
  
  This watcher type works by installing a signal handler for C<SIGCHLD>,
  and since it cannot be shared, nothing else should use SIGCHLD or reap
  random child processes (waiting for specific child processes, e.g. inside
  C<system>, is just fine).
  
  There is a slight catch to child watchers, however: you usually start them
  I<after> the child process was created, and this means the process could
  have exited already (and no SIGCHLD will be sent anymore).
  
  Not all event models handle this correctly (neither POE nor IO::Async do,
  see their AnyEvent::Impl manpages for details), but even for event models
  that I<do> handle this correctly, they usually need to be loaded before
  the process exits (i.e. before you fork in the first place). AnyEvent's
  pure perl event loop handles all cases correctly regardless of when you
  start the watcher.
  
  This means you cannot create a child watcher as the very first
  thing in an AnyEvent program, you I<have> to create at least one
  watcher before you C<fork> the child (alternatively, you can call
  C<AnyEvent::detect>).
  
  As most event loops do not support waiting for child events, they will be
  emulated by AnyEvent in most cases, in which case the latency and race
  problems mentioned in the description of signal watchers apply.
  
  Example: fork a process and wait for it
  
     my $done = AnyEvent->condvar;
    
     my $pid = fork or exit 5;
    
     my $w = AnyEvent->child (
        pid => $pid,
        cb  => sub {
           my ($pid, $status) = @_;
           warn "pid $pid exited with status $status";
           $done->send;
        },
     );
    
     # do something else, then wait for process exit
     $done->recv;
  
  =head2 IDLE WATCHERS
  
     $w = AnyEvent->idle (cb => <callback>);
  
  This will repeatedly invoke the callback after the process becomes idle,
  until either the watcher is destroyed or new events have been detected.
  
  Idle watchers are useful when there is a need to do something, but it
  is not so important (or wise) to do it instantly. The callback will be
  invoked only when there is "nothing better to do", which is usually
  defined as "all outstanding events have been handled and no new events
  have been detected". That means that idle watchers ideally get invoked
  when the event loop has just polled for new events but none have been
  detected. Instead of blocking to wait for more events, the idle watchers
  will be invoked.
  
  Unfortunately, most event loops do not really support idle watchers (only
  EV, Event and Glib do it in a usable fashion) - for the rest, AnyEvent
  will simply call the callback "from time to time".
  
  Example: read lines from STDIN, but only process them when the
  program is otherwise idle:
  
     my @lines; # read data
     my $idle_w;
     my $io_w = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
        push @lines, scalar <STDIN>;
  
        # start an idle watcher, if not already done
        $idle_w ||= AnyEvent->idle (cb => sub {
           # handle only one line, when there are lines left
           if (my $line = shift @lines) {
              print "handled when idle: $line";
           } else {
              # otherwise disable the idle watcher again
              undef $idle_w;
           }
        });
     });
  
  =head2 CONDITION VARIABLES
  
     $cv = AnyEvent->condvar;
  
     $cv->send (<list>);
     my @res = $cv->recv;
  
  If you are familiar with some event loops you will know that all of them
  require you to run some blocking "loop", "run" or similar function that
  will actively watch for new events and call your callbacks.
  
  AnyEvent is slightly different: it expects somebody else to run the event
  loop and will only block when necessary (usually when told by the user).
  
  The tool to do that is called a "condition variable", so called because
  they represent a condition that must become true.
  
  Now is probably a good time to look at the examples further below.
  
  Condition variables can be created by calling the C<< AnyEvent->condvar
  >> method, usually without arguments. The only argument pair allowed is
  C<cb>, which specifies a callback to be called when the condition variable
  becomes true, with the condition variable as the first argument (but not
  the results).
  
  After creation, the condition variable is "false" until it becomes "true"
  by calling the C<send> method (or calling the condition variable as if it
  were a callback, read about the caveats in the description for the C<<
  ->send >> method).
  
  Since condition variables are the most complex part of the AnyEvent API, here are
  some different mental models of what they are - pick the ones you can connect to:
  
  =over 4
  
  =item * Condition variables are like callbacks - you can call them (and pass them instead
  of callbacks). Unlike callbacks however, you can also wait for them to be called.
  
  =item * Condition variables are signals - one side can emit or send them,
  the other side can wait for them, or install a handler that is called when
  the signal fires.
  
  =item * Condition variables are like "Merge Points" - points in your program
  where you merge multiple independent results/control flows into one.
  
  =item * Condition variables represent a transaction - functions that start
  some kind of transaction can return them, leaving the caller the choice
  between waiting in a blocking fashion, or setting a callback.
  
  =item * Condition variables represent future values, or promises to deliver
  some result, long before the result is available.
  
  =back
  
  Condition variables are very useful to signal that something has finished,
  for example, if you write a module that does asynchronous http requests,
  then a condition variable would be the ideal candidate to signal the
  availability of results. The user can either act when the callback is
  called or can synchronously C<< ->recv >> for the results.
  
  You can also use them to simulate traditional event loops - for example,
  you can block your main program until an event occurs - for example, you
  could C<< ->recv >> in your main program until the user clicks the Quit
  button of your app, which would C<< ->send >> the "quit" event.
  
  Note that condition variables recurse into the event loop - if you have
  two pieces of code that call C<< ->recv >> in a round-robin fashion, you
  lose. Therefore, condition variables are good to export to your caller, but
  you should avoid making a blocking wait yourself, at least in callbacks,
  as this asks for trouble.
  
  Condition variables are represented by hash refs in perl, and the keys
  used by AnyEvent itself are all named C<_ae_XXX> to make subclassing
  easy (it is often useful to build your own transaction class on top of
  AnyEvent). To subclass, use C<AnyEvent::CondVar> as base class and call
  its C<new> method in your own C<new> method.
  
  There are two "sides" to a condition variable - the "producer side" which
  eventually calls C<< -> send >>, and the "consumer side", which waits
  for the send to occur.
  
  Example: wait for a timer.
  
     # condition: "wait till the timer is fired"
     my $timer_fired = AnyEvent->condvar;
  
     # create the timer - we could wait for, say
     # a handle becomign ready, or even an
     # AnyEvent::HTTP request to finish, but
     # in this case, we simply use a timer:
     my $w = AnyEvent->timer (
        after => 1,
        cb    => sub { $timer_fired->send },
     );
  
     # this "blocks" (while handling events) till the callback
     # calls ->send
     $timer_fired->recv;
  
  Example: wait for a timer, but take advantage of the fact that condition
  variables are also callable directly.
  
     my $done = AnyEvent->condvar;
     my $delay = AnyEvent->timer (after => 5, cb => $done);
     $done->recv;
  
  Example: Imagine an API that returns a condvar and doesn't support
  callbacks. This is how you make a synchronous call, for example from
  the main program:
  
     use AnyEvent::CouchDB;
  
     ...
  
     my @info = $couchdb->info->recv;
  
  And this is how you would just set a callback to be called whenever the
  results are available:
  
     $couchdb->info->cb (sub {
        my @info = $_[0]->recv;
     });
  
  =head3 METHODS FOR PRODUCERS
  
  These methods should only be used by the producing side, i.e. the
  code/module that eventually sends the signal. Note that it is also
  the producer side which creates the condvar in most cases, but it isn't
  uncommon for the consumer to create it as well.
  
  =over 4
  
  =item $cv->send (...)
  
  Flag the condition as ready - a running C<< ->recv >> and all further
  calls to C<recv> will (eventually) return after this method has been
  called. If nobody is waiting the send will be remembered.
  
  If a callback has been set on the condition variable, it is called
  immediately from within send.
  
  Any arguments passed to the C<send> call will be returned by all
  future C<< ->recv >> calls.
  
  Condition variables are overloaded so one can call them directly (as if
  they were a code reference). Calling them directly is the same as calling
  C<send>.
  
  =item $cv->croak ($error)
  
  Similar to send, but causes all calls to C<< ->recv >> to invoke
  C<Carp::croak> with the given error message/object/scalar.
  
  This can be used to signal any errors to the condition variable
  user/consumer. Doing it this way instead of calling C<croak> directly
  delays the error detection, but has the overwhelming advantage that it
  diagnoses the error at the place where the result is expected, and not
  deep in some event callback with no connection to the actual code causing
  the problem.
  
  =item $cv->begin ([group callback])
  
  =item $cv->end
  
  These two methods can be used to combine many transactions/events into
  one. For example, a function that pings many hosts in parallel might want
  to use a condition variable for the whole process.
  
  Every call to C<< ->begin >> will increment a counter, and every call to
  C<< ->end >> will decrement it.  If the counter reaches C<0> in C<< ->end
  >>, the (last) callback passed to C<begin> will be executed, passing the
  condvar as first argument. That callback is I<supposed> to call C<< ->send
  >>, but that is not required. If no group callback was set, C<send> will
  be called without any arguments.
  
  You can think of C<< $cv->send >> giving you an OR condition (one call
  sends), while C<< $cv->begin >> and C<< $cv->end >> giving you an AND
  condition (all C<begin> calls must be C<end>'ed before the condvar sends).
  
  Let's start with a simple example: you have two I/O watchers (for example,
  STDOUT and STDERR for a program), and you want to wait for both streams to
  close before activating a condvar:
  
     my $cv = AnyEvent->condvar;
  
     $cv->begin; # first watcher
     my $w1 = AnyEvent->io (fh => $fh1, cb => sub {
        defined sysread $fh1, my $buf, 4096
           or $cv->end;
     });
  
     $cv->begin; # second watcher
     my $w2 = AnyEvent->io (fh => $fh2, cb => sub {
        defined sysread $fh2, my $buf, 4096
           or $cv->end;
     });
  
     $cv->recv;
  
  This works because for every event source (EOF on file handle), there is
  one call to C<begin>, so the condvar waits for all calls to C<end> before
  sending.
  
  The ping example mentioned above is slightly more complicated, as the
  there are results to be passwd back, and the number of tasks that are
  begun can potentially be zero:
  
     my $cv = AnyEvent->condvar;
  
     my %result;
     $cv->begin (sub { shift->send (\%result) });
  
     for my $host (@list_of_hosts) {
        $cv->begin;
        ping_host_then_call_callback $host, sub {
           $result{$host} = ...;
           $cv->end;
        };
     }
  
     $cv->end;
  
  This code fragment supposedly pings a number of hosts and calls
  C<send> after results for all then have have been gathered - in any
  order. To achieve this, the code issues a call to C<begin> when it starts
  each ping request and calls C<end> when it has received some result for
  it. Since C<begin> and C<end> only maintain a counter, the order in which
  results arrive is not relevant.
  
  There is an additional bracketing call to C<begin> and C<end> outside the
  loop, which serves two important purposes: first, it sets the callback
  to be called once the counter reaches C<0>, and second, it ensures that
  C<send> is called even when C<no> hosts are being pinged (the loop
  doesn't execute once).
  
  This is the general pattern when you "fan out" into multiple (but
  potentially zero) subrequests: use an outer C<begin>/C<end> pair to set
  the callback and ensure C<end> is called at least once, and then, for each
  subrequest you start, call C<begin> and for each subrequest you finish,
  call C<end>.
  
  =back
  
  =head3 METHODS FOR CONSUMERS
  
  These methods should only be used by the consuming side, i.e. the
  code awaits the condition.
  
  =over 4
  
  =item $cv->recv
  
  Wait (blocking if necessary) until the C<< ->send >> or C<< ->croak
  >> methods have been called on C<$cv>, while servicing other watchers
  normally.
  
  You can only wait once on a condition - additional calls are valid but
  will return immediately.
  
  If an error condition has been set by calling C<< ->croak >>, then this
  function will call C<croak>.
  
  In list context, all parameters passed to C<send> will be returned,
  in scalar context only the first one will be returned.
  
  Note that doing a blocking wait in a callback is not supported by any
  event loop, that is, recursive invocation of a blocking C<< ->recv
  >> is not allowed, and the C<recv> call will C<croak> if such a
  condition is detected. This condition can be slightly loosened by using
  L<Coro::AnyEvent>, which allows you to do a blocking C<< ->recv >> from
  any thread that doesn't run the event loop itself.
  
  Not all event models support a blocking wait - some die in that case
  (programs might want to do that to stay interactive), so I<if you are
  using this from a module, never require a blocking wait>. Instead, let the
  caller decide whether the call will block or not (for example, by coupling
  condition variables with some kind of request results and supporting
  callbacks so the caller knows that getting the result will not block,
  while still supporting blocking waits if the caller so desires).
  
  You can ensure that C<< ->recv >> never blocks by setting a callback and
  only calling C<< ->recv >> from within that callback (or at a later
  time). This will work even when the event loop does not support blocking
  waits otherwise.
  
  =item $bool = $cv->ready
  
  Returns true when the condition is "true", i.e. whether C<send> or
  C<croak> have been called.
  
  =item $cb = $cv->cb ($cb->($cv))
  
  This is a mutator function that returns the callback set and optionally
  replaces it before doing so.
  
  The callback will be called when the condition becomes "true", i.e. when
  C<send> or C<croak> are called, with the only argument being the
  condition variable itself. If the condition is already true, the
  callback is called immediately when it is set. Calling C<recv> inside
  the callback or at any later time is guaranteed not to block.
  
  =back
  
  =head1 SUPPORTED EVENT LOOPS/BACKENDS
  
  The available backend classes are (every class has its own manpage):
  
  =over 4
  
  =item Backends that are autoprobed when no other event loop can be found.
  
  EV is the preferred backend when no other event loop seems to be in
  use. If EV is not installed, then AnyEvent will fall back to its own
  pure-perl implementation, which is available everywhere as it comes with
  AnyEvent itself.
  
     AnyEvent::Impl::EV        based on EV (interface to libev, best choice).
     AnyEvent::Impl::Perl      pure-perl AnyEvent::Loop, fast and portable.
  
  =item Backends that are transparently being picked up when they are used.
  
  These will be used if they are already loaded when the first watcher
  is created, in which case it is assumed that the application is using
  them. This means that AnyEvent will automatically pick the right backend
  when the main program loads an event module before anything starts to
  create watchers. Nothing special needs to be done by the main program.
  
     AnyEvent::Impl::Event     based on Event, very stable, few glitches.
     AnyEvent::Impl::Glib      based on Glib, slow but very stable.
     AnyEvent::Impl::Tk        based on Tk, very broken.
     AnyEvent::Impl::EventLib  based on Event::Lib, leaks memory and worse.
     AnyEvent::Impl::POE       based on POE, very slow, some limitations.
     AnyEvent::Impl::Irssi     used when running within irssi.
     AnyEvent::Impl::IOAsync   based on IO::Async.
     AnyEvent::Impl::Cocoa     based on Cocoa::EventLoop.
     AnyEvent::Impl::FLTK      based on FLTK (fltk 2 binding).
  
  =item Backends with special needs.
  
  Qt requires the Qt::Application to be instantiated first, but will
  otherwise be picked up automatically. As long as the main program
  instantiates the application before any AnyEvent watchers are created,
  everything should just work.
  
     AnyEvent::Impl::Qt        based on Qt.
  
  =item Event loops that are indirectly supported via other backends.
  
  Some event loops can be supported via other modules:
  
  There is no direct support for WxWidgets (L<Wx>) or L<Prima>.
  
  B<WxWidgets> has no support for watching file handles. However, you can
  use WxWidgets through the POE adaptor, as POE has a Wx backend that simply
  polls 20 times per second, which was considered to be too horrible to even
  consider for AnyEvent.
  
  B<Prima> is not supported as nobody seems to be using it, but it has a POE
  backend, so it can be supported through POE.
  
  AnyEvent knows about both L<Prima> and L<Wx>, however, and will try to
  load L<POE> when detecting them, in the hope that POE will pick them up,
  in which case everything will be automatic.
  
  =back
  
  =head1 GLOBAL VARIABLES AND FUNCTIONS
  
  These are not normally required to use AnyEvent, but can be useful to
  write AnyEvent extension modules.
  
  =over 4
  
  =item $AnyEvent::MODEL
  
  Contains C<undef> until the first watcher is being created, before the
  backend has been autodetected.
  
  Afterwards it contains the event model that is being used, which is the
  name of the Perl class implementing the model. This class is usually one
  of the C<AnyEvent::Impl::xxx> modules, but can be any other class in the
  case AnyEvent has been extended at runtime (e.g. in I<rxvt-unicode> it
  will be C<urxvt::anyevent>).
  
  =item AnyEvent::detect
  
  Returns C<$AnyEvent::MODEL>, forcing autodetection of the event model
  if necessary. You should only call this function right before you would
  have created an AnyEvent watcher anyway, that is, as late as possible at
  runtime, and not e.g. during initialisation of your module.
  
  The effect of calling this function is as if a watcher had been created
  (specifically, actions that happen "when the first watcher is created"
  happen when calling detetc as well).
  
  If you need to do some initialisation before AnyEvent watchers are
  created, use C<post_detect>.
  
  =item $guard = AnyEvent::post_detect { BLOCK }
  
  Arranges for the code block to be executed as soon as the event model is
  autodetected (or immediately if that has already happened).
  
  The block will be executed I<after> the actual backend has been detected
  (C<$AnyEvent::MODEL> is set), but I<before> any watchers have been
  created, so it is possible to e.g. patch C<@AnyEvent::ISA> or do
  other initialisations - see the sources of L<AnyEvent::Strict> or
  L<AnyEvent::AIO> to see how this is used.
  
  The most common usage is to create some global watchers, without forcing
  event module detection too early, for example, L<AnyEvent::AIO> creates
  and installs the global L<IO::AIO> watcher in a C<post_detect> block to
  avoid autodetecting the event module at load time.
  
  If called in scalar or list context, then it creates and returns an object
  that automatically removes the callback again when it is destroyed (or
  C<undef> when the hook was immediately executed). See L<AnyEvent::AIO> for
  a case where this is useful.
  
  Example: Create a watcher for the IO::AIO module and store it in
  C<$WATCHER>, but do so only do so after the event loop is initialised.
  
     our WATCHER;
  
     my $guard = AnyEvent::post_detect {
        $WATCHER = AnyEvent->io (fh => IO::AIO::poll_fileno, poll => 'r', cb => \&IO::AIO::poll_cb);
     };
  
     # the ||= is important in case post_detect immediately runs the block,
     # as to not clobber the newly-created watcher. assigning both watcher and
     # post_detect guard to the same variable has the advantage of users being
     # able to just C<undef $WATCHER> if the watcher causes them grief.
  
     $WATCHER ||= $guard;
  
  =item @AnyEvent::post_detect
  
  If there are any code references in this array (you can C<push> to it
  before or after loading AnyEvent), then they will be called directly
  after the event loop has been chosen.
  
  You should check C<$AnyEvent::MODEL> before adding to this array, though:
  if it is defined then the event loop has already been detected, and the
  array will be ignored.
  
  Best use C<AnyEvent::post_detect { BLOCK }> when your application allows
  it, as it takes care of these details.
  
  This variable is mainly useful for modules that can do something useful
  when AnyEvent is used and thus want to know when it is initialised, but do
  not need to even load it by default. This array provides the means to hook
  into AnyEvent passively, without loading it.
  
  Example: To load Coro::AnyEvent whenever Coro and AnyEvent are used
  together, you could put this into Coro (this is the actual code used by
  Coro to accomplish this):
  
     if (defined $AnyEvent::MODEL) {
        # AnyEvent already initialised, so load Coro::AnyEvent
        require Coro::AnyEvent;
     } else {
        # AnyEvent not yet initialised, so make sure to load Coro::AnyEvent
        # as soon as it is
        push @AnyEvent::post_detect, sub { require Coro::AnyEvent };
     }
  
  =item AnyEvent::postpone { BLOCK }
  
  Arranges for the block to be executed as soon as possible, but not before
  the call itself returns. In practise, the block will be executed just
  before the event loop polls for new events, or shortly afterwards.
  
  This function never returns anything (to make the C<return postpone { ...
  }> idiom more useful.
  
  To understand the usefulness of this function, consider a function that
  asynchronously does something for you and returns some transaction
  object or guard to let you cancel the operation. For example,
  C<AnyEvent::Socket::tcp_connect>:
  
     # start a conenction attempt unless one is active
     $self->{connect_guard} ||= AnyEvent::Socket::tcp_connect "www.example.net", 80, sub {
        delete $self->{connect_guard};
        ...
     };
  
  Imagine that this function could instantly call the callback, for
  example, because it detects an obvious error such as a negative port
  number. Invoking the callback before the function returns causes problems
  however: the callback will be called and will try to delete the guard
  object. But since the function hasn't returned yet, there is nothing to
  delete. When the function eventually returns it will assign the guard
  object to C<< $self->{connect_guard} >>, where it will likely never be
  deleted, so the program thinks it is still trying to connect.
  
  This is where C<AnyEvent::postpone> should be used. Instead of calling the
  callback directly on error:
  
     $cb->(undef), return # signal error to callback, BAD!
        if $some_error_condition;
  
  It should use C<postpone>:
  
     AnyEvent::postpone { $cb->(undef) }, return # signal error to callback, later
        if $some_error_condition;
  
  =item AnyEvent::log $level, $msg[, @args]
  
  Log the given C<$msg> at the given C<$level>.
  
  If L<AnyEvent::Log> is not loaded then this function makes a simple test
  to see whether the message will be logged. If the test succeeds it will
  load AnyEvent::Log and call C<AnyEvent::Log::log> - consequently, look at
  the L<AnyEvent::Log> documentation for details.
  
  If the test fails it will simply return. Right now this happens when a
  numerical loglevel is used and it is larger than the level specified via
  C<$ENV{PERL_ANYEVENT_VERBOSE}>.
  
  If you want to sprinkle loads of logging calls around your code, consider
  creating a logger callback with the C<AnyEvent::Log::logger> function,
  which can reduce typing, codesize and can reduce the logging overhead
  enourmously.
  
  =back
  
  =head1 WHAT TO DO IN A MODULE
  
  As a module author, you should C<use AnyEvent> and call AnyEvent methods
  freely, but you should not load a specific event module or rely on it.
  
  Be careful when you create watchers in the module body - AnyEvent will
  decide which event module to use as soon as the first method is called, so
  by calling AnyEvent in your module body you force the user of your module
  to load the event module first.
  
  Never call C<< ->recv >> on a condition variable unless you I<know> that
  the C<< ->send >> method has been called on it already. This is
  because it will stall the whole program, and the whole point of using
  events is to stay interactive.
  
  It is fine, however, to call C<< ->recv >> when the user of your module
  requests it (i.e. if you create a http request object ad have a method
  called C<results> that returns the results, it may call C<< ->recv >>
  freely, as the user of your module knows what she is doing. Always).
  
  =head1 WHAT TO DO IN THE MAIN PROGRAM
  
  There will always be a single main program - the only place that should
  dictate which event model to use.
  
  If the program is not event-based, it need not do anything special, even
  when it depends on a module that uses an AnyEvent. If the program itself
  uses AnyEvent, but does not care which event loop is used, all it needs
  to do is C<use AnyEvent>. In either case, AnyEvent will choose the best
  available loop implementation.
  
  If the main program relies on a specific event model - for example, in
  Gtk2 programs you have to rely on the Glib module - you should load the
  event module before loading AnyEvent or any module that uses it: generally
  speaking, you should load it as early as possible. The reason is that
  modules might create watchers when they are loaded, and AnyEvent will
  decide on the event model to use as soon as it creates watchers, and it
  might choose the wrong one unless you load the correct one yourself.
  
  You can chose to use a pure-perl implementation by loading the
  C<AnyEvent::Loop> module, which gives you similar behaviour
  everywhere, but letting AnyEvent chose the model is generally better.
  
  =head2 MAINLOOP EMULATION
  
  Sometimes (often for short test scripts, or even standalone programs who
  only want to use AnyEvent), you do not want to run a specific event loop.
  
  In that case, you can use a condition variable like this:
  
     AnyEvent->condvar->recv;
  
  This has the effect of entering the event loop and looping forever.
  
  Note that usually your program has some exit condition, in which case
  it is better to use the "traditional" approach of storing a condition
  variable somewhere, waiting for it, and sending it when the program should
  exit cleanly.
  
  
  =head1 OTHER MODULES
  
  The following is a non-exhaustive list of additional modules that use
  AnyEvent as a client and can therefore be mixed easily with other
  AnyEvent modules and other event loops in the same program. Some of the
  modules come as part of AnyEvent, the others are available via CPAN (see
  L<http://search.cpan.org/search?m=module&q=anyevent%3A%3A*> for
  a longer non-exhaustive list), and the list is heavily biased towards
  modules of the AnyEvent author himself :)
  
  =over 4
  
  =item L<AnyEvent::Util>
  
  Contains various utility functions that replace often-used blocking
  functions such as C<inet_aton> with event/callback-based versions.
  
  =item L<AnyEvent::Socket>
  
  Provides various utility functions for (internet protocol) sockets,
  addresses and name resolution. Also functions to create non-blocking tcp
  connections or tcp servers, with IPv6 and SRV record support and more.
  
  =item L<AnyEvent::Handle>
  
  Provide read and write buffers, manages watchers for reads and writes,
  supports raw and formatted I/O, I/O queued and fully transparent and
  non-blocking SSL/TLS (via L<AnyEvent::TLS>).
  
  =item L<AnyEvent::DNS>
  
  Provides rich asynchronous DNS resolver capabilities.
  
  =item L<AnyEvent::HTTP>, L<AnyEvent::IRC>, L<AnyEvent::XMPP>, L<AnyEvent::GPSD>, L<AnyEvent::IGS>, L<AnyEvent::FCP>
  
  Implement event-based interfaces to the protocols of the same name (for
  the curious, IGS is the International Go Server and FCP is the Freenet
  Client Protocol).
  
  =item L<AnyEvent::AIO>
  
  Truly asynchronous (as opposed to non-blocking) I/O, should be in the
  toolbox of every event programmer. AnyEvent::AIO transparently fuses
  L<IO::AIO> and AnyEvent together, giving AnyEvent access to event-based
  file I/O, and much more.
  
  =item L<AnyEvent::Filesys::Notify>
  
  AnyEvent is good for non-blocking stuff, but it can't detect file or
  path changes (e.g. "watch this directory for new files", "watch this
  file for changes"). The L<AnyEvent::Filesys::Notify> module promises to
  do just that in a portbale fashion, supporting inotify on GNU/Linux and
  some weird, without doubt broken, stuff on OS X to monitor files. It can
  fall back to blocking scans at regular intervals transparently on other
  platforms, so it's about as portable as it gets.
  
  (I haven't used it myself, but I haven't heard anybody complaining about
  it yet).
  
  =item L<AnyEvent::DBI>
  
  Executes L<DBI> requests asynchronously in a proxy process for you,
  notifying you in an event-based way when the operation is finished.
  
  =item L<AnyEvent::HTTPD>
  
  A simple embedded webserver.
  
  =item L<AnyEvent::FastPing>
  
  The fastest ping in the west.
  
  =item L<Coro>
  
  Has special support for AnyEvent via L<Coro::AnyEvent>, which allows you
  to simply invert the flow control - don't call us, we will call you:
  
     async {
        Coro::AnyEvent::sleep 5; # creates a 5s timer and waits for it
        print "5 seconds later!\n";
  
        Coro::AnyEvent::readable *STDIN; # uses an I/O watcher
        my $line = <STDIN>; # works for ttys
  
        AnyEvent::HTTP::http_get "url", Coro::rouse_cb;
        my ($body, $hdr) = Coro::rouse_wait;
     };
  
  =back
  
  =cut
  
  package AnyEvent;
  
  # basically a tuned-down version of common::sense
  sub common_sense {
     # from common:.sense 3.4
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x3c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00";
     # use strict vars subs - NO UTF-8, as Util.pm doesn't like this atm. (uts46data.pl)
     $^H |= 0x00000600;
  }
  
  BEGIN { AnyEvent::common_sense }
  
  use Carp ();
  
  our $VERSION = '6.14';
  our $MODEL;
  our @ISA;
  our @REGISTRY;
  our $VERBOSE;
  our %PROTOCOL; # (ipv4|ipv6) => (1|2), higher numbers are preferred
  our $MAX_SIGNAL_LATENCY = $ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY} || 10; # executes after the BEGIN block below (tainting!)
  
  BEGIN {
     require "AnyEvent/constants.pl";
  
     eval "sub TAINT (){" . (${^TAINT}*1) . "}";
  
     delete @ENV{grep /^PERL_ANYEVENT_/, keys %ENV}
        if ${^TAINT};
  
     $ENV{"PERL_ANYEVENT_$_"} = $ENV{"AE_$_"}
        for grep s/^AE_// && !exists $ENV{"PERL_ANYEVENT_$_"}, keys %ENV;
  
     @ENV{grep /^PERL_ANYEVENT_/, keys %ENV} = ()
        if ${^TAINT};
  
     # $ENV{PERL_ANYEVENT_xxx} now valid
  
     $VERBOSE = length $ENV{PERL_ANYEVENT_VERBOSE} ? $ENV{PERL_ANYEVENT_VERBOSE}*1 : 4;
  
     my $idx;
     $PROTOCOL{$_} = ++$idx
        for reverse split /\s*,\s*/,
               $ENV{PERL_ANYEVENT_PROTOCOLS} || "ipv4,ipv6";
  }
  
  our @post_detect;
  
  sub post_detect(&) {
     my ($cb) = @_;
  
     push @post_detect, $cb;
  
     defined wantarray
        ? bless \$cb, "AnyEvent::Util::postdetect"
        : ()
  }
  
  sub AnyEvent::Util::postdetect::DESTROY {
     @post_detect = grep $_ != ${$_[0]}, @post_detect;
  }
  
  our $POSTPONE_W;
  our @POSTPONE;
  
  sub _postpone_exec {
     undef $POSTPONE_W;
  
     &{ shift @POSTPONE }
        while @POSTPONE;
  }
  
  sub postpone(&) {
     push @POSTPONE, shift;
  
     $POSTPONE_W ||= AE::timer (0, 0, \&_postpone_exec);
  
     ()
  }
  
  sub log($$;@) {
     # only load the big bloated module when we actually are about to log something
     if ($_[0] <= ($VERBOSE || 1)) { # also catches non-numeric levels(!) and fatal
        local ($!, $@);
        require AnyEvent::Log; # among other things, sets $VERBOSE to 9
        # AnyEvent::Log overwrites this function
        goto &log;
     }
  
     0 # not logged
  }
  
  sub _logger($;$) {
     my ($level, $renabled) = @_;
  
     $$renabled = $level <= $VERBOSE;
  
     my $logger = [(caller)[0], $level, $renabled];
  
     $AnyEvent::Log::LOGGER{$logger+0} = $logger;
  
  #   return unless defined wantarray;
  # 
  #   require AnyEvent::Util;
  #   my $guard = AnyEvent::Util::guard (sub {
  #      # "clean up"
  #      delete $LOGGER{$logger+0};
  #   });
  # 
  #   sub {
  #      return 0 unless $$renabled;
  # 
  #      $guard if 0; # keep guard alive, but don't cause runtime overhead
  #      require AnyEvent::Log unless $AnyEvent::Log::VERSION;
  #      package AnyEvent::Log;
  #      _log ($logger->[0], $level, @_) # logger->[0] has been converted at load time
  #   }
  }
  
  if (length $ENV{PERL_ANYEVENT_LOG}) {
     require AnyEvent::Log; # AnyEvent::Log does the thing for us
  }
  
  our @models = (
     [EV::                   => AnyEvent::Impl::EV::],
     [AnyEvent::Loop::       => AnyEvent::Impl::Perl::],
     # everything below here will not (normally) be autoprobed
     # as the pure perl backend should work everywhere
     # and is usually faster
     [Irssi::                => AnyEvent::Impl::Irssi::],    # Irssi has a bogus "Event" package, so msut be near the top
     [Event::                => AnyEvent::Impl::Event::],    # slow, stable
     [Glib::                 => AnyEvent::Impl::Glib::],     # becomes extremely slow with many watchers
     # everything below here should not be autoloaded
     [Event::Lib::           => AnyEvent::Impl::EventLib::], # too buggy
     [Tk::                   => AnyEvent::Impl::Tk::],       # crashes with many handles
     [Qt::                   => AnyEvent::Impl::Qt::],       # requires special main program
     [POE::Kernel::          => AnyEvent::Impl::POE::],      # lasciate ogni speranza
     [Wx::                   => AnyEvent::Impl::POE::],
     [Prima::                => AnyEvent::Impl::POE::],
     [IO::Async::Loop::      => AnyEvent::Impl::IOAsync::],  # a bitch to autodetect
     [Cocoa::EventLoop::     => AnyEvent::Impl::Cocoa::],
     [FLTK::                 => AnyEvent::Impl::FLTK::],
  );
  
  our @isa_hook;
  
  sub _isa_set {
     my @pkg = ("AnyEvent", (map $_->[0], grep defined, @isa_hook), $MODEL);
  
     @{"$pkg[$_-1]::ISA"} = $pkg[$_]
        for 1 .. $#pkg;
  
     grep $_ && $_->[1], @isa_hook
        and AE::_reset ();
  }
  
  # used for hooking AnyEvent::Strict and AnyEvent::Debug::Wrap into the class hierarchy
  sub _isa_hook($$;$) {
     my ($i, $pkg, $reset_ae) = @_;
  
     $isa_hook[$i] = $pkg ? [$pkg, $reset_ae] : undef;
  
     _isa_set;
  }
  
  # all autoloaded methods reserve the complete glob, not just the method slot.
  # due to bugs in perls method cache implementation.
  our @methods = qw(io timer time now now_update signal child idle condvar);
  
  sub detect() {
     return $MODEL if $MODEL; # some programs keep references to detect
  
     # IO::Async::Loop::AnyEvent is extremely evil, refuse to work with it
     # the author knows about the problems and what it does to AnyEvent as a whole
     # (and the ability of others to use AnyEvent), but simply wants to abuse AnyEvent
     # anyway.
     AnyEvent::log fatal => "AnyEvent: IO::Async::Loop::AnyEvent detected - that module is broken by\n"
                          . "design, abuses internals and breaks AnyEvent - will not continue."
        if exists $INC{"IO/Async/Loop/AnyEvent.pm"};
  
     local $!; # for good measure
     local $SIG{__DIE__}; # we use eval
  
     # free some memory
     *detect = sub () { $MODEL };
     # undef &func doesn't correctly update the method cache. grmbl.
     # so we delete the whole glob. grmbl.
     # otoh, perl doesn't let me undef an active usb, but it lets me free
     # a glob with an active sub. hrm. i hope it works, but perl is
     # usually buggy in this department. sigh.
     delete @{"AnyEvent::"}{@methods};
     undef @methods;
  
     if ($ENV{PERL_ANYEVENT_MODEL} =~ /^([a-zA-Z0-9:]+)$/) {
        my $model = $1;
        $model = "AnyEvent::Impl::$model" unless $model =~ s/::$//;
        if (eval "require $model") {
           AnyEvent::log 7 => "loaded model '$model' (forced by \$ENV{PERL_ANYEVENT_MODEL}), using it.";
           $MODEL = $model;
        } else {
           AnyEvent::log 4 => "unable to load model '$model' (from \$ENV{PERL_ANYEVENT_MODEL}):\n$@";
        }
     }
  
     # check for already loaded models
     unless ($MODEL) {
        for (@REGISTRY, @models) {
           my ($package, $model) = @$_;
           if (${"$package\::VERSION"} > 0) {
              if (eval "require $model") {
                 AnyEvent::log 7 => "autodetected model '$model', using it.";
                 $MODEL = $model;
                 last;
              } else {
                 AnyEvent::log 8 => "detected event loop $package, but cannot load '$model', skipping: $@";
              }
           }
        }
  
        unless ($MODEL) {
           # try to autoload a model
           for (@REGISTRY, @models) {
              my ($package, $model) = @$_;
              if (
                 eval "require $package"
                 and ${"$package\::VERSION"} > 0
                 and eval "require $model"
              ) {
                 AnyEvent::log 7 => "autoloaded model '$model', using it.";
                 $MODEL = $model;
                 last;
              }
           }
  
           $MODEL
             or AnyEvent::log fatal => "AnyEvent: backend autodetection failed - did you properly install AnyEvent?";
        }
     }
  
     # free memory only needed for probing
     undef @models;
     undef @REGISTRY;
  
     push @{"$MODEL\::ISA"}, "AnyEvent::Base";
  
     # now nuke some methods that are overridden by the backend.
     # SUPER usage is not allowed in these.
     for (qw(time signal child idle)) {
        undef &{"AnyEvent::Base::$_"}
           if defined &{"$MODEL\::$_"};
     }
  
     _isa_set;
  
     # we're officially open!
  
     if ($ENV{PERL_ANYEVENT_STRICT}) {
        require AnyEvent::Strict;
     }
  
     if ($ENV{PERL_ANYEVENT_DEBUG_WRAP}) {
        require AnyEvent::Debug;
        AnyEvent::Debug::wrap ($ENV{PERL_ANYEVENT_DEBUG_WRAP});
     }
  
     if (length $ENV{PERL_ANYEVENT_DEBUG_SHELL}) {
        require AnyEvent::Socket;
        require AnyEvent::Debug;
  
        my $shell = $ENV{PERL_ANYEVENT_DEBUG_SHELL};
        $shell =~ s/\$\$/$$/g;
  
        my ($host, $service) = AnyEvent::Socket::parse_hostport ($shell);
        $AnyEvent::Debug::SHELL = AnyEvent::Debug::shell ($host, $service);
     }
  
     # now the anyevent environment is set up as the user told us to, so
     # call the actual user code - post detects
  
     (shift @post_detect)->() while @post_detect;
     undef @post_detect;
  
     *post_detect = sub(&) {
        shift->();
  
        undef
     };
  
     $MODEL
  }
  
  for my $name (@methods) {
     *$name = sub {
        detect;
        # we use goto because
        # a) it makes the thunk more transparent
        # b) it allows us to delete the thunk later
        goto &{ UNIVERSAL::can AnyEvent => "SUPER::$name" }
     };
  }
  
  # utility function to dup a filehandle. this is used by many backends
  # to support binding more than one watcher per filehandle (they usually
  # allow only one watcher per fd, so we dup it to get a different one).
  sub _dupfh($$;$$) {
     my ($poll, $fh, $r, $w) = @_;
  
     # cygwin requires the fh mode to be matching, unix doesn't
     my ($rw, $mode) = $poll eq "r" ? ($r, "<&") : ($w, ">&");
  
     open my $fh2, $mode, $fh
        or die "AnyEvent->io: cannot dup() filehandle in mode '$poll': $!,";
  
     # we assume CLOEXEC is already set by perl in all important cases
  
     ($fh2, $rw)
  }
  
  =head1 SIMPLIFIED AE API
  
  Starting with version 5.0, AnyEvent officially supports a second, much
  simpler, API that is designed to reduce the calling, typing and memory
  overhead by using function call syntax and a fixed number of parameters.
  
  See the L<AE> manpage for details.
  
  =cut
  
  package AE;
  
  our $VERSION = $AnyEvent::VERSION;
  
  sub _reset() {
     eval q{ 
        # fall back to the main API by default - backends and AnyEvent::Base
        # implementations can overwrite these.
  
        sub io($$$) {
           AnyEvent->io (fh => $_[0], poll => $_[1] ? "w" : "r", cb => $_[2])
        }
  
        sub timer($$$) {
           AnyEvent->timer (after => $_[0], interval => $_[1], cb => $_[2])
        }
  
        sub signal($$) {
           AnyEvent->signal (signal => $_[0], cb => $_[1])
        }
  
        sub child($$) {
           AnyEvent->child (pid => $_[0], cb => $_[1])
        }
  
        sub idle($) {
           AnyEvent->idle (cb => $_[0]);
        }
  
        sub cv(;&) {
           AnyEvent->condvar (@_ ? (cb => $_[0]) : ())
        }
  
        sub now() {
           AnyEvent->now
        }
  
        sub now_update() {
           AnyEvent->now_update
        }
  
        sub time() {
           AnyEvent->time
        }
  
        *postpone = \&AnyEvent::postpone;
        *log      = \&AnyEvent::log;
     };
     die if $@;
  }
  
  BEGIN { _reset }
  
  package AnyEvent::Base;
  
  # default implementations for many methods
  
  sub time {
     eval q{ # poor man's autoloading {}
        # probe for availability of Time::HiRes
        if (eval "use Time::HiRes (); Time::HiRes::time (); 1") {
           *time     = sub { Time::HiRes::time () };
           *AE::time = \&    Time::HiRes::time     ;
           *now      = \&time;
           AnyEvent::log 8 => "AnyEvent: using Time::HiRes for sub-second timing accuracy.";
           # if (eval "use POSIX (); (POSIX::times())...
        } else {
           *time     = sub   { CORE::time };
           *AE::time = sub (){ CORE::time };
           *now      = \&time;
           AnyEvent::log 3 => "using built-in time(), WARNING, no sub-second resolution!";
        }
     };
     die if $@;
  
     &time
  }
  
  *now = \&time;
  sub now_update { }
  
  sub _poll {
     Carp::croak "$AnyEvent::MODEL does not support blocking waits. Caught";
  }
  
  # default implementation for ->condvar
  # in fact, the default should not be overwritten
  
  sub condvar {
     eval q{ # poor man's autoloading {}
        *condvar = sub {
           bless { @_ == 3 ? (_ae_cb => $_[2]) : () }, "AnyEvent::CondVar"
        };
  
        *AE::cv = sub (;&) {
           bless { @_ ? (_ae_cb => shift) : () }, "AnyEvent::CondVar"
        };
     };
     die if $@;
  
     &condvar
  }
  
  # default implementation for ->signal
  
  our $HAVE_ASYNC_INTERRUPT;
  
  sub _have_async_interrupt() {
     $HAVE_ASYNC_INTERRUPT = 1*(!$ENV{PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT}
                                && eval "use Async::Interrupt 1.02 (); 1")
        unless defined $HAVE_ASYNC_INTERRUPT;
  
     $HAVE_ASYNC_INTERRUPT
  }
  
  our ($SIGPIPE_R, $SIGPIPE_W, %SIG_CB, %SIG_EV, $SIG_IO);
  our (%SIG_ASY, %SIG_ASY_W);
  our ($SIG_COUNT, $SIG_TW);
  
  # install a dummy wakeup watcher to reduce signal catching latency
  # used by Impls
  sub _sig_add() {
     unless ($SIG_COUNT++) {
        # try to align timer on a full-second boundary, if possible
        my $NOW = AE::now;
  
        $SIG_TW = AE::timer
           $MAX_SIGNAL_LATENCY - ($NOW - int $NOW),
           $MAX_SIGNAL_LATENCY,
           sub { } # just for the PERL_ASYNC_CHECK
        ;
     }
  }
  
  sub _sig_del {
     undef $SIG_TW
        unless --$SIG_COUNT;
  }
  
  our $_sig_name_init; $_sig_name_init = sub {
     eval q{ # poor man's autoloading {}
        undef $_sig_name_init;
  
        if (_have_async_interrupt) {
           *sig2num  = \&Async::Interrupt::sig2num;
           *sig2name = \&Async::Interrupt::sig2name;
        } else {
           require Config;
  
           my %signame2num;
           @signame2num{ split ' ', $Config::Config{sig_name} }
                          = split ' ', $Config::Config{sig_num};
  
           my @signum2name;
           @signum2name[values %signame2num] = keys %signame2num;
  
           *sig2num = sub($) {
              $_[0] > 0 ? shift : $signame2num{+shift}
           };
           *sig2name = sub ($) {
              $_[0] > 0 ? $signum2name[+shift] : shift
           };
        }
     };
     die if $@;
  };
  
  sub sig2num ($) { &$_sig_name_init; &sig2num  }
  sub sig2name($) { &$_sig_name_init; &sig2name }
  
  sub signal {
     eval q{ # poor man's autoloading {}
        # probe for availability of Async::Interrupt 
        if (_have_async_interrupt) {
           AnyEvent::log 8 => "using Async::Interrupt for race-free signal handling.";
  
           $SIGPIPE_R = new Async::Interrupt::EventPipe;
           $SIG_IO = AE::io $SIGPIPE_R->fileno, 0, \&_signal_exec;
  
        } else {
           AnyEvent::log 8 => "using emulated perl signal handling with latency timer.";
  
           if (AnyEvent::WIN32) {
              require AnyEvent::Util;
  
              ($SIGPIPE_R, $SIGPIPE_W) = AnyEvent::Util::portable_pipe ();
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_R, 1) if $SIGPIPE_R;
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_W, 1) if $SIGPIPE_W; # just in case
           } else {
              pipe $SIGPIPE_R, $SIGPIPE_W;
              fcntl $SIGPIPE_R, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_R;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_W; # just in case
  
              # not strictly required, as $^F is normally 2, but let's make sure...
              fcntl $SIGPIPE_R, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
           }
  
           $SIGPIPE_R
              or Carp::croak "AnyEvent: unable to create a signal reporting pipe: $!\n";
  
           $SIG_IO = AE::io $SIGPIPE_R, 0, \&_signal_exec;
        }
  
        *signal = $HAVE_ASYNC_INTERRUPT
           ? sub {
                my (undef, %arg) = @_;
  
                # async::interrupt
                my $signal = sig2num $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG_ASY{$signal} ||= new Async::Interrupt
                   cb             => sub { undef $SIG_EV{$signal} },
                   signal         => $signal,
                   pipe           => [$SIGPIPE_R->filenos],
                   pipe_autodrain => 0,
                ;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
           : sub {
                my (undef, %arg) = @_;
  
                # pure perl
                my $signal = sig2name $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG{$signal} ||= sub {
                   local $!;
                   syswrite $SIGPIPE_W, "\x00", 1 unless %SIG_EV;
                   undef $SIG_EV{$signal};
                };
  
                # can't do signal processing without introducing races in pure perl,
                # so limit the signal latency.
                _sig_add;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
        ;
  
        *AnyEvent::Base::signal::DESTROY = sub {
           my ($signal, $cb) = @{$_[0]};
  
           _sig_del;
  
           delete $SIG_CB{$signal}{$cb};
  
           $HAVE_ASYNC_INTERRUPT
              ? delete $SIG_ASY{$signal}
              : # delete doesn't work with older perls - they then
                # print weird messages, or just unconditionally exit
                # instead of getting the default action.
                undef $SIG{$signal}
              unless keys %{ $SIG_CB{$signal} };
        };
  
        *_signal_exec = sub {
           $HAVE_ASYNC_INTERRUPT
              ? $SIGPIPE_R->drain
              : sysread $SIGPIPE_R, (my $dummy), 9;
  
           while (%SIG_EV) {
              for (keys %SIG_EV) {
                 delete $SIG_EV{$_};
                 &$_ for values %{ $SIG_CB{$_} || {} };
              }
           }
        };
     };
     die if $@;
  
     &signal
  }
  
  # default implementation for ->child
  
  our %PID_CB;
  our $CHLD_W;
  our $CHLD_DELAY_W;
  
  # used by many Impl's
  sub _emit_childstatus($$) {
     my (undef, $rpid, $rstatus) = @_;
  
     $_->($rpid, $rstatus)
        for values %{ $PID_CB{$rpid} || {} },
            values %{ $PID_CB{0}     || {} };
  }
  
  sub child {
     eval q{ # poor man's autoloading {}
        *_sigchld = sub {
           my $pid;
  
           AnyEvent->_emit_childstatus ($pid, $?)
              while ($pid = waitpid -1, WNOHANG) > 0;
        };
  
        *child = sub {
           my (undef, %arg) = @_;
  
           my $pid = $arg{pid};
           my $cb  = $arg{cb};
  
           $PID_CB{$pid}{$cb+0} = $cb;
  
           unless ($CHLD_W) {
              $CHLD_W = AE::signal CHLD => \&_sigchld;
              # child could be a zombie already, so make at least one round
              &_sigchld;
           }
  
           bless [$pid, $cb+0], "AnyEvent::Base::child"
        };
  
        *AnyEvent::Base::child::DESTROY = sub {
           my ($pid, $icb) = @{$_[0]};
  
           delete $PID_CB{$pid}{$icb};
           delete $PID_CB{$pid} unless keys %{ $PID_CB{$pid} };
  
           undef $CHLD_W unless keys %PID_CB;
        };
     };
     die if $@;
  
     &child
  }
  
  # idle emulation is done by simply using a timer, regardless
  # of whether the process is idle or not, and not letting
  # the callback use more than 50% of the time.
  sub idle {
     eval q{ # poor man's autoloading {}
        *idle = sub {
           my (undef, %arg) = @_;
  
           my ($cb, $w, $rcb) = $arg{cb};
  
           $rcb = sub {
              if ($cb) {
                 $w = AE::time;
                 &$cb;
                 $w = AE::time - $w;
  
                 # never use more then 50% of the time for the idle watcher,
                 # within some limits
                 $w = 0.0001 if $w < 0.0001;
                 $w = 5      if $w > 5;
  
                 $w = AE::timer $w, 0, $rcb;
              } else {
                 # clean up...
                 undef $w;
                 undef $rcb;
              }
           };
  
           $w = AE::timer 0.05, 0, $rcb;
  
           bless \\$cb, "AnyEvent::Base::idle"
        };
  
        *AnyEvent::Base::idle::DESTROY = sub {
           undef $${$_[0]};
        };
     };
     die if $@;
  
     &idle
  }
  
  package AnyEvent::CondVar;
  
  our @ISA = AnyEvent::CondVar::Base::;
  
  # only to be used for subclassing
  sub new {
     my $class = shift;
     bless AnyEvent->condvar (@_), $class
  }
  
  package AnyEvent::CondVar::Base;
  
  #use overload
  #   '&{}'    => sub { my $self = shift; sub { $self->send (@_) } },
  #   fallback => 1;
  
  # save 300+ kilobytes by dirtily hardcoding overloading
  ${"AnyEvent::CondVar::Base::OVERLOAD"}{dummy}++; # Register with magic by touching.
  *{'AnyEvent::CondVar::Base::()'}   = sub { }; # "Make it findable via fetchmethod."
  *{'AnyEvent::CondVar::Base::(&{}'} = sub { my $self = shift; sub { $self->send (@_) } }; # &{}
  ${'AnyEvent::CondVar::Base::()'}   = 1; # fallback
  
  our $WAITING;
  
  sub _send {
     # nop
  }
  
  sub _wait {
     AnyEvent->_poll until $_[0]{_ae_sent};
  }
  
  sub send {
     my $cv = shift;
     $cv->{_ae_sent} = [@_];
     (delete $cv->{_ae_cb})->($cv) if $cv->{_ae_cb};
     $cv->_send;
  }
  
  sub croak {
     $_[0]{_ae_croak} = $_[1];
     $_[0]->send;
  }
  
  sub ready {
     $_[0]{_ae_sent}
  }
  
  sub recv {
     unless ($_[0]{_ae_sent}) {
        $WAITING
           and Carp::croak "AnyEvent::CondVar: recursive blocking wait attempted";
  
        local $WAITING = 1;
        $_[0]->_wait;
     }
  
     $_[0]{_ae_croak}
        and Carp::croak $_[0]{_ae_croak};
  
     wantarray
        ? @{ $_[0]{_ae_sent} }
        : $_[0]{_ae_sent}[0]
  }
  
  sub cb {
     my $cv = shift;
  
     @_
        and $cv->{_ae_cb} = shift
        and $cv->{_ae_sent}
        and (delete $cv->{_ae_cb})->($cv);
  
     $cv->{_ae_cb}
  }
  
  sub begin {
     ++$_[0]{_ae_counter};
     $_[0]{_ae_end_cb} = $_[1] if @_ > 1;
  }
  
  sub end {
     return if --$_[0]{_ae_counter};
     &{ $_[0]{_ae_end_cb} || sub { $_[0]->send } };
  }
  
  # undocumented/compatibility with pre-3.4
  *broadcast = \&send;
  *wait      = \&recv;
  
  =head1 ERROR AND EXCEPTION HANDLING
  
  In general, AnyEvent does not do any error handling - it relies on the
  caller to do that if required. The L<AnyEvent::Strict> module (see also
  the C<PERL_ANYEVENT_STRICT> environment variable, below) provides strict
  checking of all AnyEvent methods, however, which is highly useful during
  development.
  
  As for exception handling (i.e. runtime errors and exceptions thrown while
  executing a callback), this is not only highly event-loop specific, but
  also not in any way wrapped by this module, as this is the job of the main
  program.
  
  The pure perl event loop simply re-throws the exception (usually
  within C<< condvar->recv >>), the L<Event> and L<EV> modules call C<<
  $Event/EV::DIED->() >>, L<Glib> uses C<< install_exception_handler >> and
  so on.
  
  =head1 ENVIRONMENT VARIABLES
  
  AnyEvent supports a number of environment variables that tune the
  runtime behaviour. They are usually evaluated when AnyEvent is
  loaded, initialised, or a submodule that uses them is loaded. Many of
  them also cause AnyEvent to load additional modules - for example,
  C<PERL_ANYEVENT_DEBUG_WRAP> causes the L<AnyEvent::Debug> module to be
  loaded.
  
  All the environment variables documented here start with
  C<PERL_ANYEVENT_>, which is what AnyEvent considers its own
  namespace. Other modules are encouraged (but by no means required) to use
  C<PERL_ANYEVENT_SUBMODULE> if they have registered the AnyEvent::Submodule
  namespace on CPAN, for any submodule. For example, L<AnyEvent::HTTP> could
  be expected to use C<PERL_ANYEVENT_HTTP_PROXY> (it should not access env
  variables starting with C<AE_>, see below).
  
  All variables can also be set via the C<AE_> prefix, that is, instead
  of setting C<PERL_ANYEVENT_VERBOSE> you can also set C<AE_VERBOSE>. In
  case there is a clash btween anyevent and another program that uses
  C<AE_something> you can set the corresponding C<PERL_ANYEVENT_something>
  variable to the empty string, as those variables take precedence.
  
  When AnyEvent is first loaded, it copies all C<AE_xxx> env variables
  to their C<PERL_ANYEVENT_xxx> counterpart unless that variable already
  exists. If taint mode is on, then AnyEvent will remove I<all> environment
  variables starting with C<PERL_ANYEVENT_> from C<%ENV> (or replace them
  with C<undef> or the empty string, if the corresaponding C<AE_> variable
  is set).
  
  The exact algorithm is currently:
  
     1. if taint mode enabled, delete all PERL_ANYEVENT_xyz variables from %ENV
     2. copy over AE_xyz to PERL_ANYEVENT_xyz unless the latter alraedy exists
     3. if taint mode enabled, set all PERL_ANYEVENT_xyz variables to undef.
  
  This ensures that child processes will not see the C<AE_> variables.
  
  The following environment variables are currently known to AnyEvent:
  
  =over 4
  
  =item C<PERL_ANYEVENT_VERBOSE>
  
  By default, AnyEvent will only log messages with loglevel C<3>
  (C<critical>) or higher (see L<AnyEvent::Log>). You can set this
  environment variable to a numerical loglevel to make AnyEvent more (or
  less) talkative.
  
  If you want to do more than just set the global logging level
  you should have a look at C<PERL_ANYEVENT_LOG>, which allows much more
  complex specifications.
  
  When set to C<0> (C<off>), then no messages whatsoever will be logged with
  the default logging settings.
  
  When set to C<5> or higher (C<warn>), causes AnyEvent to warn about
  unexpected conditions, such as not being able to load the event model
  specified by C<PERL_ANYEVENT_MODEL>, or a guard callback throwing an
  exception - this is the minimum recommended level.
  
  When set to C<7> or higher (info), cause AnyEvent to report which event model it
  chooses.
  
  When set to C<8> or higher (debug), then AnyEvent will report extra information on
  which optional modules it loads and how it implements certain features.
  
  =item C<PERL_ANYEVENT_LOG>
  
  Accepts rather complex logging specifications. For example, you could log
  all C<debug> messages of some module to stderr, warnings and above to
  stderr, and errors and above to syslog, with:
  
     PERL_ANYEVENT_LOG=Some::Module=debug,+log:filter=warn,+%syslog:%syslog=error,syslog
  
  For the rather extensive details, see L<AnyEvent::Log>.
  
  This variable is evaluated when AnyEvent (or L<AnyEvent::Log>) is loaded,
  so will take effect even before AnyEvent has initialised itself.
  
  Note that specifying this environment variable causes the L<AnyEvent::Log>
  module to be loaded, while C<PERL_ANYEVENT_VERBOSE> does not, so only
  using the latter saves a few hundred kB of memory until the first message
  is being logged.
  
  =item C<PERL_ANYEVENT_STRICT>
  
  AnyEvent does not do much argument checking by default, as thorough
  argument checking is very costly. Setting this variable to a true value
  will cause AnyEvent to load C<AnyEvent::Strict> and then to thoroughly
  check the arguments passed to most method calls. If it finds any problems,
  it will croak.
  
  In other words, enables "strict" mode.
  
  Unlike C<use strict> (or its modern cousin, C<< use L<common::sense>
  >>, it is definitely recommended to keep it off in production. Keeping
  C<PERL_ANYEVENT_STRICT=1> in your environment while developing programs
  can be very useful, however.
  
  =item C<PERL_ANYEVENT_DEBUG_SHELL>
  
  If this env variable is nonempty, then its contents will be interpreted by
  C<AnyEvent::Socket::parse_hostport> and C<AnyEvent::Debug::shell> (after
  replacing every occurance of C<$$> by the process pid). The shell object
  is saved in C<$AnyEvent::Debug::SHELL>.
  
  This happens when the first watcher is created.
  
  For example, to bind a debug shell on a unix domain socket in
  F<< /tmp/debug<pid>.sock >>, you could use this:
  
     PERL_ANYEVENT_DEBUG_SHELL=/tmp/debug\$\$.sock perlprog
     # connect with e.g.: socat readline /tmp/debug123.sock
  
  Or to bind to tcp port 4545 on localhost:
  
     PERL_ANYEVENT_DEBUG_SHELL=127.0.0.1:4545 perlprog
     # connect with e.g.: telnet localhost 4545
  
  Note that creating sockets in F</tmp> or on localhost is very unsafe on
  multiuser systems.
  
  =item C<PERL_ANYEVENT_DEBUG_WRAP>
  
  Can be set to C<0>, C<1> or C<2> and enables wrapping of all watchers for
  debugging purposes. See C<AnyEvent::Debug::wrap> for details.
  
  =item C<PERL_ANYEVENT_MODEL>
  
  This can be used to specify the event model to be used by AnyEvent, before
  auto detection and -probing kicks in.
  
  It normally is a string consisting entirely of ASCII letters (e.g. C<EV>
  or C<IOAsync>). The string C<AnyEvent::Impl::> gets prepended and the
  resulting module name is loaded and - if the load was successful - used as
  event model backend. If it fails to load then AnyEvent will proceed with
  auto detection and -probing.
  
  If the string ends with C<::> instead (e.g. C<AnyEvent::Impl::EV::>) then
  nothing gets prepended and the module name is used as-is (hint: C<::> at
  the end of a string designates a module name and quotes it appropriately).
  
  For example, to force the pure perl model (L<AnyEvent::Loop::Perl>) you
  could start your program like this:
  
     PERL_ANYEVENT_MODEL=Perl perl ...
  
  =item C<PERL_ANYEVENT_PROTOCOLS>
  
  Used by both L<AnyEvent::DNS> and L<AnyEvent::Socket> to determine preferences
  for IPv4 or IPv6. The default is unspecified (and might change, or be the result
  of auto probing).
  
  Must be set to a comma-separated list of protocols or address families,
  current supported: C<ipv4> and C<ipv6>. Only protocols mentioned will be
  used, and preference will be given to protocols mentioned earlier in the
  list.
  
  This variable can effectively be used for denial-of-service attacks
  against local programs (e.g. when setuid), although the impact is likely
  small, as the program has to handle conenction and other failures anyways.
  
  Examples: C<PERL_ANYEVENT_PROTOCOLS=ipv4,ipv6> - prefer IPv4 over IPv6,
  but support both and try to use both.  C<PERL_ANYEVENT_PROTOCOLS=ipv4>
  - only support IPv4, never try to resolve or contact IPv6
  addresses. C<PERL_ANYEVENT_PROTOCOLS=ipv6,ipv4> support either IPv4 or
  IPv6, but prefer IPv6 over IPv4.
  
  =item C<PERL_ANYEVENT_HOSTS>
  
  This variable, if specified, overrides the F</etc/hosts> file used by
  L<AnyEvent::Socket>C<::resolve_sockaddr>, i.e. hosts aliases will be read
  from that file instead.
  
  =item C<PERL_ANYEVENT_EDNS0>
  
  Used by L<AnyEvent::DNS> to decide whether to use the EDNS0 extension for
  DNS. This extension is generally useful to reduce DNS traffic, especially
  when DNSSEC is involved, but some (broken) firewalls drop such DNS
  packets, which is why it is off by default.
  
  Setting this variable to C<1> will cause L<AnyEvent::DNS> to announce
  EDNS0 in its DNS requests.
  
  =item C<PERL_ANYEVENT_MAX_FORKS>
  
  The maximum number of child processes that C<AnyEvent::Util::fork_call>
  will create in parallel.
  
  =item C<PERL_ANYEVENT_MAX_OUTSTANDING_DNS>
  
  The default value for the C<max_outstanding> parameter for the default DNS
  resolver - this is the maximum number of parallel DNS requests that are
  sent to the DNS server.
  
  =item C<PERL_ANYEVENT_MAX_SIGNAL_LATENCY>
  
  Perl has inherently racy signal handling (you can basically choose between
  losing signals and memory corruption) - pure perl event loops (including
  C<AnyEvent::Loop>, when C<Async::Interrupt> isn't available) therefore
  have to poll regularly to avoid losing signals.
  
  Some event loops are racy, but don't poll regularly, and some event loops
  are written in C but are still racy. For those event loops, AnyEvent
  installs a timer that regularly wakes up the event loop.
  
  By default, the interval for this timer is C<10> seconds, but you can
  override this delay with this environment variable (or by setting
  the C<$AnyEvent::MAX_SIGNAL_LATENCY> variable before creating signal
  watchers).
  
  Lower values increase CPU (and energy) usage, higher values can introduce
  long delays when reaping children or waiting for signals.
  
  The L<AnyEvent::Async> module, if available, will be used to avoid this
  polling (with most event loops).
  
  =item C<PERL_ANYEVENT_RESOLV_CONF>
  
  The absolute path to a F<resolv.conf>-style file to use instead of
  F</etc/resolv.conf> (or the OS-specific configuration) in the default
  resolver, or the empty string to select the default configuration.
  
  =item C<PERL_ANYEVENT_CA_FILE>, C<PERL_ANYEVENT_CA_PATH>.
  
  When neither C<ca_file> nor C<ca_path> was specified during
  L<AnyEvent::TLS> context creation, and either of these environment
  variables are nonempty, they will be used to specify CA certificate
  locations instead of a system-dependent default.
  
  =item C<PERL_ANYEVENT_AVOID_GUARD> and C<PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT>
  
  When these are set to C<1>, then the respective modules are not
  loaded. Mostly good for testing AnyEvent itself.
  
  =back
  
  =head1 SUPPLYING YOUR OWN EVENT MODEL INTERFACE
  
  This is an advanced topic that you do not normally need to use AnyEvent in
  a module. This section is only of use to event loop authors who want to
  provide AnyEvent compatibility.
  
  If you need to support another event library which isn't directly
  supported by AnyEvent, you can supply your own interface to it by
  pushing, before the first watcher gets created, the package name of
  the event module and the package name of the interface to use onto
  C<@AnyEvent::REGISTRY>. You can do that before and even without loading
  AnyEvent, so it is reasonably cheap.
  
  Example:
  
     push @AnyEvent::REGISTRY, [urxvt => urxvt::anyevent::];
  
  This tells AnyEvent to (literally) use the C<urxvt::anyevent::>
  package/class when it finds the C<urxvt> package/module is already loaded.
  
  When AnyEvent is loaded and asked to find a suitable event model, it
  will first check for the presence of urxvt by trying to C<use> the
  C<urxvt::anyevent> module.
  
  The class should provide implementations for all watcher types. See
  L<AnyEvent::Impl::EV> (source code), L<AnyEvent::Impl::Glib> (Source code)
  and so on for actual examples. Use C<perldoc -m AnyEvent::Impl::Glib> to
  see the sources.
  
  If you don't provide C<signal> and C<child> watchers than AnyEvent will
  provide suitable (hopefully) replacements.
  
  The above example isn't fictitious, the I<rxvt-unicode> (a.k.a. urxvt)
  terminal emulator uses the above line as-is. An interface isn't included
  in AnyEvent because it doesn't make sense outside the embedded interpreter
  inside I<rxvt-unicode>, and it is updated and maintained as part of the
  I<rxvt-unicode> distribution.
  
  I<rxvt-unicode> also cheats a bit by not providing blocking access to
  condition variables: code blocking while waiting for a condition will
  C<die>. This still works with most modules/usages, and blocking calls must
  not be done in an interactive application, so it makes sense.
  
  =head1 EXAMPLE PROGRAM
  
  The following program uses an I/O watcher to read data from STDIN, a timer
  to display a message once per second, and a condition variable to quit the
  program when the user enters quit:
  
     use AnyEvent;
  
     my $cv = AnyEvent->condvar;
  
     my $io_watcher = AnyEvent->io (
        fh   => \*STDIN,
        poll => 'r',
        cb   => sub {
           warn "io event <$_[0]>\n";   # will always output <r>
           chomp (my $input = <STDIN>); # read a line
           warn "read: $input\n";       # output what has been read
           $cv->send if $input =~ /^q/i; # quit program if /^q/i
        },
     );
  
     my $time_watcher = AnyEvent->timer (after => 1, interval => 1, cb => sub {
        warn "timeout\n"; # print 'timeout' at most every second
     });
  
     $cv->recv; # wait until user enters /^q/i
  
  =head1 REAL-WORLD EXAMPLE
  
  Consider the L<Net::FCP> module. It features (among others) the following
  API calls, which are to freenet what HTTP GET requests are to http:
  
     my $data = $fcp->client_get ($url); # blocks
  
     my $transaction = $fcp->txn_client_get ($url); # does not block
     $transaction->cb ( sub { ... } ); # set optional result callback
     my $data = $transaction->result; # possibly blocks
  
  The C<client_get> method works like C<LWP::Simple::get>: it requests the
  given URL and waits till the data has arrived. It is defined to be:
  
     sub client_get { $_[0]->txn_client_get ($_[1])->result }
  
  And in fact is automatically generated. This is the blocking API of
  L<Net::FCP>, and it works as simple as in any other, similar, module.
  
  More complicated is C<txn_client_get>: It only creates a transaction
  (completion, result, ...) object and initiates the transaction.
  
     my $txn = bless { }, Net::FCP::Txn::;
  
  It also creates a condition variable that is used to signal the completion
  of the request:
  
     $txn->{finished} = AnyAvent->condvar;
  
  It then creates a socket in non-blocking mode.
  
     socket $txn->{fh}, ...;
     fcntl $txn->{fh}, F_SETFL, O_NONBLOCK;
     connect $txn->{fh}, ...
        and !$!{EWOULDBLOCK}
        and !$!{EINPROGRESS}
        and Carp::croak "unable to connect: $!\n";
  
  Then it creates a write-watcher which gets called whenever an error occurs
  or the connection succeeds:
  
     $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'w', cb => sub { $txn->fh_ready_w });
  
  And returns this transaction object. The C<fh_ready_w> callback gets
  called as soon as the event loop detects that the socket is ready for
  writing.
  
  The C<fh_ready_w> method makes the socket blocking again, writes the
  request data and replaces the watcher by a read watcher (waiting for reply
  data). The actual code is more complicated, but that doesn't matter for
  this example:
  
     fcntl $txn->{fh}, F_SETFL, 0;
     syswrite $txn->{fh}, $txn->{request}
        or die "connection or write error";
     $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'r', cb => sub { $txn->fh_ready_r });
  
  Again, C<fh_ready_r> waits till all data has arrived, and then stores the
  result and signals any possible waiters that the request has finished:
  
     sysread $txn->{fh}, $txn->{buf}, length $txn->{$buf};
  
     if (end-of-file or data complete) {
       $txn->{result} = $txn->{buf};
       $txn->{finished}->send;
       $txb->{cb}->($txn) of $txn->{cb}; # also call callback
     }
  
  The C<result> method, finally, just waits for the finished signal (if the
  request was already finished, it doesn't wait, of course, and returns the
  data:
  
     $txn->{finished}->recv;
     return $txn->{result};
  
  The actual code goes further and collects all errors (C<die>s, exceptions)
  that occurred during request processing. The C<result> method detects
  whether an exception as thrown (it is stored inside the $txn object)
  and just throws the exception, which means connection errors and other
  problems get reported to the code that tries to use the result, not in a
  random callback.
  
  All of this enables the following usage styles:
  
  1. Blocking:
  
     my $data = $fcp->client_get ($url);
  
  2. Blocking, but running in parallel:
  
     my @datas = map $_->result,
                    map $fcp->txn_client_get ($_),
                       @urls;
  
  Both blocking examples work without the module user having to know
  anything about events.
  
  3a. Event-based in a main program, using any supported event module:
  
     use EV;
  
     $fcp->txn_client_get ($url)->cb (sub {
        my $txn = shift;
        my $data = $txn->result;
        ...
     });
  
     EV::loop;
  
  3b. The module user could use AnyEvent, too:
  
     use AnyEvent;
  
     my $quit = AnyEvent->condvar;
  
     $fcp->txn_client_get ($url)->cb (sub {
        ...
        $quit->send;
     });
  
     $quit->recv;
  
  
  =head1 BENCHMARKS
  
  To give you an idea of the performance and overheads that AnyEvent adds
  over the event loops themselves and to give you an impression of the speed
  of various event loops I prepared some benchmarks.
  
  =head2 BENCHMARKING ANYEVENT OVERHEAD
  
  Here is a benchmark of various supported event models used natively and
  through AnyEvent. The benchmark creates a lot of timers (with a zero
  timeout) and I/O watchers (watching STDOUT, a pty, to become writable,
  which it is), lets them fire exactly once and destroys them again.
  
  Source code for this benchmark is found as F<eg/bench> in the AnyEvent
  distribution. It uses the L<AE> interface, which makes a real difference
  for the EV and Perl backends only.
  
  =head3 Explanation of the columns
  
  I<watcher> is the number of event watchers created/destroyed. Since
  different event models feature vastly different performances, each event
  loop was given a number of watchers so that overall runtime is acceptable
  and similar between tested event loop (and keep them from crashing): Glib
  would probably take thousands of years if asked to process the same number
  of watchers as EV in this benchmark.
  
  I<bytes> is the number of bytes (as measured by the resident set size,
  RSS) consumed by each watcher. This method of measuring captures both C
  and Perl-based overheads.
  
  I<create> is the time, in microseconds (millionths of seconds), that it
  takes to create a single watcher. The callback is a closure shared between
  all watchers, to avoid adding memory overhead. That means closure creation
  and memory usage is not included in the figures.
  
  I<invoke> is the time, in microseconds, used to invoke a simple
  callback. The callback simply counts down a Perl variable and after it was
  invoked "watcher" times, it would C<< ->send >> a condvar once to
  signal the end of this phase.
  
  I<destroy> is the time, in microseconds, that it takes to destroy a single
  watcher.
  
  =head3 Results
  
            name watchers bytes create invoke destroy comment
           EV/EV   100000   223   0.47   0.43    0.27 EV native interface
          EV/Any   100000   223   0.48   0.42    0.26 EV + AnyEvent watchers
    Coro::EV/Any   100000   223   0.47   0.42    0.26 coroutines + Coro::Signal
        Perl/Any   100000   431   2.70   0.74    0.92 pure perl implementation
     Event/Event    16000   516  31.16  31.84    0.82 Event native interface
       Event/Any    16000  1203  42.61  34.79    1.80 Event + AnyEvent watchers
     IOAsync/Any    16000  1911  41.92  27.45   16.81 via IO::Async::Loop::IO_Poll
     IOAsync/Any    16000  1726  40.69  26.37   15.25 via IO::Async::Loop::Epoll
        Glib/Any    16000  1118  89.00  12.57   51.17 quadratic behaviour
          Tk/Any     2000  1346  20.96  10.75    8.00 SEGV with >> 2000 watchers
         POE/Any     2000  6951 108.97 795.32   14.24 via POE::Loop::Event
         POE/Any     2000  6648  94.79 774.40  575.51 via POE::Loop::Select
  
  =head3 Discussion
  
  The benchmark does I<not> measure scalability of the event loop very
  well. For example, a select-based event loop (such as the pure perl one)
  can never compete with an event loop that uses epoll when the number of
  file descriptors grows high. In this benchmark, all events become ready at
  the same time, so select/poll-based implementations get an unnatural speed
  boost.
  
  Also, note that the number of watchers usually has a nonlinear effect on
  overall speed, that is, creating twice as many watchers doesn't take twice
  the time - usually it takes longer. This puts event loops tested with a
  higher number of watchers at a disadvantage.
  
  To put the range of results into perspective, consider that on the
  benchmark machine, handling an event takes roughly 1600 CPU cycles with
  EV, 3100 CPU cycles with AnyEvent's pure perl loop and almost 3000000 CPU
  cycles with POE.
  
  C<EV> is the sole leader regarding speed and memory use, which are both
  maximal/minimal, respectively. When using the L<AE> API there is zero
  overhead (when going through the AnyEvent API create is about 5-6 times
  slower, with other times being equal, so still uses far less memory than
  any other event loop and is still faster than Event natively).
  
  The pure perl implementation is hit in a few sweet spots (both the
  constant timeout and the use of a single fd hit optimisations in the perl
  interpreter and the backend itself). Nevertheless this shows that it
  adds very little overhead in itself. Like any select-based backend its
  performance becomes really bad with lots of file descriptors (and few of
  them active), of course, but this was not subject of this benchmark.
  
  The C<Event> module has a relatively high setup and callback invocation
  cost, but overall scores in on the third place.
  
  C<IO::Async> performs admirably well, about on par with C<Event>, even
  when using its pure perl backend.
  
  C<Glib>'s memory usage is quite a bit higher, but it features a
  faster callback invocation and overall ends up in the same class as
  C<Event>. However, Glib scales extremely badly, doubling the number of
  watchers increases the processing time by more than a factor of four,
  making it completely unusable when using larger numbers of watchers
  (note that only a single file descriptor was used in the benchmark, so
  inefficiencies of C<poll> do not account for this).
  
  The C<Tk> adaptor works relatively well. The fact that it crashes with
  more than 2000 watchers is a big setback, however, as correctness takes
  precedence over speed. Nevertheless, its performance is surprising, as the
  file descriptor is dup()ed for each watcher. This shows that the dup()
  employed by some adaptors is not a big performance issue (it does incur a
  hidden memory cost inside the kernel which is not reflected in the figures
  above).
  
  C<POE>, regardless of underlying event loop (whether using its pure perl
  select-based backend or the Event module, the POE-EV backend couldn't
  be tested because it wasn't working) shows abysmal performance and
  memory usage with AnyEvent: Watchers use almost 30 times as much memory
  as EV watchers, and 10 times as much memory as Event (the high memory
  requirements are caused by requiring a session for each watcher). Watcher
  invocation speed is almost 900 times slower than with AnyEvent's pure perl
  implementation.
  
  The design of the POE adaptor class in AnyEvent can not really account
  for the performance issues, though, as session creation overhead is
  small compared to execution of the state machine, which is coded pretty
  optimally within L<AnyEvent::Impl::POE> (and while everybody agrees that
  using multiple sessions is not a good approach, especially regarding
  memory usage, even the author of POE could not come up with a faster
  design).
  
  =head3 Summary
  
  =over 4
  
  =item * Using EV through AnyEvent is faster than any other event loop
  (even when used without AnyEvent), but most event loops have acceptable
  performance with or without AnyEvent.
  
  =item * The overhead AnyEvent adds is usually much smaller than the overhead of
  the actual event loop, only with extremely fast event loops such as EV
  does AnyEvent add significant overhead.
  
  =item * You should avoid POE like the plague if you want performance or
  reasonable memory usage.
  
  =back
  
  =head2 BENCHMARKING THE LARGE SERVER CASE
  
  This benchmark actually benchmarks the event loop itself. It works by
  creating a number of "servers": each server consists of a socket pair, a
  timeout watcher that gets reset on activity (but never fires), and an I/O
  watcher waiting for input on one side of the socket. Each time the socket
  watcher reads a byte it will write that byte to a random other "server".
  
  The effect is that there will be a lot of I/O watchers, only part of which
  are active at any one point (so there is a constant number of active
  fds for each loop iteration, but which fds these are is random). The
  timeout is reset each time something is read because that reflects how
  most timeouts work (and puts extra pressure on the event loops).
  
  In this benchmark, we use 10000 socket pairs (20000 sockets), of which 100
  (1%) are active. This mirrors the activity of large servers with many
  connections, most of which are idle at any one point in time.
  
  Source code for this benchmark is found as F<eg/bench2> in the AnyEvent
  distribution. It uses the L<AE> interface, which makes a real difference
  for the EV and Perl backends only.
  
  =head3 Explanation of the columns
  
  I<sockets> is the number of sockets, and twice the number of "servers" (as
  each server has a read and write socket end).
  
  I<create> is the time it takes to create a socket pair (which is
  nontrivial) and two watchers: an I/O watcher and a timeout watcher.
  
  I<request>, the most important value, is the time it takes to handle a
  single "request", that is, reading the token from the pipe and forwarding
  it to another server. This includes deleting the old timeout and creating
  a new one that moves the timeout into the future.
  
  =head3 Results
  
       name sockets create  request 
         EV   20000  62.66     7.99 
       Perl   20000  68.32    32.64 
    IOAsync   20000 174.06   101.15 epoll
    IOAsync   20000 174.67   610.84 poll
      Event   20000 202.69   242.91 
       Glib   20000 557.01  1689.52 
        POE   20000 341.54 12086.32 uses POE::Loop::Event
  
  =head3 Discussion
  
  This benchmark I<does> measure scalability and overall performance of the
  particular event loop.
  
  EV is again fastest. Since it is using epoll on my system, the setup time
  is relatively high, though.
  
  Perl surprisingly comes second. It is much faster than the C-based event
  loops Event and Glib.
  
  IO::Async performs very well when using its epoll backend, and still quite
  good compared to Glib when using its pure perl backend.
  
  Event suffers from high setup time as well (look at its code and you will
  understand why). Callback invocation also has a high overhead compared to
  the C<< $_->() for .. >>-style loop that the Perl event loop uses. Event
  uses select or poll in basically all documented configurations.
  
  Glib is hit hard by its quadratic behaviour w.r.t. many watchers. It
  clearly fails to perform with many filehandles or in busy servers.
  
  POE is still completely out of the picture, taking over 1000 times as long
  as EV, and over 100 times as long as the Perl implementation, even though
  it uses a C-based event loop in this case.
  
  =head3 Summary
  
  =over 4
  
  =item * The pure perl implementation performs extremely well.
  
  =item * Avoid Glib or POE in large projects where performance matters.
  
  =back
  
  =head2 BENCHMARKING SMALL SERVERS
  
  While event loops should scale (and select-based ones do not...) even to
  large servers, most programs we (or I :) actually write have only a few
  I/O watchers.
  
  In this benchmark, I use the same benchmark program as in the large server
  case, but it uses only eight "servers", of which three are active at any
  one time. This should reflect performance for a small server relatively
  well.
  
  The columns are identical to the previous table.
  
  =head3 Results
  
      name sockets create request 
        EV      16  20.00    6.54 
      Perl      16  25.75   12.62 
     Event      16  81.27   35.86 
      Glib      16  32.63   15.48 
       POE      16 261.87  276.28 uses POE::Loop::Event
  
  =head3 Discussion
  
  The benchmark tries to test the performance of a typical small
  server. While knowing how various event loops perform is interesting, keep
  in mind that their overhead in this case is usually not as important, due
  to the small absolute number of watchers (that is, you need efficiency and
  speed most when you have lots of watchers, not when you only have a few of
  them).
  
  EV is again fastest.
  
  Perl again comes second. It is noticeably faster than the C-based event
  loops Event and Glib, although the difference is too small to really
  matter.
  
  POE also performs much better in this case, but is is still far behind the
  others.
  
  =head3 Summary
  
  =over 4
  
  =item * C-based event loops perform very well with small number of
  watchers, as the management overhead dominates.
  
  =back
  
  =head2 THE IO::Lambda BENCHMARK
  
  Recently I was told about the benchmark in the IO::Lambda manpage, which
  could be misinterpreted to make AnyEvent look bad. In fact, the benchmark
  simply compares IO::Lambda with POE, and IO::Lambda looks better (which
  shouldn't come as a surprise to anybody). As such, the benchmark is
  fine, and mostly shows that the AnyEvent backend from IO::Lambda isn't
  very optimal. But how would AnyEvent compare when used without the extra
  baggage? To explore this, I wrote the equivalent benchmark for AnyEvent.
  
  The benchmark itself creates an echo-server, and then, for 500 times,
  connects to the echo server, sends a line, waits for the reply, and then
  creates the next connection. This is a rather bad benchmark, as it doesn't
  test the efficiency of the framework or much non-blocking I/O, but it is a
  benchmark nevertheless.
  
     name                    runtime
     Lambda/select           0.330 sec
        + optimized          0.122 sec
     Lambda/AnyEvent         0.327 sec
        + optimized          0.138 sec
     Raw sockets/select      0.077 sec
     POE/select, components  0.662 sec
     POE/select, raw sockets 0.226 sec
     POE/select, optimized   0.404 sec
  
     AnyEvent/select/nb      0.085 sec
     AnyEvent/EV/nb          0.068 sec
        +state machine       0.134 sec
  
  The benchmark is also a bit unfair (my fault): the IO::Lambda/POE
  benchmarks actually make blocking connects and use 100% blocking I/O,
  defeating the purpose of an event-based solution. All of the newly
  written AnyEvent benchmarks use 100% non-blocking connects (using
  AnyEvent::Socket::tcp_connect and the asynchronous pure perl DNS
  resolver), so AnyEvent is at a disadvantage here, as non-blocking connects
  generally require a lot more bookkeeping and event handling than blocking
  connects (which involve a single syscall only).
  
  The last AnyEvent benchmark additionally uses L<AnyEvent::Handle>, which
  offers similar expressive power as POE and IO::Lambda, using conventional
  Perl syntax. This means that both the echo server and the client are 100%
  non-blocking, further placing it at a disadvantage.
  
  As you can see, the AnyEvent + EV combination even beats the
  hand-optimised "raw sockets benchmark", while AnyEvent + its pure perl
  backend easily beats IO::Lambda and POE.
  
  And even the 100% non-blocking version written using the high-level (and
  slow :) L<AnyEvent::Handle> abstraction beats both POE and IO::Lambda
  higher level ("unoptimised") abstractions by a large margin, even though
  it does all of DNS, tcp-connect and socket I/O in a non-blocking way.
  
  The two AnyEvent benchmarks programs can be found as F<eg/ae0.pl> and
  F<eg/ae2.pl> in the AnyEvent distribution, the remaining benchmarks are
  part of the IO::Lambda distribution and were used without any changes.
  
  
  =head1 SIGNALS
  
  AnyEvent currently installs handlers for these signals:
  
  =over 4
  
  =item SIGCHLD
  
  A handler for C<SIGCHLD> is installed by AnyEvent's child watcher
  emulation for event loops that do not support them natively. Also, some
  event loops install a similar handler.
  
  Additionally, when AnyEvent is loaded and SIGCHLD is set to IGNORE, then
  AnyEvent will reset it to default, to avoid losing child exit statuses.
  
  =item SIGPIPE
  
  A no-op handler is installed for C<SIGPIPE> when C<$SIG{PIPE}> is C<undef>
  when AnyEvent gets loaded.
  
  The rationale for this is that AnyEvent users usually do not really depend
  on SIGPIPE delivery (which is purely an optimisation for shell use, or
  badly-written programs), but C<SIGPIPE> can cause spurious and rare
  program exits as a lot of people do not expect C<SIGPIPE> when writing to
  some random socket.
  
  The rationale for installing a no-op handler as opposed to ignoring it is
  that this way, the handler will be restored to defaults on exec.
  
  Feel free to install your own handler, or reset it to defaults.
  
  =back
  
  =cut
  
  undef $SIG{CHLD}
     if $SIG{CHLD} eq 'IGNORE';
  
  $SIG{PIPE} = sub { }
     unless defined $SIG{PIPE};
  
  =head1 RECOMMENDED/OPTIONAL MODULES
  
  One of AnyEvent's main goals is to be 100% Pure-Perl(tm): only perl (and
  its built-in modules) are required to use it.
  
  That does not mean that AnyEvent won't take advantage of some additional
  modules if they are installed.
  
  This section explains which additional modules will be used, and how they
  affect AnyEvent's operation.
  
  =over 4
  
  =item L<Async::Interrupt>
  
  This slightly arcane module is used to implement fast signal handling: To
  my knowledge, there is no way to do completely race-free and quick
  signal handling in pure perl. To ensure that signals still get
  delivered, AnyEvent will start an interval timer to wake up perl (and
  catch the signals) with some delay (default is 10 seconds, look for
  C<$AnyEvent::MAX_SIGNAL_LATENCY>).
  
  If this module is available, then it will be used to implement signal
  catching, which means that signals will not be delayed, and the event loop
  will not be interrupted regularly, which is more efficient (and good for
  battery life on laptops).
  
  This affects not just the pure-perl event loop, but also other event loops
  that have no signal handling on their own (e.g. Glib, Tk, Qt).
  
  Some event loops (POE, Event, Event::Lib) offer signal watchers natively,
  and either employ their own workarounds (POE) or use AnyEvent's workaround
  (using C<$AnyEvent::MAX_SIGNAL_LATENCY>). Installing L<Async::Interrupt>
  does nothing for those backends.
  
  =item L<EV>
  
  This module isn't really "optional", as it is simply one of the backend
  event loops that AnyEvent can use. However, it is simply the best event
  loop available in terms of features, speed and stability: It supports
  the AnyEvent API optimally, implements all the watcher types in XS, does
  automatic timer adjustments even when no monotonic clock is available,
  can take avdantage of advanced kernel interfaces such as C<epoll> and
  C<kqueue>, and is the fastest backend I<by far>. You can even embed
  L<Glib>/L<Gtk2> in it (or vice versa, see L<EV::Glib> and L<Glib::EV>).
  
  If you only use backends that rely on another event loop (e.g. C<Tk>),
  then this module will do nothing for you.
  
  =item L<Guard>
  
  The guard module, when used, will be used to implement
  C<AnyEvent::Util::guard>. This speeds up guards considerably (and uses a
  lot less memory), but otherwise doesn't affect guard operation much. It is
  purely used for performance.
  
  =item L<JSON> and L<JSON::XS>
  
  One of these modules is required when you want to read or write JSON data
  via L<AnyEvent::Handle>. L<JSON> is also written in pure-perl, but can take
  advantage of the ultra-high-speed L<JSON::XS> module when it is installed.
  
  =item L<Net::SSLeay>
  
  Implementing TLS/SSL in Perl is certainly interesting, but not very
  worthwhile: If this module is installed, then L<AnyEvent::Handle> (with
  the help of L<AnyEvent::TLS>), gains the ability to do TLS/SSL.
  
  =item L<Time::HiRes>
  
  This module is part of perl since release 5.008. It will be used when the
  chosen event library does not come with a timing source of its own. The
  pure-perl event loop (L<AnyEvent::Loop>) will additionally load it to
  try to use a monotonic clock for timing stability.
  
  =back
  
  
  =head1 FORK
  
  Most event libraries are not fork-safe. The ones who are usually are
  because they rely on inefficient but fork-safe C<select> or C<poll> calls
  - higher performance APIs such as BSD's kqueue or the dreaded Linux epoll
  are usually badly thought-out hacks that are incompatible with fork in
  one way or another. Only L<EV> is fully fork-aware and ensures that you
  continue event-processing in both parent and child (or both, if you know
  what you are doing).
  
  This means that, in general, you cannot fork and do event processing in
  the child if the event library was initialised before the fork (which
  usually happens when the first AnyEvent watcher is created, or the library
  is loaded).
  
  If you have to fork, you must either do so I<before> creating your first
  watcher OR you must not use AnyEvent at all in the child OR you must do
  something completely out of the scope of AnyEvent.
  
  The problem of doing event processing in the parent I<and> the child
  is much more complicated: even for backends that I<are> fork-aware or
  fork-safe, their behaviour is not usually what you want: fork clones all
  watchers, that means all timers, I/O watchers etc. are active in both
  parent and child, which is almost never what you want. USing C<exec>
  to start worker children from some kind of manage rprocess is usually
  preferred, because it is much easier and cleaner, at the expense of having
  to have another binary.
  
  
  =head1 SECURITY CONSIDERATIONS
  
  AnyEvent can be forced to load any event model via
  $ENV{PERL_ANYEVENT_MODEL}. While this cannot (to my knowledge) be used to
  execute arbitrary code or directly gain access, it can easily be used to
  make the program hang or malfunction in subtle ways, as AnyEvent watchers
  will not be active when the program uses a different event model than
  specified in the variable.
  
  You can make AnyEvent completely ignore this variable by deleting it
  before the first watcher gets created, e.g. with a C<BEGIN> block:
  
     BEGIN { delete $ENV{PERL_ANYEVENT_MODEL} }
    
     use AnyEvent;
  
  Similar considerations apply to $ENV{PERL_ANYEVENT_VERBOSE}, as that can
  be used to probe what backend is used and gain other information (which is
  probably even less useful to an attacker than PERL_ANYEVENT_MODEL), and
  $ENV{PERL_ANYEVENT_STRICT}.
  
  Note that AnyEvent will remove I<all> environment variables starting with
  C<PERL_ANYEVENT_> from C<%ENV> when it is loaded while taint mode is
  enabled.
  
  
  =head1 BUGS
  
  Perl 5.8 has numerous memleaks that sometimes hit this module and are hard
  to work around. If you suffer from memleaks, first upgrade to Perl 5.10
  and check wether the leaks still show up. (Perl 5.10.0 has other annoying
  memleaks, such as leaking on C<map> and C<grep> but it is usually not as
  pronounced).
  
  
  =head1 SEE ALSO
  
  Tutorial/Introduction: L<AnyEvent::Intro>.
  
  FAQ: L<AnyEvent::FAQ>.
  
  Utility functions: L<AnyEvent::Util> (misc. grab-bag), L<AnyEvent::Log>
  (simply logging).
  
  Development/Debugging: L<AnyEvent::Strict> (stricter checking),
  L<AnyEvent::Debug> (interactive shell, watcher tracing).
  
  Supported event modules: L<AnyEvent::Loop>, L<EV>, L<EV::Glib>,
  L<Glib::EV>, L<Event>, L<Glib::Event>, L<Glib>, L<Tk>, L<Event::Lib>,
  L<Qt>, L<POE>, L<FLTK>.
  
  Implementations: L<AnyEvent::Impl::EV>, L<AnyEvent::Impl::Event>,
  L<AnyEvent::Impl::Glib>, L<AnyEvent::Impl::Tk>, L<AnyEvent::Impl::Perl>,
  L<AnyEvent::Impl::EventLib>, L<AnyEvent::Impl::Qt>,
  L<AnyEvent::Impl::POE>, L<AnyEvent::Impl::IOAsync>, L<Anyevent::Impl::Irssi>,
  L<AnyEvent::Impl::FLTK>.
  
  Non-blocking handles, pipes, stream sockets, TCP clients and
  servers: L<AnyEvent::Handle>, L<AnyEvent::Socket>, L<AnyEvent::TLS>.
  
  Asynchronous DNS: L<AnyEvent::DNS>.
  
  Thread support: L<Coro>, L<Coro::AnyEvent>, L<Coro::EV>, L<Coro::Event>.
  
  Nontrivial usage examples: L<AnyEvent::GPSD>, L<AnyEvent::IRC>,
  L<AnyEvent::HTTP>.
  
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
  1
  
DARWIN-2LEVEL_ANYEVENT

$fatpacked{"darwin-2level/AnyEvent/DNS.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_DNS';
  =head1 NAME
  
  AnyEvent::DNS - fully asynchronous DNS resolution
  
  =head1 SYNOPSIS
  
     use AnyEvent::DNS;
     
     my $cv = AnyEvent->condvar;
     AnyEvent::DNS::a "www.google.de", $cv;
     # ... later
     my @addrs = $cv->recv;
  
  =head1 DESCRIPTION
  
  This module offers both a number of DNS convenience functions as well
  as a fully asynchronous and high-performance pure-perl stub resolver.
  
  The stub resolver supports DNS over IPv4 and IPv6, UDP and TCP, optional
  EDNS0 support for up to 4kiB datagrams and automatically falls back to
  virtual circuit mode for large responses.
  
  =head2 CONVENIENCE FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::DNS;
  
  use Carp ();
  use Socket qw(AF_INET SOCK_DGRAM SOCK_STREAM);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(AF_INET6);
  
  our $VERSION = $AnyEvent::VERSION;
  our @DNS_FALLBACK; # some public dns servers as fallback
  
  {
     my $prep = sub {
        $_ = $_->[rand @$_] for @_;
        push @_, splice @_, rand $_, 1 for reverse 1..@_; # shuffle
        $_ = pack "H*", $_ for @_;
        \@_
     };
  
     my $ipv4 = $prep->(
        ["08080808", "08080404"], # 8.8.8.8, 8.8.4.4 - google public dns
  #      ["d1f40003", "d1f30004"], # v209.244.0.3/4 - resolver1/2.level3.net - status unknown
        ["04020201", "04020203", "04020204", "04020205", "04020206"], # v4.2.2.1/3/4/5/6 - vnsc-pri.sys.gtei.net - effectively public
        ["cdd22ad2", "4044c8c8"], # 205.210.42.205, 64.68.200.200 - cache1/2.dnsresolvers.com - verified public
  #      ["8d010101"], # 141.1.1.1 - cable&wireless - status unknown
     );
  
     my $ipv6 = $prep->(
        ["20014860486000000000000000008888", "20014860486000000000000000008844"], # 2001:4860:4860::8888/8844 - google ipv6
     );
  
     undef $ipv4 unless $AnyEvent::PROTOCOL{ipv4};
     undef $ipv6 unless $AnyEvent::PROTOCOL{ipv6};
  
     ($ipv6, $ipv4) = ($ipv4, $ipv6)
        if $AnyEvent::PROTOCOL{ipv6} > $AnyEvent::PROTOCOL{ipv4};
  
     @DNS_FALLBACK = (@$ipv4, @$ipv6);
  }
  
  =item AnyEvent::DNS::a $domain, $cb->(@addrs)
  
  Tries to resolve the given domain to IPv4 address(es).
  
  =item AnyEvent::DNS::aaaa $domain, $cb->(@addrs)
  
  Tries to resolve the given domain to IPv6 address(es).
  
  =item AnyEvent::DNS::mx $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain into a sorted (lower preference value
  first) list of domain names.
  
  =item AnyEvent::DNS::ns $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain name into a list of name servers.
  
  =item AnyEvent::DNS::txt $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain name into a list of text records. Only
  the first text string per record will be returned. If you want all
  strings, you need to call the resolver manually:
  
     resolver->resolve ($domain => "txt", sub {
        for my $record (@_) {
           my (undef, undef, undef, @txt) = @$record;
           # strings now in @txt
        }
     });
  
  =item AnyEvent::DNS::srv $service, $proto, $domain, $cb->(@srv_rr)
  
  Tries to resolve the given service, protocol and domain name into a list
  of service records.
  
  Each C<$srv_rr> is an array reference with the following contents: 
  C<[$priority, $weight, $transport, $target]>.
  
  They will be sorted with lowest priority first, then randomly
  distributed by weight as per RFC 2782.
  
  Example:
  
     AnyEvent::DNS::srv "sip", "udp", "schmorp.de", sub { ...
     # @_ = ( [10, 10, 5060, "sip1.schmorp.de" ] )
  
  =item AnyEvent::DNS::any $domain, $cb->(@rrs)
  
  Tries to resolve the given domain and passes all resource records found to
  the callback.
  
  =item AnyEvent::DNS::ptr $domain, $cb->(@hostnames)
  
  Tries to make a PTR lookup on the given domain. See C<reverse_lookup>
  and C<reverse_verify> if you want to resolve an IP address to a hostname
  instead.
  
  =item AnyEvent::DNS::reverse_lookup $ipv4_or_6, $cb->(@hostnames)
  
  Tries to reverse-resolve the given IPv4 or IPv6 address (in textual form)
  into its hostname(s). Handles V4MAPPED and V4COMPAT IPv6 addresses
  transparently.
  
  =item AnyEvent::DNS::reverse_verify $ipv4_or_6, $cb->(@hostnames)
  
  The same as C<reverse_lookup>, but does forward-lookups to verify that
  the resolved hostnames indeed point to the address, which makes spoofing
  harder.
  
  If you want to resolve an address into a hostname, this is the preferred
  method: The DNS records could still change, but at least this function
  verified that the hostname, at one point in the past, pointed at the IP
  address you originally resolved.
  
  Example:
  
     AnyEvent::DNS::reverse_verify "2001:500:2f::f", sub { print shift };
     # => f.root-servers.net
  
  =cut
  
  sub MAX_PKT() { 4096 } # max packet size we advertise and accept
  
  sub DOMAIN_PORT() { 53 } # if this changes drop me a note
  
  sub resolver ();
  
  sub a($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "a", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub aaaa($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "aaaa", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub mx($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "mx", sub {
        $cb->(map $_->[5], sort { $a->[4] <=> $b->[4] } @_);
     });
  }
  
  sub ns($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "ns", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub txt($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "txt", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub srv($$$$) {
     my ($service, $proto, $domain, $cb) = @_;
  
     # todo, ask for any and check glue records
     resolver->resolve ("_$service._$proto.$domain" => "srv", sub {
        my @res;
  
        # classify by priority
        my %pri;
        push @{ $pri{$_->[4]} }, [ @$_[4,5,6,7] ]
           for @_;
  
        # order by priority
        for my $pri (sort { $a <=> $b } keys %pri) {
           # order by weight
           my @rr = sort { $a->[1] <=> $b->[1] } @{ delete $pri{$pri} };
  
           my $sum; $sum += $_->[1] for @rr;
  
           while (@rr) {
              my $w = int rand $sum + 1;
              for (0 .. $#rr) {
                 if (($w -= $rr[$_][1]) <= 0) {
                    $sum -= $rr[$_][1];
                    push @res, splice @rr, $_, 1, ();
                    last;
                 }
              }
           }
        }
  
        $cb->(@res);
     });
  }
  
  sub ptr($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "ptr", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub any($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "*", $cb);
  }
  
  # convert textual ip address into reverse lookup form
  sub _munge_ptr($) {
     my $ipn = $_[0]
        or return;
  
     my $ptr;
  
     my $af = AnyEvent::Socket::address_family ($ipn);
  
     if ($af == AF_INET6) {
        $ipn = substr $ipn, 0, 16; # anticipate future expansion
  
        # handle v4mapped and v4compat
        if ($ipn =~ s/^\x00{10}(?:\xff\xff|\x00\x00)//) {
           $af = AF_INET;
        } else {
           $ptr = join ".", (reverse split //, unpack "H32", $ipn), "ip6.arpa.";
        }
     }
  
     if ($af == AF_INET) {
        $ptr = join ".", (reverse unpack "C4", $ipn), "in-addr.arpa.";
     }
  
     $ptr
  }
  
  sub reverse_lookup($$) {
     my ($ip, $cb) = @_;
  
     $ip = _munge_ptr AnyEvent::Socket::parse_address ($ip)
        or return $cb->();
  
     resolver->resolve ($ip => "ptr", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub reverse_verify($$) {
     my ($ip, $cb) = @_;
     
     my $ipn = AnyEvent::Socket::parse_address ($ip)
        or return $cb->();
  
     my $af = AnyEvent::Socket::address_family ($ipn);
  
     my @res;
     my $cnt;
  
     my $ptr = _munge_ptr $ipn
        or return $cb->();
  
     $ip = AnyEvent::Socket::format_address ($ipn); # normalise into the same form
  
     ptr $ptr, sub {
        for my $name (@_) {
           ++$cnt;
           
           # () around AF_INET to work around bug in 5.8
           resolver->resolve ("$name." => ($af == (AF_INET) ? "a" : "aaaa"), sub {
              for (@_) {
                 push @res, $name
                    if $_->[4] eq $ip;
              }
              $cb->(@res) unless --$cnt;
           });
        }
  
        $cb->() unless $cnt;
     };
  }
  
  #################################################################################
  
  =back
  
  =head2 LOW-LEVEL DNS EN-/DECODING FUNCTIONS
  
  =over 4
  
  =item $AnyEvent::DNS::EDNS0
  
  This variable decides whether dns_pack automatically enables EDNS0
  support. By default, this is disabled (C<0>), unless overridden by
  C<$ENV{PERL_ANYEVENT_EDNS0}>, but when set to C<1>, AnyEvent::DNS will use
  EDNS0 in all requests.
  
  =cut
  
  our $EDNS0 = $ENV{PERL_ANYEVENT_EDNS0}*1; # set to 1 to enable (partial) edns0
  
  our %opcode_id = (
     query  => 0,
     iquery => 1,
     status => 2,
     notify => 4,
     update => 5,
     map +($_ => $_), 3, 6..15
  );
  
  our %opcode_str = reverse %opcode_id;
  
  our %rcode_id = (
     noerror  =>  0,
     formerr  =>  1,
     servfail =>  2,
     nxdomain =>  3,
     notimp   =>  4,
     refused  =>  5,
     yxdomain =>  6, # Name Exists when it should not     [RFC 2136]
     yxrrset  =>  7, # RR Set Exists when it should not   [RFC 2136]
     nxrrset  =>  8, # RR Set that should exist does not  [RFC 2136]
     notauth  =>  9, # Server Not Authoritative for zone  [RFC 2136]
     notzone  => 10, # Name not contained in zone         [RFC 2136]
  # EDNS0  16    BADVERS   Bad OPT Version                    [RFC 2671]
  # EDNS0  16    BADSIG    TSIG Signature Failure             [RFC 2845]
  # EDNS0  17    BADKEY    Key not recognized                 [RFC 2845]
  # EDNS0  18    BADTIME   Signature out of time window       [RFC 2845]
  # EDNS0  19    BADMODE   Bad TKEY Mode                      [RFC 2930]
  # EDNS0  20    BADNAME   Duplicate key name                 [RFC 2930]
  # EDNS0  21    BADALG    Algorithm not supported            [RFC 2930]
     map +($_ => $_), 11..15
  );
  
  our %rcode_str = reverse %rcode_id;
  
  our %type_id = (
     a     =>   1,
     ns    =>   2,
     md    =>   3,
     mf    =>   4,
     cname =>   5,
     soa   =>   6,
     mb    =>   7,
     mg    =>   8,
     mr    =>   9,
     null  =>  10,
     wks   =>  11,
     ptr   =>  12,
     hinfo =>  13,
     minfo =>  14,
     mx    =>  15,
     txt   =>  16,
     aaaa  =>  28,
     srv   =>  33,
     naptr =>  35, # rfc2915
     dname =>  39, # rfc2672
     opt   =>  41,
     spf   =>  99,
     tkey  => 249,
     tsig  => 250,
     ixfr  => 251,
     axfr  => 252,
     mailb => 253,
     "*"   => 255,
  );
  
  our %type_str = reverse %type_id;
  
  our %class_id = (
     in   =>   1,
     ch   =>   3,
     hs   =>   4,
     none => 254,
     "*"  => 255,
  );
  
  our %class_str = reverse %class_id;
  
  sub _enc_name($) {
     pack "(C/a*)*", (split /\./, shift), ""
  }
  
  if ($] < 5.008) {
     # special slower 5.6 version
     *_enc_name = sub ($) {
        join "", map +(pack "C/a*", $_), (split /\./, shift), ""
     };
  }
  
  sub _enc_qd() {
     (_enc_name $_->[0]) . pack "nn",
       ($_->[1] > 0 ? $_->[1] : $type_id {$_->[1]}),
       ($_->[3] > 0 ? $_->[2] : $class_id{$_->[2] || "in"})
  }
  
  sub _enc_rr() {
     die "encoding of resource records is not supported";
  }
  
  =item $pkt = AnyEvent::DNS::dns_pack $dns
  
  Packs a perl data structure into a DNS packet. Reading RFC 1035 is strongly
  recommended, then everything will be totally clear. Or maybe not.
  
  Resource records are not yet encodable.
  
  Examples:
  
     # very simple request, using lots of default values:
     { rd => 1, qd => [ [ "host.domain", "a"] ] }
    
     # more complex example, showing how flags etc. are named:
    
     {
        id => 10000,
        op => "query",
        rc => "nxdomain",
    
        # flags
        qr => 1,
        aa => 0,
        tc => 0,
        rd => 0,
        ra => 0,
        ad => 0,
        cd => 0,
    
        qd => [@rr], # query section
        an => [@rr], # answer section
        ns => [@rr], # authority section
        ar => [@rr], # additional records section
     }
  
  =cut
  
  sub dns_pack($) {
     my ($req) = @_;
  
     pack "nn nnnn a* a* a* a* a*",
        $req->{id},
  
        ! !$req->{qr}   * 0x8000
        + $opcode_id{$req->{op}} * 0x0800
        + ! !$req->{aa} * 0x0400
        + ! !$req->{tc} * 0x0200
        + ! !$req->{rd} * 0x0100
        + ! !$req->{ra} * 0x0080
        + ! !$req->{ad} * 0x0020
        + ! !$req->{cd} * 0x0010
        + $rcode_id{$req->{rc}} * 0x0001,
  
        scalar @{ $req->{qd} || [] },
        scalar @{ $req->{an} || [] },
        scalar @{ $req->{ns} || [] },
        $EDNS0 + scalar @{ $req->{ar} || [] }, # EDNS0 option included here
  
        (join "", map _enc_qd, @{ $req->{qd} || [] }),
        (join "", map _enc_rr, @{ $req->{an} || [] }),
        (join "", map _enc_rr, @{ $req->{ns} || [] }),
        (join "", map _enc_rr, @{ $req->{ar} || [] }),
  
        ($EDNS0 ? pack "C nnNn", 0, 41, MAX_PKT, 0, 0 : "") # EDNS0 option
  }
  
  our $ofs;
  our $pkt;
  
  # bitches
  sub _dec_name {
     my @res;
     my $redir;
     my $ptr = $ofs;
     my $cnt;
  
     while () {
        return undef if ++$cnt >= 256; # to avoid DoS attacks
  
        my $len = ord substr $pkt, $ptr++, 1;
  
        if ($len >= 0xc0) {
           $ptr++;
           $ofs = $ptr if $ptr > $ofs;
           $ptr = (unpack "n", substr $pkt, $ptr - 2, 2) & 0x3fff;
        } elsif ($len) {
           push @res, substr $pkt, $ptr, $len;
           $ptr += $len;
        } else {
           $ofs = $ptr if $ptr > $ofs;
           return join ".", @res;
        }
     }
  }
  
  sub _dec_qd {
     my $qname = _dec_name;
     my ($qt, $qc) = unpack "nn", substr $pkt, $ofs; $ofs += 4;
     [$qname, $type_str{$qt} || $qt, $class_str{$qc} || $qc]
  }
  
  our %dec_rr = (
       1 => sub { join ".", unpack "C4", $_ }, # a
       2 => sub { local $ofs = $ofs - length; _dec_name }, # ns
       5 => sub { local $ofs = $ofs - length; _dec_name }, # cname
       6 => sub { 
               local $ofs = $ofs - length;
               my $mname = _dec_name;
               my $rname = _dec_name;
               ($mname, $rname, unpack "NNNNN", substr $pkt, $ofs)
            }, # soa
      11 => sub { ((join ".", unpack "C4", $_), unpack "C a*", substr $_, 4) }, # wks
      12 => sub { local $ofs = $ofs - length; _dec_name }, # ptr
      13 => sub { unpack "C/a* C/a*", $_ }, # hinfo
      15 => sub { local $ofs = $ofs + 2 - length; ((unpack "n", $_), _dec_name) }, # mx
      16 => sub { unpack "(C/a*)*", $_ }, # txt
      28 => sub { AnyEvent::Socket::format_ipv6 ($_) }, # aaaa
      33 => sub { local $ofs = $ofs + 6 - length; ((unpack "nnn", $_), _dec_name) }, # srv
      35 => sub { # naptr
         # requires perl 5.10, sorry
         my ($order, $preference, $flags, $service, $regexp, $offset) = unpack "nn C/a* C/a* C/a* .", $_;
         local $ofs = $ofs + $offset - length;
         ($order, $preference, $flags, $service, $regexp, _dec_name)
      },
      39 => sub { local $ofs = $ofs - length; _dec_name }, # dname
      99 => sub { unpack "(C/a*)*", $_ }, # spf
  );
  
  sub _dec_rr {
     my $name = _dec_name;
  
     my ($rt, $rc, $ttl, $rdlen) = unpack "nn N n", substr $pkt, $ofs; $ofs += 10;
     local $_ = substr $pkt, $ofs, $rdlen; $ofs += $rdlen;
  
     [
        $name,
        $type_str{$rt}  || $rt,
        $class_str{$rc} || $rc,
        $ttl,
        ($dec_rr{$rt} || sub { $_ })->(),
     ]
  }
  
  =item $dns = AnyEvent::DNS::dns_unpack $pkt
  
  Unpacks a DNS packet into a perl data structure.
  
  Examples:
  
     # an unsuccessful reply
     {
       'qd' => [
                 [ 'ruth.plan9.de.mach.uni-karlsruhe.de', '*', 'in' ]
               ],
       'rc' => 'nxdomain',
       'ar' => [],
       'ns' => [
                 [
                   'uni-karlsruhe.de',
                   'soa',
                   'in',
                   600,
                   'netserv.rz.uni-karlsruhe.de',
                   'hostmaster.rz.uni-karlsruhe.de',
                   2008052201, 10800, 1800, 2592000, 86400
                 ]
               ],
       'tc' => '',
       'ra' => 1,
       'qr' => 1,
       'id' => 45915,
       'aa' => '',
       'an' => [],
       'rd' => 1,
       'op' => 'query'
     }
     
     # a successful reply
     
     {
       'qd' => [ [ 'www.google.de', 'a', 'in' ] ],
       'rc' => 0,
       'ar' => [
                 [ 'a.l.google.com', 'a', 'in', 3600, '209.85.139.9' ],
                 [ 'b.l.google.com', 'a', 'in', 3600, '64.233.179.9' ],
                 [ 'c.l.google.com', 'a', 'in', 3600, '64.233.161.9' ],
               ],
       'ns' => [
                 [ 'l.google.com', 'ns', 'in', 3600, 'a.l.google.com' ],
                 [ 'l.google.com', 'ns', 'in', 3600, 'b.l.google.com' ],
               ],
       'tc' => '',
       'ra' => 1,
       'qr' => 1,
       'id' => 64265,
       'aa' => '',
       'an' => [
                 [ 'www.google.de', 'cname', 'in', 3600, 'www.google.com' ],
                 [ 'www.google.com', 'cname', 'in', 3600, 'www.l.google.com' ],
                 [ 'www.l.google.com', 'a', 'in', 3600, '66.249.93.104' ],
                 [ 'www.l.google.com', 'a', 'in', 3600, '66.249.93.147' ],
               ],
       'rd' => 1,
       'op' => 0
     }
  
  =cut
  
  sub dns_unpack($) {
     local $pkt = shift;
     my ($id, $flags, $qd, $an, $ns, $ar)
        = unpack "nn nnnn A*", $pkt;
  
     local $ofs = 6 * 2;
  
     {
        id => $id,
        qr => ! ! ($flags & 0x8000),
        aa => ! ! ($flags & 0x0400),
        tc => ! ! ($flags & 0x0200),
        rd => ! ! ($flags & 0x0100),
        ra => ! ! ($flags & 0x0080),
        ad => ! ! ($flags & 0x0020),
        cd => ! ! ($flags & 0x0010),
        op => $opcode_str{($flags & 0x001e) >> 11},
        rc => $rcode_str{($flags & 0x000f)},
  
        qd => [map _dec_qd, 1 .. $qd],
        an => [map _dec_rr, 1 .. $an],
        ns => [map _dec_rr, 1 .. $ns],
        ar => [map _dec_rr, 1 .. $ar],
     }
  }
  
  #############################################################################
  
  =back
  
  =head2 THE AnyEvent::DNS RESOLVER CLASS
  
  This is the class which does the actual protocol work.
  
  =over 4
  
  =cut
  
  use Carp ();
  use Scalar::Util ();
  use Socket ();
  
  our $NOW;
  
  =item AnyEvent::DNS::resolver
  
  This function creates and returns a resolver that is ready to use and
  should mimic the default resolver for your system as good as possible. It
  is used by AnyEvent itself as well.
  
  It only ever creates one resolver and returns this one on subsequent calls
  - see C<$AnyEvent::DNS::RESOLVER>, below, for details.
  
  Unless you have special needs, prefer this function over creating your own
  resolver object.
  
  The resolver is created with the following parameters:
  
     untaint          enabled
     max_outstanding  $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}
  
  C<os_config> will be used for OS-specific configuration, unless
  C<$ENV{PERL_ANYEVENT_RESOLV_CONF}> is specified, in which case that file
  gets parsed.
  
  =item $AnyEvent::DNS::RESOLVER
  
  This variable stores the default resolver returned by
  C<AnyEvent::DNS::resolver>, or C<undef> when the default resolver hasn't
  been instantiated yet.
  
  One can provide a custom resolver (e.g. one with caching functionality)
  by storing it in this variable, causing all subsequent resolves done via
  C<AnyEvent::DNS::resolver> to be done via the custom one.
  
  =cut
  
  our $RESOLVER;
  
  sub resolver() {
     $RESOLVER || do {
        $RESOLVER = new AnyEvent::DNS
           untaint         => 1,
           max_outstanding => $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}*1 || 1,
        ;
  
        $ENV{PERL_ANYEVENT_RESOLV_CONF}
           ? $RESOLVER->_parse_resolv_conf_file ($ENV{PERL_ANYEVENT_RESOLV_CONF})
           : $RESOLVER->os_config;
  
        $RESOLVER
     }
  }
  
  =item $resolver = new AnyEvent::DNS key => value...
  
  Creates and returns a new resolver.
  
  The following options are supported:
  
  =over 4
  
  =item server => [...]
  
  A list of server addresses (default: C<v127.0.0.1> or C<::1>) in network
  format (i.e. as returned by C<AnyEvent::Socket::parse_address> - both IPv4
  and IPv6 are supported).
  
  =item timeout => [...]
  
  A list of timeouts to use (also determines the number of retries). To make
  three retries with individual time-outs of 2, 5 and 5 seconds, use C<[2,
  5, 5]>, which is also the default.
  
  =item search => [...]
  
  The default search list of suffixes to append to a domain name (default: none).
  
  =item ndots => $integer
  
  The number of dots (default: C<1>) that a name must have so that the resolver
  tries to resolve the name without any suffixes first.
  
  =item max_outstanding => $integer
  
  Most name servers do not handle many parallel requests very well. This
  option limits the number of outstanding requests to C<$integer>
  (default: C<10>), that means if you request more than this many requests,
  then the additional requests will be queued until some other requests have
  been resolved.
  
  =item reuse => $seconds
  
  The number of seconds (default: C<300>) that a query id cannot be re-used
  after a timeout. If there was no time-out then query ids can be reused
  immediately.
  
  =item untaint => $boolean
  
  When true, then the resolver will automatically untaint results, and might
  also ignore certain environment variables.
  
  =back
  
  =cut
  
  sub new {
     my ($class, %arg) = @_;
  
     my $self = bless {
        server  => [],
        timeout => [2, 5, 5],
        search  => [],
        ndots   => 1,
        max_outstanding => 10,
        reuse   => 300,
        %arg,
        reuse_q => [],
     }, $class;
  
     # search should default to gethostname's domain
     # but perl lacks a good posix module
  
     # try to create an ipv4 and an ipv6 socket
     # only fail when we cannot create either
     my $got_socket;
  
     Scalar::Util::weaken (my $wself = $self);
  
     if (socket my $fh4, AF_INET , Socket::SOCK_DGRAM(), 0) {
        ++$got_socket;
  
        AnyEvent::Util::fh_nonblocking $fh4, 1;
        $self->{fh4} = $fh4;
        $self->{rw4} = AE::io $fh4, 0, sub {
           if (my $peer = recv $fh4, my $pkt, MAX_PKT, 0) {
              $wself->_recv ($pkt, $peer);
           }
        };
     }
  
     if (AF_INET6 && socket my $fh6, AF_INET6, Socket::SOCK_DGRAM(), 0) {
        ++$got_socket;
  
        $self->{fh6} = $fh6;
        AnyEvent::Util::fh_nonblocking $fh6, 1;
        $self->{rw6} = AE::io $fh6, 0, sub {
           if (my $peer = recv $fh6, my $pkt, MAX_PKT, 0) {
              $wself->_recv ($pkt, $peer);
           }
        };
     }
  
     $got_socket
        or Carp::croak "unable to create either an IPv4 or an IPv6 socket";
  
     $self->_compile;
  
     $self
  }
  
  =item $resolver->parse_resolv_conf ($string)
  
  Parses the given string as if it were a F<resolv.conf> file. The following
  directives are supported (but not necessarily implemented).
  
  C<#>- and C<;>-style comments, C<nameserver>, C<domain>, C<search>, C<sortlist>,
  C<options> (C<timeout>, C<attempts>, C<ndots>).
  
  Everything else is silently ignored.
  
  =cut
  
  sub parse_resolv_conf {
     my ($self, $resolvconf) = @_;
  
     $self->{server} = [];
     $self->{search} = [];
  
     my $attempts;
  
     for (split /\n/, $resolvconf) {
        s/\s*[;#].*$//; # not quite legal, but many people insist
  
        if (/^\s*nameserver\s+(\S+)\s*$/i) {
           my $ip = $1;
           if (my $ipn = AnyEvent::Socket::parse_address ($ip)) {
              push @{ $self->{server} }, $ipn;
           } else {
              AE::log 5 => "nameserver $ip invalid and ignored, while parsing resolver config.";
           }
        } elsif (/^\s*domain\s+(\S*)\s*$/i) {
           $self->{search} = [$1];
        } elsif (/^\s*search\s+(.*?)\s*$/i) {
           $self->{search} = [split /\s+/, $1];
        } elsif (/^\s*sortlist\s+(.*?)\s*$/i) {
           # ignored, NYI
        } elsif (/^\s*options\s+(.*?)\s*$/i) {
           for (split /\s+/, $1) {
              if (/^timeout:(\d+)$/) {
                 $self->{timeout} = [$1];
              } elsif (/^attempts:(\d+)$/) {
                 $attempts = $1;
              } elsif (/^ndots:(\d+)$/) {
                 $self->{ndots} = $1;
              } else {
                 # debug, rotate, no-check-names, inet6
              }
           }
        } else {
           # silently skip stuff we don't understand
        }
     }
  
     $self->{timeout} = [($self->{timeout}[0]) x $attempts]
        if $attempts;
  
     $self->_compile;
  }
  
  sub _parse_resolv_conf_file {
     my ($self, $resolv_conf) = @_;
  
     open my $fh, "<", $resolv_conf
        or Carp::croak "$resolv_conf: $!";
  
     local $/;
     $self->parse_resolv_conf (<$fh>);
  }
  
  =item $resolver->os_config
  
  Tries so load and parse F</etc/resolv.conf> on portable operating
  systems. Tries various egregious hacks on windows to force the DNS servers
  and searchlist out of the system.
  
  =cut
  
  sub os_config {
     my ($self) = @_;
  
     $self->{server} = [];
     $self->{search} = [];
  
     if ((AnyEvent::WIN32 || $^O =~ /cygwin/i)) {
        #no strict 'refs';
  
        # there are many options to find the current nameservers etc. on windows
        # all of them don't work consistently:
        # - the registry thing needs separate code on win32 native vs. cygwin
        # - the registry layout differs between windows versions
        # - calling windows api functions doesn't work on cygwin
        # - ipconfig uses locale-specific messages
  
        # we use Net::DNS::Resolver first, and if it fails, will fall back to
        # ipconfig parsing.
        unless (eval {
           # Net::DNS::Resolver uses a LOT of ram (~10mb), but what can we do :/
           # (this seems mostly to be due to Win32::API).
           require Net::DNS::Resolver;
           my $r = Net::DNS::Resolver->new;
  
           $r->nameservers
              or die;
  
           for my $s ($r->nameservers) {
              if (my $ipn = AnyEvent::Socket::parse_address ($s)) {
                 push @{ $self->{server} }, $ipn;
              }
           }
           $self->{search} = [$r->searchlist];
  
           1
        }) {
           # we use ipconfig parsing because, despite all its brokenness,
           # it seems most stable in practise.
           # unfortunately it wants a console window.
           # for good measure, we append a fallback nameserver to our list.
  
           if (open my $fh, "ipconfig /all |") {
              # parsing strategy: we go through the output and look for
              # :-lines with DNS in them. everything in those is regarded as
              # either a nameserver (if it parses as an ip address), or a suffix
              # (all else).
  
              my $dns;
              local $_;
              while (<$fh>) {
                 if (s/^\s.*\bdns\b.*://i) {
                    $dns = 1;
                 } elsif (/^\S/ || /^\s[^:]{16,}: /) {
                    $dns = 0;
                 }
                 if ($dns && /^\s*(\S+)\s*$/) {
                    my $s = $1;
                    $s =~ s/%\d+(?!\S)//; # get rid of ipv6 scope id
                    if (my $ipn = AnyEvent::Socket::parse_address ($s)) {
                       push @{ $self->{server} }, $ipn;
                    } else {
                       push @{ $self->{search} }, $s;
                    }
                 }
              }
           }
        }
  
        # always add the fallback servers on windows
        push @{ $self->{server} }, @DNS_FALLBACK;
  
        $self->_compile;
     } else {
        # try resolv.conf everywhere else
  
        $self->_parse_resolv_conf_file ("/etc/resolv.conf")
           if -e "/etc/resolv.conf";
     }
  }
  
  =item $resolver->timeout ($timeout, ...)
  
  Sets the timeout values. See the C<timeout> constructor argument (and note
  that this method uses the values itself, not an array-reference).
  
  =cut
  
  sub timeout {
     my ($self, @timeout) = @_;
  
     $self->{timeout} = \@timeout;
     $self->_compile;
  }
  
  =item $resolver->max_outstanding ($nrequests)
  
  Sets the maximum number of outstanding requests to C<$nrequests>. See the
  C<max_outstanding> constructor argument.
  
  =cut
  
  sub max_outstanding {
     my ($self, $max) = @_;
  
     $self->{max_outstanding} = $max;
     $self->_scheduler;
  }
  
  sub _compile {
     my $self = shift;
  
     my %search; $self->{search} = [grep 0 < length, grep !$search{$_}++, @{ $self->{search} }];
     my %server; $self->{server} = [grep 0 < length, grep !$server{$_}++, @{ $self->{server} }];
  
     unless (@{ $self->{server} }) {
        # use 127.0.0.1/::1 by default, add public nameservers as fallback
        my $default = $AnyEvent::PROTOCOL{ipv6} > $AnyEvent::PROTOCOL{ipv4}
                      ? "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1" : "\x7f\x00\x00\x01";
        $self->{server} = [$default, @DNS_FALLBACK];
     }
  
     my @retry;
  
     for my $timeout (@{ $self->{timeout} }) {
        for my $server (@{ $self->{server} }) {
           push @retry, [$server, $timeout];
        }
     }
  
     $self->{retry} = \@retry;
  }
  
  sub _feed {
     my ($self, $res) = @_;
  
     ($res) = $res =~ /^(.*)$/s
        if AnyEvent::TAINT && $self->{untaint};
  
     $res = dns_unpack $res
        or return;
  
     my $id = $self->{id}{$res->{id}};
  
     return unless ref $id;
  
     $NOW = time;
     $id->[1]->($res);
  }
  
  sub _recv {
     my ($self, $pkt, $peer) = @_;
  
     # we ignore errors (often one gets port unreachable, but there is
     # no good way to take advantage of that.
  
     my ($port, $host) = AnyEvent::Socket::unpack_sockaddr ($peer);
  
     return unless $port == 53 && grep $_ eq $host, @{ $self->{server} };
  
     $self->_feed ($pkt);
  }
  
  sub _free_id {
     my ($self, $id, $timeout) = @_;
  
     if ($timeout) {
        # we need to block the id for a while
        $self->{id}{$id} = 1;
        push @{ $self->{reuse_q} }, [$NOW + $self->{reuse}, $id];
     } else {
        # we can quickly recycle the id
        delete $self->{id}{$id};
     }
  
     --$self->{outstanding};
     $self->_scheduler;
  }
  
  # execute a single request, involves sending it with timeouts to multiple servers
  sub _exec {
     my ($self, $req) = @_;
  
     my $retry; # of retries
     my $do_retry;
  
     $do_retry = sub {
        my $retry_cfg = $self->{retry}[$retry++]
           or do {
              # failure
              $self->_free_id ($req->[2], $retry > 1);
              undef $do_retry; return $req->[1]->();
           };
  
        my ($server, $timeout) = @$retry_cfg;
        
        $self->{id}{$req->[2]} = [(AE::timer $timeout, 0, sub {
           $NOW = time;
  
           # timeout, try next
           &$do_retry if $do_retry;
        }), sub {
           my ($res) = @_;
  
           if ($res->{tc}) {
              # success, but truncated, so use tcp
              AnyEvent::Socket::tcp_connect (AnyEvent::Socket::format_address ($server), DOMAIN_PORT, sub {
                 return unless $do_retry; # some other request could have invalidated us already
  
                 my ($fh) = @_
                    or return &$do_retry;
  
                 require AnyEvent::Handle;
  
                 my $handle; $handle = new AnyEvent::Handle
                    fh       => $fh,
                    timeout  => $timeout,
                    on_error => sub {
                       undef $handle;
                       return unless $do_retry; # some other request could have invalidated us already
                       # failure, try next
                       &$do_retry;
                    };
  
                 $handle->push_write (pack "n/a*", $req->[0]);
                 $handle->push_read (chunk => 2, sub {
                    $handle->unshift_read (chunk => (unpack "n", $_[1]), sub {
                       undef $handle;
                       $self->_feed ($_[1]);
                    });
                 });
  
              }, sub { $timeout });
  
           } else {
              # success
              $self->_free_id ($req->[2], $retry > 1);
              undef $do_retry; return $req->[1]->($res);
           }
        }];
        
        my $sa = AnyEvent::Socket::pack_sockaddr (DOMAIN_PORT, $server);
  
        my $fh = AF_INET == AnyEvent::Socket::sockaddr_family ($sa)
                 ? $self->{fh4} : $self->{fh6}
           or return &$do_retry;
  
        send $fh, $req->[0], 0, $sa;
     };
  
     &$do_retry;
  }
  
  sub _scheduler {
     my ($self) = @_;
  
     #no strict 'refs';
  
     $NOW = time;
  
     # first clear id reuse queue
     delete $self->{id}{ (shift @{ $self->{reuse_q} })->[1] }
        while @{ $self->{reuse_q} } && $self->{reuse_q}[0][0] <= $NOW;
  
     while ($self->{outstanding} < $self->{max_outstanding}) {
  
        if (@{ $self->{reuse_q} } >= 30000) {
           # we ran out of ID's, wait a bit
           $self->{reuse_to} ||= AE::timer $self->{reuse_q}[0][0] - $NOW, 0, sub {
              delete $self->{reuse_to};
              $self->_scheduler;
           };
           last;
        }
  
        if (my $req = shift @{ $self->{queue} }) {
           # found a request in the queue, execute it
           while () {
              $req->[2] = int rand 65536;
              last unless exists $self->{id}{$req->[2]};
           }
  
           ++$self->{outstanding};
           $self->{id}{$req->[2]} = 1;
           substr $req->[0], 0, 2, pack "n", $req->[2];
  
           $self->_exec ($req);
  
        } elsif (my $cb = shift @{ $self->{wait} }) {
           # found a wait_for_slot callback, call that one first
           $cb->($self);
  
        } else {
           # nothing to do, just exit
           last;
        }
     }
  }
  
  =item $resolver->request ($req, $cb->($res))
  
  This is the main low-level workhorse for sending DNS requests.
  
  This function sends a single request (a hash-ref formated as specified
  for C<dns_pack>) to the configured nameservers in turn until it gets a
  response. It handles timeouts, retries and automatically falls back to
  virtual circuit mode (TCP) when it receives a truncated reply. It does not
  handle anything else, such as the domain searchlist or relative names -
  use C<< ->resolve >> for that.
  
  Calls the callback with the decoded response packet if a reply was
  received, or no arguments in case none of the servers answered.
  
  =cut
  
  sub request($$) {
     my ($self, $req, $cb) = @_;
  
     # _enc_name barfs on names that are too long, which is often outside
     # program control, so check for too long names here.
     for (@{ $req->{qd} }) {
        return AE::postpone sub { $cb->(undef) }
           if 255 < length $_->[0];
     }
  
     push @{ $self->{queue} }, [dns_pack $req, $cb];
     $self->_scheduler;
  }
  
  =item $resolver->resolve ($qname, $qtype, %options, $cb->(@rr))
  
  Queries the DNS for the given domain name C<$qname> of type C<$qtype>.
  
  A C<$qtype> is either a numerical query type (e.g. C<1> for A records) or
  a lowercase name (you have to look at the source to see which aliases are
  supported, but all types from RFC 1035, C<aaaa>, C<srv>, C<spf> and a few
  more are known to this module). A C<$qtype> of "*" is supported and means
  "any" record type.
  
  The callback will be invoked with a list of matching result records or
  none on any error or if the name could not be found.
  
  CNAME chains (although illegal) are followed up to a length of 10.
  
  The callback will be invoked with arraryefs of the form C<[$name,
  $type, $class, $ttl, @data>], where C<$name> is the domain name,
  C<$type> a type string or number, C<$class> a class name, C<$ttl> is the
  remaining time-to-live and C<@data> is resource-record-dependent data, in
  seconds. For C<a> records, this will be the textual IPv4 addresses, for
  C<ns> or C<cname> records this will be a domain name, for C<txt> records
  these are all the strings and so on.
  
  All types mentioned in RFC 1035, C<aaaa>, C<srv>, C<naptr> and C<spf> are
  decoded. All resource records not known to this module will have the raw
  C<rdata> field as fifth array element.
  
  Note that this resolver is just a stub resolver: it requires a name server
  supporting recursive queries, will not do any recursive queries itself and
  is not secure when used against an untrusted name server.
  
  The following options are supported:
  
  =over 4
  
  =item search => [$suffix...]
  
  Use the given search list (which might be empty), by appending each one
  in turn to the C<$qname>. If this option is missing then the configured
  C<ndots> and C<search> values define its value (depending on C<ndots>, the
  empty suffix will be prepended or appended to that C<search> value). If
  the C<$qname> ends in a dot, then the searchlist will be ignored.
  
  =item accept => [$type...]
  
  Lists the acceptable result types: only result types in this set will be
  accepted and returned. The default includes the C<$qtype> and nothing
  else. If this list includes C<cname>, then CNAME-chains will not be
  followed (because you asked for the CNAME record).
  
  =item class => "class"
  
  Specify the query class ("in" for internet, "ch" for chaosnet and "hs" for
  hesiod are the only ones making sense). The default is "in", of course.
  
  =back
  
  Examples:
  
     # full example, you can paste this into perl:
     use Data::Dumper;
     use AnyEvent::DNS;
     AnyEvent::DNS::resolver->resolve (
        "google.com", "*", my $cv = AnyEvent->condvar);
     warn Dumper [$cv->recv];
  
     # shortened result:
     # [
     #   [ 'google.com', 'soa', 'in', 3600, 'ns1.google.com', 'dns-admin.google.com',
     #     2008052701, 7200, 1800, 1209600, 300 ],
     #   [
     #     'google.com', 'txt', 'in', 3600,
     #     'v=spf1 include:_netblocks.google.com ~all'
     #   ],
     #   [ 'google.com', 'a', 'in', 3600, '64.233.187.99' ],
     #   [ 'google.com', 'mx', 'in', 3600, 10, 'smtp2.google.com' ],
     #   [ 'google.com', 'ns', 'in', 3600, 'ns2.google.com' ],
     # ]
  
     # resolve a records:
     $res->resolve ("ruth.plan9.de", "a", sub { warn Dumper [@_] });
  
     # result:
     # [
     #   [ 'ruth.schmorp.de', 'a', 'in', 86400, '129.13.162.95' ]
     # ]
  
     # resolve any records, but return only a and aaaa records:
     $res->resolve ("test1.laendle", "*",
        accept => ["a", "aaaa"],
        sub {
           warn Dumper [@_];
        }
     );
  
     # result:
     # [
     #   [ 'test1.laendle', 'a', 'in', 86400, '10.0.0.255' ],
     #   [ 'test1.laendle', 'aaaa', 'in', 60, '3ffe:1900:4545:0002:0240:0000:0000:f7e1' ]
     # ]
  
  =cut
  
  sub resolve($%) {
     my $cb = pop;
     my ($self, $qname, $qtype, %opt) = @_;
  
     my @search = $qname =~ s/\.$//
        ? ""
        : $opt{search}
          ? @{ $opt{search} }
          : ($qname =~ y/.//) >= $self->{ndots}
            ? ("", @{ $self->{search} })
            : (@{ $self->{search} }, "");
  
     my $class = $opt{class} || "in";
  
     my %atype = $opt{accept}
        ? map +($_ => 1), @{ $opt{accept} }
        : ($qtype => 1);
  
     # advance in searchlist
     my ($do_search, $do_req);
     
     $do_search = sub {
        @search
           or (undef $do_search), (undef $do_req), return $cb->();
  
        (my $name = lc "$qname." . shift @search) =~ s/\.$//;
        my $depth = 10;
  
        # advance in cname-chain
        $do_req = sub {
           $self->request ({
              rd => 1,
              qd => [[$name, $qtype, $class]],
           }, sub {
              my ($res) = @_
                 or return $do_search->();
  
              my $cname;
  
              while () {
                 # results found?
                 my @rr = grep $name eq lc $_->[0] && ($atype{"*"} || $atype{$_->[1]}), @{ $res->{an} };
  
                 (undef $do_search), (undef $do_req), return $cb->(@rr)
                    if @rr;
  
                 # see if there is a cname we can follow
                 my @rr = grep $name eq lc $_->[0] && $_->[1] eq "cname", @{ $res->{an} };
  
                 if (@rr) {
                    $depth--
                       or return $do_search->(); # cname chain too long
  
                    $cname = 1;
                    $name = lc $rr[0][4];
  
                 } elsif ($cname) {
                    # follow the cname
                    return $do_req->();
  
                 } else {
                    # no, not found anything
                    return $do_search->();
                 }
               }
           });
        };
  
        $do_req->();
     };
  
     $do_search->();
  }
  
  =item $resolver->wait_for_slot ($cb->($resolver))
  
  Wait until a free request slot is available and call the callback with the
  resolver object.
  
  A request slot is used each time a request is actually sent to the
  nameservers: There are never more than C<max_outstanding> of them.
  
  Although you can submit more requests (they will simply be queued until
  a request slot becomes available), sometimes, usually for rate-limiting
  purposes, it is useful to instead wait for a slot before generating the
  request (or simply to know when the request load is low enough so one can
  submit requests again).
  
  This is what this method does: The callback will be called when submitting
  a DNS request will not result in that request being queued. The callback
  may or may not generate any requests in response.
  
  Note that the callback will only be invoked when the request queue is
  empty, so this does not play well if somebody else keeps the request queue
  full at all times.
  
  =cut
  
  sub wait_for_slot {
     my ($self, $cb) = @_;
  
     push @{ $self->{wait} }, $cb;
     $self->_scheduler;
  }
  
  use AnyEvent::Socket (); # circular dependency, so do not import anything and do it at the end
  
  1;
  
  =back
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_DNS

$fatpacked{"darwin-2level/AnyEvent/Debug.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_DEBUG';
  =head1 NAME
  
  AnyEvent::Debug - debugging utilities for AnyEvent
  
  =head1 SYNOPSIS
  
     use AnyEvent::Debug;
  
     # create an interactive shell into the program
     my $shell = AnyEvent::Debug::shell "unix/", "/home/schmorp/myshell";
     # then on the shell: "socat readline /home/schmorp/myshell"
  
  =head1 DESCRIPTION
  
  This module provides functionality hopefully useful for debugging.
  
  At the moment, "only" an interactive shell is implemented. This shell
  allows you to interactively "telnet into" your program and execute Perl
  code, e.g. to look at global variables.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::Debug;
  
  use B ();
  use Carp ();
  use Errno ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  use AnyEvent::Socket ();
  use AnyEvent::Log ();
  
  our $TRACE = 1; # trace status
  
  our ($TRACE_LOGGER, $TRACE_ENABLED);
  
  # cache often-used strings, purely to save memory, at the expense of speed
  our %STRCACHE;
  
  =item $shell = AnyEvent::Debug::shell $host, $service
  
  This function binds on the given host and service port and returns a
  shell object, which determines the lifetime of the shell. Any number
  of conenctions are accepted on the port, and they will give you a very
  primitive shell that simply executes every line you enter.
  
  All commands will be executed "blockingly" with the socket C<select>ed for
  output. For a less "blocking" interface see L<Coro::Debug>.
  
  The commands will be executed in the C<AnyEvent::Debug::shell> package,
  which currently has "help" and a few other commands, and can be freely
  modified by all shells. Code is evaluated under C<use strict 'subs'>.
  
  Every shell has a logging context (C<$LOGGER>) that is attached to
  C<$AnyEvent::Log::COLLECT>), which is especially useful to gether debug
  and trace messages.
  
  As a general programming guide, consider the beneficial aspects of
  using more global (C<our>) variables than local ones (C<my>) in package
  scope: Earlier all my modules tended to hide internal variables inside
  C<my> variables, so users couldn't accidentally access them. Having
  interactive access to your programs changed that: having internal
  variables still in the global scope means you can debug them easier.
  
  As no authentication is done, in most cases it is best not to use a TCP
  port, but a unix domain socket, whcih can be put wherever you can access
  it, but not others:
  
     our $SHELL = AnyEvent::Debug::shell "unix/", "/home/schmorp/shell";
  
  Then you can use a tool to connect to the shell, such as the ever
  versatile C<socat>, which in addition can give you readline support:
  
     socat readline /home/schmorp/shell
     # or:
     cd /home/schmorp; socat readline unix:shell
  
  Socat can even give you a persistent history:
  
     socat readline,history=.anyevent-history unix:shell
  
  Binding on C<127.0.0.1> (or C<::1>) might be a less secure but sitll not
  totally insecure (on single-user machines) alternative to let you use
  other tools, such as telnet:
  
     our $SHELL = AnyEvent::Debug::shell "127.1", "1357";
  
  And then:
  
     telnet localhost 1357
  
  =cut
  
  sub shell($$) {
     local $TRACE = 0;
  
     AnyEvent::Socket::tcp_server $_[0], $_[1], sub {
        my ($fh, $host, $port) = @_;
  
        syswrite $fh, "Welcome, $host:$port, use 'help' for more info!\015\012> ";
        my $rbuf;
  
        my $logger = new AnyEvent::Log::Ctx
           log_cb => sub {
              syswrite $fh, shift;
              0
           };
  
        my $logger_guard = AnyEvent::Util::guard {
           $AnyEvent::Log::COLLECT->detach ($logger);
        };
        $AnyEvent::Log::COLLECT->attach ($logger);
  
        local $TRACE = 0;
        my $rw; $rw = AE::io $fh, 0, sub {
           my $len = sysread $fh, $rbuf, 1024, length $rbuf;
  
           $logger_guard if 0; # reference it
  
           if (defined $len ? $len == 0 : $! != Errno::EAGAIN) {
              undef $rw;
           } else {
              while ($rbuf =~ s/^(.*)\015?\012//) {
                 my $line = $1;
  
                 AnyEvent::Util::fh_nonblocking $fh, 0;
  
                 if ($line =~ /^\s*exit\b/) {
                    syswrite $fh, "sorry, no... if you want to execute exit, try CORE::exit.\015\012";
                 } else {
                    package AnyEvent::Debug::shell;
  
                    no strict 'vars';
                    local $LOGGER = $logger;
                    my $old_stdout = select $fh;
                    local $| = 1;
  
                    my @res = eval $line;
  
                    select $old_stdout;
                    syswrite $fh, "$@" if $@;
                    syswrite $fh, "\015\012";
  
                    if (@res > 1) {
                       syswrite $fh, "$_: $res[$_]\015\012" for 0 .. $#res;
                    } elsif (@res == 1) {
                       syswrite $fh, "$res[0]\015\012";
                    }
                 }
  
                 syswrite $fh, "> ";
                 AnyEvent::Util::fh_nonblocking $fh, 1;
              }
           }
        };
     }
  }
  
  {
     package AnyEvent::Debug::shell;
  
     our $LOGGER;
  
     sub help() {
        <<EOF
  help         this command
  wr [level]   sets wrap level to level (or toggles if missing)
  v [level]    sets verbosity (or toggles between 0 and 9 if missing)
  wl 'regex'   print wrapped watchers matching the regex (or all if missing)
  i id,...     prints the watcher with the given ids in more detail
  t            enable tracing for newly created watchers (enabled by default)
  ut           disable tracing for newly created watchers
  t  id,...    enable tracing for the given watcher (enabled by default)
  ut id,...    disable tracing for the given weatcher
  w id,...     converts the watcher ids to watcher objects (for scripting)
  EOF
     }
  
     sub wl(;$) {
        my $re = @_ ? qr<$_[0]>i : qr<.>;
  
        my %res;
  
        while (my ($k, $v) = each %AnyEvent::Debug::Wrapped) {
           my $s = "$v";
           $res{$s} = $k . (exists $v->{error} ? "*" : " ")
              if $s =~ $re;
        }
  
        join "", map "$res{$_} $_\n", sort keys %res
     }
  
     sub w {
        map {
           $AnyEvent::Debug::Wrapped{$_} || do {
              print "$_: no such wrapped watcher.\n";
              ()
           }
        } @_
     }
  
     sub i {
        join "",
           map $_->id . " $_\n" . $_->verbose . "\n",
              &w
     }
  
     sub wr {
        AnyEvent::Debug::wrap (@_);
  
        "wrap level now $AnyEvent::Debug::WRAP_LEVEL"
     }
  
     sub t {
        if (@_) {
           @_ = &w;
           $_->trace (1)
              for @_;
           "tracing enabled for @_."
        } else {
           $AnyEvent::Debug::TRACE = 1;
           "tracing for newly created watchers is now enabled."
        }
     }
  
     sub u {
        if (@_) {
           @_ = &w;
           $_->trace (0)
              for @_;
           "tracing disabled for @_."
        } else {
           $AnyEvent::Debug::TRACE = 0;
           "tracing for newly created watchers is now disabled."
        }
     }
  
     sub v {
        $LOGGER->level (@_ ? $_[0] : $LOGGER->[1] ? 0 : 9);
  
        "verbose logging is now " . ($LOGGER->[1] ? "enabled" : "disabled") . "."
     }
  }
  
  =item AnyEvent::Debug::wrap [$level]
  
  Sets the instrumenting/wrapping level of all watchers that are being
  created after this call. If no C<$level> has been specified, then it
  toggles between C<0> and C<1>.
  
  The default wrap level is C<0>, or whatever
  C<$ENV{PERL_ANYEVENT_DEBUG_WRAP}> specifies.
  
  A level of C<0> disables wrapping, i.e. AnyEvent works normally, and in
  its most efficient mode.
  
  A level of C<1> or higher enables wrapping, which replaces all watchers
  by AnyEvent::Debug::Wrapped objects, stores the location where a
  watcher was created and wraps the callback to log all invocations at
  "trace" loglevel if tracing is enabled fore the watcher. The initial
  state of tracing when creating a watcher is taken from the global
  variable C<$AnyEvent:Debug::TRACE>. The default value of that variable
  is C<1>, but it can make sense to set it to C<0> and then do C<< local
  $AnyEvent::Debug::TRACE = 1 >> in a block where you create "interesting"
  watchers. Tracing can also be enabled and disabled later by calling the
  watcher's C<trace> method.
  
  The wrapper will also count how many times the callback was invoked and
  will record up to ten runtime errors with corresponding backtraces. It
  will also log runtime errors at "error" loglevel.
  
  To see the trace messages, you can invoke your program with
  C<PERL_ANYEVENT_VERBOSE=9>, or you can use AnyEvent::Log to divert
  the trace messages in any way you like (the EXAMPLES section in
  L<AnyEvent::Log> has some examples).
  
  A level of C<2> does everything that level C<1> does, but also stores a
  full backtrace of the location the watcher was created, which slows down
  watcher creation considerably.
  
  Every wrapped watcher will be linked into C<%AnyEvent::Debug::Wrapped>,
  with its address as key. The C<wl> command in the debug shell can be used
  to list watchers.
  
  Instrumenting can increase the size of each watcher multiple times, and,
  especially when backtraces are involved, also slows down watcher creation
  a lot.
  
  Also, enabling and disabling instrumentation will not recover the full
  performance that you had before wrapping (the AE::xxx functions will stay
  slower, for example).
  
  If you are developing your program, also consider using AnyEvent::Strict
  to check for common mistakes.
  
  =cut
  
  our $WRAP_LEVEL;
  our $TRACE_CUR;
  our $POST_DETECT;
  
  sub wrap(;$) {
     my $PREV_LEVEL = $WRAP_LEVEL;
     $WRAP_LEVEL = @_ ? 0+shift : $WRAP_LEVEL ? 0 : 1;
  
     if ($AnyEvent::MODEL) {
        if ($WRAP_LEVEL && !$PREV_LEVEL) {
           $TRACE_LOGGER = AnyEvent::Log::logger trace => \$TRACE_ENABLED;
           AnyEvent::_isa_hook 0 => "AnyEvent::Debug::Wrap", 1;
           AnyEvent::Debug::Wrap::_reset ();
        } elsif (!$WRAP_LEVEL && $PREV_LEVEL) {
           AnyEvent::_isa_hook 0 => undef;
        }
     } else {
        $POST_DETECT ||= AnyEvent::post_detect {
           undef $POST_DETECT;
           return unless $WRAP_LEVEL;
  
           (my $level, $WRAP_LEVEL) = ($WRAP_LEVEL, undef);
  
           require AnyEvent::Strict unless $AnyEvent::Strict::VERSION;
  
           AnyEvent::post_detect { # make sure we run after AnyEvent::Strict
              wrap ($level);
           };
        };
     }
  }
  
  =item AnyEvent::Debug::path2mod $path
  
  Tries to replace a path (e.g. the file name returned by caller)
  by a module name. Returns the path unchanged if it fails.
  
  Example:
  
     print AnyEvent::Debug::path2mod "/usr/lib/perl5/AnyEvent/Debug.pm";
     # might print "AnyEvent::Debug"
  
  =cut
  
  sub path2mod($) {
     keys %INC; # reset iterator
  
     while (my ($k, $v) = each %INC) {
        if ($_[0] eq $v) {
           $k =~ s%/%::%g if $k =~ s/\.pm$//;
           return $k;
        }
     }
  
     my $path = shift;
  
     $path =~ s%^\./%%;
  
     $path
  }
  
  =item AnyEvent::Debug::cb2str $cb
  
  Using various gambits, tries to convert a callback (e.g. a code reference)
  into a more useful string.
  
  Very useful if you debug a program and have some callback, but you want to
  know where in the program the callback is actually defined.
  
  =cut
  
  sub cb2str($) {
     my $cb = shift;
  
     "CODE" eq ref $cb
        or return "$cb";
  
     eval {
        my $cv = B::svref_2object ($cb);
  
        my $gv = $cv->GV
           or return "$cb";
  
        my $name = $gv->NAME;
  
        return (AnyEvent::Debug::path2mod $gv->FILE) . ":" . $gv->LINE
           if $name eq "__ANON__";
  
        $gv->STASH->NAME . "::" . $name;
     } || "$cb"
  }
  
  sub sv2str($) {
     if (ref $_[0]) {
        if (ref $_[0] eq "CODE") {
           return "$_[0]=" . cb2str $_[0];
        } else {
           return "$_[0]";
        }
     } else {
        for ("\'$_[0]\'") { # make copy
           substr $_, $Carp::MaxArgLen, length, "'..."
              if length > $Carp::MaxArgLen;
           return $_;
        }
     }
  }
  
  =item AnyEvent::Debug::backtrace [$skip]
  
  Creates a backtrace (actually an AnyEvent::Debug::Backtrace object
  that you can stringify), not unlike the Carp module would. Unlike the
  Carp module it resolves some references (such as callbacks) to more
  user-friendly strings, has a more succinct output format and most
  importantly: doesn't leak memory like hell.
  
  The reason it creates an object is to save time, as formatting can be
  done at a later time. Still, creating a backtrace is a relatively slow
  operation.
  
  =cut
  
  sub backtrace(;$) {
     my $w = shift;
  
     my (@bt, @c);
     my ($modlen, $sub);
  
     for (;;) {
        #         0          1      2            3         4           5          6            7       8         9         10
        # ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
        package DB;
        @c = caller $w++
           or last;
        package AnyEvent::Debug; # no block for speed reasons
  
        if ($c[7]) {
           $sub = "require $c[6]";
        } elsif (defined $c[6]) {
           $sub = "eval \"\"";
        } else {
           $sub = ($c[4] ? "" : "&") . $c[3];
  
           $sub .= "("
                   . (join ",",
                         map sv2str $DB::args[$_],
                            0 .. (@DB::args < $Carp::MaxArgNums ? @DB::args : $Carp::MaxArgNums) - 1)
                   . ")"
              if $c[4];
        }
  
        push @bt, [\($STRCACHE{$c[1]} ||= $c[1]), $c[2], $sub];
     }
  
     @DB::args = ();
  
     bless \@bt, "AnyEvent::Debug::Backtrace"
  }
  
  =back
  
  =cut
  
  package AnyEvent::Debug::Wrap;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Scalar::Util ();
  use Carp ();
  
  sub _reset {
     for my $name (qw(io timer signal child idle)) {
        my $super = "SUPER::$name";
  
        *$name = sub {
           my ($self, %arg) = @_;
  
           my $w;
  
           my $t = $TRACE;
  
           my ($pkg, $file, $line, $sub);
           
           $w = 0;
           do {
              ($pkg, $file, $line) = caller $w++;
           } while $pkg =~ /^(?:AE|AnyEvent::(?:Socket|Handle|Util|Debug|Strict|Base|CondVar|CondVar::Base|Impl::.*)|Coro::AnyEvent::CondVar)$/;
  
           $sub = (caller $w)[3];
  
           my $cb = $arg{cb};
           $arg{cb} = sub {
              ++$w->{called};
  
              local $TRACE_CUR = $w;
  
              $TRACE_LOGGER->("enter $w") if $TRACE_ENABLED && $t;
              eval {
                 local $SIG{__DIE__} = sub {
                    die $_[0] . AnyEvent::Debug::backtrace
                       if defined $^S;
                 };
                 &$cb;
              };
              if ($@) {
                 my $err = "$@";
                 push @{ $w->{error} }, [AE::now, $err]
                    if @{ $w->{error} } < 10;
                 AE::log die => "($w) $err"
                    or warn "($w) $err";
              }
              $TRACE_LOGGER->("leave $w") if $TRACE_ENABLED && $t;
           };
  
           $self = bless {
              type   => $name,
              w      => $self->$super (%arg),
              rfile  => \($STRCACHE{$file} ||= $file),
              line   => $line,
              sub    => $sub,
              cur    => "$TRACE_CUR",
              now    => AE::now,
              arg    => \%arg,
              cb     => $cb,
              called => 0,
              rt     => \$t,
           }, "AnyEvent::Debug::Wrapped";
  
           delete $arg{cb};
  
           $self->{bt} = AnyEvent::Debug::backtrace 1
              if $WRAP_LEVEL >= 2;
  
           Scalar::Util::weaken ($w = $self);
           Scalar::Util::weaken ($AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $self} = $self);
  
           $TRACE_LOGGER->("creat $w") if $TRACE_ENABLED && $t;
  
           $self
        };
     }
  }
  
  package AnyEvent::Debug::Wrapped;
  
  =head1 THE AnyEvent::Debug::Wrapped CLASS
  
  All watchers created while the wrap level is non-zero will be wrapped
  inside an AnyEvent::Debug::Wrapped object. The address of the
  wrapped watcher will become its ID - every watcher will be stored in
  C<$AnyEvent::Debug::Wrapped{$id}>.
  
  These wrapper objects can be stringified and have some methods defined on
  them.
  
  For debugging, of course, it can be helpful to look into these objects,
  which is why this is documented here, but this might change at any time in
  future versions.
  
  Each object is a relatively standard hash with the following members:
  
     type   => name of the method used ot create the watcher (e.g. C<io>, C<timer>).
     w      => the actual watcher
     rfile  => reference to the filename of the file the watcher was created in
     line   => line number where it was created
     sub    => function name (or a special string) which created the watcher
     cur    => if created inside another watcher callback, this is the string rep of the other watcher
     now    => the timestamp (AE::now) when the watcher was created
     arg    => the arguments used to create the watcher (sans C<cb>)
     cb     => the original callback used to create the watcher
     called => the number of times the callback was called
  
  Each object supports the following mehtods (warning: these are only
  available on wrapped watchers, so are best for interactive use via the
  debug shell).
  
  =over 4
  
  =cut
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use overload
     '""'     => sub {
        $_[0]{str} ||= do {
           my ($pkg, $line) = @{ $_[0]{caller} };
  
           my $mod = AnyEvent::Debug::path2mod ${ $_[0]{rfile} };
           my $sub = $_[0]{sub};
  
           if (defined $sub) {
              $sub =~ s/^\Q$mod\E:://;
              $sub = "($sub)";
           }
  
           "$mod:$_[0]{line}$sub>$_[0]{type}>"
           . (AnyEvent::Debug::cb2str $_[0]{cb})
        };
     },
     fallback => 1,
  ;
  
  =item $w->id
  
  Returns the numerical id of the watcher, as used in the debug shell.
  
  =cut
  
  sub id {
     Scalar::Util::refaddr shift
  }
  
  =item $w->verbose
  
  Returns a multiline textual description of the watcher, including the
  first ten exceptions caught while executing the callback.
  
  =cut
  
  sub verbose {
     my ($self) = @_;
  
     my $res = "type:    $self->{type} watcher\n"
             . "args:    " . (join " ", %{ $self->{arg} }) . "\n" # TODO: decode fh?
             . "created: " . (AnyEvent::Log::ft $self->{now}) . " ($self->{now})\n"
             . "file:    ${ $self->{rfile} }\n"
             . "line:    $self->{line}\n"
             . "subname: $self->{sub}\n"
             . "context: $self->{cur}\n"
             . "tracing: " . (${ $self->{rt} } ? "enabled" : "disabled") . "\n"
             . "cb:      $self->{cb} (" . (AnyEvent::Debug::cb2str $self->{cb}) . ")\n"
             . "invoked: $self->{called} times\n";
  
     if (exists $self->{bt}) {
        $res .= "created\n$self->{bt}";
     }
  
     if (exists $self->{error}) {
        $res .= "errors:   " . @{$self->{error}} . "\n";
  
        $res .= "error: " . (AnyEvent::Log::ft $_->[0]) . " ($_->[0]) $_->[1]\n"
           for @{$self->{error}};
     }
  
     $res
  }
  
  =item $w->trace ($on)
  
  Enables (C<$on> is true) or disables (C<$on> is false) tracing on this
  watcher.
  
  To get tracing messages, both the global logging settings must have trace
  messages enabled for the context C<AnyEvent::Debug> and tracing must be
  enabled for the wrapped watcher.
  
  To enable trace messages globally, the simplest way is to start the
  program with C<PERL_ANYEVENT_VERBOSE=9> in the environment.
  
  Tracing for each individual watcher is enabled by default (unless
  C<$AnyEvent::Debug::TRACE> has been set to false).
  
  =cut
  
  sub trace {
     ${ $_[0]{rt} } = $_[1];
  }
  
  sub DESTROY {
     $TRACE_LOGGER->("dstry $_[0]") if $TRACE_ENABLED && ${ $_[0]{rt} };
  
     delete $AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $_[0]};
  }
  
  =back
  
  =cut
  
  package AnyEvent::Debug::Backtrace;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  sub as_string {
     my ($self) = @_;
  
     my @bt;
     my $modlen;
  
     for (@$self) {
        my ($rpath, $line, $sub) = @$_;
  
        $rpath = (AnyEvent::Debug::path2mod $$rpath) . " line $line";
        $modlen = length $rpath if $modlen < length $rpath;
  
        $sub =~ s/\r/\\r/g;
        $sub =~ s/\n/\\n/g;
        $sub =~ s/([\x00-\x1f\x7e-\xff])/sprintf "\\x%02x", ord $1/ge;
        $sub =~ s/([^\x20-\x7e])/sprintf "\\x{%x}", ord $1/ge;
  
        push @bt, [$rpath, $sub];
     }
  
     join "",
        map { sprintf "%*s %s\n", -$modlen, $_->[0], $_->[1] }
           @bt
  }
  
  use overload
     '""'     => \&as_string,
     fallback => 1,
  ;
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_DEBUG

$fatpacked{"darwin-2level/AnyEvent/Handle.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_HANDLE';
  =head1 NAME
  
  AnyEvent::Handle - non-blocking I/O on streaming handles via AnyEvent
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use AnyEvent::Handle;
  
     my $cv = AnyEvent->condvar;
  
     my $hdl; $hdl = new AnyEvent::Handle
        fh => \*STDIN,
        on_error => sub {
           my ($hdl, $fatal, $msg) = @_;
           AE::log error => "got error $msg\n";
           $hdl->destroy;
           $cv->send;
        };
  
     # send some request line
     $hdl->push_write ("getinfo\015\012");
  
     # read the response line
     $hdl->push_read (line => sub {
        my ($hdl, $line) = @_;
        say "got line <$line>";
        $cv->send;
     });
  
     $cv->recv;
  
  =head1 DESCRIPTION
  
  This is a helper module to make it easier to do event-based I/O on
  stream-based filehandles (sockets, pipes, and other stream things).
  
  The L<AnyEvent::Intro> tutorial contains some well-documented
  AnyEvent::Handle examples.
  
  In the following, where the documentation refers to "bytes", it means
  characters. As sysread and syswrite are used for all I/O, their
  treatment of characters applies to this module as well.
  
  At the very minimum, you should specify C<fh> or C<connect>, and the
  C<on_error> callback.
  
  All callbacks will be invoked with the handle object as their first
  argument.
  
  =cut
  
  package AnyEvent::Handle;
  
  use Scalar::Util ();
  use List::Util ();
  use Carp ();
  use Errno qw(EAGAIN EINTR);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  
  our $VERSION = $AnyEvent::VERSION;
  
  sub _load_func($) {
     my $func = $_[0];
  
     unless (defined &$func) {
        my $pkg = $func;
        do {
           $pkg =~ s/::[^:]+$//
              or return;
           eval "require $pkg";
        } until defined &$func;
     }
  
     \&$func
  }
  
  sub MAX_READ_SIZE() { 131072 }
  
  =head1 METHODS
  
  =over 4
  
  =item $handle = B<new> AnyEvent::Handle fh => $filehandle, key => value...
  
  The constructor supports these arguments (all as C<< key => value >> pairs).
  
  =over 4
  
  =item fh => $filehandle     [C<fh> or C<connect> MANDATORY]
  
  The filehandle this L<AnyEvent::Handle> object will operate on.
  NOTE: The filehandle will be set to non-blocking mode (using
  C<AnyEvent::Util::fh_nonblocking>) by the constructor and needs to stay in
  that mode.
  
  =item connect => [$host, $service]      [C<fh> or C<connect> MANDATORY]
  
  Try to connect to the specified host and service (port), using
  C<AnyEvent::Socket::tcp_connect>. The C<$host> additionally becomes the
  default C<peername>.
  
  You have to specify either this parameter, or C<fh>, above.
  
  It is possible to push requests on the read and write queues, and modify
  properties of the stream, even while AnyEvent::Handle is connecting.
  
  When this parameter is specified, then the C<on_prepare>,
  C<on_connect_error> and C<on_connect> callbacks will be called under the
  appropriate circumstances:
  
  =over 4
  
  =item on_prepare => $cb->($handle)
  
  This (rarely used) callback is called before a new connection is
  attempted, but after the file handle has been created (you can access that
  file handle via C<< $handle->{fh} >>). It could be used to prepare the
  file handle with parameters required for the actual connect (as opposed to
  settings that can be changed when the connection is already established).
  
  The return value of this callback should be the connect timeout value in
  seconds (or C<0>, or C<undef>, or the empty list, to indicate that the
  default timeout is to be used).
  
  =item on_connect => $cb->($handle, $host, $port, $retry->())
  
  This callback is called when a connection has been successfully established.
  
  The peer's numeric host and port (the socket peername) are passed as
  parameters, together with a retry callback.
  
  If, for some reason, the handle is not acceptable, calling C<$retry>
  will continue with the next connection target (in case of multi-homed
  hosts or SRV records there can be multiple connection endpoints). At the
  time it is called the read and write queues, eof status, tls status and
  similar properties of the handle will have been reset.
  
  In most cases, you should ignore the C<$retry> parameter.
  
  =item on_connect_error => $cb->($handle, $message)
  
  This callback is called when the connection could not be
  established. C<$!> will contain the relevant error code, and C<$message> a
  message describing it (usually the same as C<"$!">).
  
  If this callback isn't specified, then C<on_error> will be called with a
  fatal error instead.
  
  =back
  
  =item on_error => $cb->($handle, $fatal, $message)
  
  This is the error callback, which is called when, well, some error
  occured, such as not being able to resolve the hostname, failure to
  connect, or a read error.
  
  Some errors are fatal (which is indicated by C<$fatal> being true). On
  fatal errors the handle object will be destroyed (by a call to C<< ->
  destroy >>) after invoking the error callback (which means you are free to
  examine the handle object). Examples of fatal errors are an EOF condition
  with active (but unsatisfiable) read watchers (C<EPIPE>) or I/O errors. In
  cases where the other side can close the connection at will, it is
  often easiest to not report C<EPIPE> errors in this callback.
  
  AnyEvent::Handle tries to find an appropriate error code for you to check
  against, but in some cases (TLS errors), this does not work well. It is
  recommended to always output the C<$message> argument in human-readable
  error messages (it's usually the same as C<"$!">).
  
  Non-fatal errors can be retried by returning, but it is recommended
  to simply ignore this parameter and instead abondon the handle object
  when this callback is invoked. Examples of non-fatal errors are timeouts
  C<ETIMEDOUT>) or badly-formatted data (C<EBADMSG>).
  
  On entry to the callback, the value of C<$!> contains the operating
  system error code (or C<ENOSPC>, C<EPIPE>, C<ETIMEDOUT>, C<EBADMSG> or
  C<EPROTO>).
  
  While not mandatory, it is I<highly> recommended to set this callback, as
  you will not be notified of errors otherwise. The default just calls
  C<croak>.
  
  =item on_read => $cb->($handle)
  
  This sets the default read callback, which is called when data arrives
  and no read request is in the queue (unlike read queue callbacks, this
  callback will only be called when at least one octet of data is in the
  read buffer).
  
  To access (and remove data from) the read buffer, use the C<< ->rbuf >>
  method or access the C<< $handle->{rbuf} >> member directly. Note that you
  must not enlarge or modify the read buffer, you can only remove data at
  the beginning from it.
  
  You can also call C<< ->push_read (...) >> or any other function that
  modifies the read queue. Or do both. Or ...
  
  When an EOF condition is detected, AnyEvent::Handle will first try to
  feed all the remaining data to the queued callbacks and C<on_read> before
  calling the C<on_eof> callback. If no progress can be made, then a fatal
  error will be raised (with C<$!> set to C<EPIPE>).
  
  Note that, unlike requests in the read queue, an C<on_read> callback
  doesn't mean you I<require> some data: if there is an EOF and there
  are outstanding read requests then an error will be flagged. With an
  C<on_read> callback, the C<on_eof> callback will be invoked.
  
  =item on_eof => $cb->($handle)
  
  Set the callback to be called when an end-of-file condition is detected,
  i.e. in the case of a socket, when the other side has closed the
  connection cleanly, and there are no outstanding read requests in the
  queue (if there are read requests, then an EOF counts as an unexpected
  connection close and will be flagged as an error).
  
  For sockets, this just means that the other side has stopped sending data,
  you can still try to write data, and, in fact, one can return from the EOF
  callback and continue writing data, as only the read part has been shut
  down.
  
  If an EOF condition has been detected but no C<on_eof> callback has been
  set, then a fatal error will be raised with C<$!> set to <0>.
  
  =item on_drain => $cb->($handle)
  
  This sets the callback that is called when the write buffer becomes empty
  (or immediately if the buffer is empty already).
  
  To append to the write buffer, use the C<< ->push_write >> method.
  
  This callback is useful when you don't want to put all of your write data
  into the queue at once, for example, when you want to write the contents
  of some file to the socket you might not want to read the whole file into
  memory and push it into the queue, but instead only read more data from
  the file when the write queue becomes empty.
  
  =item timeout => $fractional_seconds
  
  =item rtimeout => $fractional_seconds
  
  =item wtimeout => $fractional_seconds
  
  If non-zero, then these enables an "inactivity" timeout: whenever this
  many seconds pass without a successful read or write on the underlying
  file handle (or a call to C<timeout_reset>), the C<on_timeout> callback
  will be invoked (and if that one is missing, a non-fatal C<ETIMEDOUT>
  error will be raised).
  
  There are three variants of the timeouts that work independently of each
  other, for both read and write (triggered when nothing was read I<OR>
  written), just read (triggered when nothing was read), and just write:
  C<timeout>, C<rtimeout> and C<wtimeout>, with corresponding callbacks
  C<on_timeout>, C<on_rtimeout> and C<on_wtimeout>, and reset functions
  C<timeout_reset>, C<rtimeout_reset>, and C<wtimeout_reset>.
  
  Note that timeout processing is active even when you do not have any
  outstanding read or write requests: If you plan to keep the connection
  idle then you should disable the timeout temporarily or ignore the
  timeout in the corresponding C<on_timeout> callback, in which case
  AnyEvent::Handle will simply restart the timeout.
  
  Zero (the default) disables the corresponding timeout.
  
  =item on_timeout => $cb->($handle)
  
  =item on_rtimeout => $cb->($handle)
  
  =item on_wtimeout => $cb->($handle)
  
  Called whenever the inactivity timeout passes. If you return from this
  callback, then the timeout will be reset as if some activity had happened,
  so this condition is not fatal in any way.
  
  =item rbuf_max => <bytes>
  
  If defined, then a fatal error will be raised (with C<$!> set to C<ENOSPC>)
  when the read buffer ever (strictly) exceeds this size. This is useful to
  avoid some forms of denial-of-service attacks.
  
  For example, a server accepting connections from untrusted sources should
  be configured to accept only so-and-so much data that it cannot act on
  (for example, when expecting a line, an attacker could send an unlimited
  amount of data without a callback ever being called as long as the line
  isn't finished).
  
  =item wbuf_max => <bytes>
  
  If defined, then a fatal error will be raised (with C<$!> set to C<ENOSPC>)
  when the write buffer ever (strictly) exceeds this size. This is useful to
  avoid some forms of denial-of-service attacks.
  
  Although the units of this parameter is bytes, this is the I<raw> number
  of bytes not yet accepted by the kernel. This can make a difference when
  you e.g. use TLS, as TLS typically makes your write data larger (but it
  can also make it smaller due to compression).
  
  As an example of when this limit is useful, take a chat server that sends
  chat messages to a client. If the client does not read those in a timely
  manner then the send buffer in the server would grow unbounded.
  
  =item autocork => <boolean>
  
  When disabled (the default), C<push_write> will try to immediately
  write the data to the handle if possible. This avoids having to register
  a write watcher and wait for the next event loop iteration, but can
  be inefficient if you write multiple small chunks (on the wire, this
  disadvantage is usually avoided by your kernel's nagle algorithm, see
  C<no_delay>, but this option can save costly syscalls).
  
  When enabled, writes will always be queued till the next event loop
  iteration. This is efficient when you do many small writes per iteration,
  but less efficient when you do a single write only per iteration (or when
  the write buffer often is full). It also increases write latency.
  
  =item no_delay => <boolean>
  
  When doing small writes on sockets, your operating system kernel might
  wait a bit for more data before actually sending it out. This is called
  the Nagle algorithm, and usually it is beneficial.
  
  In some situations you want as low a delay as possible, which can be
  accomplishd by setting this option to a true value.
  
  The default is your operating system's default behaviour (most likely
  enabled). This option explicitly enables or disables it, if possible.
  
  =item keepalive => <boolean>
  
  Enables (default disable) the SO_KEEPALIVE option on the stream socket:
  normally, TCP connections have no time-out once established, so TCP
  connections, once established, can stay alive forever even when the other
  side has long gone. TCP keepalives are a cheap way to take down long-lived
  TCP connections when the other side becomes unreachable. While the default
  is OS-dependent, TCP keepalives usually kick in after around two hours,
  and, if the other side doesn't reply, take down the TCP connection some 10
  to 15 minutes later.
  
  It is harmless to specify this option for file handles that do not support
  keepalives, and enabling it on connections that are potentially long-lived
  is usually a good idea.
  
  =item oobinline => <boolean>
  
  BSD majorly fucked up the implementation of TCP urgent data. The result
  is that almost no OS implements TCP according to the specs, and every OS
  implements it slightly differently.
  
  If you want to handle TCP urgent data, then setting this flag (the default
  is enabled) gives you the most portable way of getting urgent data, by
  putting it into the stream.
  
  Since BSD emulation of OOB data on top of TCP's urgent data can have
  security implications, AnyEvent::Handle sets this flag automatically
  unless explicitly specified. Note that setting this flag after
  establishing a connection I<may> be a bit too late (data loss could
  already have occured on BSD systems), but at least it will protect you
  from most attacks.
  
  =item read_size => <bytes>
  
  The initial read block size, the number of bytes this module will try
  to read during each loop iteration. Each handle object will consume
  at least this amount of memory for the read buffer as well, so when
  handling many connections watch out for memory requirements). See also
  C<max_read_size>. Default: C<2048>.
  
  =item max_read_size => <bytes>
  
  The maximum read buffer size used by the dynamic adjustment
  algorithm: Each time AnyEvent::Handle can read C<read_size> bytes in
  one go it will double C<read_size> up to the maximum given by this
  option. Default: C<131072> or C<read_size>, whichever is higher.
  
  =item low_water_mark => <bytes>
  
  Sets the number of bytes (default: C<0>) that make up an "empty" write
  buffer: If the buffer reaches this size or gets even samller it is
  considered empty.
  
  Sometimes it can be beneficial (for performance reasons) to add data to
  the write buffer before it is fully drained, but this is a rare case, as
  the operating system kernel usually buffers data as well, so the default
  is good in almost all cases.
  
  =item linger => <seconds>
  
  If this is non-zero (default: C<3600>), the destructor of the
  AnyEvent::Handle object will check whether there is still outstanding
  write data and will install a watcher that will write this data to the
  socket. No errors will be reported (this mostly matches how the operating
  system treats outstanding data at socket close time).
  
  This will not work for partial TLS data that could not be encoded
  yet. This data will be lost. Calling the C<stoptls> method in time might
  help.
  
  =item peername => $string
  
  A string used to identify the remote site - usually the DNS hostname
  (I<not> IDN!) used to create the connection, rarely the IP address.
  
  Apart from being useful in error messages, this string is also used in TLS
  peername verification (see C<verify_peername> in L<AnyEvent::TLS>). This
  verification will be skipped when C<peername> is not specified or is
  C<undef>.
  
  =item tls => "accept" | "connect" | Net::SSLeay::SSL object
  
  When this parameter is given, it enables TLS (SSL) mode, that means
  AnyEvent will start a TLS handshake as soon as the connection has been
  established and will transparently encrypt/decrypt data afterwards.
  
  All TLS protocol errors will be signalled as C<EPROTO>, with an
  appropriate error message.
  
  TLS mode requires Net::SSLeay to be installed (it will be loaded
  automatically when you try to create a TLS handle): this module doesn't
  have a dependency on that module, so if your module requires it, you have
  to add the dependency yourself.
  
  Unlike TCP, TLS has a server and client side: for the TLS server side, use
  C<accept>, and for the TLS client side of a connection, use C<connect>
  mode.
  
  You can also provide your own TLS connection object, but you have
  to make sure that you call either C<Net::SSLeay::set_connect_state>
  or C<Net::SSLeay::set_accept_state> on it before you pass it to
  AnyEvent::Handle. Also, this module will take ownership of this connection
  object.
  
  At some future point, AnyEvent::Handle might switch to another TLS
  implementation, then the option to use your own session object will go
  away.
  
  B<IMPORTANT:> since Net::SSLeay "objects" are really only integers,
  passing in the wrong integer will lead to certain crash. This most often
  happens when one uses a stylish C<< tls => 1 >> and is surprised about the
  segmentation fault.
  
  Use the C<< ->starttls >> method if you need to start TLS negotiation later.
  
  =item tls_ctx => $anyevent_tls
  
  Use the given C<AnyEvent::TLS> object to create the new TLS connection
  (unless a connection object was specified directly). If this
  parameter is missing (or C<undef>), then AnyEvent::Handle will use
  C<AnyEvent::Handle::TLS_CTX>.
  
  Instead of an object, you can also specify a hash reference with C<< key
  => value >> pairs. Those will be passed to L<AnyEvent::TLS> to create a
  new TLS context object.
  
  =item on_starttls => $cb->($handle, $success[, $error_message])
  
  This callback will be invoked when the TLS/SSL handshake has finished. If
  C<$success> is true, then the TLS handshake succeeded, otherwise it failed
  (C<on_stoptls> will not be called in this case).
  
  The session in C<< $handle->{tls} >> can still be examined in this
  callback, even when the handshake was not successful.
  
  TLS handshake failures will not cause C<on_error> to be invoked when this
  callback is in effect, instead, the error message will be passed to C<on_starttls>.
  
  Without this callback, handshake failures lead to C<on_error> being
  called as usual.
  
  Note that you cannot just call C<starttls> again in this callback. If you
  need to do that, start an zero-second timer instead whose callback can
  then call C<< ->starttls >> again.
  
  =item on_stoptls => $cb->($handle)
  
  When a SSLv3/TLS shutdown/close notify/EOF is detected and this callback is
  set, then it will be invoked after freeing the TLS session. If it is not,
  then a TLS shutdown condition will be treated like a normal EOF condition
  on the handle.
  
  The session in C<< $handle->{tls} >> can still be examined in this
  callback.
  
  This callback will only be called on TLS shutdowns, not when the
  underlying handle signals EOF.
  
  =item json => JSON or JSON::XS object
  
  This is the json coder object used by the C<json> read and write types.
  
  If you don't supply it, then AnyEvent::Handle will create and use a
  suitable one (on demand), which will write and expect UTF-8 encoded JSON
  texts.
  
  Note that you are responsible to depend on the JSON module if you want to
  use this functionality, as AnyEvent does not have a dependency itself.
  
  =back
  
  =cut
  
  sub new {
     my $class = shift;
     my $self = bless { @_ }, $class;
  
     if ($self->{fh}) {
        $self->_start;
        return unless $self->{fh}; # could be gone by now
  
     } elsif ($self->{connect}) {
        require AnyEvent::Socket;
  
        $self->{peername} = $self->{connect}[0]
           unless exists $self->{peername};
  
        $self->{_skip_drain_rbuf} = 1;
  
        {
           Scalar::Util::weaken (my $self = $self);
  
           $self->{_connect} =
              AnyEvent::Socket::tcp_connect (
                 $self->{connect}[0],
                 $self->{connect}[1],
                 sub {
                    my ($fh, $host, $port, $retry) = @_;
  
                    delete $self->{_connect}; # no longer needed
  
                    if ($fh) {
                       $self->{fh} = $fh;
  
                       delete $self->{_skip_drain_rbuf};
                       $self->_start;
  
                       $self->{on_connect}
                          and $self->{on_connect}($self, $host, $port, sub {
                                 delete @$self{qw(fh _tw _rtw _wtw _ww _rw _eof _queue rbuf _wbuf tls _tls_rbuf _tls_wbuf)};
                                 $self->{_skip_drain_rbuf} = 1;
                                 &$retry;
                              });
  
                    } else {
                       if ($self->{on_connect_error}) {
                          $self->{on_connect_error}($self, "$!");
                          $self->destroy if $self;
                       } else {
                          $self->_error ($!, 1);
                       }
                    }
                 },
                 sub {
                    local $self->{fh} = $_[0];
  
                    $self->{on_prepare}
                       ? $self->{on_prepare}->($self)
                       : ()
                 }
              );
        }
  
     } else {
        Carp::croak "AnyEvent::Handle: either an existing fh or the connect parameter must be specified";
     }
  
     $self
  }
  
  sub _start {
     my ($self) = @_;
  
     # too many clueless people try to use udp and similar sockets
     # with AnyEvent::Handle, do them a favour.
     my $type = getsockopt $self->{fh}, Socket::SOL_SOCKET (), Socket::SO_TYPE ();
     Carp::croak "AnyEvent::Handle: only stream sockets supported, anything else will NOT work!"
        if Socket::SOCK_STREAM () != (unpack "I", $type) && defined $type;
  
     AnyEvent::Util::fh_nonblocking $self->{fh}, 1;
  
     $self->{_activity}  =
     $self->{_ractivity} =
     $self->{_wactivity} = AE::now;
  
     $self->{read_size} ||= 2048;
     $self->{max_read_size} = $self->{read_size}
        if $self->{read_size} > ($self->{max_read_size} || MAX_READ_SIZE);
  
     $self->timeout   (delete $self->{timeout}  ) if $self->{timeout};
     $self->rtimeout  (delete $self->{rtimeout} ) if $self->{rtimeout};
     $self->wtimeout  (delete $self->{wtimeout} ) if $self->{wtimeout};
  
     $self->no_delay  (delete $self->{no_delay} ) if exists $self->{no_delay}  && $self->{no_delay};
     $self->keepalive (delete $self->{keepalive}) if exists $self->{keepalive} && $self->{keepalive};
  
     $self->oobinline (exists $self->{oobinline} ? delete $self->{oobinline} : 1);
  
     $self->starttls  (delete $self->{tls}, delete $self->{tls_ctx})
        if $self->{tls};
  
     $self->on_drain  (delete $self->{on_drain} ) if $self->{on_drain};
  
     $self->start_read
        if $self->{on_read} || @{ $self->{_queue} };
  
     $self->_drain_wbuf;
  }
  
  sub _error {
     my ($self, $errno, $fatal, $message) = @_;
  
     $! = $errno;
     $message ||= "$!";
  
     if ($self->{on_error}) {
        $self->{on_error}($self, $fatal, $message);
        $self->destroy if $fatal;
     } elsif ($self->{fh} || $self->{connect}) {
        $self->destroy;
        Carp::croak "AnyEvent::Handle uncaught error: $message";
     }
  }
  
  =item $fh = $handle->fh
  
  This method returns the file handle used to create the L<AnyEvent::Handle> object.
  
  =cut
  
  sub fh { $_[0]{fh} }
  
  =item $handle->on_error ($cb)
  
  Replace the current C<on_error> callback (see the C<on_error> constructor argument).
  
  =cut
  
  sub on_error {
     $_[0]{on_error} = $_[1];
  }
  
  =item $handle->on_eof ($cb)
  
  Replace the current C<on_eof> callback (see the C<on_eof> constructor argument).
  
  =cut
  
  sub on_eof {
     $_[0]{on_eof} = $_[1];
  }
  
  =item $handle->on_timeout ($cb)
  
  =item $handle->on_rtimeout ($cb)
  
  =item $handle->on_wtimeout ($cb)
  
  Replace the current C<on_timeout>, C<on_rtimeout> or C<on_wtimeout>
  callback, or disables the callback (but not the timeout) if C<$cb> =
  C<undef>. See the C<timeout> constructor argument and method.
  
  =cut
  
  # see below
  
  =item $handle->autocork ($boolean)
  
  Enables or disables the current autocork behaviour (see C<autocork>
  constructor argument). Changes will only take effect on the next write.
  
  =cut
  
  sub autocork {
     $_[0]{autocork} = $_[1];
  }
  
  =item $handle->no_delay ($boolean)
  
  Enables or disables the C<no_delay> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub no_delay {
     $_[0]{no_delay} = $_[1];
  
     setsockopt $_[0]{fh}, Socket::IPPROTO_TCP (), Socket::TCP_NODELAY (), int $_[1]
        if $_[0]{fh};
  }
  
  =item $handle->keepalive ($boolean)
  
  Enables or disables the C<keepalive> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub keepalive {
     $_[0]{keepalive} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_KEEPALIVE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->oobinline ($boolean)
  
  Enables or disables the C<oobinline> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub oobinline {
     $_[0]{oobinline} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_OOBINLINE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->keepalive ($boolean)
  
  Enables or disables the C<keepalive> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub keepalive {
     $_[0]{keepalive} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_KEEPALIVE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->on_starttls ($cb)
  
  Replace the current C<on_starttls> callback (see the C<on_starttls> constructor argument).
  
  =cut
  
  sub on_starttls {
     $_[0]{on_starttls} = $_[1];
  }
  
  =item $handle->on_stoptls ($cb)
  
  Replace the current C<on_stoptls> callback (see the C<on_stoptls> constructor argument).
  
  =cut
  
  sub on_stoptls {
     $_[0]{on_stoptls} = $_[1];
  }
  
  =item $handle->rbuf_max ($max_octets)
  
  Configures the C<rbuf_max> setting (C<undef> disables it).
  
  =item $handle->wbuf_max ($max_octets)
  
  Configures the C<wbuf_max> setting (C<undef> disables it).
  
  =cut
  
  sub rbuf_max {
     $_[0]{rbuf_max} = $_[1];
  }
  
  sub wbuf_max {
     $_[0]{wbuf_max} = $_[1];
  }
  
  #############################################################################
  
  =item $handle->timeout ($seconds)
  
  =item $handle->rtimeout ($seconds)
  
  =item $handle->wtimeout ($seconds)
  
  Configures (or disables) the inactivity timeout.
  
  The timeout will be checked instantly, so this method might destroy the
  handle before it returns.
  
  =item $handle->timeout_reset
  
  =item $handle->rtimeout_reset
  
  =item $handle->wtimeout_reset
  
  Reset the activity timeout, as if data was received or sent.
  
  These methods are cheap to call.
  
  =cut
  
  for my $dir ("", "r", "w") {
     my $timeout    = "${dir}timeout";
     my $tw         = "_${dir}tw";
     my $on_timeout = "on_${dir}timeout";
     my $activity   = "_${dir}activity";
     my $cb;
  
     *$on_timeout = sub {
        $_[0]{$on_timeout} = $_[1];
     };
  
     *$timeout = sub {
        my ($self, $new_value) = @_;
  
        $new_value >= 0
           or Carp::croak "AnyEvent::Handle->$timeout called with negative timeout ($new_value), caught";
  
        $self->{$timeout} = $new_value;
        delete $self->{$tw}; &$cb;
     };
  
     *{"${dir}timeout_reset"} = sub {
        $_[0]{$activity} = AE::now;
     };
  
     # main workhorse:
     # reset the timeout watcher, as neccessary
     # also check for time-outs
     $cb = sub {
        my ($self) = @_;
  
        if ($self->{$timeout} && $self->{fh}) {
           my $NOW = AE::now;
  
           # when would the timeout trigger?
           my $after = $self->{$activity} + $self->{$timeout} - $NOW;
  
           # now or in the past already?
           if ($after <= 0) {
              $self->{$activity} = $NOW;
  
              if ($self->{$on_timeout}) {
                 $self->{$on_timeout}($self);
              } else {
                 $self->_error (Errno::ETIMEDOUT);
              }
  
              # callback could have changed timeout value, optimise
              return unless $self->{$timeout};
  
              # calculate new after
              $after = $self->{$timeout};
           }
  
           Scalar::Util::weaken $self;
           return unless $self; # ->error could have destroyed $self
  
           $self->{$tw} ||= AE::timer $after, 0, sub {
              delete $self->{$tw};
              $cb->($self);
           };
        } else {
           delete $self->{$tw};
        }
     }
  }
  
  #############################################################################
  
  =back
  
  =head2 WRITE QUEUE
  
  AnyEvent::Handle manages two queues per handle, one for writing and one
  for reading.
  
  The write queue is very simple: you can add data to its end, and
  AnyEvent::Handle will automatically try to get rid of it for you.
  
  When data could be written and the write buffer is shorter then the low
  water mark, the C<on_drain> callback will be invoked.
  
  =over 4
  
  =item $handle->on_drain ($cb)
  
  Sets the C<on_drain> callback or clears it (see the description of
  C<on_drain> in the constructor).
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub on_drain {
     my ($self, $cb) = @_;
  
     $self->{on_drain} = $cb;
  
     $cb->($self)
        if $cb && $self->{low_water_mark} >= (length $self->{wbuf}) + (length $self->{_tls_wbuf});
  }
  
  =item $handle->push_write ($data)
  
  Queues the given scalar to be written. You can push as much data as
  you want (only limited by the available memory and C<wbuf_max>), as
  C<AnyEvent::Handle> buffers it independently of the kernel.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub _drain_wbuf {
     my ($self) = @_;
  
     if (!$self->{_ww} && length $self->{wbuf}) {
  
        Scalar::Util::weaken $self;
  
        my $cb = sub {
           my $len = syswrite $self->{fh}, $self->{wbuf};
  
           if (defined $len) {
              substr $self->{wbuf}, 0, $len, "";
  
              $self->{_activity} = $self->{_wactivity} = AE::now;
  
              $self->{on_drain}($self)
                 if $self->{low_water_mark} >= (length $self->{wbuf}) + (length $self->{_tls_wbuf})
                    && $self->{on_drain};
  
              delete $self->{_ww} unless length $self->{wbuf};
           } elsif ($! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              $self->_error ($!, 1);
           }
        };
  
        # try to write data immediately
        $cb->() unless $self->{autocork};
  
        # if still data left in wbuf, we need to poll
        $self->{_ww} = AE::io $self->{fh}, 1, $cb
           if length $self->{wbuf};
  
        if (
           defined $self->{wbuf_max}
           && $self->{wbuf_max} < length $self->{wbuf}
        ) {
           $self->_error (Errno::ENOSPC, 1), return;
        }
     };
  }
  
  our %WH;
  
  # deprecated
  sub register_write_type($$) {
     $WH{$_[0]} = $_[1];
  }
  
  sub push_write {
     my $self = shift;
  
     if (@_ > 1) {
        my $type = shift;
  
        @_ = ($WH{$type} ||= _load_func "$type\::anyevent_write_type"
              or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_write")
             ->($self, @_);
     }
  
     # we downgrade here to avoid hard-to-track-down bugs,
     # and diagnose the problem earlier and better.
  
     if ($self->{tls}) {
        utf8::downgrade $self->{_tls_wbuf} .= $_[0];
        &_dotls ($self)    if $self->{fh};
     } else {
        utf8::downgrade $self->{wbuf}      .= $_[0];
        $self->_drain_wbuf if $self->{fh};
     }
  }
  
  =item $handle->push_write (type => @args)
  
  Instead of formatting your data yourself, you can also let this module
  do the job by specifying a type and type-specific arguments. You
  can also specify the (fully qualified) name of a package, in which
  case AnyEvent tries to load the package and then expects to find the
  C<anyevent_write_type> function inside (see "custom write types", below).
  
  Predefined types are (if you have ideas for additional types, feel free to
  drop by and tell us):
  
  =over 4
  
  =item netstring => $string
  
  Formats the given value as netstring
  (http://cr.yp.to/proto/netstrings.txt, this is not a recommendation to use them).
  
  =cut
  
  register_write_type netstring => sub {
     my ($self, $string) = @_;
  
     (length $string) . ":$string,"
  };
  
  =item packstring => $format, $data
  
  An octet string prefixed with an encoded length. The encoding C<$format>
  uses the same format as a Perl C<pack> format, but must specify a single
  integer only (only one of C<cCsSlLqQiInNvVjJw> is allowed, plus an
  optional C<!>, C<< < >> or C<< > >> modifier).
  
  =cut
  
  register_write_type packstring => sub {
     my ($self, $format, $string) = @_;
  
     pack "$format/a*", $string
  };
  
  =item json => $array_or_hashref
  
  Encodes the given hash or array reference into a JSON object. Unless you
  provide your own JSON object, this means it will be encoded to JSON text
  in UTF-8.
  
  JSON objects (and arrays) are self-delimiting, so you can write JSON at
  one end of a handle and read them at the other end without using any
  additional framing.
  
  The generated JSON text is guaranteed not to contain any newlines: While
  this module doesn't need delimiters after or between JSON texts to be
  able to read them, many other languages depend on that.
  
  A simple RPC protocol that interoperates easily with others is to send
  JSON arrays (or objects, although arrays are usually the better choice as
  they mimic how function argument passing works) and a newline after each
  JSON text:
  
     $handle->push_write (json => ["method", "arg1", "arg2"]); # whatever
     $handle->push_write ("\012");
   
  An AnyEvent::Handle receiver would simply use the C<json> read type and
  rely on the fact that the newline will be skipped as leading whitespace:
  
     $handle->push_read (json => sub { my $array = $_[1]; ... });
  
  Other languages could read single lines terminated by a newline and pass
  this line into their JSON decoder of choice.
  
  =cut
  
  sub json_coder() {
     eval { require JSON::XS; JSON::XS->new->utf8 }
        || do { require JSON; JSON->new->utf8 }
  }
  
  register_write_type json => sub {
     my ($self, $ref) = @_;
  
     my $json = $self->{json} ||= json_coder;
  
     $json->encode ($ref)
  };
  
  =item storable => $reference
  
  Freezes the given reference using L<Storable> and writes it to the
  handle. Uses the C<nfreeze> format.
  
  =cut
  
  register_write_type storable => sub {
     my ($self, $ref) = @_;
  
     require Storable unless $Storable::VERSION;
  
     pack "w/a*", Storable::nfreeze ($ref)
  };
  
  =back
  
  =item $handle->push_shutdown
  
  Sometimes you know you want to close the socket after writing your data
  before it was actually written. One way to do that is to replace your
  C<on_drain> handler by a callback that shuts down the socket (and set
  C<low_water_mark> to C<0>). This method is a shorthand for just that, and
  replaces the C<on_drain> callback with:
  
     sub { shutdown $_[0]{fh}, 1 }
  
  This simply shuts down the write side and signals an EOF condition to the
  the peer.
  
  You can rely on the normal read queue and C<on_eof> handling
  afterwards. This is the cleanest way to close a connection.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub push_shutdown {
     my ($self) = @_;
  
     delete $self->{low_water_mark};
     $self->on_drain (sub { shutdown $_[0]{fh}, 1 });
  }
  
  =item custom write types - Package::anyevent_write_type $handle, @args
  
  Instead of one of the predefined types, you can also specify the name of
  a package. AnyEvent will try to load the package and then expects to find
  a function named C<anyevent_write_type> inside. If it isn't found, it
  progressively tries to load the parent package until it either finds the
  function (good) or runs out of packages (bad).
  
  Whenever the given C<type> is used, C<push_write> will the function with
  the handle object and the remaining arguments.
  
  The function is supposed to return a single octet string that will be
  appended to the write buffer, so you can mentally treat this function as a
  "arguments to on-the-wire-format" converter.
  
  Example: implement a custom write type C<join> that joins the remaining
  arguments using the first one.
  
     $handle->push_write (My::Type => " ", 1,2,3);
  
     # uses the following package, which can be defined in the "My::Type" or in
     # the "My" modules to be auto-loaded, or just about anywhere when the
     # My::Type::anyevent_write_type is defined before invoking it.
  
     package My::Type;
  
     sub anyevent_write_type {
        my ($handle, $delim, @args) = @_;
  
        join $delim, @args
     }
  
  =cut
  
  #############################################################################
  
  =back
  
  =head2 READ QUEUE
  
  AnyEvent::Handle manages two queues per handle, one for writing and one
  for reading.
  
  The read queue is more complex than the write queue. It can be used in two
  ways, the "simple" way, using only C<on_read> and the "complex" way, using
  a queue.
  
  In the simple case, you just install an C<on_read> callback and whenever
  new data arrives, it will be called. You can then remove some data (if
  enough is there) from the read buffer (C<< $handle->rbuf >>). Or you can
  leave the data there if you want to accumulate more (e.g. when only a
  partial message has been received so far), or change the read queue with
  e.g. C<push_read>.
  
  In the more complex case, you want to queue multiple callbacks. In this
  case, AnyEvent::Handle will call the first queued callback each time new
  data arrives (also the first time it is queued) and remove it when it has
  done its job (see C<push_read>, below).
  
  This way you can, for example, push three line-reads, followed by reading
  a chunk of data, and AnyEvent::Handle will execute them in order.
  
  Example 1: EPP protocol parser. EPP sends 4 byte length info, followed by
  the specified number of bytes which give an XML datagram.
  
     # in the default state, expect some header bytes
     $handle->on_read (sub {
        # some data is here, now queue the length-header-read (4 octets)
        shift->unshift_read (chunk => 4, sub {
           # header arrived, decode
           my $len = unpack "N", $_[1];
  
           # now read the payload
           shift->unshift_read (chunk => $len, sub {
              my $xml = $_[1];
              # handle xml
           });
        });
     });
  
  Example 2: Implement a client for a protocol that replies either with "OK"
  and another line or "ERROR" for the first request that is sent, and 64
  bytes for the second request. Due to the availability of a queue, we can
  just pipeline sending both requests and manipulate the queue as necessary
  in the callbacks.
  
  When the first callback is called and sees an "OK" response, it will
  C<unshift> another line-read. This line-read will be queued I<before> the
  64-byte chunk callback.
  
     # request one, returns either "OK + extra line" or "ERROR"
     $handle->push_write ("request 1\015\012");
  
     # we expect "ERROR" or "OK" as response, so push a line read
     $handle->push_read (line => sub {
        # if we got an "OK", we have to _prepend_ another line,
        # so it will be read before the second request reads its 64 bytes
        # which are already in the queue when this callback is called
        # we don't do this in case we got an error
        if ($_[1] eq "OK") {
           $_[0]->unshift_read (line => sub {
              my $response = $_[1];
              ...
           });
        }
     });
  
     # request two, simply returns 64 octets
     $handle->push_write ("request 2\015\012");
  
     # simply read 64 bytes, always
     $handle->push_read (chunk => 64, sub {
        my $response = $_[1];
        ...
     });
  
  =over 4
  
  =cut
  
  sub _drain_rbuf {
     my ($self) = @_;
  
     # avoid recursion
     return if $self->{_skip_drain_rbuf};
     local $self->{_skip_drain_rbuf} = 1;
  
     while () {
        # we need to use a separate tls read buffer, as we must not receive data while
        # we are draining the buffer, and this can only happen with TLS.
        $self->{rbuf} .= delete $self->{_tls_rbuf}
           if exists $self->{_tls_rbuf};
  
        my $len = length $self->{rbuf};
  
        if (my $cb = shift @{ $self->{_queue} }) {
           unless ($cb->($self)) {
              # no progress can be made
              # (not enough data and no data forthcoming)
              $self->_error (Errno::EPIPE, 1), return
                 if $self->{_eof};
  
              unshift @{ $self->{_queue} }, $cb;
              last;
           }
        } elsif ($self->{on_read}) {
           last unless $len;
  
           $self->{on_read}($self);
  
           if (
              $len == length $self->{rbuf} # if no data has been consumed
              && !@{ $self->{_queue} }     # and the queue is still empty
              && $self->{on_read}          # but we still have on_read
           ) {
              # no further data will arrive
              # so no progress can be made
              $self->_error (Errno::EPIPE, 1), return
                 if $self->{_eof};
  
              last; # more data might arrive
           }
        } else {
           # read side becomes idle
           delete $self->{_rw} unless $self->{tls};
           last;
        }
     }
  
     if ($self->{_eof}) {
        $self->{on_eof}
           ? $self->{on_eof}($self)
           : $self->_error (0, 1, "Unexpected end-of-file");
  
        return;
     }
  
     if (
        defined $self->{rbuf_max}
        && $self->{rbuf_max} < length $self->{rbuf}
     ) {
        $self->_error (Errno::ENOSPC, 1), return;
     }
  
     # may need to restart read watcher
     unless ($self->{_rw}) {
        $self->start_read
           if $self->{on_read} || @{ $self->{_queue} };
     }
  }
  
  =item $handle->on_read ($cb)
  
  This replaces the currently set C<on_read> callback, or clears it (when
  the new callback is C<undef>). See the description of C<on_read> in the
  constructor.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub on_read {
     my ($self, $cb) = @_;
  
     $self->{on_read} = $cb;
     $self->_drain_rbuf if $cb;
  }
  
  =item $handle->rbuf
  
  Returns the read buffer (as a modifiable lvalue). You can also access the
  read buffer directly as the C<< ->{rbuf} >> member, if you want (this is
  much faster, and no less clean).
  
  The only operation allowed on the read buffer (apart from looking at it)
  is removing data from its beginning. Otherwise modifying or appending to
  it is not allowed and will lead to hard-to-track-down bugs.
  
  NOTE: The read buffer should only be used or modified in the C<on_read>
  callback or when C<push_read> or C<unshift_read> are used with a single
  callback (i.e. untyped). Typed C<push_read> and C<unshift_read> methods
  will manage the read buffer on their own.
  
  =cut
  
  sub rbuf : lvalue {
     $_[0]{rbuf}
  }
  
  =item $handle->push_read ($cb)
  
  =item $handle->unshift_read ($cb)
  
  Append the given callback to the end of the queue (C<push_read>) or
  prepend it (C<unshift_read>).
  
  The callback is called each time some additional read data arrives.
  
  It must check whether enough data is in the read buffer already.
  
  If not enough data is available, it must return the empty list or a false
  value, in which case it will be called repeatedly until enough data is
  available (or an error condition is detected).
  
  If enough data was available, then the callback must remove all data it is
  interested in (which can be none at all) and return a true value. After returning
  true, it will be removed from the queue.
  
  These methods may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  our %RH;
  
  sub register_read_type($$) {
     $RH{$_[0]} = $_[1];
  }
  
  sub push_read {
     my $self = shift;
     my $cb = pop;
  
     if (@_) {
        my $type = shift;
  
        $cb = ($RH{$type} ||= _load_func "$type\::anyevent_read_type"
               or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_read")
              ->($self, $cb, @_);
     }
  
     push @{ $self->{_queue} }, $cb;
     $self->_drain_rbuf;
  }
  
  sub unshift_read {
     my $self = shift;
     my $cb = pop;
  
     if (@_) {
        my $type = shift;
  
        $cb = ($RH{$type} ||= _load_func "$type\::anyevent_read_type"
               or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::unshift_read")
              ->($self, $cb, @_);
     }
  
     unshift @{ $self->{_queue} }, $cb;
     $self->_drain_rbuf;
  }
  
  =item $handle->push_read (type => @args, $cb)
  
  =item $handle->unshift_read (type => @args, $cb)
  
  Instead of providing a callback that parses the data itself you can chose
  between a number of predefined parsing formats, for chunks of data, lines
  etc. You can also specify the (fully qualified) name of a package, in
  which case AnyEvent tries to load the package and then expects to find the
  C<anyevent_read_type> function inside (see "custom read types", below).
  
  Predefined types are (if you have ideas for additional types, feel free to
  drop by and tell us):
  
  =over 4
  
  =item chunk => $octets, $cb->($handle, $data)
  
  Invoke the callback only once C<$octets> bytes have been read. Pass the
  data read to the callback. The callback will never be called with less
  data.
  
  Example: read 2 bytes.
  
     $handle->push_read (chunk => 2, sub {
        say "yay " . unpack "H*", $_[1];
     });
  
  =cut
  
  register_read_type chunk => sub {
     my ($self, $cb, $len) = @_;
  
     sub {
        $len <= length $_[0]{rbuf} or return;
        $cb->($_[0], substr $_[0]{rbuf}, 0, $len, "");
        1
     }
  };
  
  =item line => [$eol, ]$cb->($handle, $line, $eol)
  
  The callback will be called only once a full line (including the end of
  line marker, C<$eol>) has been read. This line (excluding the end of line
  marker) will be passed to the callback as second argument (C<$line>), and
  the end of line marker as the third argument (C<$eol>).
  
  The end of line marker, C<$eol>, can be either a string, in which case it
  will be interpreted as a fixed record end marker, or it can be a regex
  object (e.g. created by C<qr>), in which case it is interpreted as a
  regular expression.
  
  The end of line marker argument C<$eol> is optional, if it is missing (NOT
  undef), then C<qr|\015?\012|> is used (which is good for most internet
  protocols).
  
  Partial lines at the end of the stream will never be returned, as they are
  not marked by the end of line marker.
  
  =cut
  
  register_read_type line => sub {
     my ($self, $cb, $eol) = @_;
  
     if (@_ < 3) {
        # this is more than twice as fast as the generic code below
        sub {
           $_[0]{rbuf} =~ s/^([^\015\012]*)(\015?\012)// or return;
  
           $cb->($_[0], "$1", "$2");
           1
        }
     } else {
        $eol = quotemeta $eol unless ref $eol;
        $eol = qr|^(.*?)($eol)|s;
  
        sub {
           $_[0]{rbuf} =~ s/$eol// or return;
  
           $cb->($_[0], "$1", "$2");
           1
        }
     }
  };
  
  =item regex => $accept[, $reject[, $skip], $cb->($handle, $data)
  
  Makes a regex match against the regex object C<$accept> and returns
  everything up to and including the match.
  
  Example: read a single line terminated by '\n'.
  
     $handle->push_read (regex => qr<\n>, sub { ... });
  
  If C<$reject> is given and not undef, then it determines when the data is
  to be rejected: it is matched against the data when the C<$accept> regex
  does not match and generates an C<EBADMSG> error when it matches. This is
  useful to quickly reject wrong data (to avoid waiting for a timeout or a
  receive buffer overflow).
  
  Example: expect a single decimal number followed by whitespace, reject
  anything else (not the use of an anchor).
  
     $handle->push_read (regex => qr<^[0-9]+\s>, qr<[^0-9]>, sub { ... });
  
  If C<$skip> is given and not C<undef>, then it will be matched against
  the receive buffer when neither C<$accept> nor C<$reject> match,
  and everything preceding and including the match will be accepted
  unconditionally. This is useful to skip large amounts of data that you
  know cannot be matched, so that the C<$accept> or C<$reject> regex do not
  have to start matching from the beginning. This is purely an optimisation
  and is usually worth it only when you expect more than a few kilobytes.
  
  Example: expect a http header, which ends at C<\015\012\015\012>. Since we
  expect the header to be very large (it isn't in practice, but...), we use
  a skip regex to skip initial portions. The skip regex is tricky in that
  it only accepts something not ending in either \015 or \012, as these are
  required for the accept regex.
  
     $handle->push_read (regex =>
        qr<\015\012\015\012>,
        undef, # no reject
        qr<^.*[^\015\012]>,
        sub { ... });
  
  =cut
  
  register_read_type regex => sub {
     my ($self, $cb, $accept, $reject, $skip) = @_;
  
     my $data;
     my $rbuf = \$self->{rbuf};
  
     sub {
        # accept
        if ($$rbuf =~ $accept) {
           $data .= substr $$rbuf, 0, $+[0], "";
           $cb->($_[0], $data);
           return 1;
        }
        
        # reject
        if ($reject && $$rbuf =~ $reject) {
           $_[0]->_error (Errno::EBADMSG);
        }
  
        # skip
        if ($skip && $$rbuf =~ $skip) {
           $data .= substr $$rbuf, 0, $+[0], "";
        }
  
        ()
     }
  };
  
  =item netstring => $cb->($handle, $string)
  
  A netstring (http://cr.yp.to/proto/netstrings.txt, this is not an endorsement).
  
  Throws an error with C<$!> set to EBADMSG on format violations.
  
  =cut
  
  register_read_type netstring => sub {
     my ($self, $cb) = @_;
  
     sub {
        unless ($_[0]{rbuf} =~ s/^(0|[1-9][0-9]*)://) {
           if ($_[0]{rbuf} =~ /[^0-9]/) {
              $_[0]->_error (Errno::EBADMSG);
           }
           return;
        }
  
        my $len = $1;
  
        $_[0]->unshift_read (chunk => $len, sub {
           my $string = $_[1];
           $_[0]->unshift_read (chunk => 1, sub {
              if ($_[1] eq ",") {
                 $cb->($_[0], $string);
              } else {
                 $_[0]->_error (Errno::EBADMSG);
              }
           });
        });
  
        1
     }
  };
  
  =item packstring => $format, $cb->($handle, $string)
  
  An octet string prefixed with an encoded length. The encoding C<$format>
  uses the same format as a Perl C<pack> format, but must specify a single
  integer only (only one of C<cCsSlLqQiInNvVjJw> is allowed, plus an
  optional C<!>, C<< < >> or C<< > >> modifier).
  
  For example, DNS over TCP uses a prefix of C<n> (2 octet network order),
  EPP uses a prefix of C<N> (4 octtes).
  
  Example: read a block of data prefixed by its length in BER-encoded
  format (very efficient).
  
     $handle->push_read (packstring => "w", sub {
        my ($handle, $data) = @_;
     });
  
  =cut
  
  register_read_type packstring => sub {
     my ($self, $cb, $format) = @_;
  
     sub {
        # when we can use 5.10 we can use ".", but for 5.8 we use the re-pack method
        defined (my $len = eval { unpack $format, $_[0]{rbuf} })
           or return;
  
        $format = length pack $format, $len;
  
        # bypass unshift if we already have the remaining chunk
        if ($format + $len <= length $_[0]{rbuf}) {
           my $data = substr $_[0]{rbuf}, $format, $len;
           substr $_[0]{rbuf}, 0, $format + $len, "";
           $cb->($_[0], $data);
        } else {
           # remove prefix
           substr $_[0]{rbuf}, 0, $format, "";
  
           # read remaining chunk
           $_[0]->unshift_read (chunk => $len, $cb);
        }
  
        1
     }
  };
  
  =item json => $cb->($handle, $hash_or_arrayref)
  
  Reads a JSON object or array, decodes it and passes it to the
  callback. When a parse error occurs, an C<EBADMSG> error will be raised.
  
  If a C<json> object was passed to the constructor, then that will be used
  for the final decode, otherwise it will create a JSON coder expecting UTF-8.
  
  This read type uses the incremental parser available with JSON version
  2.09 (and JSON::XS version 2.2) and above. You have to provide a
  dependency on your own: this module will load the JSON module, but
  AnyEvent does not depend on it itself.
  
  Since JSON texts are fully self-delimiting, the C<json> read and write
  types are an ideal simple RPC protocol: just exchange JSON datagrams. See
  the C<json> write type description, above, for an actual example.
  
  =cut
  
  register_read_type json => sub {
     my ($self, $cb) = @_;
  
     my $json = $self->{json} ||= json_coder;
  
     my $data;
     my $rbuf = \$self->{rbuf};
  
     sub {
        my $ref = eval { $json->incr_parse ($_[0]{rbuf}) };
  
        if ($ref) {
           $_[0]{rbuf} = $json->incr_text;
           $json->incr_text = "";
           $cb->($_[0], $ref);
  
           1
        } elsif ($@) {
           # error case
           $json->incr_skip;
  
           $_[0]{rbuf} = $json->incr_text;
           $json->incr_text = "";
  
           $_[0]->_error (Errno::EBADMSG);
  
           ()
        } else {
           $_[0]{rbuf} = "";
  
           ()
        }
     }
  };
  
  =item storable => $cb->($handle, $ref)
  
  Deserialises a L<Storable> frozen representation as written by the
  C<storable> write type (BER-encoded length prefix followed by nfreeze'd
  data).
  
  Raises C<EBADMSG> error if the data could not be decoded.
  
  =cut
  
  register_read_type storable => sub {
     my ($self, $cb) = @_;
  
     require Storable unless $Storable::VERSION;
  
     sub {
        # when we can use 5.10 we can use ".", but for 5.8 we use the re-pack method
        defined (my $len = eval { unpack "w", $_[0]{rbuf} })
           or return;
  
        my $format = length pack "w", $len;
  
        # bypass unshift if we already have the remaining chunk
        if ($format + $len <= length $_[0]{rbuf}) {
           my $data = substr $_[0]{rbuf}, $format, $len;
           substr $_[0]{rbuf}, 0, $format + $len, "";
           $cb->($_[0], Storable::thaw ($data));
        } else {
           # remove prefix
           substr $_[0]{rbuf}, 0, $format, "";
  
           # read remaining chunk
           $_[0]->unshift_read (chunk => $len, sub {
              if (my $ref = eval { Storable::thaw ($_[1]) }) {
                 $cb->($_[0], $ref);
              } else {
                 $_[0]->_error (Errno::EBADMSG);
              }
           });
        }
  
        1
     }
  };
  
  =back
  
  =item custom read types - Package::anyevent_read_type $handle, $cb, @args
  
  Instead of one of the predefined types, you can also specify the name
  of a package. AnyEvent will try to load the package and then expects to
  find a function named C<anyevent_read_type> inside. If it isn't found, it
  progressively tries to load the parent package until it either finds the
  function (good) or runs out of packages (bad).
  
  Whenever this type is used, C<push_read> will invoke the function with the
  handle object, the original callback and the remaining arguments.
  
  The function is supposed to return a callback (usually a closure) that
  works as a plain read callback (see C<< ->push_read ($cb) >>), so you can
  mentally treat the function as a "configurable read type to read callback"
  converter.
  
  It should invoke the original callback when it is done reading (remember
  to pass C<$handle> as first argument as all other callbacks do that,
  although there is no strict requirement on this).
  
  For examples, see the source of this module (F<perldoc -m
  AnyEvent::Handle>, search for C<register_read_type>)).
  
  =item $handle->stop_read
  
  =item $handle->start_read
  
  In rare cases you actually do not want to read anything from the
  socket. In this case you can call C<stop_read>. Neither C<on_read> nor
  any queued callbacks will be executed then. To start reading again, call
  C<start_read>.
  
  Note that AnyEvent::Handle will automatically C<start_read> for you when
  you change the C<on_read> callback or push/unshift a read callback, and it
  will automatically C<stop_read> for you when neither C<on_read> is set nor
  there are any read requests in the queue.
  
  In older versions of this module (<= 5.3), these methods had no effect,
  as TLS does not support half-duplex connections. In current versions they
  work as expected, as this behaviour is required to avoid certain resource
  attacks, where the program would be forced to read (and buffer) arbitrary
  amounts of data before being able to send some data. The drawback is that
  some readings of the the SSL/TLS specifications basically require this
  attack to be working, as SSL/TLS implementations might stall sending data
  during a rehandshake.
  
  As a guideline, during the initial handshake, you should not stop reading,
  and as a client, it might cause problems, depending on your application.
  
  =cut
  
  sub stop_read {
     my ($self) = @_;
  
     delete $self->{_rw};
  }
  
  sub start_read {
     my ($self) = @_;
  
     unless ($self->{_rw} || $self->{_eof} || !$self->{fh}) {
        Scalar::Util::weaken $self;
  
        $self->{_rw} = AE::io $self->{fh}, 0, sub {
           my $rbuf = \($self->{tls} ? my $buf : $self->{rbuf});
           my $len = sysread $self->{fh}, $$rbuf, $self->{read_size}, length $$rbuf;
  
           if ($len > 0) {
              $self->{_activity} = $self->{_ractivity} = AE::now;
  
              if ($self->{tls}) {
                 Net::SSLeay::BIO_write ($self->{_rbio}, $$rbuf);
  
                 &_dotls ($self);
              } else {
                 $self->_drain_rbuf;
              }
  
              if ($len == $self->{read_size}) {
                 $self->{read_size} *= 2;
                 $self->{read_size} = $self->{max_read_size} || MAX_READ_SIZE
                    if $self->{read_size} > ($self->{max_read_size} || MAX_READ_SIZE);
              }
  
           } elsif (defined $len) {
              delete $self->{_rw};
              $self->{_eof} = 1;
              $self->_drain_rbuf;
  
           } elsif ($! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              return $self->_error ($!, 1);
           }
        };
     }
  }
  
  our $ERROR_SYSCALL;
  our $ERROR_WANT_READ;
  
  sub _tls_error {
     my ($self, $err) = @_;
  
     return $self->_error ($!, 1)
        if $err == Net::SSLeay::ERROR_SYSCALL ();
  
     my $err =Net::SSLeay::ERR_error_string (Net::SSLeay::ERR_get_error ());
  
     # reduce error string to look less scary
     $err =~ s/^error:[0-9a-fA-F]{8}:[^:]+:([^:]+):/\L$1: /;
  
     if ($self->{_on_starttls}) {
        (delete $self->{_on_starttls})->($self, undef, $err);
        &_freetls;
     } else {
        &_freetls;
        $self->_error (Errno::EPROTO, 1, $err);
     }
  }
  
  # poll the write BIO and send the data if applicable
  # also decode read data if possible
  # this is basiclaly our TLS state machine
  # more efficient implementations are possible with openssl,
  # but not with the buggy and incomplete Net::SSLeay.
  sub _dotls {
     my ($self) = @_;
  
     my $tmp;
  
     if (length $self->{_tls_wbuf}) {
        while (($tmp = Net::SSLeay::write ($self->{tls}, $self->{_tls_wbuf})) > 0) {
           substr $self->{_tls_wbuf}, 0, $tmp, "";
        }
  
        $tmp = Net::SSLeay::get_error ($self->{tls}, $tmp);
        return $self->_tls_error ($tmp)
           if $tmp != $ERROR_WANT_READ
              && ($tmp != $ERROR_SYSCALL || $!);
     }
  
     while (defined ($tmp = Net::SSLeay::read ($self->{tls}))) {
        unless (length $tmp) {
           $self->{_on_starttls}
              and (delete $self->{_on_starttls})->($self, undef, "EOF during handshake"); # ???
           &_freetls;
  
           if ($self->{on_stoptls}) {
              $self->{on_stoptls}($self);
              return;
           } else {
              # let's treat SSL-eof as we treat normal EOF
              delete $self->{_rw};
              $self->{_eof} = 1;
           }
        }
  
        $self->{_tls_rbuf} .= $tmp;
        $self->_drain_rbuf;
        $self->{tls} or return; # tls session might have gone away in callback
     }
  
     $tmp = Net::SSLeay::get_error ($self->{tls}, -1);
     return $self->_tls_error ($tmp)
        if $tmp != $ERROR_WANT_READ
           && ($tmp != $ERROR_SYSCALL || $!);
  
     while (length ($tmp = Net::SSLeay::BIO_read ($self->{_wbio}))) {
        $self->{wbuf} .= $tmp;
        $self->_drain_wbuf;
        $self->{tls} or return; # tls session might have gone away in callback
     }
  
     $self->{_on_starttls}
        and Net::SSLeay::state ($self->{tls}) == Net::SSLeay::ST_OK ()
        and (delete $self->{_on_starttls})->($self, 1, "TLS/SSL connection established");
  }
  
  =item $handle->starttls ($tls[, $tls_ctx])
  
  Instead of starting TLS negotiation immediately when the AnyEvent::Handle
  object is created, you can also do that at a later time by calling
  C<starttls>.
  
  Starting TLS is currently an asynchronous operation - when you push some
  write data and then call C<< ->starttls >> then TLS negotiation will start
  immediately, after which the queued write data is then sent.
  
  The first argument is the same as the C<tls> constructor argument (either
  C<"connect">, C<"accept"> or an existing Net::SSLeay object).
  
  The second argument is the optional C<AnyEvent::TLS> object that is used
  when AnyEvent::Handle has to create its own TLS connection object, or
  a hash reference with C<< key => value >> pairs that will be used to
  construct a new context.
  
  The TLS connection object will end up in C<< $handle->{tls} >>, the TLS
  context in C<< $handle->{tls_ctx} >> after this call and can be used or
  changed to your liking. Note that the handshake might have already started
  when this function returns.
  
  Due to bugs in OpenSSL, it might or might not be possible to do multiple
  handshakes on the same stream. It is best to not attempt to use the
  stream after stopping TLS.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  our %TLS_CACHE; #TODO not yet documented, should we?
  
  sub starttls {
     my ($self, $tls, $ctx) = @_;
  
     Carp::croak "It is an error to call starttls on an AnyEvent::Handle object while TLS is already active, caught"
        if $self->{tls};
  
     $self->{tls}     = $tls;
     $self->{tls_ctx} = $ctx if @_ > 2;
  
     return unless $self->{fh};
  
     require Net::SSLeay;
  
     $ERROR_SYSCALL   = Net::SSLeay::ERROR_SYSCALL     ();
     $ERROR_WANT_READ = Net::SSLeay::ERROR_WANT_READ   ();
  
     $tls = delete $self->{tls};
     $ctx = $self->{tls_ctx};
  
     local $Carp::CarpLevel = 1; # skip ourselves when creating a new context or session
  
     if ("HASH" eq ref $ctx) {
        require AnyEvent::TLS;
  
        if ($ctx->{cache}) {
           my $key = $ctx+0;
           $ctx = $TLS_CACHE{$key} ||= new AnyEvent::TLS %$ctx;
        } else {
           $ctx = new AnyEvent::TLS %$ctx;
        }
     }
     
     $self->{tls_ctx} = $ctx || TLS_CTX ();
     $self->{tls}     = $tls = $self->{tls_ctx}->_get_session ($tls, $self, $self->{peername});
  
     # basically, this is deep magic (because SSL_read should have the same issues)
     # but the openssl maintainers basically said: "trust us, it just works".
     # (unfortunately, we have to hardcode constants because the abysmally misdesigned
     # and mismaintained ssleay-module doesn't even offer them).
     # http://www.mail-archive.com/openssl-dev@openssl.org/msg22420.html
     #
     # in short: this is a mess.
     # 
     # note that we do not try to keep the length constant between writes as we are required to do.
     # we assume that most (but not all) of this insanity only applies to non-blocking cases,
     # and we drive openssl fully in blocking mode here. Or maybe we don't - openssl seems to
     # have identity issues in that area.
  #   Net::SSLeay::CTX_set_mode ($ssl,
  #      (eval { local $SIG{__DIE__}; Net::SSLeay::MODE_ENABLE_PARTIAL_WRITE () } || 1)
  #      | (eval { local $SIG{__DIE__}; Net::SSLeay::MODE_ACCEPT_MOVING_WRITE_BUFFER () } || 2));
     Net::SSLeay::CTX_set_mode ($tls, 1|2);
  
     $self->{_rbio} = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
     $self->{_wbio} = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
  
     Net::SSLeay::BIO_write ($self->{_rbio}, $self->{rbuf});
     $self->{rbuf} = "";
  
     Net::SSLeay::set_bio ($tls, $self->{_rbio}, $self->{_wbio});
  
     $self->{_on_starttls} = sub { $_[0]{on_starttls}(@_) }
        if $self->{on_starttls};
  
     &_dotls; # need to trigger the initial handshake
     $self->start_read; # make sure we actually do read
  }
  
  =item $handle->stoptls
  
  Shuts down the SSL connection - this makes a proper EOF handshake by
  sending a close notify to the other side, but since OpenSSL doesn't
  support non-blocking shut downs, it is not guaranteed that you can re-use
  the stream afterwards.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub stoptls {
     my ($self) = @_;
  
     if ($self->{tls} && $self->{fh}) {
        Net::SSLeay::shutdown ($self->{tls});
  
        &_dotls;
  
  #      # we don't give a shit. no, we do, but we can't. no...#d#
  #      # we, we... have to use openssl :/#d#
  #      &_freetls;#d#
     }
  }
  
  sub _freetls {
     my ($self) = @_;
  
     return unless $self->{tls};
  
     $self->{tls_ctx}->_put_session (delete $self->{tls})
        if $self->{tls} > 0;
     
     delete @$self{qw(_rbio _wbio _tls_wbuf _on_starttls)};
  }
  
  =item $handle->resettls
  
  This rarely-used method simply resets and TLS state on the handle, usually
  causing data loss.
  
  One case where it may be useful is when you want to skip over the data in
  the stream but you are not interested in interpreting it, so data loss is
  no concern.
  
  =cut
  
  *resettls = \&_freetls;
  
  sub DESTROY {
     my ($self) = @_;
  
     &_freetls;
  
     my $linger = exists $self->{linger} ? $self->{linger} : 3600;
  
     if ($linger && length $self->{wbuf} && $self->{fh}) {
        my $fh   = delete $self->{fh};
        my $wbuf = delete $self->{wbuf};
  
        my @linger;
  
        push @linger, AE::io $fh, 1, sub {
           my $len = syswrite $fh, $wbuf, length $wbuf;
  
           if ($len > 0) {
              substr $wbuf, 0, $len, "";
           } elsif (defined $len || ($! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK)) {
              @linger = (); # end
           }
        };
        push @linger, AE::timer $linger, 0, sub {
           @linger = ();
        };
     }
  }
  
  =item $handle->destroy
  
  Shuts down the handle object as much as possible - this call ensures that
  no further callbacks will be invoked and as many resources as possible
  will be freed. Any method you will call on the handle object after
  destroying it in this way will be silently ignored (and it will return the
  empty list).
  
  Normally, you can just "forget" any references to an AnyEvent::Handle
  object and it will simply shut down. This works in fatal error and EOF
  callbacks, as well as code outside. It does I<NOT> work in a read or write
  callback, so when you want to destroy the AnyEvent::Handle object from
  within such an callback. You I<MUST> call C<< ->destroy >> explicitly in
  that case.
  
  Destroying the handle object in this way has the advantage that callbacks
  will be removed as well, so if those are the only reference holders (as
  is common), then one doesn't need to do anything special to break any
  reference cycles.
  
  The handle might still linger in the background and write out remaining
  data, as specified by the C<linger> option, however.
  
  =cut
  
  sub destroy {
     my ($self) = @_;
  
     $self->DESTROY;
     %$self = ();
     bless $self, "AnyEvent::Handle::destroyed";
  }
  
  sub AnyEvent::Handle::destroyed::AUTOLOAD {
     #nop
  }
  
  =item $handle->destroyed
  
  Returns false as long as the handle hasn't been destroyed by a call to C<<
  ->destroy >>, true otherwise.
  
  Can be useful to decide whether the handle is still valid after some
  callback possibly destroyed the handle. For example, C<< ->push_write >>,
  C<< ->starttls >> and other methods can call user callbacks, which in turn
  can destroy the handle, so work can be avoided by checking sometimes:
  
     $hdl->starttls ("accept");
     return if $hdl->destroyed;
     $hdl->push_write (...
  
  Note that the call to C<push_write> will silently be ignored if the handle
  has been destroyed, so often you can just ignore the possibility of the
  handle being destroyed.
  
  =cut
  
  sub destroyed { 0 }
  sub AnyEvent::Handle::destroyed::destroyed { 1 }
  
  =item AnyEvent::Handle::TLS_CTX
  
  This function creates and returns the AnyEvent::TLS object used by default
  for TLS mode.
  
  The context is created by calling L<AnyEvent::TLS> without any arguments.
  
  =cut
  
  our $TLS_CTX;
  
  sub TLS_CTX() {
     $TLS_CTX ||= do {
        require AnyEvent::TLS;
  
        new AnyEvent::TLS
     }
  }
  
  =back
  
  
  =head1 NONFREQUENTLY ASKED QUESTIONS
  
  =over 4
  
  =item I C<undef> the AnyEvent::Handle reference inside my callback and
  still get further invocations!
  
  That's because AnyEvent::Handle keeps a reference to itself when handling
  read or write callbacks.
  
  It is only safe to "forget" the reference inside EOF or error callbacks,
  from within all other callbacks, you need to explicitly call the C<<
  ->destroy >> method.
  
  =item Why is my C<on_eof> callback never called?
  
  Probably because your C<on_error> callback is being called instead: When
  you have outstanding requests in your read queue, then an EOF is
  considered an error as you clearly expected some data.
  
  To avoid this, make sure you have an empty read queue whenever your handle
  is supposed to be "idle" (i.e. connection closes are O.K.). You can set
  an C<on_read> handler that simply pushes the first read requests in the
  queue.
  
  See also the next question, which explains this in a bit more detail.
  
  =item How can I serve requests in a loop?
  
  Most protocols consist of some setup phase (authentication for example)
  followed by a request handling phase, where the server waits for requests
  and handles them, in a loop.
  
  There are two important variants: The first (traditional, better) variant
  handles requests until the server gets some QUIT command, causing it to
  close the connection first (highly desirable for a busy TCP server). A
  client dropping the connection is an error, which means this variant can
  detect an unexpected detection close.
  
  To handle this case, always make sure you have a on-empty read queue, by
  pushing the "read request start" handler on it:
  
     # we assume a request starts with a single line
     my @start_request; @start_request = (line => sub {
        my ($hdl, $line) = @_;
  
        ... handle request
  
        # push next request read, possibly from a nested callback
        $hdl->push_read (@start_request);
     });
  
     # auth done, now go into request handling loop
     # now push the first @start_request
     $hdl->push_read (@start_request);
  
  By always having an outstanding C<push_read>, the handle always expects
  some data and raises the C<EPIPE> error when the connction is dropped
  unexpectedly.
  
  The second variant is a protocol where the client can drop the connection
  at any time. For TCP, this means that the server machine may run out of
  sockets easier, and in general, it means you cannot distinguish a protocl
  failure/client crash from a normal connection close. Nevertheless, these
  kinds of protocols are common (and sometimes even the best solution to the
  problem).
  
  Having an outstanding read request at all times is possible if you ignore
  C<EPIPE> errors, but this doesn't help with when the client drops the
  connection during a request, which would still be an error.
  
  A better solution is to push the initial request read in an C<on_read>
  callback. This avoids an error, as when the server doesn't expect data
  (i.e. is idly waiting for the next request, an EOF will not raise an
  error, but simply result in an C<on_eof> callback. It is also a bit slower
  and simpler:
  
     # auth done, now go into request handling loop
     $hdl->on_read (sub {
        my ($hdl) = @_;
  
        # called each time we receive data but the read queue is empty
        # simply start read the request
  
        $hdl->push_read (line => sub {
           my ($hdl, $line) = @_;
  
           ... handle request
  
           # do nothing special when the request has been handled, just
           # let the request queue go empty.
        });
     });
  
  =item I get different callback invocations in TLS mode/Why can't I pause
  reading?
  
  Unlike, say, TCP, TLS connections do not consist of two independent
  communication channels, one for each direction. Or put differently, the
  read and write directions are not independent of each other: you cannot
  write data unless you are also prepared to read, and vice versa.
  
  This means that, in TLS mode, you might get C<on_error> or C<on_eof>
  callback invocations when you are not expecting any read data - the reason
  is that AnyEvent::Handle always reads in TLS mode.
  
  During the connection, you have to make sure that you always have a
  non-empty read-queue, or an C<on_read> watcher. At the end of the
  connection (or when you no longer want to use it) you can call the
  C<destroy> method.
  
  =item How do I read data until the other side closes the connection?
  
  If you just want to read your data into a perl scalar, the easiest way
  to achieve this is by setting an C<on_read> callback that does nothing,
  clearing the C<on_eof> callback and in the C<on_error> callback, the data
  will be in C<$_[0]{rbuf}>:
  
     $handle->on_read (sub { });
     $handle->on_eof (undef);
     $handle->on_error (sub {
        my $data = delete $_[0]{rbuf};
     });
  
  Note that this example removes the C<rbuf> member from the handle object,
  which is not normally allowed by the API. It is expressly permitted in
  this case only, as the handle object needs to be destroyed afterwards.
  
  The reason to use C<on_error> is that TCP connections, due to latencies
  and packets loss, might get closed quite violently with an error, when in
  fact all data has been received.
  
  It is usually better to use acknowledgements when transferring data,
  to make sure the other side hasn't just died and you got the data
  intact. This is also one reason why so many internet protocols have an
  explicit QUIT command.
  
  =item I don't want to destroy the handle too early - how do I wait until
  all data has been written?
  
  After writing your last bits of data, set the C<on_drain> callback
  and destroy the handle in there - with the default setting of
  C<low_water_mark> this will be called precisely when all data has been
  written to the socket:
  
     $handle->push_write (...);
     $handle->on_drain (sub {
        AE::log debug => "all data submitted to the kernel\n";
        undef $handle;
     });
  
  If you just want to queue some data and then signal EOF to the other side,
  consider using C<< ->push_shutdown >> instead.
  
  =item I want to contact a TLS/SSL server, I don't care about security.
  
  If your TLS server is a pure TLS server (e.g. HTTPS) that only speaks TLS,
  connect to it and then create the AnyEvent::Handle with the C<tls>
  parameter:
  
     tcp_connect $host, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh  => $fh,
           tls => "connect",
           on_error => sub { ... };
  
        $handle->push_write (...);
     };
  
  =item I want to contact a TLS/SSL server, I do care about security.
  
  Then you should additionally enable certificate verification, including
  peername verification, if the protocol you use supports it (see
  L<AnyEvent::TLS>, C<verify_peername>).
  
  E.g. for HTTPS:
  
     tcp_connect $host, $port, sub {
        my ($fh) = @_;
  
         my $handle = new AnyEvent::Handle
            fh       => $fh,
            peername => $host,
            tls      => "connect",
            tls_ctx  => { verify => 1, verify_peername => "https" },
            ...
  
  Note that you must specify the hostname you connected to (or whatever
  "peername" the protocol needs) as the C<peername> argument, otherwise no
  peername verification will be done.
  
  The above will use the system-dependent default set of trusted CA
  certificates. If you want to check against a specific CA, add the
  C<ca_file> (or C<ca_cert>) arguments to C<tls_ctx>:
  
         tls_ctx  => {
            verify          => 1,
            verify_peername => "https",
            ca_file         => "my-ca-cert.pem",
         },
  
  =item I want to create a TLS/SSL server, how do I do that?
  
  Well, you first need to get a server certificate and key. You have
  three options: a) ask a CA (buy one, use cacert.org etc.) b) create a
  self-signed certificate (cheap. check the search engine of your choice,
  there are many tutorials on the net) or c) make your own CA (tinyca2 is a
  nice program for that purpose).
  
  Then create a file with your private key (in PEM format, see
  L<AnyEvent::TLS>), followed by the certificate (also in PEM format). The
  file should then look like this:
  
     -----BEGIN RSA PRIVATE KEY-----
     ...header data
     ... lots of base64'y-stuff
     -----END RSA PRIVATE KEY-----
  
     -----BEGIN CERTIFICATE-----
     ... lots of base64'y-stuff
     -----END CERTIFICATE-----
  
  The important bits are the "PRIVATE KEY" and "CERTIFICATE" parts.  Then
  specify this file as C<cert_file>:
  
     tcp_server undef, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh       => $fh,
           tls      => "accept",
           tls_ctx  => { cert_file => "my-server-keycert.pem" },
           ...
  
  When you have intermediate CA certificates that your clients might not
  know about, just append them to the C<cert_file>.
  
  =back
  
  
  =head1 SUBCLASSING AnyEvent::Handle
  
  In many cases, you might want to subclass AnyEvent::Handle.
  
  To make this easier, a given version of AnyEvent::Handle uses these
  conventions:
  
  =over 4
  
  =item * all constructor arguments become object members.
  
  At least initially, when you pass a C<tls>-argument to the constructor it
  will end up in C<< $handle->{tls} >>. Those members might be changed or
  mutated later on (for example C<tls> will hold the TLS connection object).
  
  =item * other object member names are prefixed with an C<_>.
  
  All object members not explicitly documented (internal use) are prefixed
  with an underscore character, so the remaining non-C<_>-namespace is free
  for use for subclasses.
  
  =item * all members not documented here and not prefixed with an underscore
  are free to use in subclasses.
  
  Of course, new versions of AnyEvent::Handle may introduce more "public"
  member variables, but that's just life. At least it is documented.
  
  =back
  
  =head1 AUTHOR
  
  Robin Redeker C<< <elmex at ta-sa.org> >>, Marc Lehmann <schmorp@schmorp.de>.
  
  =cut
  
  1; # End of AnyEvent::Handle
DARWIN-2LEVEL_ANYEVENT_HANDLE

$fatpacked{"darwin-2level/AnyEvent/Impl/Cocoa.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_COCOA';
  =head1 NAME
  
  AnyEvent::Impl::Cocoa - AnyEvent adaptor for Cocoa::EventLoop
  
  =head1 SYNOPSIS
  
      use AnyEvent;
      use Cocoa::EventLoop;
      
      # do something
  
  =head1 DESCRIPTION
  
  This module provides NSRunLoop support to AnyEvent.
  
  NSRunLoop is an event loop for Cocoa applications, wrapped by
  L<Cocoa::EventLoop>. By using this module, you can use Cocoa based API in
  your AnyEvent application, or AnyEvent within Cocoa applications.
  
  It does not support blocking waits.
  
  =head1 BUGS
  
  Right now, L<Cocoa::EventLoop> (and this module) are in an early
  development phase and has some shortcomings and likely bugs.
  
  For example, there seems to be no way to just handle a single event
  with Cocoa (is there nothing they can implement properly?), so this
  module currently wakes up at least ten times a second when waiting for
  events. Also, events caused by timers might get delayed by up to 0.1
  seconds.
  
  =cut
  
  package AnyEvent::Impl::Cocoa;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Cocoa::EventLoop;
  
  sub io {
     my ($class, %arg) = @_;
  
     Cocoa::EventLoop->io (%arg)
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     Cocoa::EventLoop->timer (%arg)
  }
  
  # does not support blocking waits
  
  #sub loop {
  #   Cocoa::EventLoop->run;
  #}
  
  1;
  
  =head1 AUTHORS
  
  Daisuke Murase <typester@cpan.org>, Marc Lehmann <schmorp@schmorp.de>.
  
  =head1 COPYRIGHTS
  
     Copyright (c) 2009 by KAYAC Inc.
     Copyright (c) 2010,2011 by Marc Lehmann <schmorp@schmorp.de>
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_COCOA

$fatpacked{"darwin-2level/AnyEvent/Impl/EV.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_EV';
  =head1 NAME
  
  AnyEvent::Impl::EV - AnyEvent adaptor for EV
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use EV;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make EV work with AnyEvent except by loading EV before
  creating the first AnyEvent watcher.
  
  EV is the fastest event library for perl, and best supported by
  AnyEvent. Most functions from the L<AE> API are implemented as direct
  aliases to EV functions, so using EV via AE is as fast as using EV
  directly.
  
  =cut
  
  package AnyEvent::Impl::EV;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use EV 4.00;
  
  *AE::time       = \&EV::time;
  *AE::now        = \&EV::now;
  *AE::now_update = \&EV::now_update;
  *AE::timer      = \&EV::timer;
  *AE::signal     = \&EV::signal;
  *AE::idle       = \&EV::idle;
  
  # cannot override directly, as EV doesn't allow arguments
  sub time       { EV::time       }
  sub now        { EV::now        }
  sub now_update { EV::now_update }
  
  *AE::io = defined &EV::_ae_io # 3.8+, but keep just in case it is dropped
     ? \&EV::_ae_io
     : sub($$$) { EV::io $_[0], $_[1] ? EV::WRITE : EV::READ, $_[2] };
  
  sub timer {
     my ($class, %arg) = @_;
  
     EV::timer $arg{after}, $arg{interval}, $arg{cb}
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     EV::io
        $arg{fh},
        $arg{poll} eq "r" ? EV::READ : EV::WRITE,
        $arg{cb}
  }
  
  sub signal {
     my ($class, %arg) = @_;
  
     EV::signal $arg{signal}, $arg{cb}
  }
  
  sub child {
     my ($class, %arg) = @_;
  
     my $cb = $arg{cb};
  
     EV::child $arg{pid}, 0, sub {
        $cb->($_[0]->rpid, $_[0]->rstatus);
     }
  }
  
  sub idle {
     my ($class, %arg) = @_;
  
     EV::idle $arg{cb}
  }
  
  sub _poll {
     EV::run EV::RUN_ONCE;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     EV::run EV::RUN_ONCE until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   EV::run;
  #}
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<EV>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_EV

$fatpacked{"darwin-2level/AnyEvent/Impl/Event.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_EVENT';
  =head1 NAME
  
  AnyEvent::Impl::Event - AnyEvent adaptor for Event
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Event;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Event work with AnyEvent except by loading Event before
  creating the first AnyEvent watcher.
  
  The event module is reasonably efficient and generally works correctly
  even with many watchers, except that its signal handling is inherently
  racy and requires the wake-up-frequently workaround.
  
  =cut
  
  package AnyEvent::Impl::Event;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Event qw(unloop); # we have to import something to make Event use Time::HiRes
  
  sub io {
     my (undef, %arg) = @_;
     $arg{fd} = delete $arg{fh};
     $arg{poll} .= "e" if AnyEvent::WIN32; # work around windows connect bug
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \(Event->io (%arg)), __PACKAGE__
  }
  
  sub timer {
     my (undef, %arg) = @_;
     $arg{after} = 0 if $arg{after} < 0;
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \Event->timer (%arg, repeat => $arg{interval}), __PACKAGE__
  }
  
  sub idle {
     my (undef, %arg) = @_;
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \Event->idle (repeat => 1, min => 0, %arg), __PACKAGE__
  }
  
  sub DESTROY {
     ${$_[0]}->cancel;
  }
  
  sub signal {
     my (undef, %arg) = @_;
  
     my $cb = $arg{cb};
     my $w = Event->signal (
        signal => AnyEvent::Base::sig2name $arg{signal},
        cb     => sub { &$cb }, # event doesn't like callable objects
     );
  
     AnyEvent::Base::_sig_add;
     bless \$w, "AnyEvent::Impl::Event::signal"
  }
  
  sub AnyEvent::Impl::Event::signal::DESTROY {
     AnyEvent::Base::_sig_del;
     ${$_[0]}->cancel;
  }
  
  sub _poll {
     Event::one_event;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Event::one_event until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   Event::loop;
  #}
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Event>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_EVENT

$fatpacked{"darwin-2level/AnyEvent/Impl/EventLib.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_EVENTLIB';
  =head1 NAME
  
  AnyEvent::Impl::EventLib - AnyEvent adaptor for Event::Lib
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Event::Lib;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Event work with AnyEvent except by loading Event::Lib
  before creating the first AnyEvent watcher.
  
  Note: the AnyEvent author has not found recent releases of Event::Lib to
  be even remotely working (not even the examples from the manpage or the
  testsuite work), so this event backend should be avoided (or somebody
  should step up and maintain it, hint, hint).
  
  The L<Event::Lib> module suffers from the same limitations and bugs as
  libevent, most notably it kills already-installed watchers on a file
  descriptor and it is unable to support fork. These are not fatal issues,
  and are worked-around by this module, but the L<Event::Lib> perl module
  itself has many additional bugs such as taking references to file handles
  and callbacks instead of making a copy or freeing still-allocated scalars,
  causing memory corruption and random crashes. Only Tk rivals it in its
  brokenness.
  
  This adaptor module employs the same workaround around the watcher
  problems as Tk and should therefore be avoided. (This was done for
  simplicity, one could in theory work around the problems with lower
  overhead by managing our own watchers).
  
  Event::Lib also leaks file handles and memory and tends to just exit on
  problems.
  
  It also doesn't work around the Windows bug of not signalling TCP
  connection failures.
  
  It also doesn't work with many special devices on Linux (F</dev/random>
  works, F</dev/urandom> fails, F</dev/tty> works, F</dev/null> fails and so
  on).
  
  Event::Lib does not support idle watchers. They could be emulated using
  low-priority timers but as the priority range (and availability) is not
  queryable nor guaranteed, and the default priority is likely the lowest
  one, this module cannot use them.
  
  Avoid Event::Lib if you can.
  
  =cut
  
  package AnyEvent::Impl::EventLib;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Event::Lib;
  
  # Event::Lib doesn't always take a reference to the callback, so closures
  # cause memory corruption and segfaults. it also has an issue actually
  # calling callbacks, so this exists as workaround.
  sub ccb {
     # Event:Lib accesses $_[0] after the callback, when it might be freed,
     # so we keep it referenced until after the callback. This still accesses
     # a freed scalar, but at least it'll not crash.
     my $keep_it = $_[0];
  
     $_[2]();
  }
  
  my $ccb = \&ccb;
  
  sub io {
     my (undef, %arg) = @_;
  
     # work around these bugs in Event::Lib:
     # - adding a callback might destroy other callbacks
     # - only one callback per fd/poll combination
     my ($fh, $mode) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, EV_READ, EV_WRITE;
  
     # event_new errornously takes a reference to fh and cb instead of making a copy
     # fortunately, going through %arg/_dupfh already makes a copy, so it happpens to work
     my $w = event_new $fh, $mode | EV_PERSIST, $ccb, $arg{cb};
     event_add $w;
     bless \\$w, __PACKAGE__
  }
  
  sub timer {
     my (undef, %arg) = @_;
  
     my $ival = $arg{interval};
     my $cb   = $arg{cb};
  
     my $w; $w = timer_new $ccb,
                    $ival
                       ? sub { event_add $w, $ival; &$cb }
                       : sub { undef $w           ; &$cb };
  
     event_add $w, $arg{after} || 1e-10; # work around 0-bug in Event::Lib
  
     bless \\$w, __PACKAGE__
  }
  
  sub DESTROY {
     local $@;
     ${${$_[0]}}->remove;
  }
  
  sub signal {
     my (undef, %arg) = @_;
  
     my $w = signal_new AnyEvent::Base::sig2num $arg{signal}, $ccb, $arg{cb};
     event_add $w;
     AnyEvent::Base::_sig_add;
     bless \\$w, "AnyEvent::Impl::EventLib::signal"
  }
  
  sub AnyEvent::Impl::EventLib::signal::DESTROY {
     AnyEvent::Base::_sig_del;
     local $@;
     ${${$_[0]}}->remove;
  }
  
  #sub loop {
  #   event_mainloop;
  #}
  
  sub _poll {
     event_one_loop;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     event_one_loop until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Event::Lib>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_EVENTLIB

$fatpacked{"darwin-2level/AnyEvent/Impl/FLTK.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_FLTK';
  =head1 NAME
  
  AnyEvent::Impl::FLTK - AnyEvent adaptor for FLTK (Fast Light Toolkit version two)
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use FLTK;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make FLTK work with AnyEvent except by loading FLTK before
  creating the first AnyEvent watcher.
  
  This implementation is not to be confused with AnyEvent::Impl::FLTK by
  Sanko Robinson. That implementation is completely broken, and the author
  is apparently unreachable.
  
  In any case, FLTK suffers from typical GUI-ToolKit diseases, such as O(n)
  or worse for every operation (adding a timer, destroying a timer etc.),
  the typical Not-Well-Tested Perl Interface disases such as non-random
  memory corruption and the typical Event-Loop-as-an-Afterthrough issues,
  such as multiple watchers on the same fd silently overwriting the others.
  
  It doesn't have native idle, signal or child watchers, so all of these are
  emulated.
  
  =cut
  
  package AnyEvent::Impl::FLTK;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use FLTK 0.532 ();
  use Scalar::Util ();
  
  #*AE::timer      = \&EV::timer;
  #*AE::signal     = \&EV::signal;
  #*AE::idle       = \&EV::idle;
  
  # FLTK::get_time_secs returns a glob :/
  # on unix, fltk uses gettimeofday, so we are likely compatible
  # on windows, fltk uses GetTickCount, to which we are unlikely to be compatible with.
  #sub time { FLTK::get_time_secs }
  #*now = \&time;
  
  sub timer_interval_cb {
     my $id = shift; # add_timeout kills @_, so we have to make a copy :(
     $id->[0] = FLTK::add_timeout $id->[1], \&timer_interval_cb, $id;
     &{ $id->[2] }
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     my $cb = $arg{cb};
  
     if ($arg{interval}) {
        my $id = [undef, $arg{interval}, $cb];
  
        $id->[0] = FLTK::add_timeout $arg{after}, \&timer_interval_cb, $id;
  
        return bless $id, "AnyEvent::Impl::FLTK::timer"
     } else {
        # non-repeating timers can be done very efficiently
        # also, FLTK doesn't like callable objects
        return FLTK::add_timeout $arg{after}, sub { &$cb }
     }
  }
  
  sub AnyEvent::Impl::FLTK::timer::DESTROY {
     undef $_[0][0];
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     # only one watcher/fd :(
  
     my $cb = $arg{cb};
     my ($fh, $ev) = AnyEvent::_dupfh $arg{poll}, $arg{fh},
        FLTK::READ,
        FLTK::WRITE | (AnyEvent::WIN32 ? FLTK::EXCEPT : 0);
  
     # fltk hardcodes poll constants and aliases EXCEPT with POLLERR,
     # which is grossly wrong, but likely it doesn't use poll on windows.
     FLTK::add_fd $fh, $ev, sub { &$cb }
  }
  
  # use signal and child emulation - fltk has no facilities for that
  
  # fltk idle watchers are like EV::check watchers, and fltk check watchers
  # are like EV::prepare watchers. both are called when the loop is busy,
  # so we have to use idle watcher emulation.
  
  sub _poll {
     FLTK::wait;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     FLTK::wait until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   FLTK::run;
  #}
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<FLTK>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_FLTK

$fatpacked{"darwin-2level/AnyEvent/Impl/Glib.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_GLIB';
  =head1 NAME
  
  AnyEvent::Impl::Glib - AnyEvent adaptor for Glib
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Glib;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Glib work with AnyEvent except by loading Glib before
  creating the first AnyEvent watcher.
  
  Glib is probably the most inefficient event loop that has ever seen the
  light of the world: Glib not only scans all its watchers (really, ALL of
  them, whether I/O-related, timer-related or what not) during each loop
  iteration, it also does so multiple times and rebuilds the poll list for
  the kernel each time again, dynamically even.
  
  On the positive side, and most importantly, Glib generally works
  correctly, no quarrels there.
  
  If you create many watchers (as in: more than two), you might consider one
  of the L<Glib::EV>, L<EV::Glib> or L<Glib::Event> modules that map Glib to
  other, more efficient, event loops.
  
  This module uses the default Glib main context for all its watchers.
  
  =cut
  
  package AnyEvent::Impl::Glib;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Glib 1.210 (); # (stable 1.220 2009, also Glib 2.4+ required, 2004)
  
  our $mainloop = Glib::MainContext->default;
  
  my %io_cond = (
     r => ["in" , "hup"],
     w => ["out", "hup"],
  );
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = add_watch Glib::IO
        $fd,
        $io_cond{$arg{poll}},
        sub { &$cb; 1 };
  
     bless \\$source, $class
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb   = $arg{cb};
     my $ival = $arg{interval} * 1000;
  
     my $source; $source = add Glib::Timeout $arg{after} < 0 ? 0 : $arg{after} * 1000,
        $ival ? sub {
                  remove Glib::Source $source;
                  $source = add Glib::Timeout $ival, sub { &$cb; 1 };
                  &$cb;
                  0
                }
              : sub { &$cb; 0 };
  
     bless \\$source, $class
  }
  
  sub idle {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $source = add Glib::Idle sub { &$cb; 1 };
  
     bless \\$source, $class
  }
  
  sub DESTROY {
     remove Glib::Source $${$_[0]};
  }
  
  our %pid_w;
  our %pid_cb;
  
  sub child {
     my ($class, %arg) = @_;
  
     $arg{pid} > 0
        or Carp::croak "Glib does not support watching for all pids (pid == 0) as attempted";
  
     my $pid = $arg{pid};
     my $cb  = $arg{cb};
  
     $pid_cb{$pid}{$cb+0} = $cb;
  
     $pid_w{$pid} ||= Glib::Child->watch_add ($pid, sub {
        $_->($_[0], $_[1])
           for values %{ $pid_cb{$pid} };
  
        1
     });
  
     bless [$pid, $cb+0], "AnyEvent::Impl::Glib::child"
  }
  
  sub AnyEvent::Impl::Glib::child::DESTROY {
     my ($pid, $icb) = @{ $_[0] };
  
     delete $pid_cb{$pid}{$icb};
     unless (%{ $pid_cb{$pid} }) {
        delete $pid_cb{$pid};
        remove Glib::Source delete $pid_w{$pid};
     }
  }
  
  #sub loop {
  #   # hackish, but we do not have a mainloop, just a maincontext
  #   $mainloop->iteration (1) while 1;
  #}
  
  sub _poll {
     $mainloop->iteration (1);
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     $mainloop->iteration (1) until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Glib>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_GLIB

$fatpacked{"darwin-2level/AnyEvent/Impl/IOAsync.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_IOASYNC';
  =head1 NAME
  
  AnyEvent::Impl::IOAsync - AnyEvent adaptor for IO::Async
  
  =head1 SYNOPSIS
  
    use AnyEvent;
    use IO::Async::Loop;
  
    # optionally set another event loop
    use AnyEvent::Impl::IOAsync;
    my $loop = new IO::Async::Loop;
    AnyEvent::Impl::IOAsync::set_loop $loop;
  
  =head1 DESCRIPTION
  
  This module provides support for IO::Async as AnyEvent backend. It supports
  I/O, timers, signals and child process watchers. Idle watchers are emulated.
  I/O watchers need to dup their fh because IO::Async only supports IO handles,
  not plain file descriptors.
  
  =head1 PROBLEMS WITH IO::Async
  
  This section had a long list of problems and shortcomings that made it
  almost impossible to support L<IO::Async>. With version 0.33 of IO::Async,
  however, most of these have been fixed, so L<IO::Async> can now be used as
  easily as many other loops.
  
  There are a few remaining problems that require emulation or workarounds:
  
  =over 4
  
  =item No support for multiple watchers per event
  
  In most (all? documentation?) cases you cannot have multiple watchers
  for the same event (what's the point of having all these fancy notifier
  classes when you cannot have multiple notifiers for the same event? That's
  like only allowing one timer per second or so...).
  
  For I/O watchers, AnyEvent has to dup() every file handle, as IO::Async
  fails to support the same or different file handles pointing to the same
  fd (the good thing is that it is documented, but why not fix it instead?).
  
  =back
  
  Apart from these fatal flaws, there are a number of unpleasent properties
  that just need some mentioning:
  
  =over 4
  
  =item Confusing and misleading names
  
  Another rather negative point about this module family is its name,
  which is deeply confusing: Despite the "async" in the name, L<IO::Async>
  only does I<synchronous> I/O, there is nothing "asynchronous" about it
  whatsoever (when I first heard about it, I thought, "wow, a second async
  I/O module, what does it do compared to L<IO::AIO>", and was somehow set
  back when I learned that the only "async" aspect of it is the name).
  
  =item Inconsistent, incomplete and convoluted API
  
  Implementing AnyEvent's rather simple timers on top of IO::Async's timers
  was a nightmare (try implementing a timer with configurable interval and
  delay value...).
  
  The method naming is chaotic: C<watch_child> creates a child watcher,
  but C<watch_io> is an internal method; C<detach_signal> removes a signal
  watcher, but C<detach_child> forks a subprocess and so on).
  
  =item Unpleasant surprises on GNU/Linux
  
  When you develop your program on FreeBSD and run it on GNU/Linux, you
  might have unpleasant surprises, as IO::Async::Loop will by default use
  L<IO::Async::Loop::Epoll>, which is incompatible with C<fork>, so your
  network server will run into spurious and very hard to debug problems
  under heavy load, as IO::Async forks a lot of processes, e.g. for DNS
  resolution. It would be better if IO::Async would only load "safe"
  backends by default (or fix the epoll backend to work in the presence of
  fork, which admittedly is hard - EV does it for you, and also does not use
  unsafe backends by default).
  
  =back
  
  On the positive side, performance with IO::Async is quite good even in my
  very demanding eyes.
  
  =cut
  
  package AnyEvent::Impl::IOAsync;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Time::HiRes ();
  use Scalar::Util ();
  
  use IO::Async::Loop 0.33;
  
  our $LOOP = new IO::Async::Loop;
  
  sub set_loop($) {
     $LOOP = $_[0];
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
  
     my $id;
  
     if (my $ival = $arg{interval}) {
        my $ival_cb; $ival_cb = sub {
           $id = $LOOP->enqueue_timer (delay => $ival, code => $ival_cb);
           &$cb;
        };
        $id = $LOOP->enqueue_timer (delay => $arg{after}, code => $ival_cb);
  
        # we have to weaken afterwards, but when enqueue dies, we have a memleak.
        # still, we do anything for speed...
        Scalar::Util::weaken $ival_cb;
  
     } else {
        # IO::Async has problems with overloaded objects
        $id = $LOOP->enqueue_timer (delay => $arg{after}, code => sub {
           undef $id; # IO::Async <= 0.43 bug workaround
           &$cb;
        });
     }
  
     bless \\$id, "AnyEvent::Impl::IOAsync::timer"
  }
  
  sub AnyEvent::Impl::IOAsync::timer::DESTROY {
     # Need to be well-behaved during global destruction
     $LOOP->cancel_timer (${${$_[0]}})
        if defined ${${$_[0]}}; # IO::Async <= 0.43 bug workaround
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     # Ensure we have a real IO handle, and not just a UNIX fd integer
     my ($fh) = AnyEvent::_dupfh $arg{poll}, $arg{fh};
  
     my $event = $arg{poll} eq "r" ? "on_read_ready" : "on_write_ready";
  
     $LOOP->watch_io (
        handle => $fh,
        $event => $arg{cb},
     );
  
     bless [$fh, $event], "AnyEvent::Impl::IOAsync::io"
  }
  
  sub AnyEvent::Impl::IOAsync::io::DESTROY {
     $LOOP->unwatch_io (
        handle => $_[0][0],
        $_[0][1] => 1,
     );
  }
  
  sub signal {
     my ($class, %arg) = @_;
  
     my $signal = $arg{signal};
  
     my $id = $LOOP->attach_signal ($arg{signal}, $arg{cb});
     bless [$signal, $id], "AnyEvent::Impl::IOAsync::signal"
  }
  
  sub AnyEvent::Impl::IOAsync::signal::DESTROY {
     $LOOP->detach_signal (@{ $_[0] });
  }
  
  our %pid_cb;
  
  sub child {
     my ($class, %arg) = @_;
  
     my $pid = $arg{pid};
  
     $LOOP->watch_child ($pid, $arg{cb});
     bless [$pid], "AnyEvent::Impl::IOAsync::child"
  }
  
  sub child {
     my ($class, %arg) = @_;
  
     my $pid = $arg{pid};
     my $cb  = $arg{cb};
  
     unless (%{ $pid_cb{$pid} }) {
        $LOOP->watch_child ($pid, sub {
           $_->($_[0], $_[1])
              for values %{ $pid_cb{$pid} };
        });
     }
  
     $pid_cb{$pid}{$cb+0} = $cb;
  
     bless [$pid, $cb+0], "AnyEvent::Impl::IOAsync::child"
  }
  
  sub AnyEvent::Impl::IOAsync::child::DESTROY {
     my ($pid, $icb) = @{ $_[0] };
  
     delete $pid_cb{$pid}{$icb};
  
     unless (%{ $pid_cb{$pid} }) {
        delete $pid_cb{$pid};
        $LOOP->unwatch_child ($pid);
     }
  }
  
  #sub loop {
  #   $LOOP->loop_forever;
  #}
  
  sub _poll {
     $LOOP->loop_once;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     $LOOP->loop_once until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<IO::Async>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
   Paul Evans <leonerd@leonerd.org.uk>
   Rewrote the backend for IO::Async version 0.33.
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_IOASYNC

$fatpacked{"darwin-2level/AnyEvent/Impl/Irssi.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_IRSSI';
  =head1 NAME
  
  AnyEvent::Impl::Irssi - AnyEvent adaptor for Irssi
  
  =head1 SYNOPSIS
  
     use AnyEvent;
    
     # this module gets loaded automatically when running under irssi
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Irssi scripts work with AnyEvent.
  
  Limitations of this backend and implementation details:
  
  =over 4
  
  =item * This backend does not support blocking waits.
  
  That means you must set a callback on any condvars, or otherwise make sure
  to never call C<recv> on a condvar that hasn't been signalled yet.
  
  =item * Child exits will be handled by AnyEvent.
  
  AnyEvent will take over child handling, as Irssi only polls for children
  once/second and cannot handle unspecific child watchers.
  
  This I<should> have no negative effect, as AnyEvent will emit a pidwait
  signal just like irssi itself would.
  
  =item * Artificial timer delays.
  
  Irssi artificially enforces timers to have at least a 10ms delay (by
  croaking, even).
  
  This means that some applications will be limited to a rate of 100Hz (for
  example, L<Coro::AnyEvent> thread scheduling).
  
  =item * Irssi leaks memory like hell.
  
  Yeah.
  
  =back
  
  Apart from that, documentation is notoriously wrong (e.g. file handles
  are not supported by C<input_add>, contrary to documentation), hooking
  into irssi has to be done in... weird... ways, but otherwise, Irssi is
  surprisingly full-featured (for basically being a hack).
  
  =cut
  
  package AnyEvent::Impl::Irssi;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Carp ();
  use Irssi ();
  
  our @ISA;
  
  # irssi works only from certain namespaces, so we
  # create one and use it.
  sub init {
     my $pkg = caller;
  
     push @ISA, $pkg;
  
     local $/;
     eval "package $pkg; " . <DATA>;
     print "AnyEvent::Impl::Irssi fatal compilation error: $@" if $@;
  
     close DATA;
  }
  
  Irssi::command "/script exec -permanent AnyEvent::Impl::Irssi::init 'AnyEvent adaptor'";
  
  1;
  
  __DATA__
  
  BEGIN { AnyEvent::common_sense }
  use base "AnyEvent::Base";
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = Irssi::input_add
        $fd,
        $arg{poll} eq "r" ? Irssi::INPUT_READ : Irssi::INPUT_WRITE,
        $cb,
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::io"
  }
  
  sub AnyEvent::Impl::Irssi::io::DESTROY {
     Irssi::input_remove $${$_[0]};
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb    = $arg{cb};
     my $ival  = $arg{interval} * 1000;
     my $after = $arg{after} * 1000;
  
     my $source; $source = Irssi::timeout_add_once $after > 10 ? $after : 10,
        ($ival ? sub {
                   $source = Irssi::timeout_add $ival > 10 ? $ival : 10, $cb, undef;
                   &$cb;
                   0
                 }
               : $cb),
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::timer"
  }
  
  sub AnyEvent::Impl::Irssi::timer::DESTROY {
     Irssi::timeout_remove $${$_[0]};
  }
  
  my $_pidwait = sub {
     my ($rpid, $rstatus) = @_;
  
     AnyEvent::Base->_emit_childstatus ($rpid, $rstatus);
  };
  
  Irssi::signal_add pidwait => $_pidwait;
  
  sub _emit_childstatus {
     my ($self, $rpid, $rstatus) = @_;
     $self->SUPER::_emit_childstatus ($rpid, $rstatus);
  
     Irssi::signal_remove pidwait => $_pidwait;
     Irssi::signal_emit   pidwait => $rpid+0, $rstatus+0;
     Irssi::signal_add    pidwait => $_pidwait;
  }
  
  #sub loop {
  #   Carp::croak "Irssi does not support blocking waits";
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Irssi>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_IRSSI

$fatpacked{"darwin-2level/AnyEvent/Impl/POE.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_POE';
  =head1 NAME
  
  AnyEvent::Impl::POE - AnyEvent adaptor for POE
  
  =encoding utf-8
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use POE;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make POE work with AnyEvent except by loading POE before
  creating the first AnyEvent watcher. There are some cases where POE will
  issue spurious (and non-suppressible) warnings. These can be avoided by
  loading AnyEvent::Impl::POE before loading any other modules using POE and
  AnyEvent, i.e. in your main program.
  
  AnyEvent::Impl::POE will output some spurious message how to work around
  POE's spurious messages when it detects these cases.
  
  Unfortunately, POE isn't generic enough to implement a fully working
  AnyEvent backend: POE is too badly designed, too badly documented and too
  badly implemented.
  
  Here are the details, and what it means to you if you want to be
  interoperable with POE:
  
  =over 4
  
  =item Weird messages
  
  If you only use C<run_one_timeslice> (as AnyEvent has to for its
  condition variables), POE will print an ugly, unsuppressible, message at
  program exit:
  
     Sessions were started, but POE::Kernel's run() method was never...
  
  The message is correct, the question is why POE prints it in the first
  place in a correct program (this is not a singular case though).
  
  AnyEvent consequently patches the POE kernel so it thinks it already
  ran. Other workarounds, even the one cited in the POE documentation
  itself, have serious side effects, such as throwing away events.
  
  The author of POE verified that this is indeed true, and has no plans to
  change this.
  
  POE has other weird messages, and sometimes weird behaviour, for example,
  it doesn't support overloaded code references as callbacks for no apparent
  reason.
  
  =item One POE session per Event
  
  AnyEvent has to create one POE::Session per event watcher, which is
  immensely slow and makes watchers very large. The reason for this is
  lacking lifetime management (mostly undocumented, too). Without one
  session/watcher it is not possible to easily keep the kernel from running
  endlessly.
  
  This is not just a problem with the way AnyEvent has to interact with
  POE, but is a principal issue with POEs lifetime management (namely
  that stopping the kernel stops sessions, but AnyEvent has no control
  over who and when the kernel starts or stops w.r.t. AnyEvent watcher
  creation/destruction).
  
  From benchmark data it is not clear that session creation is that costly,
  though - the real inefficiencies with POE seem to come from other sources,
  such as event handling.
  
  =item One watcher per fd/event combo
  
  POE, of course, suffers from the same bug as Tk and some other badly
  designed event models in that it doesn't support multiple watchers per
  fd/poll combo. The workaround is the same as with Tk: AnyEvent::Impl::POE
  creates a separate file descriptor to hand to POE, which isn't fast and
  certainly not nice to your resources.
  
  Of course, without the workaround, POE also prints ugly messages again
  that say the program *might* be buggy.
  
  While this is not good to performance, at least regarding speed, with a
  modern Linux kernel, the overhead is actually quite small.
  
  =item Timing Deficiencies
  
  POE manages to not have a function that returns the current time. This is
  extremely problematic, as POE can use different time functions, which can
  differ by more than a second - and user code is left guessing which one is
  used.
  
  In addition, most timer functions in POE want an absolute timestamp, which
  is hard to create if all you have is a relative time and no function to
  return the "current time".
  
  And of course POE doesn't handle time jumps at all (not even when using
  an event loop that happens to do that, such as L<EV>, as it does its own
  unoptimised timer management).
  
  AnyEvent works around the unavailability of the current time using
  relative timers exclusively, in the hope that POE gets it right at least
  internally.
  
  =item Event Non-Ordering
  
  POE cannot guarantee the order of callback invocation for timers, and
  usually gets it wrong. That is, if you have two timers, one timing out
  after another (all else being equal), the callbacks might be called in
  reverse order.
  
  How one manages to even implement stuff that way escapes me.
  
  =item Child Watchers
  
  POE offers child watchers - which is a laudable thing, as few event loops
  do. Unfortunately, they cannot even implement AnyEvent's simple child
  watchers: they are not generic enough (the POE implementation isn't even
  generic enough to let properly designed back-end use their native child
  watcher instead - it insist on doing it itself the broken way).
  
  Unfortunately, POE's child handling is inherently racy: if the child
  exits before the handler is created (which is impossible to avoid in
  general, imagine the forked program to exit immediately because of a bug,
  or imagine the POE kernel being busy for a second), one has to wait for
  another event to occur, which can take an indefinite amount of time.
  
  Of course, whenever POE reaps an unrelated child it will also output a
  message for it that you cannot suppress (which shouldn't be too surprising
  at this point). Very professional.
  
  As a workaround, AnyEvent::Impl::POE will take advantage of undocumented
  behaviour in POE::Kernel to catch the status of all child processes, but
  it cannot guarantee delivery.
  
  How one manages to have such a glaring bug in an event loop after ten
  years of development escapes me.
  
  (There are more annoying bugs, for example, POE runs C<waitpid>
  unconditionally on finalizing, so your program will hang until all child
  processes have exited.)
  
  =item Documentation Quality
  
  At the time of this writing, POE was in its tenth year. Still, its
  documentation is extremely lacking, making it impossible to implement
  stuff as trivial as AnyEvent watchers without having to resort to
  undocumented behaviour or features.
  
  For example, the POE::Kernel manpage has nine occurrences of the word TODO
  with an explanation of whats missing. In general, the POE man pages are
  littered with comments like "section not yet written".
  
  Some other gems:
  
     This allows many object methods to also be package methods.
  
  This is nice, but since it doesn't document I<which> methods these are,
  this is utterly useless information.
  
     Terminal signals will kill sessions if they are not handled by a
     "sig_handled"() call. The OS signals that usually kill or dump a
     process are considered terminal in POE, but they never trigger a
     coredump. These are: HUP, INT, QUIT and TERM.
  
  Although AnyEvent calls C<sig_handled>, removing it has no apparent
  effects on POE handling SIGINT.
  
     refcount_increment SESSION_ID, COUNTER_NAME
  
  Nowhere is explained which COUNTER_NAMEs are valid and which aren't - not
  all scalars (or even strings) are valid counter names. Take your guess,
  failure is of course completely silent. I found this out the hard way, as
  the first name I came up with was silently ignored.
  
     get_next_event_time() returns the time the next event is due, in a form
     compatible with the UNIX time() function.
  
  And surely, one would hope that POE supports sub-second accuracy as
  documented elsewhere, unlike the explanation above implies. Yet:
  
     POE::Kernel timers support subsecond accuracy, but dont expect too
     much here. Perl is not the right language for realtime programming.
  
  ... of course, Perl is not the right language to expect sub-second
  accuracy - the manpage author must hate Perl to spread so much FUD in
  so little space. The Deliantra game server logs with 100s-accuracy
  because Perl is fast enough to require this, and is still able to deliver
  map updates with little jitter at exactly the right time. It does not,
  however, use POE.
  
     Furthermore, since the Kernel keeps track of everything sessions do, it
     knows when a session has run out of tasks to perform.
  
  This is impossible - how does the kernel know that a session is no longer
  watching for some (external) event (e.g. by some other session)? It
  cannot, and therefore this is wrong - but you would be hard pressed to
  find out how to work around this and tell the kernel manually about such
  events.
  
  It gets worse, though - the notion of "task" or "resource", although used
  throughout the documentation, is not defined in a usable way. For example,
  waiting for a timeout is considered to be a task, waiting for a signal is
  not (a session that only waits for a signal is considered finished and
  gets removed). The user is left guessing when waiting for an event counts
  as task and when not (in fact, the issue with signals is mentioned in
  passing in a section about child watchers and directly contradicts earlier
  parts in that document).
  
  One could go on endlessly - ten years, no usable documentation.
  
  It is likely that differences between documentation, or the one or two
  things I had to guess, cause unanticipated problems with this adaptor.
  
  =item Fragile and inconsistent API
  
  The POE API is extremely inconsistent - sometimes you have to pass a
  session argument, sometimes it gets ignored, sometimes a session-specific
  method must not use a session argument.
  
  Error handling is sub-standard as well: even for programming mistakes,
  POE does not C<croak> but, in most cases, just sets C<$!> or simply does
  nothing at all, leading to fragile programs.
  
  Sometimes registering a handler uses the "eventname, parameter" ordering
  (timeouts), sometimes it is "parameter, eventname" (signals). There is
  little consistency overall.
  
  =item Lack of knowledge
  
     The IO::Poll event loop provides an alternative that theoretically
     scales better than select().
  
  The IO::Poll "event loop" (who in his right mind would call that an event
  loop) of course scales about identically (sometimes it is a bit faster,
  sometimes a bit slower) to select in theory, and also in practise, of
  course, as both are O(n) in the number of file descriptors, which is
  rather bad.
  
  This is just one place where it gets obvious how little the author of the
  POE manpage understands.
  
  =item No idle events
  
  The POE-recommended workaround to this is apparently to use
  C<fork>. Consequently, idle watchers will have to be emulated by AnyEvent.
  
  =back
  
  On the good side, AnyEvent allows you to write your modules in a 100%
  POE-compatible way (bug-for-bug compatible even), without forcing your
  module to use POE - it is still open to better event models, of which
  there are plenty.
  
  Oh, and one other positive thing:
  
     RUNNING_IN_HELL
  
  POE knows about the nature of the beast!
  
  =cut
  
  package AnyEvent::Impl::POE;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use POE;
  
  # suppress an idiotic warning inside POE
  ${ POE::Kernel->new->[POE::Kernel::KR_RUN] } |= POE::Kernel::KR_RUN_CALLED;
  
  sub io {
     my ($class, %arg) = @_;
  
     # POE itself might do the right thing, but some POE backends don't,
     # so do the safe thing, it's not as if this will slow us down
     # any further *g*
     my ($fh, $pee) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, "select_read", "select_write";
  
     my $cb = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
  
     my $session = POE::Session->create (
        inline_states => {
           _start => sub { $_[KERNEL]->$pee ($fh => "ready") },
           ready  => sub { $cb->() },
           stop   => sub { $_[KERNEL]->$pee ($fh) },
        },
     );
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     my $after = delete $arg{after};
     my $ival  = delete $arg{interval};
     my $cb    = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
  
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              $_[KERNEL]->delay_set (timeout => $after);
           },
           timeout => $ival ? sub { $_[KERNEL]->delay_set (timeout => $ival); $cb->() } : $cb,
           stop => sub {
              $_[KERNEL]->alarm_remove_all;
           },
        },
     );
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub signal {
     my ($class, %arg) = @_;
     my $signal = AnyEvent::Base::sig2name delete $arg{signal};
     my $cb     = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              # I suck - POE
           },
           start => sub {
              $_[KERNEL]->sig ($signal => "catch");
              $_[KERNEL]->refcount_increment ($_[SESSION]->ID => "poe");
           },
           catch => sub {
              $cb->();
              $_[KERNEL]->sig_handled;
           },
           stop => sub {
              $_[KERNEL]->refcount_decrement ($_[SESSION]->ID => "poe");
              $_[KERNEL]->sig ($signal);
           },
        },
     );
     POE::Kernel->call ($session, "start");
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub child {
     my ($class, %arg) = @_;
     my $pid = delete $arg{pid};
     my $cb  = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              # I suck - POE
           },
           start => sub {
              $_[KERNEL]->sig (CHLD => "child");
              $_[KERNEL]->refcount_increment ($_[SESSION]->ID => "poe");
           },
           child => sub {
              my ($rpid, $status) = @_[ARG1, ARG2];
  
              $cb->($rpid, $status) if $rpid == $pid || $pid == 0;
           },
           stop => sub {
              $_[KERNEL]->refcount_decrement ($_[SESSION]->ID => "poe");
              $_[KERNEL]->sig ("CHLD");
           },
        },
     );
     # newer POE versions lose signals unless we call ->sig early.
     POE::Kernel->call ($session, "start");
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub DESTROY {
     POE::Kernel->call (${${$_[0]}}, "stop");
  }
  
  #sub loop {
  #   POE::Kernel->run;
  #}
  
  sub _poll {
     POE::Kernel->loop_do_timeslice;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     POE::Kernel->loop_do_timeslice until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<POE>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_POE

$fatpacked{"darwin-2level/AnyEvent/Impl/Perl.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_PERL';
  =head1 NAME
  
  AnyEvent::Impl::Perl - AnyEvent adaptor for AnyEvent's pure perl AnyEvent::Loop
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use AnyEvent::Loop;
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent in case no other
  event loop could be found or loaded.
  
  If you want to use this module instead of autoloading another event loop
  you can simply load L<AnyEvent::Loop> before creating the first watcher.
  
  Naturally, it supports all features of AnyEvent.
  
  See L<AnyEvent::Loop> for more details on performance characteristics.
  
  =cut
  
  package AnyEvent::Impl::Perl;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Loop;
  
  our $VERSION = $AnyEvent::VERSION;
  
  # time() is provided via AnyEvent::Base
  
  *AE::now        = \&AnyEvent::Loop::now;
  *AE::now_update = \&AnyEvent::Loop::now_update;
  *AE::io         = \&AnyEvent::Loop::io;
  *AE::timer      = \&AnyEvent::Loop::timer;
  *AE::idle       = \&AnyEvent::Loop::idle;
  *_poll          = \&AnyEvent::Loop::one_event;
  *loop           = \&AnyEvent::Loop::run; # compatibility with AnyEvent < 6.0
  
  sub now        { $AnyEvent::Loop::NOW }
  sub now_update { AE::now_update       }
  
  sub AnyEvent::CondVar::Base::_wait {
     AnyEvent::Loop::one_event until exists $_[0]{_ae_sent};
  }
  
  sub io {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::io $arg{fh}, $arg{poll} eq "w", $arg{cb}
  }
  
  sub timer {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::timer $arg{after}, $arg{interval}, $arg{cb}
  }
  
  sub idle {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::idle $arg{cb}
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
  
DARWIN-2LEVEL_ANYEVENT_IMPL_PERL

$fatpacked{"darwin-2level/AnyEvent/Impl/Qt.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_QT';
  =head1 NAME
  
  AnyEvent::Impl::Qt - AnyEvent adaptor for Qt
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Qt;
    
     my $app = Qt::Application \@ARGV; # REQUIRED!
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have
  to do anything to make Qt work with AnyEvent except by loading Qt
  before creating the first AnyEvent watcher I<and instantiating the
  Qt::Application object>. Failure to do so will result in segfaults,
  which is why this model doesn't work as a default model and will not be
  autoprobed (but it will be autodetected when the main program uses Qt).
  
  Qt suffers from the same limitations as Event::Lib and Tk, the workaround
  is also the same (duplicating file descriptors).
  
  Qt doesn't support idle events, so they are being emulated.
  
  Avoid Qt if you can.
  
  =cut
  
  package AnyEvent::Impl::Qt::Io;
  
  use Qt;
  use Qt::isa qw(Qt::SocketNotifier); # Socket? what where they smoking
  use Qt::slots cb => [];
  
  sub NEW {
     my ($class, $fh, $mode, $cb) = @_;
     shift->SUPER::NEW (fileno $fh, $mode);
     this->{fh} = $fh;
     this->{cb} = $cb;
     this->connect (this, SIGNAL "activated(int)", SLOT "cb()");
  }
  
  sub cb {
     this->setEnabled (0); # required according to the docs. heavy smoking required.
     this->{cb}->();
     this->setEnabled (1);
  }
  
  package AnyEvent::Impl::Qt::Timer;
  
  use Qt;
  use Qt::isa qw(Qt::Timer);
  use Qt::slots cb => [];
  
  # having to go through these contortions just to get a timer event is
  # considered an advantage over other gui toolkits how?
  
  sub NEW {
     my ($class, $after, $interval, $cb) = @_;
     shift->SUPER::NEW ();
     this->{interval} = $interval;
     this->{cb}       = $cb;
     this->connect (this, SIGNAL "timeout()", SLOT "cb()");
     this->start ($after, 1);
  }
  
  sub cb {
     this->start (this->{interval}, 1) if defined this->{interval};
     this->{cb}->();
  }
  
  package AnyEvent::Impl::Qt;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Qt;
  
  use AnyEvent::Impl::Qt::Timer;
  use AnyEvent::Impl::Qt::Io;
  
  our $app = Qt::Application \@ARGV; # REQUIRED!
  
  sub io {
     my ($class, %arg) = @_;
  
     # work around these bugs in Qt:
     # - adding a callback might destroy other callbacks
     # - only one callback per fd/poll combination
     my ($fh, $qt) = AnyEvent::_dupfh $arg{poll}, $arg{fh},
                        Qt::SocketNotifier::Read (), Qt::SocketNotifier::Write ();
  
     AnyEvent::Impl::Qt::Io $fh, $qt, $arg{cb}
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     # old Qt treats 0 timeout as "idle"
     AnyEvent::Impl::Qt::Timer
        $arg{after} * 1000 || 1,
        $arg{interval} ? $arg{interval} * 1000 || 1 : undef,
        $arg{cb}
  }
  
  # newer Qt have no idle mode for timers anymore...
  #sub idle {
  #   my ($class, %arg) = @_;
  #   
  #   AnyEvent::Impl::Qt::Timer 0, 0, $arg{cb}
  #}
  
  #sub loop {
  #   Qt::app->exec;
  #}
  
  sub _poll {
     Qt::app->processOneEvent;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Qt::app->processOneEvent until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Qt>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
  
DARWIN-2LEVEL_ANYEVENT_IMPL_QT

$fatpacked{"darwin-2level/AnyEvent/Impl/Tk.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_TK';
  =head1 NAME
  
  AnyEvent::Impl::Tk - AnyEvent adaptor for Tk
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Tk;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Tk work with AnyEvent except by loading Tk before
  creating the first AnyEvent watcher.
  
  Tk is buggy. Tk is extremely buggy. Tk is so unbelievably buggy that
  for each bug reported and fixed, you get one new bug followed by
  reintroduction of the old bug in a later revision. It is also basically
  unmaintained: the maintainers are not even interested in improving
  the situation - reporting bugs is considered rude, and fixing bugs is
  considered changing holy code, so it's apparently better to leave it
  broken.
  
  I regularly run out of words to describe how bad it really is.
  
  To work around some of the many, many bugs in Tk that don't get fixed,
  this adaptor dup()'s all filehandles that get passed into its I/O
  watchers, so if you register a read and a write watcher for one fh,
  AnyEvent will create two additional file descriptors (and handles).
  
  This creates a high overhead and is slow, but seems to work around most
  known bugs in L<Tk::fileevent> on 32 bit architectures (Tk seems to be
  terminally broken on 64 bit, do not expect more than 10 or so watchers to
  work on 64 bit machines).
  
  Do not expect these workarounds to avoid segfaults and crashes inside Tk.
  
  Note also that Tk event ids wrap around after 2**32 or so events, which on
  my machine can happen within less than 12 hours, after which Tk will stomp
  on random other events and kill them. So don't run Tk programs for more
  than an hour or so.
  
  To be able to access the Tk event loop, this module creates a main
  window and withdraws it immediately. This might cause flickering on some
  platforms, but Tk perversely requires a window to be able to wait for file
  handle readyness notifications. This window is always created (in this
  version of AnyEvent) and can be accessed as C<$AnyEvent::Impl::Tk::mw>.
  
  =cut
  
  package AnyEvent::Impl::Tk;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Tk ();
  
  our $mw = new MainWindow -title => "AnyEvent Dummy Window";
  $mw->withdraw;
  
  END { undef $mw }
  
  sub io {
     my (undef, %arg) = @_;
  
     # work around these bugs in Tk:
     # - removing a callback will destroy other callbacks
     # - removing a callback might crash
     # - adding a callback might destroy other callbacks
     # - only one callback per fh
     # - only one callback per fh/poll combination
     my ($fh, $tk) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, "readable", "writable";
  
     $mw->fileevent ($fh, $tk => $arg{cb});
  
     bless [$fh, $tk], "AnyEvent::Impl::Tk::io"
  }
  
  sub AnyEvent::Impl::Tk::io::DESTROY {
     my ($fh, $tk) = @{$_[0]};
  
     # work around another bug: watchers don't get removed when
     # the fh is closed, contrary to documentation. also, trying
     # to unregister a read callback will make it impossible
     # to remove the write callback.
     # if your program segfaults here then you need to destroy
     # your watchers before program exit. sorry, no way around
     # that.
     $mw->fileevent ($fh, $tk => "");
  }
  
  sub timer {
     my (undef, %arg) = @_;
     
     my $after = $arg{after} < 0 ? 0 : $arg{after} * 1000;
     my $cb = $arg{cb};
     my $id;
  
     if ($arg{interval}) {
        my $ival = $arg{interval} * 1000;
        my $rcb = sub {
           $id = Tk::after $mw, $ival, [$_[0], $_[0]];
           &$cb;
        };
        $id = Tk::after $mw, $after, [$rcb, $rcb];
     } else {
        # tk blesses $cb, thus the extra indirection
        $id = Tk::after $mw, $after, sub { &$cb };
     }
  
     bless \\$id, "AnyEvent::Impl::Tk::after"
  }
  
  sub idle {
     my (undef, %arg) = @_;
  
     my $cb = $arg{cb};
     my $id;
     my $rcb = sub {
        # in their endless stupidity, they decided to give repeating idle watchers
        # strictly higher priority than timers :/
        $id = Tk::after $mw, 0 => [sub {
           $id = Tk::after $mw, idle => [$_[0], $_[0]];
        }, $_[0]];
        &$cb;
     };
  
     $id = Tk::after $mw, idle => [$rcb, $rcb];
     bless \\$id, "AnyEvent::Impl::Tk::after"
  }
  
  sub AnyEvent::Impl::Tk::after::DESTROY {
     Tk::after $mw, cancel => $${$_[0]};
  }
  
  #sub loop {
  #   Tk::MainLoop;
  #}
  
  sub _poll {
     Tk::DoOneEvent (0);
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Tk::DoOneEvent (0) until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Tk>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  
DARWIN-2LEVEL_ANYEVENT_IMPL_TK

$fatpacked{"darwin-2level/AnyEvent/Log.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_LOG';
  =head1 NAME
  
  AnyEvent::Log - simple logging "framework"
  
  =head1 SYNOPSIS
  
  Simple uses:
  
     use AnyEvent;
  
     AE::log trace => "going to call function abc";
     AE::log debug => "the function returned 3";
     AE::log info  => "file soandso successfully deleted";
     AE::log note  => "wanted to create config, but config was alraedy created";
     AE::log warn  => "couldn't delete the file";
     AE::log error => "failed to retrieve data";
     AE::log crit  => "the battery temperature is too hot";
     AE::log alert => "the battery died";
     AE::log fatal => "no config found, cannot continue"; # never returns
  
  Log level overview:
  
     LVL NAME      SYSLOG   PERL  NOTE
      1  fatal     emerg    exit  system unusable, aborts program!
      2  alert                    failure in primary system
      3  critical  crit           failure in backup system
      4  error     err      die   non-urgent program errors, a bug
      5  warn      warning        possible problem, not necessarily error
      6  note      notice         unusual conditions
      7  info                     normal messages, no action required
      8  debug                    debugging messages for development
      9  trace                    copious tracing output
  
  "Complex" uses (for speed sensitive code, e.g. trace/debug messages):
  
     use AnyEvent::Log;
  
     my $tracer = AnyEvent::Log::logger trace => \$my $trace;
  
     $tracer->("i am here") if $trace;
     $tracer->(sub { "lots of data: " . Dumper $self }) if $trace;
  
  Configuration (also look at the EXAMPLES section):
  
     # set logging for the current package to errors and higher only
     AnyEvent::Log::ctx->level ("error");
  
     # set logging level to suppress anything below "notice"
     $AnyEvent::Log::FILTER->level ("notice");
  
     # send all critical and higher priority messages to syslog,
     # regardless of (most) other settings
     $AnyEvent::Log::COLLECT->attach (new AnyEvent::Log::Ctx
        level         => "critical",
        log_to_syslog => "user",
     );
  
  =head1 DESCRIPTION
  
  This module implements a relatively simple "logging framework". It doesn't
  attempt to be "the" logging solution or even "a" logging solution for
  AnyEvent - AnyEvent simply creates logging messages internally, and this
  module more or less exposes the mechanism, with some extra spiff to allow
  using it from other modules as well.
  
  Remember that the default verbosity level is C<0> (C<off>), so nothing
  will be logged, unless you set C<PERL_ANYEVENT_VERBOSE> to a higher number
  before starting your program, or change the logging level at runtime with
  something like:
  
     use AnyEvent::Log;
     $AnyEvent::Log::FILTER->level ("info");
  
  The design goal behind this module was to keep it simple (and small),
  but make it powerful enough to be potentially useful for any module, and
  extensive enough for the most common tasks, such as logging to multiple
  targets, or being able to log into a database.
  
  The module is also usable before AnyEvent itself is initialised, in which
  case some of the functionality might be reduced.
  
  The amount of documentation might indicate otherwise, but the runtime part
  of the module is still just below 300 lines of code.
  
  =head1 LOGGING LEVELS
  
  Logging levels in this module range from C<1> (highest priority) to C<9>
  (lowest priority). Note that the lowest numerical value is the highest
  priority, so when this document says "higher priority" it means "lower
  numerical value".
  
  Instead of specifying levels by name you can also specify them by aliases:
  
     LVL NAME      SYSLOG   PERL  NOTE
      1  fatal     emerg    exit  system unusable, aborts program!
      2  alert                    failure in primary system
      3  critical  crit           failure in backup system
      4  error     err      die   non-urgent program errors, a bug
      5  warn      warning        possible problem, not necessarily error
      6  note      notice         unusual conditions
      7  info                     normal messages, no action required
      8  debug                    debugging messages for development
      9  trace                    copious tracing output
  
  As you can see, some logging levels have multiple aliases - the first one
  is the "official" name, the second one the "syslog" name (if it differs)
  and the third one the "perl" name, suggesting (only!) that you log C<die>
  messages at C<error> priority. The NOTE column tries to provide some
  rationale on how to chose a logging level.
  
  As a rough guideline, levels 1..3 are primarily meant for users of
  the program (admins, staff), and are the only logged to STDERR by
  default. Levels 4..6 are meant for users and developers alike, while
  levels 7..9 are usually meant for developers.
  
  You can normally only log a single message at highest priority level
  (C<1>, C<fatal>), because logging a fatal message will also quit the
  program - so use it sparingly :)
  
  Some methods also offer some extra levels, such as C<0>, C<off>, C<none>
  or C<all> - these are only valid in the methods they are documented for.
  
  =head1 LOGGING FUNCTIONS
  
  These functions allow you to log messages. They always use the caller's
  package as a "logging context". Also, the main logging function C<log> is
  callable as C<AnyEvent::log> or C<AE::log> when the C<AnyEvent> module is
  loaded.
  
  =over 4
  
  =cut
  
  package AnyEvent::Log;
  
  use Carp ();
  use POSIX ();
  
  # layout of a context
  #       0       1         2        3        4,    5
  # [$title, $level, %$slaves, &$logcb, &$fmtcb, $cap]
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  #use AnyEvent::Util (); need to load this in a delayed fashion, as it uses AE::log
  
  our $VERSION = $AnyEvent::VERSION;
  
  our ($COLLECT, $FILTER, $LOG);
  
  our ($now_int, $now_str1, $now_str2);
  
  # Format Time, not public - yet?
  sub ft($) {
     my $i = int $_[0];
     my $f = sprintf "%06d", 1e6 * ($_[0] - $i);
  
     ($now_int, $now_str1, $now_str2) = ($i, split /\x01/, POSIX::strftime "%Y-%m-%d %H:%M:%S.\x01 %z", localtime $i)
        if $now_int != $i;
  
     "$now_str1$f$now_str2"
  }
  
  our %CTX; # all package contexts
  
  # creates a default package context object for the given package
  sub _pkg_ctx($) {
     my $ctx = bless [$_[0], (1 << 10) - 1 - 1, {}], "AnyEvent::Log::Ctx";
  
     # link "parent" package
     my $parent = $_[0] =~ /^(.+)::/
        ? $CTX{$1} ||= &_pkg_ctx ("$1")
        : $COLLECT;
  
     $ctx->[2]{$parent+0} = $parent;
  
     $ctx
  }
  
  =item AnyEvent::Log::log $level, $msg[, @args]
  
  Requests logging of the given C<$msg> with the given log level, and
  returns true if the message was logged I<somewhere>.
  
  For loglevel C<fatal>, the program will abort.
  
  If only a C<$msg> is given, it is logged as-is. With extra C<@args>, the
  C<$msg> is interpreted as an sprintf format string.
  
  The C<$msg> should not end with C<\n>, but may if that is convenient for
  you. Also, multiline messages are handled properly.
  
  Last not least, C<$msg> might be a code reference, in which case it is
  supposed to return the message. It will be called only then the message
  actually gets logged, which is useful if it is costly to create the
  message in the first place.
  
  This function takes care of saving and restoring C<$!> and C<$@>, so you
  don't have to.
  
  Whether the given message will be logged depends on the maximum log level
  and the caller's package. The return value can be used to ensure that
  messages or not "lost" - for example, when L<AnyEvent::Debug> detects a
  runtime error it tries to log it at C<die> level, but if that message is
  lost it simply uses warn.
  
  Note that you can (and should) call this function as C<AnyEvent::log> or
  C<AE::log>, without C<use>-ing this module if possible (i.e. you don't
  need any additional functionality), as those functions will load the
  logging module on demand only. They are also much shorter to write.
  
  Also, if you optionally generate a lot of debug messages (such as when
  tracing some code), you should look into using a logger callback and a
  boolean enabler (see C<logger>, below).
  
  Example: log something at error level.
  
     AE::log error => "something";
  
  Example: use printf-formatting.
  
     AE::log info => "%5d %-10.10s %s", $index, $category, $msg;
  
  Example: only generate a costly dump when the message is actually being logged.
  
     AE::log debug => sub { require Data::Dump; Data::Dump::dump \%cache };
  
  =cut
  
  # also allow syslog equivalent names
  our %STR2LEVEL = (
     fatal    => 1, emerg    => 1, exit => 1,
     alert    => 2,
     critical => 3, crit     => 3,
     error    => 4, err      => 4, die  => 4,
     warn     => 5, warning  => 5,
     note     => 6, notice   => 6,
     info     => 7,
     debug    => 8,
     trace    => 9,
  );
  
  our $TIME_EXACT;
  
  sub exact_time($) {
     $TIME_EXACT = shift;
     *_ts = $AnyEvent::MODEL
        ? $TIME_EXACT ? \&AE::now : \&AE::time
        : sub () { $TIME_EXACT ? do { require Time::HiRes; Time::HiRes::time () } : time };
  }
  
  BEGIN {
     exact_time 0;
  }
  
  AnyEvent::post_detect {
     exact_time $TIME_EXACT;
  };
  
  our @LEVEL2STR = qw(0 fatal alert crit error warn note info debug trace);
  
  # time, ctx, level, msg
  sub _format($$$$) {
     my $ts = ft $_[0];
     my $ct = " ";
  
     my @res;
  
     for (split /\n/, sprintf "%-5s %s: %s", $LEVEL2STR[$_[2]], $_[1][0], $_[3]) {
        push @res, "$ts$ct$_\n";
        $ct = " + ";
     }
  
     join "", @res
  }
  
  sub fatal_exit() {
     exit 1;
  }
  
  sub _log {
     my ($ctx, $level, $format, @args) = @_;
  
     $level = $level > 0 && $level <= 9
              ? $level+0
              : $STR2LEVEL{$level} || Carp::croak "$level: not a valid logging level, caught";
  
     my $mask = 1 << $level;
  
     my ($success, %seen, @ctx, $now, @fmt);
  
     do
        {
           # if !ref, then it's a level number
           if (!ref $ctx) {
              $level = $ctx;
           } elsif ($ctx->[1] & $mask and !$seen{$ctx+0}++) {
              # logging/recursing into this context
  
              # level cap
              if ($ctx->[5] > $level) {
                 push @ctx, $level; # restore level when going up in tree
                 $level = $ctx->[5];
              }
  
              # log if log cb
              if ($ctx->[3]) {
                 # logging target found
  
                 local ($!, $@);
  
                 # now get raw message, unless we have it already
                 unless ($now) {
                    $format = $format->() if ref $format;
                    $format = sprintf $format, @args if @args;
                    $format =~ s/\n$//;
                    $now = _ts;
                 };
  
                 # format msg
                 my $str = $ctx->[4]
                    ? $ctx->[4]($now, $_[0], $level, $format)
                    : ($fmt[$level] ||= _format $now, $_[0], $level, $format);
  
                 $success = 1;
  
                 $ctx->[3]($str)
                    or push @ctx, values %{ $ctx->[2] }; # not consumed - propagate
              } else {
                 push @ctx, values %{ $ctx->[2] }; # not masked - propagate
              }
           }
        }
     while $ctx = pop @ctx;
  
     fatal_exit if $level <= 1;
  
     $success
  }
  
  sub log($$;@) {
     _log
        $CTX{ (caller)[0] } ||= _pkg_ctx +(caller)[0],
        @_;
  }
  
  =item $logger = AnyEvent::Log::logger $level[, \$enabled]
  
  Creates a code reference that, when called, acts as if the
  C<AnyEvent::Log::log> function was called at this point with the given
  level. C<$logger> is passed a C<$msg> and optional C<@args>, just as with
  the C<AnyEvent::Log::log> function:
  
     my $debug_log = AnyEvent::Log::logger "debug";
  
     $debug_log->("debug here");
     $debug_log->("%06d emails processed", 12345);
     $debug_log->(sub { $obj->as_string });
  
  The idea behind this function is to decide whether to log before actually
  logging - when the C<logger> function is called once, but the returned
  logger callback often, then this can be a tremendous speed win.
  
  Despite this speed advantage, changes in logging configuration will
  still be reflected by the logger callback, even if configuration changes
  I<after> it was created.
  
  To further speed up logging, you can bind a scalar variable to the logger,
  which contains true if the logger should be called or not - if it is
  false, calling the logger can be safely skipped. This variable will be
  updated as long as C<$logger> is alive.
  
  Full example:
  
     # near the init section
     use AnyEvent::Log;
  
     my $debug_log = AnyEvent:Log::logger debug => \my $debug;
  
     # and later in your program
     $debug_log->("yo, stuff here") if $debug;
  
     $debug and $debug_log->("123");
  
  =cut
  
  our %LOGGER;
  
  # re-assess logging status for all loggers
  sub _reassess {
     local $SIG{__DIE__};
     my $die = sub { die };
  
     for (@_ ? $LOGGER{$_[0]} : values %LOGGER) {
        my ($ctx, $level, $renabled) = @$_;
  
        # to detect whether a message would be logged, we actually
        # try to log one and die. this isn't fast, but we can be
        # sure that the logging decision is correct :)
  
        $$renabled = !eval {
           _log $ctx, $level, $die;
  
           1
        };
     }
  }
  
  sub _logger {
     my ($ctx, $level, $renabled) = @_;
  
     $$renabled = 1;
  
     my $logger = [$ctx, $level, $renabled];
  
     $LOGGER{$logger+0} = $logger;
  
     _reassess $logger+0;
  
     require AnyEvent::Util unless $AnyEvent::Util::VERSION;
     my $guard = AnyEvent::Util::guard (sub {
        # "clean up"
        delete $LOGGER{$logger+0};
     });
  
     sub {
        $guard if 0; # keep guard alive, but don't cause runtime overhead
  
        _log $ctx, $level, @_
           if $$renabled;
     }
  }
  
  sub logger($;$) {
     _logger
        $CTX{ (caller)[0] } ||= _pkg_ctx +(caller)[0],
        @_
  }
  
  =item AnyEvent::Log::exact_time $on
  
  By default, C<AnyEvent::Log> will use C<AE::now>, i.e. the cached
  eventloop time, for the log timestamps. After calling this function with a
  true value it will instead resort to C<AE::time>, i.e. fetch the current
  time on each log message. This only makes a difference for event loops
  that actually cache the time (such as L<EV> or L<AnyEvent::Loop>).
  
  This setting can be changed at any time by calling this function.
  
  Since C<AnyEvent::Log> has to work even before the L<AnyEvent> has been
  initialised, this switch will also decide whether to use C<CORE::time> or
  C<Time::HiRes::time> when logging a message before L<AnyEvent> becomes
  available.
  
  =back
  
  =head1 LOGGING CONTEXTS
  
  This module associates every log message with a so-called I<logging
  context>, based on the package of the caller. Every perl package has its
  own logging context.
  
  A logging context has three major responsibilities: filtering, logging and
  propagating the message.
  
  For the first purpose, filtering, each context has a set of logging
  levels, called the log level mask. Messages not in the set will be ignored
  by this context (masked).
  
  For logging, the context stores a formatting callback (which takes the
  timestamp, context, level and string message and formats it in the way
  it should be logged) and a logging callback (which is responsible for
  actually logging the formatted message and telling C<AnyEvent::Log>
  whether it has consumed the message, or whether it should be propagated).
  
  For propagation, a context can have any number of attached I<slave
  contexts>. Any message that is neither masked by the logging mask nor
  masked by the logging callback returning true will be passed to all slave
  contexts.
  
  Each call to a logging function will log the message at most once per
  context, so it does not matter (much) if there are cycles or if the
  message can arrive at the same context via multiple paths.
  
  =head2 DEFAULTS
  
  By default, all logging contexts have an full set of log levels ("all"), a
  disabled logging callback and the default formatting callback.
  
  Package contexts have the package name as logging title by default.
  
  They have exactly one slave - the context of the "parent" package. The
  parent package is simply defined to be the package name without the last
  component, i.e. C<AnyEvent::Debug::Wrapped> becomes C<AnyEvent::Debug>,
  and C<AnyEvent> becomes ... C<$AnyEvent::Log::COLLECT> which is the
  exception of the rule - just like the "parent" of any single-component
  package name in Perl is C<main>, the default slave of any top-level
  package context is C<$AnyEvent::Log::COLLECT>.
  
  Since perl packages form only an approximate hierarchy, this slave
  context can of course be removed.
  
  All other (anonymous) contexts have no slaves and an empty title by
  default.
  
  When the module is loaded it creates the C<$AnyEvent::Log::LOG> logging
  context that simply logs everything via C<warn>, without propagating
  anything anywhere by default.  The purpose of this context is to provide
  a convenient place to override the global logging target or to attach
  additional log targets. It's not meant for filtering.
  
  It then creates the C<$AnyEvent::Log::FILTER> context whose
  purpose is to suppress all messages with priority higher
  than C<$ENV{PERL_ANYEVENT_VERBOSE}>. It then attached the
  C<$AnyEvent::Log::LOG> context to it. The purpose of the filter context
  is to simply provide filtering according to some global log level.
  
  Finally it creates the top-level package context C<$AnyEvent::Log::COLLECT>
  and attaches the C<$AnyEvent::Log::FILTER> context to it, but otherwise
  leaves it at default config. Its purpose is simply to collect all log
  messages system-wide.
  
  The hierarchy is then:
  
     any package, eventually -> $COLLECT -> $FILTER -> $LOG
  
  The effect of all this is that log messages, by default, wander up to the
  C<$AnyEvent::Log::COLLECT> context where all messages normally end up,
  from there to C<$AnyEvent::Log::FILTER> where log messages with lower
  priority then C<$ENV{PERL_ANYEVENT_VERBOSE}> will be filtered out and then
  to the C<$AnyEvent::Log::LOG> context to be passed to C<warn>.
  
  This makes it easy to set a global logging level (by modifying $FILTER),
  but still allow other contexts to send, for example, their debug and trace
  messages to the $LOG target despite the global logging level, or to attach
  additional log targets that log messages, regardless of the global logging
  level.
  
  It also makes it easy to modify the default warn-logger ($LOG) to
  something that logs to a file, or to attach additional logging targets
  (such as loggign to a file) by attaching it to $FILTER.
  
  =head2 CREATING/FINDING/DESTROYING CONTEXTS
  
  =over 4
  
  =item $ctx = AnyEvent::Log::ctx [$pkg]
  
  This function creates or returns a logging context (which is an object).
  
  If a package name is given, then the context for that packlage is
  returned. If it is called without any arguments, then the context for the
  callers package is returned (i.e. the same context as a C<AE::log> call
  would use).
  
  If C<undef> is given, then it creates a new anonymous context that is not
  tied to any package and is destroyed when no longer referenced.
  
  =cut
  
  sub ctx(;$) {
     my $pkg = @_ ? shift : (caller)[0];
  
     ref $pkg
        ? $pkg
        : defined $pkg
           ? $CTX{$pkg} ||= AnyEvent::Log::_pkg_ctx $pkg
           : bless [undef, (1 << 10) - 1 - 1], "AnyEvent::Log::Ctx"
  }
  
  =item AnyEvent::Log::reset
  
  Resets all package contexts and recreates the default hierarchy if
  necessary, i.e. resets the logging subsystem to defaults, as much as
  possible. This process keeps references to contexts held by other parts of
  the program intact.
  
  This can be used to implement config-file (re-)loading: before loading a
  configuration, reset all contexts.
  
  =cut
  
  our $ORIG_VERBOSE = $AnyEvent::VERBOSE;
  $AnyEvent::VERBOSE = 9;
  
  sub reset {
     # hard to kill complex data structures
     # we "recreate" all package loggers and reset the hierarchy
     while (my ($k, $v) = each %CTX) {
        @$v = ($k, (1 << 10) - 1 - 1, { });
  
        $v->attach ($k =~ /^(.+)::/ ? $CTX{$1} : $AnyEvent::Log::COLLECT);
     }
  
     @$_ = ($_->[0], (1 << 10) - 1 - 1)
        for $LOG, $FILTER, $COLLECT;
  
     #$LOG->slaves;
     $LOG->title ('$AnyEvent::Log::LOG');
     $LOG->log_to_warn;
  
     $FILTER->slaves ($LOG);
     $FILTER->title ('$AnyEvent::Log::FILTER');
     $FILTER->level ($ORIG_VERBOSE);
  
     $COLLECT->slaves ($FILTER);
     $COLLECT->title ('$AnyEvent::Log::COLLECT');
  
     _reassess;
  }
  
  # override AE::log/logger
  *AnyEvent::log    = *AE::log    = \&log;
  *AnyEvent::logger = *AE::logger = \&logger;
  
  # convert AnyEvent loggers to AnyEvent::Log loggers
  $_->[0] = ctx $_->[0] # convert "pkg" to "ctx"
     for values %LOGGER;
  
  # create the default logger contexts
  $LOG     = ctx undef;
  $FILTER  = ctx undef;
  $COLLECT = ctx undef;
  
  AnyEvent::Log::reset;
  
  # hello, CPAN, please catch me
  package AnyEvent::Log::LOG;
  package AE::Log::LOG;
  package AnyEvent::Log::FILTER;
  package AE::Log::FILTER;
  package AnyEvent::Log::COLLECT;
  package AE::Log::COLLECT;
  
  package AnyEvent::Log::Ctx;
  
  =item $ctx = new AnyEvent::Log::Ctx methodname => param...
  
  This is a convenience constructor that makes it simpler to construct
  anonymous logging contexts.
  
  Each key-value pair results in an invocation of the method of the same
  name as the key with the value as parameter, unless the value is an
  arrayref, in which case it calls the method with the contents of the
  array. The methods are called in the same order as specified.
  
  Example: create a new logging context and set both the default logging
  level, some slave contexts and a logging callback.
  
     $ctx = new AnyEvent::Log::Ctx
        title   => "dubious messages",
        level   => "error",
        log_cb  => sub { print STDOUT shift; 0 },
        slaves  => [$ctx1, $ctx, $ctx2],
     ;
  
  =back
  
  =cut
  
  sub new {
     my $class = shift;
  
     my $ctx = AnyEvent::Log::ctx undef;
  
     while (@_) {
        my ($k, $v) = splice @_, 0, 2;
        $ctx->$k (ref $v eq "ARRAY" ? @$v : $v);
     }
  
     bless $ctx, $class # do we really support subclassing, hmm?
  }
  
  
  =head2 CONFIGURING A LOG CONTEXT
  
  The following methods can be used to configure the logging context.
  
  =over 4
  
  =item $ctx->title ([$new_title])
  
  Returns the title of the logging context - this is the package name, for
  package contexts, and a user defined string for all others.
  
  If C<$new_title> is given, then it replaces the package name or title.
  
  =cut
  
  sub title {
     $_[0][0] = $_[1] if @_ > 1;
     $_[0][0]
  }
  
  =back
  
  =head3 LOGGING LEVELS
  
  The following methods deal with the logging level set associated with the
  log context.
  
  The most common method to use is probably C<< $ctx->level ($level) >>,
  which configures the specified and any higher priority levels.
  
  All functions which accept a list of levels also accept the special string
  C<all> which expands to all logging levels.
  
  =over 4
  
  =item $ctx->levels ($level[, $level...)
  
  Enables logging for the given levels and disables it for all others.
  
  =item $ctx->level ($level)
  
  Enables logging for the given level and all lower level (higher priority)
  ones. In addition to normal logging levels, specifying a level of C<0> or
  C<off> disables all logging for this level.
  
  Example: log warnings, errors and higher priority messages.
  
     $ctx->level ("warn");
     $ctx->level (5); # same thing, just numeric
  
  =item $ctx->enable ($level[, $level...])
  
  Enables logging for the given levels, leaving all others unchanged.
  
  =item $ctx->disable ($level[, $level...])
  
  Disables logging for the given levels, leaving all others unchanged.
  
  =item $ctx->cap ($level)
  
  Caps the maximum priority to the given level, for all messages logged
  to, or passing through, this context. That is, while this doesn't affect
  whether a message is logged or passed on, the maximum priority of messages
  will be limited to the specified level - messages with a higher priority
  will be set to the specified priority.
  
  Another way to view this is that C<< ->level >> filters out messages with
  a too low priority, while C<< ->cap >> modifies messages with a too high
  priority.
  
  This is useful when different log targets have different interpretations
  of priority. For example, for a specific command line program, a wrong
  command line switch might well result in a C<fatal> log message, while the
  same message, logged to syslog, is likely I<not> fatal to the system or
  syslog facility as a whole, but more likely a mere C<error>.
  
  This can be modeled by having a stderr logger that logs messages "as-is"
  and a syslog logger that logs messages with a level cap of, say, C<error>,
  or, for truly system-critical components, actually C<critical>.
  
  =cut
  
  sub _lvl_lst {
     map {
        $_ > 0 && $_ <= 9 ? $_+0
        : $_ eq "all"     ? (1 .. 9)
        : $STR2LEVEL{$_} || Carp::croak "$_: not a valid logging level, caught"
     } @_
  }
  
  sub _lvl {
     $_[0] =~ /^(?:0|off|none)$/ ? 0 : (_lvl_lst $_[0])[-1]
  }
  
  our $NOP_CB = sub { 0 };
  
  sub levels {
     my $ctx = shift;
     $ctx->[1] = 0;
     $ctx->[1] |= 1 << $_
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub level {
     my $ctx = shift;
     $ctx->[1] = ((1 << &_lvl) - 1) << 1;
     AnyEvent::Log::_reassess;
  }
  
  sub enable {
     my $ctx = shift;
     $ctx->[1] |= 1 << $_
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub disable {
     my $ctx = shift;
     $ctx->[1] &= ~(1 << $_)
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub cap {
     my $ctx = shift;
     $ctx->[5] = &_lvl;
  }
  
  =back
  
  =head3 SLAVE CONTEXTS
  
  The following methods attach and detach another logging context to a
  logging context.
  
  Log messages are propagated to all slave contexts, unless the logging
  callback consumes the message.
  
  =over 4
  
  =item $ctx->attach ($ctx2[, $ctx3...])
  
  Attaches the given contexts as slaves to this context. It is not an error
  to add a context twice (the second add will be ignored).
  
  A context can be specified either as package name or as a context object.
  
  =item $ctx->detach ($ctx2[, $ctx3...])
  
  Removes the given slaves from this context - it's not an error to attempt
  to remove a context that hasn't been added.
  
  A context can be specified either as package name or as a context object.
  
  =item $ctx->slaves ($ctx2[, $ctx3...])
  
  Replaces all slaves attached to this context by the ones given.
  
  =cut
  
  sub attach {
     my $ctx = shift;
  
     $ctx->[2]{$_+0} = $_
        for map { AnyEvent::Log::ctx $_ } @_;
  }
  
  sub detach {
     my $ctx = shift;
  
     delete $ctx->[2]{$_+0}
        for map { AnyEvent::Log::ctx $_ } @_;
  }
  
  sub slaves {
     undef $_[0][2];
     &attach;
  }
  
  =back
  
  =head3 LOG TARGETS
  
  The following methods configure how the logging context actually does
  the logging (which consists of formatting the message and printing it or
  whatever it wants to do with it).
  
  =over 4
  
  =item $ctx->log_cb ($cb->($str)
  
  Replaces the logging callback on the context (C<undef> disables the
  logging callback).
  
  The logging callback is responsible for handling formatted log messages
  (see C<fmt_cb> below) - normally simple text strings that end with a
  newline (and are possibly multiline themselves).
  
  It also has to return true iff it has consumed the log message, and false
  if it hasn't. Consuming a message means that it will not be sent to any
  slave context. When in doubt, return C<0> from your logging callback.
  
  Example: a very simple logging callback, simply dump the message to STDOUT
  and do not consume it.
  
     $ctx->log_cb (sub { print STDERR shift; 0 });
  
  You can filter messages by having a log callback that simply returns C<1>
  and does not do anything with the message, but this counts as "message
  being logged" and might not be very efficient.
  
  Example: propagate all messages except for log levels "debug" and
  "trace". The messages will still be generated, though, which can slow down
  your program.
  
     $ctx->levels ("debug", "trace");
     $ctx->log_cb (sub { 1 }); # do not log, but eat debug and trace messages
  
  =item $ctx->fmt_cb ($fmt_cb->($timestamp, $orig_ctx, $level, $message))
  
  Replaces the formatting callback on the context (C<undef> restores the
  default formatter).
  
  The callback is passed the (possibly fractional) timestamp, the original
  logging context, the (numeric) logging level and the raw message string
  and needs to return a formatted log message. In most cases this will be a
  string, but it could just as well be an array reference that just stores
  the values.
  
  If, for some reason, you want to use C<caller> to find out more baout the
  logger then you should walk up the call stack until you are no longer
  inside the C<AnyEvent::Log> package.
  
  Example: format just the raw message, with numeric log level in angle
  brackets.
  
     $ctx->fmt_cb (sub {
        my ($time, $ctx, $lvl, $msg) = @_;
  
        "<$lvl>$msg\n"
     });
  
  Example: return an array reference with just the log values, and use
  C<PApp::SQL::sql_exec> to store the emssage in a database.
  
     $ctx->fmt_cb (sub { \@_ });
     $ctx->log_cb (sub {
        my ($msg) = @_;
  
        sql_exec "insert into log (when, subsys, prio, msg) values (?, ?, ?, ?)",
                 $msg->[0] + 0,
                 "$msg->[1]",
                 $msg->[2] + 0,
                 "$msg->[3]";
  
        0
     });
  
  =item $ctx->log_to_warn
  
  Sets the C<log_cb> to simply use C<CORE::warn> to report any messages
  (usually this logs to STDERR).
  
  =item $ctx->log_to_file ($path)
  
  Sets the C<log_cb> to log to a file (by appending), unbuffered.
  
  =item $ctx->log_to_path ($path)
  
  Same as C<< ->log_to_file >>, but opens the file for each message. This
  is much slower, but allows you to change/move/rename/delete the file at
  basically any time.
  
  Needless(?) to say, if you do not want to be bitten by some evil person
  calling C<chdir>, the path should be absolute. Doesn't help with
  C<chroot>, but hey...
  
  =item $ctx->log_to_syslog ([$facility])
  
  Logs all messages via L<Sys::Syslog>, mapping C<trace> to C<debug> and
  all the others in the obvious way. If specified, then the C<$facility> is
  used as the facility (C<user>, C<auth>, C<local0> and so on). The default
  facility is C<user>.
  
  Note that this function also sets a C<fmt_cb> - the logging part requires
  an array reference with [$level, $str] as input.
  
  =cut
  
  sub log_cb {
     my ($ctx, $cb) = @_;
  
     $ctx->[3] = $cb;
  }
  
  sub fmt_cb {
     my ($ctx, $cb) = @_;
  
     $ctx->[4] = $cb;
  }
  
  sub log_to_warn {
     my ($ctx, $path) = @_;
  
     $ctx->log_cb (sub {
        warn shift;
        0
     });
  }
  
  sub log_to_file {
     my ($ctx, $path) = @_;
  
     open my $fh, ">>", $path
        or die "$path: $!";
  
     $ctx->log_cb (sub {
        syswrite $fh, shift;
        0
     });
  }
  
  sub log_to_path {
     my ($ctx, $path) = @_;
  
     $ctx->log_cb (sub {
        open my $fh, ">>", $path
           or die "$path: $!";
  
        syswrite $fh, shift;
        0
     });
  }
  
  sub log_to_syslog {
     my ($ctx, $facility) = @_;
  
     require Sys::Syslog;
  
     $ctx->fmt_cb (sub {
        my $str = $_[3];
        $str =~ s/\n(?=.)/\n+ /g;
  
        [$_[2], "($_[1][0]) $str"]
     });
  
     $facility ||= "user";
  
     $ctx->log_cb (sub {
        my $lvl = $_[0][0] < 9 ? $_[0][0] : 8;
  
        Sys::Syslog::syslog ("$facility|" . ($lvl - 1), $_)
           for split /\n/, $_[0][1];
  
        0
     });
  }
  
  =back
  
  =head3 MESSAGE LOGGING
  
  These methods allow you to log messages directly to a context, without
  going via your package context.
  
  =over 4
  
  =item $ctx->log ($level, $msg[, @params])
  
  Same as C<AnyEvent::Log::log>, but uses the given context as log context.
  
  =item $logger = $ctx->logger ($level[, \$enabled])
  
  Same as C<AnyEvent::Log::logger>, but uses the given context as log
  context.
  
  =cut
  
  *log    = \&AnyEvent::Log::_log;
  *logger = \&AnyEvent::Log::_logger;
  
  =back
  
  =cut
  
  package AnyEvent::Log;
  
  =head1 CONFIGURATION VIA $ENV{PERL_ANYEVENT_LOG}
  
  Logging can also be configured by setting the environment variable
  C<PERL_ANYEVENT_LOG> (or C<AE_LOG>).
  
  The value consists of one or more logging context specifications separated
  by C<:> or whitespace. Each logging specification in turn starts with a
  context name, followed by C<=>, followed by zero or more comma-separated
  configuration directives, here are some examples:
  
     # set default logging level
     filter=warn
  
     # log to file instead of to stderr
     log=file=/tmp/mylog
  
     # log to file in addition to stderr
     log=+%file:%file=file=/tmp/mylog
  
     # enable debug log messages, log warnings and above to syslog
     filter=debug:log=+%warnings:%warnings=warn,syslog=LOG_LOCAL0
  
     # log trace messages (only) from AnyEvent::Debug to file
     AnyEvent::Debug=+%trace:%trace=only,trace,file=/tmp/tracelog
  
  A context name in the log specification can be any of the following:
  
  =over 4
  
  =item C<collect>, C<filter>, C<log>
  
  Correspond to the three predefined C<$AnyEvent::Log::COLLECT>,
  C<AnyEvent::Log::FILTER> and C<$AnyEvent::Log::LOG> contexts.
  
  =item C<%name>
  
  Context names starting with a C<%> are anonymous contexts created when the
  name is first mentioned. The difference to package contexts is that by
  default they have no attached slaves.
  
  =item a perl package name
  
  Any other string references the logging context associated with the given
  Perl C<package>. In the unlikely case where you want to specify a package
  context that matches on of the other context name forms, you can add a
  C<::> to the package name to force interpretation as a package.
  
  =back
  
  The configuration specifications can be any number of the following:
  
  =over 4
  
  =item C<stderr>
  
  Configures the context to use Perl's C<warn> function (which typically
  logs to C<STDERR>). Works like C<log_to_warn>.
  
  =item C<file=>I<path>
  
  Configures the context to log to a file with the given path. Works like
  C<log_to_file>.
  
  =item C<path=>I<path>
  
  Configures the context to log to a file with the given path. Works like
  C<log_to_path>.
  
  =item C<syslog> or C<syslog=>I<expr>
  
  Configures the context to log to syslog. If I<expr> is given, then it is
  evaluated in the L<Sys::Syslog> package, so you could use:
  
     log=syslog=LOG_LOCAL0
  
  =item C<nolog>
  
  Configures the context to not log anything by itself, which is the
  default. Same as C<< $ctx->log_cb (undef) >>.
  
  =item C<cap=>I<level>
  
  Caps logging messages entering this context at the given level, i.e.
  reduces the priority of messages with higher priority than this level. The
  default is C<0> (or C<off>), meaning the priority will not be touched.
  
  =item C<0> or C<off>
  
  Sets the logging level of the context to C<0>, i.e. all messages will be
  filtered out.
  
  =item C<all>
  
  Enables all logging levels, i.e. filtering will effectively be switched
  off (the default).
  
  =item C<only>
  
  Disables all logging levels, and changes the interpretation of following
  level specifications to enable the specified level only.
  
  Example: only enable debug messages for a context.
  
     context=only,debug
  
  =item C<except>
  
  Enables all logging levels, and changes the interpretation of following
  level specifications to disable that level. Rarely used.
  
  Example: enable all logging levels except fatal and trace (this is rather
  nonsensical).
  
     filter=exept,fatal,trace
  
  =item C<level>
  
  Enables all logging levels, and changes the interpretation of following
  level specifications to be "that level or any higher priority
  message". This is the default.
  
  Example: log anything at or above warn level.
  
     filter=warn
  
     # or, more verbose
     filter=only,level,warn
  
  =item C<1>..C<9> or a logging level name (C<error>, C<debug> etc.)
  
  A numeric loglevel or the name of a loglevel will be interpreted according
  to the most recent C<only>, C<except> or C<level> directive. By default,
  specifying a logging level enables that and any higher priority messages.
  
  =item C<+>I<context>
  
  Attaches the named context as slave to the context.
  
  =item C<+>
  
  A line C<+> detaches all contexts, i.e. clears the slave list from the
  context. Anonymous (C<%name>) contexts have no attached slaves by default,
  but package contexts have the parent context as slave by default.
  
  Example: log messages from My::Module to a file, do not send them to the
  default log collector.
  
     My::Module=+,file=/tmp/mymodulelog
  
  =back
  
  Any character can be escaped by prefixing it with a C<\> (backslash), as
  usual, so to log to a file containing a comma, colon, backslash and some
  spaces in the filename, you would do this:
  
     PERL_ANYEVENT_LOG='log=file=/some\ \:file\ with\,\ \\-escapes'
  
  Since whitespace (which includes newlines) is allowed, it is fine to
  specify multiple lines in C<PERL_ANYEVENT_LOG>, e.g.:
  
     PERL_ANYEVENT_LOG="
        filter=warn
        AnyEvent::Debug=+%trace
        %trace=only,trace,+log
     " myprog
  
  Also, in the unlikely case when you want to concatenate specifications,
  use whitespace as separator, as C<::> will be interpreted as part of a
  module name, an empty spec with two separators:
  
     PERL_ANYEVENT_LOG="$PERL_ANYEVENT_LOG MyMod=debug"
  
  =cut
  
  for (my $spec = $ENV{PERL_ANYEVENT_LOG}) {
     my %anon;
  
     my $pkg = sub {
        $_[0] eq "log"              ? $LOG
        : $_[0] eq "filter"         ? $FILTER
        : $_[0] eq "collect"        ? $COLLECT
        : $_[0] =~ /^%(.+)$/        ? ($anon{$1} ||= do { my $ctx = ctx undef; $ctx->[0] = $_[0]; $ctx })
        : $_[0] =~ /^(.*?)(?:::)?$/ ? ctx "$1" # egad :/
        : die # never reached?
     };
  
     /\G[[:space:]]+/gc; # skip initial whitespace
  
     while (/\G((?:[^:=[:space:]]+|::|\\.)+)=/gc) {
        my $ctx = $pkg->($1);
        my $level = "level";
  
        while (/\G((?:[^,:[:space:]]+|::|\\.)+)/gc) {
           for ("$1") {
              if ($_ eq "stderr"               ) { $ctx->log_to_warn;
              } elsif (/^file=(.+)/            ) { $ctx->log_to_file ("$1");
              } elsif (/^path=(.+)/            ) { $ctx->log_to_path ("$1");
              } elsif (/^syslog(?:=(.*))?/     ) { require Sys::Syslog; $ctx->log_to_syslog ("$1");
              } elsif ($_ eq "nolog"           ) { $ctx->log_cb (undef);
              } elsif (/^cap=(.+)/             ) { $ctx->cap ("$1");
              } elsif (/^\+(.+)$/              ) { $ctx->attach ($pkg->("$1"));
              } elsif ($_ eq "+"               ) { $ctx->slaves;
              } elsif ($_ eq "off" or $_ eq "0") { $ctx->level (0);
              } elsif ($_ eq "all"             ) { $ctx->level ("all");
              } elsif ($_ eq "level"           ) { $ctx->level ("all"); $level = "level";
              } elsif ($_ eq "only"            ) { $ctx->level ("off"); $level = "enable";
              } elsif ($_ eq "except"          ) { $ctx->level ("all"); $level = "disable";
              } elsif (/^\d$/                  ) { $ctx->$level ($_);
              } elsif (exists $STR2LEVEL{$_}   ) { $ctx->$level ($_);
              } else                             { die "PERL_ANYEVENT_LOG ($spec): parse error at '$_'\n";
              }
           }
  
           /\G,/gc or last;
        }
  
        /\G[:[:space:]]+/gc or last;
     }
  
     /\G[[:space:]]+/gc; # skip trailing whitespace
  
     if (/\G(.+)/g) {
        die "PERL_ANYEVENT_LOG ($spec): parse error at '$1'\n";
     }
  }
  
  1;
  
  =head1 EXAMPLES
  
  This section shows some common configurations, both as code, and as
  C<PERL_ANYEVENT_LOG> string.
  
  =over 4
  
  =item Setting the global logging level.
  
  Either put C<PERL_ANYEVENT_VERBOSE=><number> into your environment before
  running your program, use C<PERL_ANYEVENT_LOG> or modify the log level of
  the root context at runtime:
  
     PERL_ANYEVENT_VERBOSE=5 ./myprog
  
     PERL_ANYEVENT_LOG=log=warn
  
     $AnyEvent::Log::FILTER->level ("warn");
  
  =item Append all messages to a file instead of sending them to STDERR.
  
  This is affected by the global logging level.
  
     $AnyEvent::Log::LOG->log_to_file ($path);
  
     PERL_ANYEVENT_LOG=log=file=/some/path
  
  =item Write all messages with priority C<error> and higher to a file.
  
  This writes them only when the global logging level allows it, because
  it is attached to the default context which is invoked I<after> global
  filtering.
  
     $AnyEvent::Log::FILTER->attach (
        new AnyEvent::Log::Ctx log_to_file => $path);
  
     PERL_ANYEVENT_LOG=filter=+%filelogger:%filelogger=file=/some/path
  
  This writes them regardless of the global logging level, because it is
  attached to the toplevel context, which receives all messages I<before>
  the global filtering.
  
     $AnyEvent::Log::COLLECT->attach (
        new AnyEvent::Log::Ctx log_to_file => $path);
  
     PERL_ANYEVENT_LOG=%filelogger=file=/some/path:collect=+%filelogger
  
  In both cases, messages are still written to STDERR.
  
  =item Additionally log all messages with C<warn> and higher priority to
  C<syslog>, but cap at C<error>.
  
  This logs all messages to the default log target, but also logs messages
  with priority C<warn> or higher (and not filtered otherwise) to syslog
  facility C<user>. Messages with priority higher than C<error> will be
  logged with level C<error>.
  
     $AnyEvent::Log::LOG->attach (
        new AnyEvent::Log::Ctx
           level  => "warn",
           cap    => "error",
           syslog => "user",
     );
  
     PERL_ANYEVENT_LOG=log=+%syslog:%syslog=warn,cap=error,syslog
  
  =item Write trace messages (only) from L<AnyEvent::Debug> to the default logging target(s).
  
  Attach the C<$AnyEvent::Log::LOG> context to the C<AnyEvent::Debug>
  context - this simply circumvents the global filtering for trace messages.
  
     my $debug = AnyEvent::Debug->AnyEvent::Log::ctx;
     $debug->attach ($AnyEvent::Log::LOG);
  
     PERL_ANYEVENT_LOG=AnyEvent::Debug=+log
  
  This of course works for any package, not just L<AnyEvent::Debug>, but
  assumes the log level for AnyEvent::Debug hasn't been changed from the
  default.
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_LOG

$fatpacked{"darwin-2level/AnyEvent/Loop.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_LOOP';
  =head1 NAME
  
  AnyEvent::Loop - AnyEvent's Pure-Perl event loop
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     # use AnyEvent::Loop;
    
     # this module gets loaded automatically when no other loop can be found
  
     # Explicit use:
     use AnyEvent::Loop;
     use AnyEvent;
  
     ...
  
     AnyEvent::Loop::run; # run the event loop
  
  =head1 DESCRIPTION
  
  This module provides an event loop for AnyEvent in case no other event
  loop could be found or loaded. You don't have to do anything to make it
  work with AnyEvent except by possibly loading it before creating the first
  AnyEvent watcher.
  
  This module is I<not> some loop abstracion used by AnyEvent, but just
  another event loop like EV or Glib, just written in pure perl and
  delivered with AnyEvent, so AnyEvent always works, even in the absence of
  any other backend.
  
  If you want to use this module instead of autoloading a potentially better
  event loop you can simply load it (and no other event loops) before
  creating the first watcher.
  
  As for performance, this module is on par with (and usually faster than)
  most select/poll-based C event modules such as Event or Glib (it does not
  even come close to EV, though), with respect to I/O watchers. Timers are
  handled less optimally, but for many common tasks, it is still on par with
  event loops written in C.
  
  This event loop has been optimised for the following use cases:
  
  =over 4
  
  =item monotonic clock is available
  
  This module will use the POSIX monotonic clock option (if it can be
  detected at runtime) or the POSIX C<times> function (if the resolution
  is at least 100Hz), in which case it will not suffer adversely from time
  jumps.
  
  If no monotonic clock is available, this module will not attempt to
  correct for time jumps in any way.
  
  The clock chosen will be reported if the environment variable
  C<$PERL_ANYEVENT_VERBOSE> is set to 8 or higher.
  
  =item any number of watchers on one fd
  
  Supporting a large number of watchers per fd is purely a dirty benchmark
  optimisation not relevant in practise. The more common case of having one
  watcher per fd/poll combo is special-cased, however, and therefore fast,
  too.
  
  =item relatively few active fds per C<select> call
  
  This module expects that only a tiny amount of fds is active at any one
  time. This is relatively typical of larger servers (but not the case where
  C<select> traditionally is fast), at the expense of the "dense activity
  case" where most of the fds are active (which suits C<select>).
  
  The optimal implementation of the "dense" case is not much faster, though,
  so the module should behave very well in most cases, subject to the bad
  scalability of C<select> in the presence of a large number of inactive
  file descriptors.
  
  =item lots of timer changes/iteration, or none at all
  
  This module sorts the timer list using perl's C<sort>, even though a total
  ordering is not required for timers internally.
  
  This sorting is expensive, but means sorting can be avoided unless the
  timer list has changed in a way that requires a new sort.
  
  This means that adding lots of timers is very efficient, as well as not
  changing the timers. Advancing timers (e.g. recreating a timeout watcher
  on activity) is also relatively efficient, for example, if you have a
  large number of timeout watchers that time out after 10 seconds, then the
  timer list will be sorted only once every 10 seconds.
  
  This should not have much of an impact unless you have hundreds or
  thousands of timers, though, or your timers have very small timeouts.
  
  =back
  
  =head1 FUNCTIONS
  
  The only user-visible functions provided by this module loop related -
  watchers are created via the normal AnyEvent mechanisms.
  
  =over 4
  
  =item AnyEvent::Loop::run
  
  Run the event loop, usually the last thing done in the main program when
  you want to use the pure-perl backend.
  
  =item AnyEvent::Loop::one_event
  
  Blocks until at least one new event has been received by the operating
  system, whether or not it was AnyEvent-related.
  
  =back
  
  =cut
  
  package AnyEvent::Loop;
  
  use Scalar::Util qw(weaken);
  use List::Util ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  
  our $VERSION = $AnyEvent::VERSION;
  
  our ($NOW, $MNOW);
  
  sub MAXWAIT() { 3600 } # never sleep for longer than this many seconds
  
  BEGIN {
     local $SIG{__DIE__};
     my $time_hires = eval "use Time::HiRes (); 1";
     my $clk_tck    = eval "use POSIX (); POSIX::sysconf (POSIX::_SC_CLK_TCK ())";
     my $round; # actual granularity
  
     if ($time_hires && eval "&Time::HiRes::clock_gettime (Time::HiRes::CLOCK_MONOTONIC ())") {
        AE::log 8 => "AnyEvent::Loop: using CLOCK_MONOTONIC as timebase.";
        *_update_clock = sub {
           $NOW  = &Time::HiRes::time;
           $MNOW = Time::HiRes::clock_gettime (&Time::HiRes::CLOCK_MONOTONIC);
        };
  
     } elsif (100 <= $clk_tck && $clk_tck <= 1000000 && eval { (POSIX::times ())[0] != -1 }) { # -1 is also a valid return value :/
        AE::log 8 => "AnyEvent::Loop: using POSIX::times (monotonic) as timebase.";
        my $HZ1 = 1 / $clk_tck;
  
        my $last = (POSIX::times ())[0];
        my $next;
        *_update_clock = sub {
           $NOW  = time; # d'oh
  
           $next = (POSIX::times ())[0];
           # we assume 32 bit signed on wrap but 64 bit will never wrap
           $last -= 4294967296 if $last > $next; # 0x100000000, but perl has probelsm with big hex constants
           $MNOW += ($next - $last) * $HZ1;
           $last = $next;
        };
  
        $round = $HZ1;
  
     } elsif (eval "use Time::HiRes (); 1") {
        AE::log 8 => "AnyEvent::Loop: using Time::HiRes::time (non-monotonic) clock as timebase.";
        *_update_clock = sub {
           $NOW = $MNOW = &Time::HiRes::time;
        };
  
     } else {
        AE::log fatal => "FATAL: unable to find sub-second time source (is this really perl 5.8.0 or later?)";
     }
  
     $round = 0.001 if $round < 0.001; # 1ms is enough for us
     $round -= $round * 1e-2; # 0.1 => 0.099
     eval "sub ROUNDUP() { $round }";
  }
  
  _update_clock;
  
  # rely on AnyEvent:Base::time to provide time
  sub now       () { $NOW          }
  sub now_update() { _update_clock }
  
  # fds[0] is for read, fds[1] is for write watchers
  # fds[poll][V] is the bitmask for select
  # fds[poll][W][fd] contains a list of i/o watchers
  # an I/O watcher is a blessed arrayref containing [fh, poll(0/1), callback, queue-index]
  # the queue-index is simply the index in the [W] array, which is only used to improve
  # benchmark results in the synthetic "many watchers on one fd" benchmark.
  my @fds = ([], []);
  sub V() { 0 }
  sub W() { 1 }
  
  my $need_sort = 1e300; # when to re-sort timer list
  my @timer; # list of [ abs-timeout, Timer::[callback] ]
  my @idle;  # list of idle callbacks
  
  # the pure perl mainloop
  sub one_event {
     _update_clock;
  
     # first sort timers if required (slow)
     if ($MNOW >= $need_sort) {
        $need_sort = 1e300;
        @timer = sort { $a->[0] <=> $b->[0] } @timer;
     }
  
     # handle all pending timers
     if (@timer && $timer[0][0] <= $MNOW) {
        do {
           my $timer = shift @timer;
           $timer->[1] && $timer->[1]($timer);
        } while @timer && $timer[0][0] <= $MNOW;
  
     } else {
        # poll for I/O events, we do not do this when there
        # were any pending timers to ensure that one_event returns
        # quickly when some timers have been handled
        my ($wait, @vec, $fds)
           = (@timer && $timer[0][0] < $need_sort ? $timer[0][0] : $need_sort) - $MNOW;
  
        $wait = $wait < MAXWAIT ? $wait + ROUNDUP : MAXWAIT;
        $wait = 0 if @idle;
  
        $fds = CORE::select
          $vec[0] = $fds[0][V],
          $vec[1] = $fds[1][V],
          AnyEvent::WIN32 ? $vec[2] = $fds[1][V] : undef,
          $wait;
  
        _update_clock;
  
        if ($fds > 0) {
           # buggy microshit windows errornously sets exceptfds instead of writefds
           $vec[1] |= $vec[2] if AnyEvent::WIN32;
  
           # prefer write watchers, because they might reduce memory pressure.
           for (1, 0) {
              my $fds = $fds[$_];
  
              # we parse the bitmask by first expanding it into
              # a string of bits
              for (unpack "b*", $vec[$_]) {
                 # and then repeatedly matching a regex against it
                 while (/1/g) {
                    # and use the resulting string position as fd
                    $_ && $_->[2]()
                       for @{ $fds->[W][(pos) - 1] || [] };
                 }
              }
           }
        } elsif (AnyEvent::WIN32 && $fds && $! == AnyEvent::Util::WSAEINVAL) {
           # buggy microshit windoze asks us to route around it
           CORE::select undef, undef, undef, $wait if $wait;
        } elsif (!@timer || $timer[0][0] > $MNOW && !$fds) {
           $$$_ && $$$_->() for @idle = grep $$$_, @idle;
        }
     }
  }
  
  sub run {
     one_event while 1;
  }
  
  sub io($$$) {
     my ($fd, $write, $cb) = @_;
  
     defined ($fd = fileno $fd)
        or $fd = $_[0];
  
     my $self = bless [
        $fd,
        $write,
        $cb,
        # q-idx
     ], "AnyEvent::Loop::io";
  
     my $fds = $fds[$self->[1]];
  
     # add watcher to fds structure
     my $q = $fds->[W][$fd] ||= [];
  
     (vec $fds->[V], $fd, 1) = 1;
  
     $self->[3] = @$q;
     push @$q, $self;
     weaken $q->[-1];
  
     $self
  }
  
  sub AnyEvent::Loop::io::DESTROY {
     my ($self) = @_;
  
     my $fds = $fds[$self->[1]];
  
     # remove watcher from fds structure
     my $fd = $self->[0];
  
     if (@{ $fds->[W][$fd] } == 1) {
        delete $fds->[W][$fd];
        (vec $fds->[V], $fd, 1) = 0;
     } else {
        my $q = $fds->[W][$fd];
        my $last = pop @$q;
  
        if ($last != $self) {
           weaken ($q->[$self->[3]] = $last);
           $last->[3] = $self->[3];
        }
     }
  }
  
  sub timer($$$) {
     my ($after, $interval, $cb) = @_;
     
     my $self;
  
     if ($interval) {
        $self = [$MNOW + $after , sub {
           $_[0][0] = List::Util::max $_[0][0] + $interval, $MNOW;
           push @timer, $_[0];
           weaken $timer[-1];
           $need_sort = $_[0][0] if $_[0][0] < $need_sort;
           &$cb;
        }];
     } else {
        $self = [$MNOW + $after, $cb];
     }
  
     push @timer, $self;
     weaken $timer[-1];
     $need_sort = $self->[0] if $self->[0] < $need_sort;
  
     $self
  }
  
  sub idle($) {
     my $cb = shift;
  
     push @idle, \\$cb;
     weaken ${$idle[-1]};
  
     ${$idle[-1]}
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
  
DARWIN-2LEVEL_ANYEVENT_LOOP

$fatpacked{"darwin-2level/AnyEvent/Socket.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_SOCKET';
  =head1 NAME
  
  AnyEvent::Socket - useful IPv4 and IPv6 stuff. also unix domain sockets. and stuff.
  
  =head1 SYNOPSIS
  
     use AnyEvent::Socket;
     
     tcp_connect "gameserver.deliantra.net", 13327, sub {
        my ($fh) = @_
           or die "gameserver.deliantra.net connect failed: $!";
     
        # enjoy your filehandle
     };
     
     # a simple tcp server
     tcp_server undef, 8888, sub {
        my ($fh, $host, $port) = @_;
     
        syswrite $fh, "The internet is full, $host:$port. Go away!\015\012";
     };
  
  =head1 DESCRIPTION
  
  This module implements various utility functions for handling internet
  protocol addresses and sockets, in an as transparent and simple way as
  possible.
  
  All functions documented without C<AnyEvent::Socket::> prefix are exported
  by default.
  
  =over 4
  
  =cut
  
  package AnyEvent::Socket;
  
  use Carp ();
  use Errno ();
  use Socket qw(AF_INET AF_UNIX SOCK_STREAM SOCK_DGRAM SOL_SOCKET SO_REUSEADDR);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(guard fh_nonblocking AF_INET6);
  use AnyEvent::DNS ();
  
  use base 'Exporter';
  
  our @EXPORT = qw(
     getprotobyname
     parse_hostport format_hostport
     parse_ipv4 parse_ipv6
     parse_ip parse_address
     format_ipv4 format_ipv6
     format_ip format_address
     address_family
     inet_aton
     tcp_server
     tcp_connect
  );
  
  our $VERSION = $AnyEvent::VERSION;
  
  =item $ipn = parse_ipv4 $dotted_quad
  
  Tries to parse the given dotted quad IPv4 address and return it in
  octet form (or undef when it isn't in a parsable format). Supports all
  forms specified by POSIX (e.g. C<10.0.0.1>, C<10.1>, C<10.0x020304>,
  C<0x12345678> or C<0377.0377.0377.0377>).
  
  =cut
  
  sub parse_ipv4($) {
     $_[0] =~ /^      (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* )
                (?:\. (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* ) ){0,3}$/x
        or return undef;
  
     @_ = map /^0/ ? oct : $_, split /\./, $_[0];
  
     # check leading parts against range
     return undef if grep $_ >= 256, @_[0 .. @_ - 2];
  
     # check trailing part against range
     return undef if $_[-1] >= 2 ** (8 * (4 - $#_));
  
     pack "N", (pop)
               + ($_[0] << 24)
               + ($_[1] << 16)
               + ($_[2] <<  8);
  }
  
  =item $ipn = parse_ipv6 $textual_ipv6_address
  
  Tries to parse the given IPv6 address and return it in
  octet form (or undef when it isn't in a parsable format).
  
  Should support all forms specified by RFC 2373 (and additionally all IPv4
  forms supported by parse_ipv4). Note that scope-id's are not supported
  (and will not parse).
  
  This function works similarly to C<inet_pton AF_INET6, ...>.
  
  Example:
  
     print unpack "H*", parse_ipv6 "2002:5345::10.0.0.1";
     # => 2002534500000000000000000a000001
  
  =cut
  
  sub parse_ipv6($) {
     # quick test to avoid longer processing
     my $n = $_[0] =~ y/://;
     return undef if $n < 2 || $n > 8;
  
     my ($h, $t) = split /::/, $_[0], 2;
  
     unless (defined $t) {
        ($h, $t) = (undef, $h);
     }
  
     my @h = split /:/, $h;
     my @t = split /:/, $t;
  
     # check for ipv4 tail
     if (@t && $t[-1]=~ /\./) {
        return undef if $n > 6;
  
        my $ipn = parse_ipv4 pop @t
           or return undef;
  
        push @t, map +(sprintf "%x", $_), unpack "nn", $ipn;
     }
  
     # no :: then we need to have exactly 8 components
     return undef unless @h + @t == 8 || $_[0] =~ /::/;
  
     # now check all parts for validity
     return undef if grep !/^[0-9a-fA-F]{1,4}$/, @h, @t;
  
     # now pad...
     push @h, 0 while @h + @t < 8;
  
     # and done
     pack "n*", map hex, @h, @t
  }
  
  =item $token = parse_unix $hostname
  
  This fucntion exists mainly for symmetry to the other C<parse_protocol>
  functions - it takes a hostname and, if it is C<unix/>, it returns a
  special address token, otherwise C<undef>.
  
  The only use for this function is probably to detect whether a hostname
  matches whatever AnyEvent uses for unix domain sockets.
  
  =cut
  
  sub parse_unix($) {
     $_[0] eq "unix/"
        ? pack "S", AF_UNIX
        : undef
  
  }
  
  =item $ipn = parse_address $ip
  
  Combines C<parse_ipv4> and C<parse_ipv6> in one function. The address
  here refers to the host address (not socket address) in network form
  (binary).
  
  If the C<$text> is C<unix/>, then this function returns a special token
  recognised by the other functions in this module to mean "UNIX domain
  socket".
  
  If the C<$text> to parse is a mapped IPv4 in IPv6 address (:ffff::<ipv4>),
  then it will be treated as an IPv4 address. If you don't want that, you
  have to call C<parse_ipv4> and/or C<parse_ipv6> manually.
  
  Example:
  
     print unpack "H*", parse_address "10.1.2.3";
     # => 0a010203
  
  =item $ipn = AnyEvent::Socket::aton $ip
  
  Same as C<parse_address>, but not exported (think C<Socket::inet_aton> but
  I<without> name resolution).
  
  =cut
  
  sub parse_address($) {
     for (&parse_ipv6) {
        if ($_) {
           s/^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff//;
           return $_;
        } else {
           return &parse_ipv4 || &parse_unix
        }
     }
  }
  
  *aton = \&parse_address;
  
  =item ($name, $aliases, $proto) = getprotobyname $name
  
  Works like the builtin function of the same name, except it tries hard to
  work even on broken platforms (well, that's windows), where getprotobyname
  is traditionally very unreliable.
  
  Example: get the protocol number for TCP (usually 6)
  
     my $proto = getprotobyname "tcp";
  
  =cut
  
  # microsoft can't even get getprotobyname working (the etc/protocols file
  # gets lost fairly often on windows), so we have to hardcode some common
  # protocol numbers ourselves.
  our %PROTO_BYNAME;
  
  $PROTO_BYNAME{tcp}  = Socket::IPPROTO_TCP () if defined &Socket::IPPROTO_TCP;
  $PROTO_BYNAME{udp}  = Socket::IPPROTO_UDP () if defined &Socket::IPPROTO_UDP;
  $PROTO_BYNAME{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
  
  sub getprotobyname($) {
     my $name = lc shift;
  
     defined (my $proton = $PROTO_BYNAME{$name} || (getprotobyname $name)[2])
        or return;
  
     ($name, uc $name, $proton)
  }
  
  =item ($host, $service) = parse_hostport $string[, $default_service]
  
  Splitting a string of the form C<hostname:port> is a common
  problem. Unfortunately, just splitting on the colon makes it hard to
  specify IPv6 addresses and doesn't support the less common but well
  standardised C<[ip literal]> syntax.
  
  This function tries to do this job in a better way, it supports the
  following formats, where C<port> can be a numerical port number of a
  service name, or a C<name=port> string, and the C< port> and C<:port>
  parts are optional. Also, everywhere where an IP address is supported
  a hostname or unix domain socket address is also supported (see
  C<parse_unix>), and strings starting with C</> will also be interpreted as
  unix domain sockets.
  
     hostname:port    e.g. "www.linux.org", "www.x.de:443", "www.x.de:https=443",
     ipv4:port        e.g. "198.182.196.56", "127.1:22"
     ipv6             e.g. "::1", "affe::1"
     [ipv4or6]:port   e.g. "[::1]", "[10.0.1]:80"
     [ipv4or6] port   e.g. "[127.0.0.1]", "[www.x.org] 17"
     ipv4or6 port     e.g. "::1 443", "10.0.0.1 smtp"
     unix/:path       e.g. "unix/:/path/to/socket"
     /path            e.g. "/path/to/socket"
  
  It also supports defaulting the service name in a simple way by using
  C<$default_service> if no service was detected. If neither a service was
  detected nor a default was specified, then this function returns the
  empty list. The same happens when a parse error was detected, such as a
  hostname with a colon in it (the function is rather conservative, though).
  
  Example:
  
    print join ",", parse_hostport "localhost:443";
    # => "localhost,443"
  
    print join ",", parse_hostport "localhost", "https";
    # => "localhost,https"
  
    print join ",", parse_hostport "[::1]";
    # => "," (empty list)
  
    print join ",", parse_host_port "/tmp/debug.sock";
    # => "unix/", "/tmp/debug.sock"
  
  =cut
  
  sub parse_hostport($;$) {
     my ($host, $port);
  
     for ("$_[0]") { # work on a copy, just in case, and also reset pos
  
        # shortcut for /path
        return ("unix/", $_)
           if m%^/%;
  
        # parse host, special cases: "ipv6" or "ipv6 port"
        unless (
           ($host) = /^\s* ([0-9a-fA-F:]*:[0-9a-fA-F:]*:[0-9a-fA-F\.:]*)/xgc
           and parse_ipv6 $host
        ) {
           /^\s*/xgc;
  
           if (/^ \[ ([^\[\]]+) \]/xgc) {
              $host = $1;
           } elsif (/^ ([^\[\]:\ ]+) /xgc) {
              $host = $1;
           } else {
              return;
           }
        }
  
        # parse port
        if (/\G (?:\s+|:) ([^:[:space:]]+) \s*$/xgc) {
           $port = $1;
        } elsif (/\G\s*$/gc && length $_[1]) {
           $port = $_[1];
        } else {
           return;
        }
  
     }
  
     # hostnames must not contain :'s
     return if $host =~ /:/ && !parse_ipv6 $host;
  
     ($host, $port)
  }
  
  =item $string = format_hostport $host, $port
  
  Takes a host (in textual form) and a port and formats in unambigiously in
  a way that C<parse_hostport> can parse it again. C<$port> can be C<undef>.
  
  =cut
  
  sub format_hostport($;$) {
     my ($host, $port) = @_;
  
     $port = ":$port"  if length $port;
     $host = "[$host]" if $host =~ /:/;
  
     "$host$port"
  }
  
  =item $sa_family = address_family $ipn
  
  Returns the address family/protocol-family (AF_xxx/PF_xxx, in one value :)
  of the given host address in network format.
  
  =cut
  
  sub address_family($) {
     4 == length $_[0]
        ? AF_INET
        : 16 == length $_[0]
           ? AF_INET6
           : unpack "S", $_[0]
  }
  
  =item $text = format_ipv4 $ipn
  
  Expects a four octet string representing a binary IPv4 address and returns
  its textual format. Rarely used, see C<format_address> for a nicer
  interface.
  
  =item $text = format_ipv6 $ipn
  
  Expects a sixteen octet string representing a binary IPv6 address and
  returns its textual format. Rarely used, see C<format_address> for a
  nicer interface.
  
  =item $text = format_address $ipn
  
  Covnvert a host address in network format (e.g. 4 octets for IPv4 or 16
  octets for IPv6) and convert it into textual form.
  
  Returns C<unix/> for UNIX domain sockets.
  
  This function works similarly to C<inet_ntop AF_INET || AF_INET6, ...>,
  except it automatically detects the address type.
  
  Returns C<undef> if it cannot detect the type.
  
  If the C<$ipn> is a mapped IPv4 in IPv6 address (:ffff::<ipv4>), then just
  the contained IPv4 address will be returned. If you do not want that, you
  have to call C<format_ipv6> manually.
  
  Example:
  
     print format_address "\x01\x02\x03\x05";
     => 1.2.3.5
  
  =item $text = AnyEvent::Socket::ntoa $ipn
  
  Same as format_address, but not exported (think C<inet_ntoa>).
  
  =cut
  
  sub format_ipv4($) {
     join ".", unpack "C4", $_[0]
  }
  
  sub format_ipv6($) {
     if ($_[0] =~ /^\x00\x00\x00\x00\x00\x00\x00\x00/) {
        if (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 eq $_[0]) {
           return "::";
        } elsif (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1 eq $_[0]) {
           return "::1";
        } elsif (v0.0.0.0.0.0.0.0.0.0.0.0 eq substr $_[0], 0, 12) {
           # v4compatible
           return "::" . format_ipv4 substr $_[0], 12;
        } elsif (v0.0.0.0.0.0.0.0.0.0.255.255 eq substr $_[0], 0, 12) {
           # v4mapped
           return "::ffff:" . format_ipv4 substr $_[0], 12;
        } elsif (v0.0.0.0.0.0.0.0.255.255.0.0 eq substr $_[0], 0, 12) {
           # v4translated
           return "::ffff:0:" . format_ipv4 substr $_[0], 12;
        }
     }
  
     my $ip = sprintf "%x:%x:%x:%x:%x:%x:%x:%x", unpack "n8", $_[0];
  
     # this is admittedly rather sucky
        $ip =~ s/(?:^|:) 0:0:0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)   0:0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)     0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)       0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)         0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)           0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)             0 (?:$|:)/::/x;
  
     $ip
  }
  
  sub format_address($) {
     if (4 == length $_[0]) {
        return &format_ipv4;
     } elsif (16 == length $_[0]) {
        return $_[0] =~ /^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff(....)$/s
           ? format_ipv4 $1
           : &format_ipv6;
     } elsif (AF_UNIX == address_family $_[0]) {
        return "unix/"
     } else {
        return undef
     }
  }
  
  *ntoa = \&format_address;
  
  =item inet_aton $name_or_address, $cb->(@addresses)
  
  Works similarly to its Socket counterpart, except that it uses a
  callback. Use the length to distinguish between ipv4 and ipv6 (4 octets
  for IPv4, 16 for IPv6), or use C<format_address> to convert it to a more
  readable format.
  
  Note that C<resolve_sockaddr>, while initially a more complex interface,
  resolves host addresses, IDNs, service names and SRV records and gives you
  an ordered list of socket addresses to try and should be preferred over
  C<inet_aton>.
  
  Example.
  
     inet_aton "www.google.com", my $cv = AE::cv;
     say unpack "H*", $_
        for $cv->recv;
     # => d155e363
     # => d155e367 etc.
  
     inet_aton "ipv6.google.com", my $cv = AE::cv;
     say unpack "H*", $_
        for $cv->recv;
     # => 20014860a00300000000000000000068
  
  =cut
  
  sub inet_aton {
     my ($name, $cb) = @_;
  
     if (my $ipn = &parse_ipv4) {
        $cb->($ipn);
     } elsif (my $ipn = &parse_ipv6) {
        $cb->($ipn);
     } elsif ($name eq "localhost") { # rfc2606 et al.
        $cb->(v127.0.0.1, v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1);
     } else {
        require AnyEvent::DNS unless $AnyEvent::DNS::VERSION;
  
        my $ipv4 = $AnyEvent::PROTOCOL{ipv4};
        my $ipv6 = $AnyEvent::PROTOCOL{ipv6};
  
        my @res;
  
        my $cv = AE::cv {
           $cb->(map @$_, reverse @res);
        };
  
        $cv->begin;
  
        if ($ipv4) {
           $cv->begin;
           AnyEvent::DNS::a ($name, sub {
              $res[$ipv4] = [map &parse_ipv4, @_];
              $cv->end;
           });
        };
  
        if ($ipv6) {
           $cv->begin;
           AnyEvent::DNS::aaaa ($name, sub {
              $res[$ipv6] = [map &parse_ipv6, @_];
              $cv->end;
           });
        };
  
        $cv->end;
     }
  }
  
  BEGIN {
     *sockaddr_family = $Socket::VERSION >= 1.75
        ? \&Socket::sockaddr_family
        : # for 5.6.x, we need to do something much more horrible
          (Socket::pack_sockaddr_in 0x5555, "\x55\x55\x55\x55"
             | eval { Socket::pack_sockaddr_un "U" }) =~ /^\x00/
             ? sub { unpack "xC", $_[0] }
             : sub { unpack "S" , $_[0] };
  }
  
  # check for broken platforms with an extra field in sockaddr structure
  # kind of a rfc vs. bsd issue, as usual (ok, normally it's a
  # unix vs. bsd issue, a iso C vs. bsd issue or simply a
  # correctness vs. bsd issue.)
  my $pack_family = 0x55 == sockaddr_family ("\x55\x55")
                    ? "xC" : "S";
  
  =item $sa = AnyEvent::Socket::pack_sockaddr $service, $host
  
  Pack the given port/host combination into a binary sockaddr
  structure. Handles both IPv4 and IPv6 host addresses, as well as UNIX
  domain sockets (C<$host> == C<unix/> and C<$service> == absolute
  pathname).
  
  Example:
  
     my $bind = AnyEvent::Socket::pack_sockaddr 43, v195.234.53.120;
     bind $socket, $bind
        or die "bind: $!";
  
  =cut
  
  sub pack_sockaddr($$) {
     my $af = address_family $_[1];
  
     if ($af == AF_INET) {
        Socket::pack_sockaddr_in $_[0], $_[1]
     } elsif ($af == AF_INET6) {
        pack "$pack_family nL a16 L",
           AF_INET6,
           $_[0], # port
           0,     # flowinfo
           $_[1], # addr
           0      # scope id
     } elsif ($af == AF_UNIX) {
        Socket::pack_sockaddr_un $_[0]
     } else {
        Carp::croak "pack_sockaddr: invalid host";
     }
  }
  
  =item ($service, $host) = AnyEvent::Socket::unpack_sockaddr $sa
  
  Unpack the given binary sockaddr structure (as used by bind, getpeername
  etc.) into a C<$service, $host> combination.
  
  For IPv4 and IPv6, C<$service> is the port number and C<$host> the host
  address in network format (binary).
  
  For UNIX domain sockets, C<$service> is the absolute pathname and C<$host>
  is a special token that is understood by the other functions in this
  module (C<format_address> converts it to C<unix/>).
  
  =cut
  
  # perl contains a bug (imho) where it requires that the kernel always returns
  # sockaddr_un structures of maximum length (which is not, AFAICS, required
  # by any standard). try to 0-pad structures for the benefit of those platforms.
  
  my $sa_un_zero = eval { Socket::pack_sockaddr_un "" }; $sa_un_zero ^= $sa_un_zero;
  
  sub unpack_sockaddr($) {
     my $af = sockaddr_family $_[0];
  
     if ($af == AF_INET) {
        Socket::unpack_sockaddr_in $_[0]
     } elsif ($af == AF_INET6) {
        unpack "x2 n x4 a16", $_[0]
     } elsif ($af == AF_UNIX) {
        ((Socket::unpack_sockaddr_un $_[0] ^ $sa_un_zero), pack "S", AF_UNIX)
     } else {
        Carp::croak "unpack_sockaddr: unsupported protocol family $af";
     }
  }
  
  =item resolve_sockaddr $node, $service, $proto, $family, $type, $cb->([$family, $type, $proto, $sockaddr], ...)
  
  Tries to resolve the given nodename and service name into protocol families
  and sockaddr structures usable to connect to this node and service in a
  protocol-independent way. It works remotely similar to the getaddrinfo
  posix function.
  
  For internet addresses, C<$node> is either an IPv4 or IPv6 address, an
  internet hostname (DNS domain name or IDN), and C<$service> is either
  a service name (port name from F</etc/services>) or a numerical port
  number. If both C<$node> and C<$service> are names, then SRV records
  will be consulted to find the real service, otherwise they will be
  used as-is. If you know that the service name is not in your services
  database, then you can specify the service in the format C<name=port>
  (e.g. C<http=80>).
  
  If a host cannot be found via DNS, then it will be looked up in
  F</etc/hosts> (or the file specified via C<< $ENV{PERL_ANYEVENT_HOSTS}
  >>). If they are found, the addresses there will be used. The effect is as
  if entries from F</etc/hosts> would yield C<A> and C<AAAA> records for the
  host name unless DNS already had records for them.
  
  For UNIX domain sockets, C<$node> must be the string C<unix/> and
  C<$service> must be the absolute pathname of the socket. In this case,
  C<$proto> will be ignored.
  
  C<$proto> must be a protocol name, currently C<tcp>, C<udp> or
  C<sctp>. The default is currently C<tcp>, but in the future, this function
  might try to use other protocols such as C<sctp>, depending on the socket
  type and any SRV records it might find.
  
  C<$family> must be either C<0> (meaning any protocol is OK), C<4> (use
  only IPv4) or C<6> (use only IPv6). The default is influenced by
  C<$ENV{PERL_ANYEVENT_PROTOCOLS}>.
  
  C<$type> must be C<SOCK_STREAM>, C<SOCK_DGRAM> or C<SOCK_SEQPACKET> (or
  C<undef> in which case it gets automatically chosen to be C<SOCK_STREAM>
  unless C<$proto> is C<udp>).
  
  The callback will receive zero or more array references that contain
  C<$family, $type, $proto> for use in C<socket> and a binary
  C<$sockaddr> for use in C<connect> (or C<bind>).
  
  The application should try these in the order given.
  
  Example:
  
     resolve_sockaddr "google.com", "http", 0, undef, undef, sub { ... };
  
  =cut
  
  our %HOSTS;
  our $HOSTS;
  
  if (
     open my $fh, "<",
        length $ENV{PERL_ANYEVENT_HOSTS} ? $ENV{PERL_ANYEVENT_HOSTS}
        : AnyEvent::WIN32                ? "$ENV{SystemRoot}/system32/drivers/etc/hosts"
        :                                  "/etc/hosts"
  ) {
     local $/;
     binmode $fh;
     $HOSTS = <$fh>;
  } else {
     $HOSTS = "";
  }
  
  sub _parse_hosts() {
     #%HOSTS = ();
  
     for (split /\n/, $HOSTS) {
        s/#.*$//;
        s/^[ \t]+//;
        y/A-Z/a-z/;
  
        my ($addr, @aliases) = split /[ \t]+/;
        next unless @aliases;
  
        if (my $ip = parse_ipv4 $addr) {
           push @{ $HOSTS{$_}[0] }, $ip
              for @aliases;
        } elsif (my $ip = parse_ipv6 $addr) {
           push @{ $HOSTS{$_}[1] }, $ip
              for @aliases;
        }
     }
  
     undef $HOSTS;
  }
  
  sub resolve_sockaddr($$$$$$) {
     my ($node, $service, $proto, $family, $type, $cb) = @_;
  
     if ($node eq "unix/") {
        return $cb->() if $family || $service !~ /^\//; # no can do
  
        return $cb->([AF_UNIX, defined $type ? $type : SOCK_STREAM, 0, Socket::pack_sockaddr_un $service]);
     }
  
     unless (AF_INET6) {
        $family != 6
           or return $cb->();
  
        $family = 4;
     }
  
     $cb->() if $family == 4 && !$AnyEvent::PROTOCOL{ipv4};
     $cb->() if $family == 6 && !$AnyEvent::PROTOCOL{ipv6};
  
     $family ||= 4 unless $AnyEvent::PROTOCOL{ipv6};
     $family ||= 6 unless $AnyEvent::PROTOCOL{ipv4};
  
     $proto ||= "tcp";
     $type  ||= $proto eq "udp" ? SOCK_DGRAM : SOCK_STREAM;
  
     my $proton = AnyEvent::Socket::getprotobyname $proto
        or Carp::croak "$proto: protocol unknown";
  
     my $port;
  
     if ($service =~ /^(\S+)=(\d+)$/) {
        ($service, $port) = ($1, $2);
     } elsif ($service =~ /^\d+$/) {
        ($service, $port) = (undef, $service);
     } else {
        $port = (getservbyname $service, $proto)[2]
                or Carp::croak "$service/$proto: service unknown";
     }
  
     # resolve a records / provide sockaddr structures
     my $resolve = sub {
        my @target = @_;
  
        my @res;
        my $cv = AE::cv {
           $cb->(
              map $_->[2],
              sort {
                 $AnyEvent::PROTOCOL{$b->[1]} <=> $AnyEvent::PROTOCOL{$a->[1]}
                    or $a->[0] <=> $b->[0]
              }
              @res
           )
        };
  
        $cv->begin;
        for my $idx (0 .. $#target) {
           my ($node, $port) = @{ $target[$idx] };
  
           if (my $noden = parse_address $node) {
              my $af = address_family $noden;
  
              if ($af == AF_INET && $family != 6) {
                 push @res, [$idx, "ipv4", [AF_INET, $type, $proton,
                             pack_sockaddr $port, $noden]]
              }
  
              if ($af == AF_INET6 && $family != 4) {
                 push @res, [$idx, "ipv6", [AF_INET6, $type, $proton,
                             pack_sockaddr $port, $noden]]
              }
           } else {
              $node =~ y/A-Z/a-z/;
  
              my $hosts = $HOSTS{$node};
  
              # a records
              if ($family != 6) {
                 $cv->begin;
                 AnyEvent::DNS::a $node, sub {
                    push @res, [$idx, "ipv4", [AF_INET , $type, $proton, pack_sockaddr $port, parse_ipv4 $_]]
                       for @_;
  
                    # dns takes precedence over hosts
                    push @res,
                       map [$idx, "ipv4", [AF_INET , $type, $proton, pack_sockaddr $port, $_]],
                          @{ $hosts->[0] }
                       unless @_;
  
                    $cv->end;
                 };
              }
  
              # aaaa records
              if ($family != 4) {
                 $cv->begin;
                 AnyEvent::DNS::aaaa $node, sub {
                    push @res, [$idx, "ipv6", [AF_INET6, $type, $proton, pack_sockaddr $port, parse_ipv6 $_]]
                       for @_;
  
                    push @res,
                       map [$idx + 0.5, "ipv6", [AF_INET6, $type, $proton, pack_sockaddr $port, $_]],
                          @{ $hosts->[1] }
                       unless @_;
  
                    $cv->end;
                 };
              }
           }
        }
        $cv->end;
     };
  
     $node = AnyEvent::Util::idn_to_ascii $node
        if $node =~ /[^\x00-\x7f]/;
  
     # parse hosts
     if (defined $HOSTS) {
        _parse_hosts;
        undef &_parse_hosts;
     }
  
     # try srv records, if applicable
     if ($node eq "localhost") {
        $resolve->(["127.0.0.1", $port], ["::1", $port]);
     } elsif (defined $service && !parse_address $node) {
        AnyEvent::DNS::srv $service, $proto, $node, sub {
           my (@srv) = @_;
  
           if (@srv) {
              # the only srv record has "." ("" here) => abort
              $srv[0][2] ne "" || $#srv
                 or return $cb->();
  
              # use srv records then
              $resolve->(
                 map ["$_->[3].", $_->[2]],
                    grep $_->[3] ne ".",
                       @srv
              );
           } else {
              # no srv records, continue traditionally
              $resolve->([$node, $port]);
           }
        };
     } else {
        # most common case
        $resolve->([$node, $port]);
     }
  }
  
  =item $guard = tcp_connect $host, $service, $connect_cb[, $prepare_cb]
  
  This is a convenience function that creates a TCP socket and makes a
  100% non-blocking connect to the given C<$host> (which can be a DNS/IDN
  hostname or a textual IP address, or the string C<unix/> for UNIX domain
  sockets) and C<$service> (which can be a numeric port number or a service
  name, or a C<servicename=portnumber> string, or the pathname to a UNIX
  domain socket).
  
  If both C<$host> and C<$port> are names, then this function will use SRV
  records to locate the real target(s).
  
  In either case, it will create a list of target hosts (e.g. for multihomed
  hosts or hosts with both IPv4 and IPv6 addresses) and try to connect to
  each in turn.
  
  After the connection is established, then the C<$connect_cb> will be
  invoked with the socket file handle (in non-blocking mode) as first, and
  the peer host (as a textual IP address) and peer port as second and third
  arguments, respectively. The fourth argument is a code reference that you
  can call if, for some reason, you don't like this connection, which will
  cause C<tcp_connect> to try the next one (or call your callback without
  any arguments if there are no more connections). In most cases, you can
  simply ignore this argument.
  
     $cb->($filehandle, $host, $port, $retry)
  
  If the connect is unsuccessful, then the C<$connect_cb> will be invoked
  without any arguments and C<$!> will be set appropriately (with C<ENXIO>
  indicating a DNS resolution failure).
  
  The callback will I<never> be invoked before C<tcp_connect> returns, even
  if C<tcp_connect> was able to connect immediately (e.g. on unix domain
  sockets).
  
  The file handle is perfect for being plugged into L<AnyEvent::Handle>, but
  can be used as a normal perl file handle as well.
  
  Unless called in void context, C<tcp_connect> returns a guard object that
  will automatically cancel the connection attempt when it gets destroyed
  - in which case the callback will not be invoked. Destroying it does not
  do anything to the socket after the connect was successful - you cannot
  "uncall" a callback that has been invoked already.
  
  Sometimes you need to "prepare" the socket before connecting, for example,
  to C<bind> it to some port, or you want a specific connect timeout that
  is lower than your kernel's default timeout. In this case you can specify
  a second callback, C<$prepare_cb>. It will be called with the file handle
  in not-yet-connected state as only argument and must return the connection
  timeout value (or C<0>, C<undef> or the empty list to indicate the default
  timeout is to be used).
  
  Note that the socket could be either a IPv4 TCP socket or an IPv6 TCP
  socket (although only IPv4 is currently supported by this module).
  
  Note to the poor Microsoft Windows users: Windows (of course) doesn't
  correctly signal connection errors, so unless your event library works
  around this, failed connections will simply hang. The only event libraries
  that handle this condition correctly are L<EV> and L<Glib>. Additionally,
  AnyEvent works around this bug with L<Event> and in its pure-perl
  backend. All other libraries cannot correctly handle this condition. To
  lessen the impact of this windows bug, a default timeout of 30 seconds
  will be imposed on windows. Cygwin is not affected.
  
  Simple Example: connect to localhost on port 22.
  
     tcp_connect localhost => 22, sub {
        my $fh = shift
           or die "unable to connect: $!";
        # do something
     };
  
  Complex Example: connect to www.google.com on port 80 and make a simple
  GET request without much error handling. Also limit the connection timeout
  to 15 seconds.
  
     tcp_connect "www.google.com", "http",
        sub {
           my ($fh) = @_
              or die "unable to connect: $!";
  
           my $handle; # avoid direct assignment so on_eof has it in scope.
           $handle = new AnyEvent::Handle
              fh     => $fh,
              on_error => sub {
                 AE::log error => "error $_[2]";
                 $_[0]->destroy;
              },
              on_eof => sub {
                 $handle->destroy; # destroy handle
                 AE::log info => "done.";
              };
  
           $handle->push_write ("GET / HTTP/1.0\015\012\015\012");
  
           $handle->push_read (line => "\015\012\015\012", sub {
              my ($handle, $line) = @_;
  
              # print response header
              print "HEADER\n$line\n\nBODY\n";
  
              $handle->on_read (sub {
                 # print response body
                 print $_[0]->rbuf;
                 $_[0]->rbuf = "";
              });
           });
        }, sub {
           my ($fh) = @_;
           # could call $fh->bind etc. here
  
           15
        };
  
  Example: connect to a UNIX domain socket.
  
     tcp_connect "unix/", "/tmp/.X11-unix/X0", sub {
        ...
     }
  
  =cut
  
  sub tcp_connect($$$;$) {
     my ($host, $port, $connect, $prepare) = @_;
  
     # see http://cr.yp.to/docs/connect.html for some tricky aspects
     # also http://advogato.org/article/672.html
  
     my %state = ( fh => undef );
  
     # name/service to type/sockaddr resolution
     resolve_sockaddr $host, $port, 0, 0, undef, sub {
        my @target = @_;
  
        $state{next} = sub {
           return unless exists $state{fh};
  
           my $errno = $!;
           my $target = shift @target
              or return AE::postpone {
                 return unless exists $state{fh};
                 %state = ();
                 $! = $errno;
                 $connect->();
              };
  
           my ($domain, $type, $proto, $sockaddr) = @$target;
  
           # socket creation
           socket $state{fh}, $domain, $type, $proto
              or return $state{next}();
  
           fh_nonblocking $state{fh}, 1;
           
           my $timeout = $prepare && $prepare->($state{fh});
  
           $timeout ||= 30 if AnyEvent::WIN32;
  
           $state{to} = AE::timer $timeout, 0, sub {
              $! = Errno::ETIMEDOUT;
              $state{next}();
           } if $timeout;
  
           # now connect       
           if (
              (connect $state{fh}, $sockaddr)
              || ($! == Errno::EINPROGRESS # POSIX
                  || $! == Errno::EWOULDBLOCK
                  # WSAEINPROGRESS intentionally not checked - it means something else entirely
                  || $! == AnyEvent::Util::WSAEINVAL # not convinced, but doesn't hurt
                  || $! == AnyEvent::Util::WSAEWOULDBLOCK)
           ) {
              $state{ww} = AE::io $state{fh}, 1, sub {
                 # we are connected, or maybe there was an error
                 if (my $sin = getpeername $state{fh}) {
                    my ($port, $host) = unpack_sockaddr $sin;
  
                    delete $state{ww}; delete $state{to};
  
                    my $guard = guard { %state = () };
  
                    $connect->(delete $state{fh}, format_address $host, $port, sub {
                       $guard->cancel;
                       $state{next}();
                    });
                 } else {
                    if ($! == Errno::ENOTCONN) {
                       # dummy read to fetch real error code if !cygwin
                       sysread $state{fh}, my $buf, 1;
  
                       # cygwin 1.5 continously reports "ready' but never delivers
                       # an error with getpeername or sysread.
                       # cygwin 1.7 only reports readyness *once*, but is otherwise
                       # the same, which is actually more broken.
                       # Work around both by using unportable SO_ERROR for cygwin.
                       $! = (unpack "l", getsockopt $state{fh}, Socket::SOL_SOCKET(), Socket::SO_ERROR()) || Errno::EAGAIN
                          if AnyEvent::CYGWIN && $! == Errno::EAGAIN;
                    }
  
                    return if $! == Errno::EAGAIN; # skip spurious wake-ups
  
                    delete $state{ww}; delete $state{to};
  
                    $state{next}();
                 }
              };
           } else {
              $state{next}();
           }
        };
  
        $! = Errno::ENXIO;
        $state{next}();
     };
  
     defined wantarray && guard { %state = () }
  }
  
  =item $guard = tcp_server $host, $service, $accept_cb[, $prepare_cb]
  
  Create and bind a stream socket to the given host address and port, set
  the SO_REUSEADDR flag (if applicable) and call C<listen>. Unlike the name
  implies, this function can also bind on UNIX domain sockets.
  
  For internet sockets, C<$host> must be an IPv4 or IPv6 address (or
  C<undef>, in which case it binds either to C<0> or to C<::>, depending
  on whether IPv4 or IPv6 is the preferred protocol, and maybe to both in
  future versions, as applicable).
  
  To bind to the IPv4 wildcard address, use C<0>, to bind to the IPv6
  wildcard address, use C<::>.
  
  The port is specified by C<$service>, which must be either a service name
  or a numeric port number (or C<0> or C<undef>, in which case an ephemeral
  port will be used).
  
  For UNIX domain sockets, C<$host> must be C<unix/> and C<$service> must be
  the absolute pathname of the socket. This function will try to C<unlink>
  the socket before it tries to bind to it, and will try to unlink it after
  it stops using it. See SECURITY CONSIDERATIONS, below.
  
  For each new connection that could be C<accept>ed, call the C<<
  $accept_cb->($fh, $host, $port) >> with the file handle (in non-blocking
  mode) as first, and the peer host and port as second and third arguments
  (see C<tcp_connect> for details).
  
  Croaks on any errors it can detect before the listen.
  
  If called in non-void context, then this function returns a guard object
  whose lifetime it tied to the TCP server: If the object gets destroyed,
  the server will be stopped (but existing accepted connections will
  not be affected).
  
  If you need more control over the listening socket, you can provide a
  C<< $prepare_cb->($fh, $host, $port) >>, which is called just before the
  C<listen ()> call, with the listen file handle as first argument, and IP
  address and port number of the local socket endpoint as second and third
  arguments.
  
  It should return the length of the listen queue (or C<0> for the default).
  
  Note to IPv6 users: RFC-compliant behaviour for IPv6 sockets listening on
  C<::> is to bind to both IPv6 and IPv4 addresses by default on dual-stack
  hosts. Unfortunately, only GNU/Linux seems to implement this properly, so
  if you want both IPv4 and IPv6 listening sockets you should create the
  IPv6 socket first and then attempt to bind on the IPv4 socket, but ignore
  any C<EADDRINUSE> errors.
  
  Example: bind on some TCP port on the local machine and tell each client
  to go away.
  
     tcp_server undef, undef, sub {
        my ($fh, $host, $port) = @_;
  
        syswrite $fh, "The internet is full, $host:$port. Go away!\015\012";
     }, sub {
        my ($fh, $thishost, $thisport) = @_;
        AE::log info => "bound to $thishost, port $thisport";
     };
  
  Example: bind a server on a unix domain socket.
  
     tcp_server "unix/", "/tmp/mydir/mysocket", sub {
        my ($fh) = @_;
     };
  
  =cut
  
  sub tcp_server($$$;$) {
     my ($host, $service, $accept, $prepare) = @_;
  
     $host = $AnyEvent::PROTOCOL{ipv4} < $AnyEvent::PROTOCOL{ipv6} && AF_INET6
             ? "::" : "0"
        unless defined $host;
  
     my $ipn = parse_address $host
        or Carp::croak "AnyEvent::Socket::tcp_server: cannot parse '$host' as host address";
  
     my $af = address_family $ipn;
  
     my %state;
  
     # win32 perl is too stupid to get this right :/
     Carp::croak "tcp_server/socket: address family not supported"
        if AnyEvent::WIN32 && $af == AF_UNIX;
  
     socket $state{fh}, $af, SOCK_STREAM, 0
        or Carp::croak "tcp_server/socket: $!";
  
     if ($af == AF_INET || $af == AF_INET6) {
        setsockopt $state{fh}, SOL_SOCKET, SO_REUSEADDR, 1
           or Carp::croak "tcp_server/so_reuseaddr: $!"
              unless AnyEvent::WIN32; # work around windows bug
  
        unless ($service =~ /^\d*$/) {
           $service = (getservbyname $service, "tcp")[2]
                      or Carp::croak "$service: service unknown"
        }
     } elsif ($af == AF_UNIX) {
        unlink $service;
     }
  
     bind $state{fh}, pack_sockaddr $service, $ipn
        or Carp::croak "bind: $!";
  
     if ($af == AF_UNIX) {
        my $fh  = $state{fh};
        my $ino = (stat $fh)[1];
        $state{unlink} = guard {
           # this is racy, but is not designed to be foolproof, just best-effort
           unlink $service
              if $ino == (stat $fh)[1];
        };
     }
  
     fh_nonblocking $state{fh}, 1;
  
     my $len;
  
     if ($prepare) {
        my ($service, $host) = unpack_sockaddr getsockname $state{fh};
        $len = $prepare && $prepare->($state{fh}, format_address $host, $service);
     }
     
     $len ||= 128;
  
     listen $state{fh}, $len
        or Carp::croak "listen: $!";
  
     $state{aw} = AE::io $state{fh}, 0, sub {
        # this closure keeps $state alive
        while ($state{fh} && (my $peer = accept my $fh, $state{fh})) {
           fh_nonblocking $fh, 1; # POSIX requires inheritance, the outside world does not
  
           my ($service, $host) = unpack_sockaddr $peer;
           $accept->($fh, format_address $host, $service);
        }
     };
  
     defined wantarray
        ? guard { %state = () } # clear fh and watcher, which breaks the circular dependency
        : ()
  }
  
  =item tcp_nodelay $fh, $enable
  
  Enables (or disables) the C<TCP_NODELAY> socket option (also known as
  Nagle's algorithm). Returns false on error, true otherwise.
  
  =cut
  
  sub tcp_nodelay($$) {
     my $onoff = int ! ! $_[1];
  
     setsockopt $_[0], Socket::IPPROTO_TCP (), Socket::TCP_NODELAY (), $onoff
  }
  
  =item tcp_congestion $fh, $algorithm
  
  Sets the tcp congestion avoidance algorithm (via the C<TCP_CONGESTION>
  socket option). The default is OS-specific, but is usually
  C<reno>. Typical other available choices include C<cubic>, C<lp>, C<bic>,
  C<highspeed>, C<htcp>, C<hybla>, C<illinois>, C<scalable>, C<vegas>,
  C<veno>, C<westwood> and C<yeah>.
  
  =cut
  
  sub tcp_congestion($$) {
     defined TCP_CONGESTION
        ? setsockopt $_[0], Socket::IPPROTO_TCP (), TCP_CONGESTION, "$_[1]"
        : undef
  }
  
  1;
  
  =back
  
  =head1 SECURITY CONSIDERATIONS
  
  This module is quite powerful, with with power comes the ability to abuse
  as well: If you accept "hostnames" and ports from untrusted sources,
  then note that this can be abused to delete files (host=C<unix/>). This
  is not really a problem with this module, however, as blindly accepting
  any address and protocol and trying to bind a server or connect to it is
  harmful in general.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_SOCKET

$fatpacked{"darwin-2level/AnyEvent/Strict.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_STRICT';
  =head1 NAME
  
  AnyEvent::Strict - force strict mode on for the whole process
  
  =head1 SYNOPSIS
  
     use AnyEvent::Strict;
     # strict mode now switched on
  
  =head1 DESCRIPTION
  
  This module implements AnyEvent's strict mode.
  
  Loading it makes AnyEvent check all arguments to AnyEvent-methods, at the
  expense of being slower (often the argument checking takes longer than the
  actual function). It also wraps all callbacks to check for modifications
  of C<$_>, which indicates a programming bug inside the watcher callback.
  
  Normally, you don't load this module yourself but instead use it
  indirectly via the C<PERL_ANYEVENT_STRICT> environment variable (see
  L<AnyEvent>). However, this module can be loaded manually at any time.
  
  =cut
  
  package AnyEvent::Strict;
  
  use Carp qw(croak);
  use Errno ();
  use POSIX ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  AnyEvent::_isa_hook 1 => "AnyEvent::Strict", 1;
  
  BEGIN {
     if (defined &Internals::SvREADONLY) {
        # readonly available (at least 5.8.9+, working better in 5.10.1+)
        *wrap = sub {
           my $cb = shift;
  
           sub {
              local $_;
              Internals::SvREADONLY $_, 1;
              &$cb;
           }
        };
     } else {
        # or not :/
        my $magic = []; # a unique magic value
  
        *wrap = sub {
           my $cb = shift;
  
           sub {
              local $_ = $magic;
  
              &$cb;
  
              if (!ref $_ || $_ != $magic) {
                 require AnyEvent::Debug;
                 die "callback $cb (" . AnyEvent::Debug::cb2str ($cb) . ") modified \$_ without restoring it.\n";
              }
           }
        };
     }
  }
  
  our (@FD_INUSE, $FD_I);
  our $FD_CHECK_W = AE::timer 4, 4, sub {
     my $cnt = (@FD_INUSE < 100 * 10 ? int @FD_INUSE * 0.1 : 100) || 10;
  
     if ($FD_I <= 0) {
        #pop @FD_INUSE while @FD_INUSE && !$FD_INUSE[-1];
        $FD_I = @FD_INUSE
           or return; # empty
     }
  
     $cnt = $FD_I if $cnt > $FD_I;
  
     eval {
        do {
           !$FD_INUSE[--$FD_I]
              or (POSIX::lseek $FD_I, 0, 1) != -1
              or $! != Errno::EBADF
              or die;
        } while --$cnt;
        1
     } or AE::log crit => "file descriptor $FD_I registered with AnyEvent but prematurely closed, event loop might malfunction.\n";
  };
  
  sub io {
     my $class = shift;
     my (%arg, $fh, $cb, $fd) = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->io called with illegal cb argument '$arg{cb}'";
     $cb = wrap delete $arg{cb};
   
     $arg{poll} =~ /^[rw]$/
        or croak "AnyEvent->io called with illegal poll argument '$arg{poll}'";
  
     $fh = delete $arg{fh};
  
     if ($fh =~ /^\s*\d+\s*$/) {
        $fd = $fh;
        $fh = AnyEvent::_dupfh $arg{poll}, $fh;
     } else {
        defined eval { $fd = fileno $fh }
           or croak "AnyEvent->io called with illegal fh argument '$fh'";
     }
  
     -f $fh
        and croak "AnyEvent->io called with fh argument pointing to a file";
  
     delete $arg{poll};
   
     croak "AnyEvent->io called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     ++$FD_INUSE[$fd];
  
     bless [
        $fd,
        $class->SUPER::io (@_, cb => $cb)
     ], "AnyEvent::Strict::io";
  }
  
  sub AnyEvent::Strict::io::DESTROY {
     --$FD_INUSE[$_[0][0]];
  }
  
  sub timer {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->timer called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     exists $arg{after}
        or croak "AnyEvent->timer called without mandatory 'after' parameter";
     delete $arg{after};
   
     !$arg{interval} or $arg{interval} > 0
        or croak "AnyEvent->timer called with illegal interval argument '$arg{interval}'";
     delete $arg{interval};
   
     croak "AnyEvent->timer called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::timer (@_, cb => $cb)
  }
  
  sub signal {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->signal called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     defined AnyEvent::Base::sig2num $arg{signal} and $arg{signal} == 0
        or croak "AnyEvent->signal called with illegal signal name '$arg{signal}'";
     delete $arg{signal};
   
     croak "AnyEvent->signal called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::signal (@_, cb => $cb)
  }
  
  sub child {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->child called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     $arg{pid} =~ /^-?\d+$/
        or croak "AnyEvent->child called with malformed pid value '$arg{pid}'";
     delete $arg{pid};
   
     croak "AnyEvent->child called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::child (@_, cb => $cb)
  }
  
  sub idle {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->idle called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     croak "AnyEvent->idle called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::idle (@_, cb => $cb)
  }
  
  sub condvar {
     my $class = shift;
     my %arg = @_;
  
     !exists $arg{cb} or ref $arg{cb}
        or croak "AnyEvent->condvar called with illegal cb argument '$arg{cb}'";
     my @cb = exists $arg{cb} ? (cb => wrap delete $arg{cb}) : ();
   
     croak "AnyEvent->condvar called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::condvar (@cb);
  }
  
  sub time {
     my $class = shift;
  
     @_
        and croak "AnyEvent->time wrongly called with paramaters";
  
     $class->SUPER::time (@_)
  }
  
  sub now {
     my $class = shift;
  
     @_
        and croak "AnyEvent->now wrongly called with paramaters";
  
     $class->SUPER::now (@_)
  }
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_STRICT

$fatpacked{"darwin-2level/AnyEvent/TLS.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_TLS';
  package AnyEvent::TLS;
  
  use Carp qw(croak);
  use Scalar::Util ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  
  use Net::SSLeay;
  
  =head1 NAME
  
  AnyEvent::TLS - SSLv2/SSLv3/TLSv1 contexts for use in AnyEvent::Handle
  
  =cut
  
  our $VERSION = $AnyEvent::VERSION;
  
  =head1 SYNOPSIS
  
     # via AnyEvent::Handle
  
     use AnyEvent;
     use AnyEvent::Handle;
     use AnyEvent::Socket;
  
     # simple https-client
     my $handle = new AnyEvent::Handle
        connect  => [$host, $port],
        tls      => "connect",
        tls_ctx  => { verify => 1, verify_peername => "https" },
        ...
  
     # simple ssl-server
     tcp_server undef, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh       => $fh,
           tls      => "accept",
           tls_ctx  => { cert_file => "my-server-keycert.pem" },
           ...
  
     # directly
  
     my $tls = new AnyEvent::TLS
        verify => 1,
        verify_peername => "ldaps",
        ca_file => "/etc/cacertificates.pem";
  
  =head1 DESCRIPTION
  
  This module is a helper module that implements TLS/SSL (Transport Layer
  Security/Secure Sockets Layer) contexts. A TLS context is a common set of
  configuration values for use in establishing TLS connections.
  
  For some quick facts about SSL/TLS, see the section of the same name near
  the end of the document.
  
  A single TLS context can be used for any number of TLS connections that
  wish to use the same certificates, policies etc.
  
  Note that this module is inherently tied to L<Net::SSLeay>, as this
  library is used to implement it. Since that perl module is rather ugly,
  and OpenSSL has a rather ugly license, AnyEvent might switch TLS providers
  at some future point, at which this API will change dramatically, at least
  in the Net::SSLeay-specific parts (most constructor arguments should still
  work, though).
  
  Although this module does not require a specific version of Net::SSLeay,
  many features will gradually stop working, or bugs will be introduced with
  old versions (verification might succeed when it shouldn't - this is a
  real security issue). Version 1.35 is recommended, 1.33 should work, 1.32
  might, and older versions are yours to keep.
  
  =head1 USAGE EXAMPLES
  
  See the L<AnyEvent::Handle> manpage, NONFREQUENTLY ASKED QUESTIONS, for
  some actual usage examples.
  
  =head1 PUBLIC METHODS AND FUNCTIONS
  
  =over 4
  
  =cut
  
  our $REF_IDX; # our session ex_data id
  
  # create temp file, populate it, and return a guard and filename
  sub _tmpfile($) {
     require File::Temp unless $File::Temp::VERSION;
  
     # File::Temp opens the file with mode 0600
     my ($fh, $path) = File::Temp::tempfile ("aetlsXXXXXXXXX", TMPDIR => 1, EXLOCK => 0);
     my $guard = AnyEvent::Util::guard { unlink $path };
  
     syswrite $fh, $_[0];
     close $fh;
  
     ($path, $guard)
  }
  
  our %DH_PARAMS = (
     # These are the DH parameters from "Assigned Number for SKIP Protocols"
     # (http://www.skip-vpn.org/spec/numbers.html).
     # (or http://web.archive.org/web/20011212141438/http://www.skip-vpn.org/spec/numbers.html#params)
     # See there for how they were generated.
     # Note that g might not be a generator,
     # but this is not a problem since p is a safe prime.
     skip512 => "MEYCQQD1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak|XUGfnHy9iUsiGSa6q6Jew1XpKgVfAgEC",
     skip1024 => "MIGHAoGBAPSI/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsY|jY67VYy4XTjTNP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6|ypUM2Zafq9AKUJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XpL3jHAgEC",
     skip2048 => "MIIBCAKCAQEA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadWoxTpj0BV|89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeSWc39uK50|T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0iP1YTknb|zSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF040zT9fBdX|Q6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQClCbAkbT|CD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwIBAg==",
     skip4096 => "MIICCAKCAgEA+hRyUsFN4VpJ1O8JLcCo/VWr19k3BCgJ4uk+d+KhehjdRqNDNyOQ|l/MOyQNQfWXPeGKmOmIig6Ev/nm6Nf9Z2B1h3R4hExf+zTiHnvVPeRBhjdQi81rt|Xeoh6TNrSBIKIHfUJWBh3va0TxxjQIs6IZOLeVNRLMqzeylWqMf49HsIXqbcokUS|Vt1BkvLdW48j8PPv5DsKRN3tloTxqDJGo9tKvj1Fuk74A+Xda1kNhB7KFlqMyN98|VETEJ6c7KpfOo30mnK30wqw3S8OtaIR/maYX72tGOno2ehFDkq3pnPtEbD2CScxc|alJC+EL7RPk5c/tgeTvCngvc1KZn92Y//EI7G9tPZtylj2b56sHtMftIoYJ9+ODM|sccD5Piz/rejE3Ome8EOOceUSCYAhXn8b3qvxVI1ddd1pED6FHRhFvLrZxFvBEM9|ERRMp5QqOaHJkM+Dxv8Cj6MqrCbfC4u+ZErxodzuusgDgvZiLF22uxMZbobFWyte|OvOzKGtwcTqO/1wV5gKkzu1ZVswVUQd5Gg8lJicwqRWyyNRczDDoG9jVDxmogKTH|AaqLulO7R8Ifa1SwF2DteSGVtgWEN8gDpN3RBmmPTDngyF2DHb5qmpnznwtFKdTL|KWbuHn491xNO25CQWMtem80uKw+pTnisBRF/454n1Jnhub144YRBoN8CAQI=",
  
     # generated on a linux desktop with openssl using /dev/urandom - entropy_avail was >= 3600 each time
     # the 8192 bit key took 25 hours to generate :/
     schmorp1024 => "MIGHAoGBAN+GjqAhNxLesSuGfDzYe6HdexXtHuxe85umshfPHfnmLSkGWl/FE27+|v+50mwY5XaNnCmo1VvGju4iTKxWoZTGgslUSc8KX197XWAXIpab8ESyg442if9Kr|vSOuu0fopwvvTOgHK8mkEWI4joU5G4/MQy+pnC5NIEVBP4HtGiTrAgEC",
     schmorp1539 => "MIHHAoHBByJzpVGUsXysX8w/+uuXRUCL9exhAixoHkaJU5lf4noJUtp9F0yr/5rb|hF8M9mSZJ+RlPyB+Zt37GPp1WQDO1+/2yZJX9kHE3+h5JCRoR8PKc2G+ts9jhM7r|CnTQ0z0b6s12Pusf+UhQPwLust4JAYE/LPuTK8yFiVx5L2a+aZhGMVlYN/12SEtY|jRl3lGXdZj9g8E2PzTQbA9CGy5dGIvz/ENTzTVleKuQ+80bzpVEPjZL9tv43Zc+l|MFLzxuE5uwIBAg==",
     schmorp2048 => "MIIBCAKCAQEAhR5Fn9h3Tgnc+q4o3CMkZtre3lLUyDT+1bf3aiVOt22JdDQndZLc|FeKz8AqliB3UIgNExc6oDtuG4znKPgklfOnHv/a9tl1AYQbV+QFM/E0jYl6oG8tF|Epgxezt1GCivvtu64ql0s213wr64QffNMt3hva8lNqK1PXfqp13PzzLzAVsfghrv|fMAX7/bYm1T5fAJdcah6FeZkKof+mqbs8HtRjfvrUF2npEM2WdupFu190vcwABnN|TTJheXCWv2BF2f9EEr61q3OUhSNWIThtZP+NKe2bACm1PebT0drAcaxKoMz9LjKr|y5onGs0TOuQ7JmhtZL45Zr4LwBcyTucLUwIBAg==",
     schmorp4096 => "MIICCAKCAgEA5WwA5lQg09YRYqc/JILCd2AfBmYBkF19wmCEJB8G3JhTxv8EGvYk|xyP2ecKVUvHTG8Xw/qpW8nRqzPIyV8QRf6YFYSf33Qnx2xYhcnqOumU3nfC0SNOL|/w2q1BA9BbHtW4574P+6hOQx9ftRtbtZ2HPKBMRcAKGjpYZiKopv0+UAM4NpEC2p|bfajp7pyVLeb/Aqm/oWP3L63wPlY1SDp+XRzrOAKB+/uLGqEwV0bBaxxGL29BpOp|O2z1ALGXiDCcLs9WTn9WqUhWDzUN6fahm53rd7zxwpFCb6K2YhaK0peG95jzSUJ8|aoL0KgWuC6v5+gPJHRu0HrQIdfAdN4VchqYOKE46uNNkQl8VJGu4RjYB7lFBpRwO|g2HCsGMo2X7BRmA1st66fh+JOd1smXMZG/2ozTOooL+ixcx4spNneg4aQerWl5cb|nWXKtPCp8yPzt/zoNzL3Fon2Ses3sNgMos0M/ZbnigScDxz84Ms6V/X8Z0L4m/qX|mL42dP40tgvmgqi6BdsBzcIWeHlEcIhmGcsEBxxKEg7gjb0OjjvatpUCJhmRrGjJ|LtMkBR68qr42OBMN/PBB4KPOWNUqTauXZajfCwYdbpvV24ZhtkcRdw1zisyARBSh|aTKW/GV8iLsUzlYN27LgVEwMwnWQaoecW6eOTNKGUURC3In6XZSvVzsCAQI=",
     schmorp8192 => "MIIECAKCBAEA/SAEbRSSLenVxoInHiltm/ztSwehGOhOiUKfzDcKlRBZHlCC9jBl|S/aeklM6Ucg8E6J2bnfoh6CAdnE/glQOn6CifhZr8X/rnlL9/eP+r9m+aiAw4l0D|MBd8BondbEqwTZthMmLtx0SslnevsFAZ1Cj8WgmUNaSPOukvJ1N7aQ98U+E99Pw3|VG8ANBydXqLqW2sogS8FtZoMbVywcQuaGmC7M6i3Akxe3CCSIpR/JkEZIytREBSC|CH+x3oW/w+wHzq3w8DGB9hqz1iMXqDMiPIMSdXC0DaIPokLnd7X8u6N14yCAco2h|P0gspD3J8pS2FpUY8ZTVjzbVCjhNNmTryBZAxHSWBuX4xYcCHUtfGlUe/IGLSVE1|xIdFpZUfvlvAJjVq0/TtDMg3r2JSXrhQVlr8MPJwSApDVr5kOBHT/uABio4z+5yR|PAvundznfyo9GGAWhIA36GQqsxSQfoRTjWssFoR/cu+9aomRwwOLkvObu8nCVVLH|nLdKDk5cIR0TvNs9HZ6ZmkzL7ah7cPzEKl7U6eE6yZLVYMNecnPLS6PSAIG4gxcq|CVQrrZjQLfTDrJn0OGgpShX85RaDsuiRtp2bpDZ23YDqdwr4wRjvIargjqc2zcF+|jIb7dUS6ci7bVG/CGOQUuiMWAiXZ3a1f343SMf9A05/sf1xwnMeco6STBLZ3X+PA|4urU+grtpWaFtS/fPD2ILn8nrJ3WuSKKUeSnVM46mmJQsOkyn7z8l3jNLB17GYKo|qc+0UuU/2PM9qtZdZElSM/ACLV2vdCuaibop4B9UIP9z3F8kfZ72+zKxpGiE+Bo1|x8SfG8FQw90mYIx+qZzJ8MCvc2wh+l4wDX5KxrhwvcouE2tHQlwfDgv/DiIXp173|hAmUCV0+bPRW8IIJvBODdAWtJe9hNwxj1FFYmPA7l4wa3gXV4I6tb+iO1MbwVjZ/|116tD5MdCo3JuSisgPYCHfkQccwEO0FHEuBbmfN+fQimQ8H0dePP8XctwbkplsB+|aLT5hYKmva/j9smEswgyHglPwc3WvZ+2DgKk7A7DHi7a2gDwCRQlHaXtNWx3992R|dfNgkSeB1CvGSQoo95WpC9ZoqGmcSlVqdetDU8iglPmfYTKO8aIPA6TuTQ/lQ0IW|90LQmqP23FwnNFiyqX8+rztLq4KVkTyeHIQwig6vFxgD8N+SbZCW2PPiB72TVF2U|WePU8MRTv1OIGBUBajF49k28HnZPSGlILHtFEkYkbPvomcE5ENnoejwzjktOTS5d|/R3SIOvCauOzadtzwTYOXT78ORaR1KI1cm8DzkkwJTd/Rrk07Q5vnvnSJQMwFUeH|PwJIgWBQf/GZ/OsDHmkbYR2ZWDClbKw2mwIBAg==",
  );
  
  =item $tls = new AnyEvent::TLS key => value...
  
  The constructor supports these arguments (all as key => value pairs).
  
  =over 4
  
  =item method => "SSLv2" | "SSLv3" | "TLSv1" | "any"
  
  The protocol parser to use. C<SSLv2>, C<SSLv3> and C<TLSv1> will use
  a parser for those protocols only (so will I<not> accept or create
  connections with/to other protocol versions), while C<any> (the
  default) uses a parser capable of all three protocols.
  
  The default is to use C<"any"> but disable SSLv2. This has the effect of
  sending a SSLv2 hello, indicating the support for SSLv3 and TLSv1, but not
  actually negotiating an (insecure) SSLv2 connection.
  
  Specifying a specific version is almost always wrong to use for a server
  speaking to a wide variety of clients (e.g. web browsers), and often wrong
  for a client. If you only want to allow a specific protocol version, use
  the C<sslv2>, C<sslv3> or C<tlsv1> arguments instead.
  
  For new services it is usually a good idea to enforce a C<TLSv1> method
  from the beginning.
  
  =item sslv2 => $enabled
  
  Enable or disable SSLv2 (normally I<disabled>).
  
  =item sslv3 => $enabled
  
  Enable or disable SSLv3 (normally I<enabled>).
  
  =item tlsv1 => $enabled
  
  Enable or disable TLSv1 (normally I<enabled>).
  
  =item verify => $enable
  
  Enable or disable peer certificate checking (default is I<disabled>, which
  is I<not recommended>).
  
  This is the "master switch" for all verify-related parameters and
  functions.
  
  If it is disabled, then no peer certificate verification will be done
  - the connection will be encrypted, but the peer certificate won't be
  verified against any known CAs, or whether it is still valid or not. No
  peername verification or custom verification will be done either.
  
  If enabled, then the peer certificate (required in client mode, optional
  in server mode, see C<verify_require_client_cert>) will be checked against
  its CA certificate chain - that means there must be a signing chain from
  the peer certificate to any of the CA certificates you trust locally, as
  specified by the C<ca_file> and/or C<ca_path> and/or C<ca_cert> parameters
  (or the system default CA repository, if all of those parameters are
  missing - see also the L<AnyEvent> manpage for the description of
  PERL_ANYEVENT_CA_FILE).
  
  Other basic checks, such as checking the validity period, will also be
  done, as well as optional peername/hostname/common name verification
  C<verify_peername>.
  
  An optional C<verify_cb> callback can also be set, which will be invoked
  with the verification results, and which can override the decision.
  
  =item verify_require_client_cert => $enable
  
  Enable or disable mandatory client certificates (default is
  I<disabled>). When this mode is enabled, then a client certificate will be
  required in server mode (a server certificate is mandatory, so in client
  mode, this switch has no effect).
  
  =item verify_peername => $scheme | $callback->($tls, $cert, $peername)
  
  TLS only protects the data that is sent - it cannot automatically verify
  that you are really talking to the right peer. The reason is that
  certificates contain a "common name" (and a set of possible alternative
  "names") that need to be checked against the peername (usually, but not
  always, the DNS name of the server) in a protocol-dependent way.
  
  This can be implemented by specifying a callback that has to verify that
  the actual C<$peername> matches the given certificate in C<$cert>.
  
  Since this can be rather hard to implement, AnyEvent::TLS offers a variety
  of predefined "schemes" (lifted from L<IO::Socket::SSL>) that are named
  like the protocols that use them:
  
  =over 4
  
  =item ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)
  
  Simple wildcards in subjectAltNames are possible, e.g. *.example.org
  matches www.example.org but not lala.www.example.org. If nothing from
  subjectAltNames matches, it checks against the common name, but there are
  no wildcards allowed.
  
  =item http (rfc2818)
  
  Extended wildcards in subjectAltNames are possible, e.g. *.example.org or
  even www*.example.org. Wildcards in the common name are not allowed. The
  common name will be only checked if no host names are given in
  subjectAltNames.
  
  =item smtp (rfc3207)
  
  This RFC isn't very useful in determining how to do verification so it
  just assumes that subjectAltNames are possible, but no wildcards are
  possible anywhere.
  
  =item [$check_cn, $wildcards_in_alt, $wildcards_in_cn]
  
  You can also specify a scheme yourself by using an array reference with
  three integers.
  
  C<$check_cn> specifies if and how the common name field is used: C<0>
  means it will be completely ignored, C<1> means it will only be used if
  no host names have been found in the subjectAltNames, and C<2> means the
  common name will always be checked against the peername.
  
  C<$wildcards_in_alt> and C<$wildcards_in_cn> specify whether and where
  wildcards (C<*>) are allowed in subjectAltNames and the common name,
  respectively. C<0> means no wildcards are allowed, C<1> means they
  are allowed only as the first component (C<*.example.org>), and C<2>
  means they can be used anywhere (C<www*.example.org>), except that very
  dangerous matches will not be allowed (C<*.org> or C<*>).
  
  =back
  
  You can specify either the name of the parent protocol (recommended,
  e.g. C<http>, C<ldap>), the protocol name as usually used in URIs
  (e.g. C<https>, C<ldaps>) or the RFC (not recommended, e.g. C<rfc2995>,
  C<rfc3920>).
  
  This verification will only be done when verification is enabled (C<<
  verify => 1 >>).
  
  =item verify_cb => $callback->($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)
  
  Provide a custom peer verification callback used by TLS sessions,
  which is called with the result of any other verification (C<verify>,
  C<verify_peername>).
  
  This callback will only be called when verification is enabled (C<< verify
  => 1 >>).
  
  C<$tls> is the C<AnyEvent::TLS> object associated with the session,
  while C<$ref> is whatever the user associated with the session (usually
  an L<AnyEvent::Handle> object when used by AnyEvent::Handle).
  
  C<$depth> is the current verification depth - C<$depth = 0> means the
  certificate to verify is the peer certificate, higher levels are its CA
  certificate and so on. In most cases, you can just return C<$preverify_ok>
  if the C<$depth> is non-zero:
  
     verify_cb => sub {
        my ($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert) = @_;
  
        return $preverify_ok
           if $depth;
  
        # more verification
     },
  
  C<$preverify_ok> is true iff the basic verification of the certificates
  was successful (a valid CA chain must exist, the certificate has passed
  basic validity checks, peername verification succeeded).
  
  C<$x509_store_ctx> is the Net::SSLeay::X509_CTX> object.
  
  C<$cert> is the C<Net::SSLeay::X509> object representing the
  peer certificate, or zero if there was an error. You can call
  C<AnyEvent::TLS::certname $cert> to get a nice user-readable string to
  identify the certificate.
  
  The callback must return either C<0> to indicate failure, or C<1> to
  indicate success.
  
  =item verify_client_once => $enable
  
  Enable or disable skipping the client certificate verification on
  renegotiations (default is I<disabled>, the certificate will always be
  checked). Only makes sense in server mode.
  
  =item ca_file => $path
  
  If this parameter is specified and non-empty, it will be the path to a
  file with (server) CA certificates in PEM format that will be loaded. Each
  certificate will look like:
  
     -----BEGIN CERTIFICATE-----
     ... (CA certificate in base64 encoding) ...
     -----END CERTIFICATE-----
  
  You have to enable verify mode (C<< verify => 1 >>) for this parameter to
  have any effect.
  
  =item ca_path => $path
  
  If this parameter is specified and non-empty, it will be
  the path to a directory with hashed CA certificate files in
  PEM format. When the ca certificate is being verified, the
  certificate will be hashed and looked up in that directory (see
  L<http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html> for
  details)
  
  The certificates specified via C<ca_file> take precedence over the ones
  found in C<ca_path>.
  
  You have to enable verify mode (C<< verify => 1 >>) for this parameter to
  have any effect.
  
  =item ca_cert => $string
  
  In addition or instead of using C<ca_file> and/or C<ca_path>, you can
  also use C<ca_cert> to directly specify the CA certificates (there can be
  multiple) in PEM format, in a string.
  
  =item check_crl => $enable
  
  Enable or disable certificate revocation list checking. If enabled, then
  peer certificates will be checked against a list of revoked certificates
  issued by the CA. The revocation lists will be expected in the C<ca_path>
  directory.
  
  certificate verification will fail if this is enabled but no revocation
  list was found.
  
  This requires OpenSSL >= 0.9.7b. Check the OpenSSL documentation for more
  details.
  
  =item key_file => $path
  
  Path to the local private key file in PEM format (might be a combined
  certificate/private key file).
  
  The local certificate is used to authenticate against the peer - servers
  mandatorily need a certificate and key, clients can use a certificate and
  key optionally to authenticate, e.g. for log-in purposes.
  
  The key in the file should look similar this:
  
     -----BEGIN RSA PRIVATE KEY-----
     ...header data
     ... (key data in base64 encoding) ...
     -----END RSA PRIVATE KEY-----
  
  =item key => $string
  
  The private key string in PEM format (see C<key_file>, only one of
  C<key_file> or C<key> can be specified).
  
  The idea behind being able to specify a string is to avoid blocking in
  I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
  needed OpenSSL functionality, this is currently implemented by writing to
  a temporary file.
  
  =item cert_file => $path
  
  The path to the local certificate file in PEM format (might be a combined
  certificate/private key file, including chained certificates).
  
  The local certificate (and key) are used to authenticate against the
  peer - servers mandatorily need a certificate and key, clients can use
  certificate and key optionally to authenticate, e.g. for log-in purposes.
  
  The certificate in the file should look like this:
  
     -----BEGIN CERTIFICATE-----
     ... (certificate in base64 encoding) ...
     -----END CERTIFICATE-----
  
  If the certificate file or string contain both the certificate and
  private key, then there is no need to specify a separate C<key_file> or
  C<key>.
  
  Additional signing certifiates to send to the peer (in SSLv3 and newer)
  can be specified by appending them to the certificate proper: the order
  must be from issuer certificate over any intermediate CA certificates to
  the root CA.
  
  So the recommended ordering for a combined key/cert/chain file, specified
  via C<cert_file> or C<cert> looks like this:
  
    certificate private key
    client/server certificate
    ca 1, signing client/server certficate
    ca 2, signing ca 1
    ...
  
  =item cert => $string
  
  The local certificate in PEM format (might be a combined
  certificate/private key file). See C<cert_file>.
  
  The idea behind being able to specify a string is to avoid blocking in
  I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
  needed OpenSSL functionality, this is currently implemented by writing to
  a temporary file.
  
  =item cert_password => $string | $callback->($tls)
  
  The certificate password - if the certificate is password-protected, then
  you can specify its password here.
  
  Instead of providing a password directly (which is not so recommended),
  you can also provide a password-query callback. The callback will be
  called whenever a password is required to decode a local certificate, and
  is supposed to return the password.
  
  =item dh_file => $path
  
  Path to a file containing Diffie-Hellman parameters in PEM format, for
  use in servers. See also C<dh> on how to specify them directly, or use a
  pre-generated set.
  
  Diffie-Hellman key exchange generates temporary encryption keys that
  are not transferred over the connection, which means that even if the
  certificate key(s) are made public at a later time and a full dump of the
  connection exists, the key still cannot be deduced.
  
  These ciphers are only available with SSLv3 and later (which is the
  default with AnyEvent::TLS), and are only used in server/accept
  mode. Anonymous DH protocols are usually disabled by default, and usually
  not even compiled into the underlying library, as they provide no direct
  protection against man-in-the-middle attacks. The same is true for the
  common practise of self-signed certificates that you have to accept first,
  of course.
  
  =item dh => $string
  
  Specify the Diffie-Hellman parameters in PEM format directly as a string
  (see C<dh_file>), the default is C<schmorp1539> unless C<dh_file> was
  specified.
  
  AnyEvent::TLS supports supports a number of precomputed DH parameters,
  since computing them is expensive. They are:
  
     # from "Assigned Number for SKIP Protocols"
     skip512, skip1024, skip2048, skip4096
  
     # from schmorp
     schmorp1024, schmorp1539, schmorp2048, schmorp4096, schmorp8192
  
  The default was chosen as a trade-off between security and speed, and
  should be secure for a few years. It is said that 2048 bit DH parameters
  are safe till 2030, and DH parameters shorter than 900 bits are totally
  insecure.
  
  To disable DH protocols completely, specify C<undef> as C<dh> parameter.
  
  =item dh_single_use => $enable
  
  Enables or disables "use only once" mode when using Diffie-Hellman key
  exchange. When enabled (default), each time a new key is exchanged a new
  Diffie-Hellman key is generated, which improves security as each key is
  only used once. When disabled, the key will be created as soon as the
  AnyEvent::TLS object is created and will be reused.
  
  All the DH parameters supplied with AnyEvent::TLS should be safe with
  C<dh_single_use> switched off, but YMMV.
  
  =item cipher_list => $string
  
  The list of ciphers to use, as a string (example:
  C<AES:ALL:!aNULL:!eNULL:+RC4:@STRENGTH>). The format
  of this string and its default value is documented at
  L<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>.
  
  =item session_ticket => $enable
  
  Enables or disables RC5077 support (Session Resumption without Server-Side
  State). The default is disabled for clients, as many (buggy) TLS/SSL
  servers choke on it, but enabled for servers.
  
  When enabled and supported by the server, a session ticket will be
  provided to the client, which allows fast resuming of connections.
  
  =item prepare => $coderef->($tls)
  
  If this argument is present, then it will be called with the new
  AnyEvent::TLS object after any other initialisation has bee done, in case
  you wish to fine-tune something...
  
  =cut
  
  #=item trust => $trust
  #
  #Sets the expected (root) certificate use on this context, i.e. what 
  #certificates to trust. The default is C<compat>, and the following strings
  #are supported:
  #
  #   compat          any certifictae will do
  #   ssl_client      only trust client certificates
  #   ssl_server      only trust server certificates
  #   email           only trust e-mail certificates
  #   object_sign     only trust signing (CA) certificates
  #   ocsp_sign       only trust ocsp signing certs
  #   ocsp_request    only trust ocsp request certs
  
  # purpose?
  
  #TODO
  # verify_depth?
  # reuse_ctx
  # session_cache_size
  # session_cache
  
  #=item debug => $level
  #
  #Enable or disable sending debugging output to STDERR. This is, as
  #the name says, mostly for debugging. The default is taken from the
  #C<PERL_ANYEVENT_TLS_DEBUG> environment variable.
  #
  #=cut
  
  =back
  
  =cut
  
  sub init ();
  
  #our %X509_TRUST = (
  #   compat       => 1,
  #   ssl_client   => 2,
  #   ssl_server   => 3,
  #   email        => 4,
  #   object_sign  => 5,
  #   ocsp_sign    => 6,
  #   ocsp_request => 7,
  #);
  
  sub new {
     my ($class, %arg) = @_;
  
     init unless $REF_IDX;
  
     my $method = lc $arg{method} || "any";
  
     my $ctx = $method eq "any"    ? Net::SSLeay::CTX_new       ()
             : $method eq "sslv23" ? Net::SSLeay::CTX_new       () # deliberately undocumented
             : $method eq "sslv2"  ? Net::SSLeay::CTX_v2_new    ()
             : $method eq "sslv3"  ? Net::SSLeay::CTX_v3_new    ()
             : $method eq "tlsv1"  ? Net::SSLeay::CTX_tlsv1_new ()
             : croak "'$method' is not a valid AnyEvent::TLS method (must be one of SSLv2, SSLv3, TLSv1 or any)";
  
     my $self = bless { ctx => $ctx }, $class; # to make sure it's destroyed if we croak
  
     my $op = Net::SSLeay::OP_ALL ();
  
     $op |= Net::SSLeay::OP_NO_SSLv2      () unless $arg{sslv2};
     $op |= Net::SSLeay::OP_NO_SSLv3      () if exists $arg{sslv3} && !$arg{sslv3};
     $op |= Net::SSLeay::OP_NO_TLSv1      () if exists $arg{tlsv1} && !$arg{tlsv1};
     $op |= Net::SSLeay::OP_SINGLE_DH_USE () if !exists $arg{dh_single_use} || $arg{dh_single_use};
  
     Net::SSLeay::CTX_set_options ($ctx, $op);
  
     Net::SSLeay::CTX_set_cipher_list ($ctx, $arg{cipher_list})
        or croak "'$arg{cipher_list}' was not accepted as a valid cipher list by AnyEvent::TLS"
           if exists $arg{cipher_list};
  
     my ($dh_bio, $dh_file);
  
     if (exists $arg{dh_file}) {
        croak
  
        $dh_file = $arg{dh_file};
  
        $dh_bio = Net::SSLeay::BIO_new_file ($dh_file, "r")
           or croak "$dh_file: failed to open DH parameter file: $!";
     } else {
        $arg{dh} = "schmorp1539" unless exists $arg{dh};
  
        if (defined $arg{dh}) {
           $dh_file = "dh string";
  
           if ($arg{dh} =~ /^\w+$/) {
              $dh_file = "dh params $arg{dh}";
              $arg{dh} = "-----BEGIN DH PARAMETERS-----\n"
                       . $DH_PARAMS{$arg{dh}} . "\n"
                       . "-----END DH PARAMETERS-----";
              $arg{dh} =~ s/\|/\n/g;
           }
  
           $dh_bio = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
           Net::SSLeay::BIO_write ($dh_bio, $arg{dh});
        }
     }
  
     if ($dh_bio) {
        my $dh = Net::SSLeay::PEM_read_bio_DHparams ($dh_bio);
        Net::SSLeay::BIO_free ($dh_bio);
        $dh or croak "$dh_file: failed to parse DH parameters - not PEM format?";
        my $rv = Net::SSLeay::CTX_set_tmp_dh ($ctx, $dh);
        Net::SSLeay::DH_free ($dh);
        $rv or croak "$dh_file: failed to set DH parameters";
     }
  
     if ($arg{verify}) {
        $self->{verify_mode} = Net::SSLeay::VERIFY_PEER ();
  
        $self->{verify_mode} |= Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT ()
           if $arg{verify_require_client_cert};
  
        $self->{verify_mode} |= Net::SSLeay::VERIFY_CLIENT_ONCE ()
           if $arg{verify_client_once};
  
     } else {
        $self->{verify_mode} = Net::SSLeay::VERIFY_NONE ();
     }
  
     $self->{verify_peername} = $arg{verify_peername}
        if exists $arg{verify_peername};
  
     $self->{verify_cb} = $arg{verify_cb}
        if exists $arg{verify_cb};
  
     $self->{session_ticket} = $arg{session_ticket}
        if exists $arg{session_ticket};
  
     $self->{debug} = $ENV{PERL_ANYEVENT_TLS_DEBUG}
        if length $ENV{PERL_ANYEVENT_TLS_DEBUG};
  
     $self->{debug} = $arg{debug}
        if exists $arg{debug};
  
     my $pw = $arg{cert_password};
     Net::SSLeay::CTX_set_default_passwd_cb ($ctx, ref $pw ? $pw : sub { $pw });
  
     if ($self->{verify_mode}) {
        if (exists $arg{ca_file} or exists $arg{ca_path} or exists $arg{ca_cert}) {
           # either specified: use them
           if (exists $arg{ca_cert}) {
              my ($ca_file, $g1) = _tmpfile delete $arg{ca_cert};
              Net::SSLeay::CTX_load_verify_locations ($ctx, $ca_file, undef);
           }
           if (exists $arg{ca_file} or exists $arg{ca_path}) {
              Net::SSLeay::CTX_load_verify_locations ($ctx, $arg{ca_file}, $arg{ca_path});
           }
        } elsif (length $ENV{PERL_ANYEVENT_CA_FILE} or length $ENV{PERL_ANYEVENT_CA_PATH}) {
           Net::SSLeay::CTX_load_verify_locations (
              $ctx,
              $ENV{PERL_ANYEVENT_CA_FILE},
              $ENV{PERL_ANYEVENT_CA_PATH},
           );
        } else {
           # else fall back to defaults
           Net::SSLeay::CTX_set_default_verify_paths ($ctx);
        }
     }
  
     if (exists $arg{cert} or exists $arg{cert_file}) {
        my ($g1, $g2);
  
        if (exists $arg{cert}) {
           croak "specifying both cert_file and cert is not allowed"
              if exists $arg{cert_file};
  
          ($arg{cert_file}, $g1) = _tmpfile delete $arg{cert};
        }
  
        if (exists $arg{key} or exists $arg{key_file}) {
           if (exists $arg{key}) {
              croak "specifying both key_file and key is not allowed"
                 if exists $arg{key_file};
             ($arg{key_file}, $g2) = _tmpfile delete $arg{key};
           }
        } else {
           $arg{key_file} = $arg{cert_file};
        }
  
        Net::SSLeay::CTX_use_PrivateKey_file
              ($ctx, $arg{key_file}, Net::SSLeay::FILETYPE_PEM ())
           or croak "$arg{key_file}: failed to load local private key (key_file or key)";
  
        Net::SSLeay::CTX_use_certificate_chain_file ($ctx, $arg{cert_file})
           or croak "$arg{cert_file}: failed to use local certificate chain (cert_file or cert)";
     }
  
     if ($arg{check_crl}) {
        Net::SSLeay::OPENSSL_VERSION_NUMBER () >= 0x00090702f
           or croak "check_crl requires openssl v0.9.7b or higher";
  
        Net::SSLeay::X509_STORE_set_flags (
           Net::SSLeay::CTX_get_cert_store ($ctx),
           Net::SSLeay::X509_V_FLAG_CRL_CHECK ());
     }
  
     Net::SSLeay::CTX_set_read_ahead ($ctx, 1);
  
     $arg{prepare}->($self)
        if $arg{prepare};
  
     $self
  }
  
  =item $tls = new_from_ssleay AnyEvent::TLS $ctx
  
  This constructor takes an existing L<Net::SSLeay> SSL_CTX object
  (which is just an integer) and converts it into an C<AnyEvent::TLS>
  object. This only works because AnyEvent::TLS is currently implemented
  using Net::SSLeay. As this is such a horrible perl module and OpenSSL has
  such an annoying license, this might change in the future, in which case
  this method might vanish.
  
  =cut
  
  sub new_from_ssleay {
     my ($class, $ctx) = @_;
  
     bless { ctx => $ctx }, $class
  }
  
  =item $ctx = $tls->ctx
  
  Returns the actual L<Net::SSLeay::CTX> object (just an integer).
  
  =cut
  
  sub ctx {
     $_[0]{ctx}
  }
  
  sub verify_hostname($$$);
  
  sub _verify_hostname {
     my ($self, $cn, $cert) = @_;
     
     return 1
        unless defined $cn;
  
     return 1
        unless exists $self->{verify_peername} && "none" ne lc $self->{verify_peername};
  
     return $self->{verify_peername}->($self, $cn, $cert)
        if ref $self->{verify_peername} && "ARRAY" ne ref $self->{verify_peername};
  
     verify_hostname $cn, $cert, $self->{verify_peername}
  }
  
  sub verify {
     my ($self, $session, $ref, $cn, $preverify_ok, $x509_store_ctx) = @_;
  
     my $cert = $x509_store_ctx
        ? Net::SSLeay::X509_STORE_CTX_get_current_cert ($x509_store_ctx)
        : undef;
     my $depth = Net::SSLeay::X509_STORE_CTX_get_error_depth ($x509_store_ctx);
  
     $preverify_ok &&= $self->_verify_hostname ($cn, $cert)
        unless $depth;
  
     $preverify_ok = $self->{verify_cb}->($self, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)
        if $self->{verify_cb};
  
     $preverify_ok
  }
  
  #=item $ssl = $tls->_get_session ($mode[, $ref])
  #
  #Creates a new Net::SSLeay::SSL session object, puts it into C<$mode>
  #(C<accept> or C<connect>) and optionally associates it with the given
  #C<$ref>. If C<$mode> is already a C<Net::SSLeay::SSL> object, then just
  #associate data with it.
  #
  #=cut
  
  #our %REF_MAP;
  
  sub _get_session($$;$$) {
     my ($self, $mode, $ref, $cn) = @_;
  
     my $session;
  
     if ($mode eq "accept") {
        $session = Net::SSLeay::new ($self->{ctx});
        Net::SSLeay::set_accept_state ($session);
  
        Net::SSLeay::set_options ($session, eval { Net::SSLeay::OP_NO_TICKET () })
           unless $self->{session_ticket} || !exists $self->{session_ticket};
  
     } elsif ($mode eq "connect") {
        $session = Net::SSLeay::new ($self->{ctx});
        Net::SSLeay::set_connect_state ($session);
  
        Net::SSLeay::set_options ($session, eval { Net::SSLeay::OP_NO_TICKET () })
           unless $self->{session_ticket};
     } else {
        croak "'$mode': unsupported TLS mode (must be either 'connect' or 'accept')"
     }
  
  #   # associate data
  #   Net::SSLeay::set_ex_data ($session, $REF_IDX, $ref+0);
  #   Scalar::Util::weaken ($REF_MAP{$ref+0} = $ref)
  #      if ref $ref;
     
     if ($self->{debug}) {
        #d# Net::SSLeay::set_info_callback ($session, 50000);
     }
  
     if ($self->{verify_mode}) {
        Scalar::Util::weaken $self;
        Scalar::Util::weaken $ref;
  
        # we have to provide a dummy callbacks as at least Net::SSLeay <= 1.35
        # try to call it even if specified as 0 or undef.
        Net::SSLeay::set_verify
           $session,
           $self->{verify_mode},
           sub { $self->verify ($session, $ref, $cn, @_) };
     }
  
     $session
  }
  
  sub _put_session($$) {
     my ($self, $session) = @_;
  
     # clear callback, if any
     # this leaks memoryin Net::SSLeay up to at least 1.35, but there
     # apparently is no other way.
     Net::SSLeay::set_verify $session, 0, undef;
  
  #   # disassociate data
  #   delete $REF_MAP{Net::SSLeay::get_ex_data ($session, $REF_IDX)};
  
     Net::SSLeay::free ($session);
  }
  
  #sub _ref($) {
  #   $REF_MAP{Net::SSLeay::get_ex_data ($_[0], $REF_IDX)}
  #}
  
  sub DESTROY {
     my ($self) = @_;
  
     # better be safe than sorry with net-ssleay
     Net::SSLeay::CTX_set_default_passwd_cb ($self->{ctx});
  
     Net::SSLeay::CTX_free ($self->{ctx});
  }
  
  =item AnyEvent::TLS::init
  
  AnyEvent::TLS does on-demand initialisation, and normally there is no need to call an initialise
  function.
  
  As initialisation might take some time (to read e.g. C</dev/urandom>), this
  could be annoying in some highly interactive programs. In that case, you can
  call C<AnyEvent::TLS::init> to make sure there will be no costly initialisation
  later. It is harmless to call C<AnyEvent::TLS::init> multiple times.
  
  =cut
  
  sub init() {
     return if $REF_IDX;
  
     AE::log 5 => "AnyEvent::TLS: Net::SSLeay versions older than 1.33 might malfunction."
        if $Net::SSLeay::VERSION < 1.33;
  
     Net::SSLeay::load_error_strings ();
     Net::SSLeay::SSLeay_add_ssl_algorithms ();
     Net::SSLeay::randomize ();
  
     $REF_IDX = Net::SSLeay::get_ex_new_index (0, 0, 0, 0, 0)
        until $REF_IDX; # Net::SSLeay uses id #0 for its own stuff without allocating it
  }
  
  =item $certname = AnyEvent::TLS::certname $x509
  
  Utility function that returns a user-readable string identifying the X509
  certificate object.
  
  =cut
  
  sub certname {
     $_[0]
        ? Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_issuer_name ($_[0]))
          . Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_subject_name ($_[0]))
        : undef
  }
  
  our %CN_SCHEME = (
     # each tuple is [$cn_wildcards, $alt_wildcards, $check_cn]
     # where *_wildcards is 0 for none allowed, 1 for allowed at beginning and 2 for allowed everywhere
     # and check_cn is 0 for do not check, 1 for check when no alternate dns names and 2 always
     # all of this is from IO::Socket::SSL
  
     rfc4513 => [0, 1, 2],
     rfc2818 => [0, 2, 1],
     rfc3207 => [0, 0, 2], # see IO::Socket::SSL, rfc seems unclear
     none    => [],        # do not check
  
     ldap    => "rfc4513",                    ldaps => "ldap",
     http    => "rfc2818",                    https => "http",
     smtp    => "rfc3207",                    smtps => "smtp",
  
     xmpp    => "rfc3920", rfc3920 => "http",
     pop3    => "rfc2595", rfc2595 => "ldap", pop3s => "pop3",
     imap    => "rfc2595", rfc2595 => "ldap", imaps => "imap",
     acap    => "rfc2595", rfc2595 => "ldap",
     nntp    => "rfc4642", rfc4642 => "ldap", nntps => "nntp",
     ftp     => "rfc4217", rfc4217 => "http", ftps  => "ftp" ,
  );
  
  sub match_cn($$$) {
     my ($name, $cn, $type) = @_;
  
     # remove leading and trailing garbage
     for ($name, $cn) {
        s/[\x00-\x1f]+$//;
        s/^[\x00-\x1f]+//;
     }
  
     my $pattern;
  
     ### IMPORTANT!
     # we accept only a single wildcard and only for a single part of the FQDN
     # e.g *.example.org does match www.example.org but not bla.www.example.org
     # The RFCs are in this regard unspecific but we don't want to have to
     # deal with certificates like *.com, *.co.uk or even *
     # see also http://nils.toedtmann.net/pub/subjectAltName.txt
     if ($type == 2 and $name =~m{^([^.]*)\*(.+)} ) {
        $pattern = qr{^\Q$1\E[^.]*\Q$2\E$}i;
     } elsif ($type == 1 and $name =~m{^\*(\..+)$} ) {
        $pattern = qr{^[^.]*\Q$1\E$}i;
     } else {
        $pattern = qr{^\Q$name\E$}i;
     }
  
     $cn =~ $pattern
  }
  
  # taken verbatim from IO::Socket::SSL, then changed to take advantage of
  # AnyEvent utilities.
  sub verify_hostname($$$) {
     my ($cn, $cert, $scheme) = @_;
  
     while (!ref $scheme) {
        $scheme = $CN_SCHEME{$scheme}
           or return 1;
     }
  
     my $cert_cn =
        Net::SSLeay::X509_NAME_get_text_by_NID (
           Net::SSLeay::X509_get_subject_name ($cert), Net::SSLeay::NID_commonName ());
  
     my @cert_alt = Net::SSLeay::X509_get_subjectAltNames ($cert);
  
     # rfc2460 - convert to network byte order
     my $ip = AnyEvent::Socket::parse_address $cn;
  
     my $alt_dns_count;
  
     while (my ($type, $name) = splice @cert_alt, 0, 2) {
        if ($type == Net::SSLeay::GEN_IPADD ()) {
           # $name is already packed format (inet_xton)
           return 1 if $ip eq $name;
        } elsif ($type == Net::SSLeay::GEN_DNS ()) {
           $alt_dns_count++;
  
           return 1 if match_cn $name, $cn, $scheme->[1];
        }
     }
  
     if ($scheme->[2] == 2
         || ($scheme->[2] == 1 && !$alt_dns_count)) {
        return 1 if match_cn $cert_cn, $cn, $scheme->[0];
     }
  
     0
  }
  
  =back
  
  =head1 SSL/TLS QUICK FACTS
  
  Here are some quick facts about TLS/SSL that might help you:
  
  =over 4
  
  =item * A certificate is the public key part, a key is the private key part.
  
  While not strictly true, certificates are the things you can hand around
  publicly as a kind of identity, while keys should really be kept private,
  as proving that you have the private key is usually interpreted as being
  the entity behind the certificate.
  
  =item * A certificate is signed by a CA (Certificate Authority).
  
  By signing, the CA basically claims that the certificate it signs
  really belongs to the identity named in it, verified according to the
  CA policies. For e.g. HTTPS, the CA usually makes some checks that the
  hostname mentioned in the certificate really belongs to the company/person
  that requested the signing and owns the domain.
  
  =item * CAs can be certified by other CAs.
  
  Or by themselves - a certificate that is signed by a CA that is itself
  is called a self-signed certificate, a trust chain of length zero. When
  you find a certificate signed by another CA, which is in turn signed by
  another CA you trust, you have a trust chain of depth two.
  
  =item * "Trusting" a CA means trusting all certificates it has signed.
  
  If you "trust" a CA certificate, then all certificates signed by it are
  automatically considered trusted as well.
  
  =item * A successfully verified certificate means that you can be
  reasonably sure that whoever you are talking with really is who he claims
  he is.
  
  By verifying certificates against a number of CAs that you trust (meaning
  it is signed directly or indirectly by such a CA), you can find out that
  the other side really is whoever he claims, according to the CA policies,
  and your belief in the integrity of the CA.
  
  =item * Verifying the certificate signature is not everything.
  
  Even when the certificate is correct, it might belong to somebody else: if
  www.attacker.com can make your computer believe that it is really called
  www.mybank.com (by making your DNS server believe this for example),
  then it could send you the certificate for www.attacker.com that your
  software trusts because it is signed by a CA you trust, and intercept
  all your traffic that you think goes to www.mybank.com. This works
  because your software sees that the certificate is correctly signed (for
  www.attacker.com) and you think you are talking to your bank.
  
  To thwart this attack vector, peername verification should be used, which
  basically checks that the certificate (for www.attacker.com) really
  belongs to the host you are trying to talk to (www.mybank.com), which in
  this example is not the case, as www.attacker.com (from the certificate)
  doesn't match www.mybank.com (the hostname used to create the connection).
  
  So peername verification is almost as important as checking the CA
  signing. Unfortunately, every protocol implements this differently, if at
  all...
  
  =item * Switching off verification is sometimes reasonable.
  
  You can switch off verification. You still get an encrypted connection
  that is protected against eavesdropping and injection - you just lose
  protection against man in the middle attacks, i.e. somebody else with
  enough abilities to to intercept all traffic can masquerade herself as the
  other side.
  
  For many applications, switching off verification is entirely
  reasonable. Downloading random stuff from websites using HTTPS for no
  reason is such an application. Talking to your bank and entering TANs is
  not such an application.
  
  =item * A SSL/TLS server always needs a certificate/key pair to operate,
  for clients this is optional.
  
  Apart from (usually disabled) anonymous cipher suites, a server always
  needs a certificate/key pair to operate.
  
  Clients almost never use certificates, but if they do, they can be used
  to authenticate the client, just as server certificates can be used to
  authenticate the server.
  
  =item * SSL version 2 is very insecure.
  
  SSL version 2 is old and not only has it some security issues, SSLv2-only
  implementations are usually buggy, too, due to their age.
  
  =item * Sometimes, even losing your "private" key might not expose all your
  data.
  
  With Diffie-Hellman ephemeral key exchange, you can lose the DH parameters
  (the "keys"), but all your connections are still protected. Diffie-Hellman
  needs special set-up (done by default by AnyEvent::TLS).
  
  =back
  
  =head1 SECURITY CONSIDERATIONS
  
  When you use any of the options that pass in keys or certificates
  as strings (e.g. C<ca_cert>), then, due to serious shortcomings in
  L<Net::SSLeay>, this module creates a temporary file to store the string -
  see L<File::Temp> and possibly its C<safe_level> setting for more details
  on what to watch out for.
  
  =head1 BUGS
  
  To to the abysmal code quality of Net::SSLeay, this module will leak small
  amounts of memory per TLS connection (currently at least one perl scalar).
  
  =head1 AUTHORS
  
  Marc Lehmann <schmorp@schmorp.de>.
  
  Some of the API, documentation and implementation (verify_hostname),
  and a lot of ideas/workarounds/knowledge have been taken from the
  L<IO::Socket::SSL> module. Care has been taken to keep the API similar to
  that and other modules, to the extent possible while providing a sensible
  API for AnyEvent.
  
  =cut
  
  1
  
DARWIN-2LEVEL_ANYEVENT_TLS

$fatpacked{"darwin-2level/AnyEvent/Util.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_UTIL';
  =head1 NAME
  
  AnyEvent::Util - various utility functions.
  
  =head1 SYNOPSIS
  
     use AnyEvent::Util;
  
  =head1 DESCRIPTION
  
  This module implements various utility functions, mostly replacing
  well-known functions by event-ised counterparts.
  
  All functions documented without C<AnyEvent::Util::> prefix are exported
  by default.
  
  =over 4
  
  =cut
  
  package AnyEvent::Util;
  
  use Carp ();
  use Errno ();
  use Socket ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use base 'Exporter';
  
  our @EXPORT = qw(fh_nonblocking guard fork_call portable_pipe portable_socketpair run_cmd);
  our @EXPORT_OK = qw(
     AF_INET6 WSAEWOULDBLOCK WSAEINPROGRESS WSAEINVAL
     close_all_fds_except
     punycode_encode punycode_decode idn_nameprep idn_to_ascii idn_to_unicode
  );
  
  our $VERSION = $AnyEvent::VERSION;
  
  BEGIN {
     # provide us with AF_INET6, but only if allowed
     if (
        $AnyEvent::PROTOCOL{ipv6}
        && _AF_INET6
        && socket my $ipv6_socket, _AF_INET6, Socket::SOCK_DGRAM(), 0 # check if they can be created
     ) {
        *AF_INET6 = \&_AF_INET6;
     } else {
        # disable ipv6
        *AF_INET6 = sub () { 0 };
        delete $AnyEvent::PROTOCOL{ipv6};
     }
  
     # fix buggy Errno on some non-POSIX platforms
     # such as openbsd and windows.
     my %ERR = (
        EBADMSG => Errno::EDOM   (),
        EPROTO  => Errno::ESPIPE (),
     );
  
     while (my ($k, $v) = each %ERR) {
        next if eval "Errno::$k ()";
        AE::log 8 => "AnyEvent::Util: broken Errno module, adding Errno::$k.";
  
        eval "sub Errno::$k () { $v }";
        push @Errno::EXPORT_OK, $k;
        push @{ $Errno::EXPORT_TAGS{POSIX} }, $k;
     }
  }
  
  =item ($r, $w) = portable_pipe
  
  Calling C<pipe> in Perl is portable - except it doesn't really work on
  sucky windows platforms (at least not with most perls - cygwin's perl
  notably works fine): On windows, you actually get two file handles you
  cannot use select on.
  
  This function gives you a pipe that actually works even on the broken
  windows platform (by creating a pair of TCP sockets on windows, so do not
  expect any speed from that, and using C<pipe> everywhere else).
  
  See C<portable_socketpair>, below, for a bidirectional "pipe".
  
  Returns the empty list on any errors.
  
  =item ($fh1, $fh2) = portable_socketpair
  
  Just like C<portable_pipe>, above, but returns a bidirectional pipe
  (usually by calling C<socketpair> to create a local loopback socket pair,
  except on windows, where it again returns two interconnected TCP sockets).
  
  Returns the empty list on any errors.
  
  =cut
  
  BEGIN {
     if (AnyEvent::WIN32) {
        *_win32_socketpair = sub () {
           # perl's socketpair emulation fails on many vista machines, because
           # vista returns fantasy port numbers.
  
           for (1..10) {
              socket my $l, Socket::AF_INET(), Socket::SOCK_STREAM(), 0
                 or next;
  
              bind $l, Socket::pack_sockaddr_in 0, "\x7f\x00\x00\x01"
                 or next;
  
              my $sa = getsockname $l
                 or next;
  
              listen $l, 1
                 or next;
  
              socket my $r, Socket::AF_INET(), Socket::SOCK_STREAM(), 0
                 or next;
  
              bind $r, Socket::pack_sockaddr_in 0, "\x7f\x00\x00\x01"
                 or next;
  
              connect $r, $sa
                 or next;
  
              accept my $w, $l
                 or next;
  
              # vista has completely broken peername/sockname that return
              # fantasy ports. this combo seems to work, though.
              #
              (Socket::unpack_sockaddr_in getpeername $r)[0]
              == (Socket::unpack_sockaddr_in getsockname $w)[0]
                 or (($! = WSAEINVAL), next);
  
              # vista example (you can't make this shit up...):
              #(Socket::unpack_sockaddr_in getsockname $r)[0] == 53364
              #(Socket::unpack_sockaddr_in getpeername $r)[0] == 53363
              #(Socket::unpack_sockaddr_in getsockname $w)[0] == 53363
              #(Socket::unpack_sockaddr_in getpeername $w)[0] == 53365
  
              return ($r, $w);
           }
  
           ()
        };
  
        *portable_socketpair = \&_win32_socketpair;
        *portable_pipe       = \&_win32_socketpair;
     } else {
        *portable_pipe = sub () {
           my ($r, $w);
  
           pipe $r, $w
              or return;
  
           ($r, $w);
        };
  
        *portable_socketpair = sub () {
           socketpair my $fh1, my $fh2, Socket::AF_UNIX(), Socket::SOCK_STREAM(), 0
              or return;
  
           ($fh1, $fh2)
        };
     }
  }
  
  =item fork_call { CODE } @args, $cb->(@res)
  
  Executes the given code block asynchronously, by forking. Everything the
  block returns will be transferred to the calling process (by serialising and
  deserialising via L<Storable>).
  
  If there are any errors, then the C<$cb> will be called without any
  arguments. In that case, either C<$@> contains the exception (and C<$!> is
  irrelevant), or C<$!> contains an error number. In all other cases, C<$@>
  will be C<undef>ined.
  
  The code block must not ever call an event-polling function or use
  event-based programming that might cause any callbacks registered in the
  parent to run.
  
  Win32 spoilers: Due to the endlessly sucky and broken native windows
  perls (there is no way to cleanly exit a child process on that platform
  that doesn't also kill the parent), you have to make sure that your main
  program doesn't exit as long as any C<fork_calls> are still in progress,
  otherwise the program won't exit. Also, on most windows platforms some
  memory will leak for every invocation. We are open for improvements that
  don't require XS hackery.
  
  Note that forking can be expensive in large programs (RSS 200MB+). On
  windows, it is abysmally slow, do not expect more than 5..20 forks/s on
  that sucky platform (note this uses perl's pseudo-threads, so avoid those
  like the plague).
  
  Example: poor man's async disk I/O (better use L<IO::AIO>).
  
     fork_call {
        open my $fh, "</etc/passwd"
           or die "passwd: $!";
        local $/;
        <$fh>
     } sub {
        my ($passwd) = @_;
        ...
     };
  
  =item $AnyEvent::Util::MAX_FORKS [default: 10]
  
  The maximum number of child processes that C<fork_call> will fork in
  parallel. Any additional requests will be queued until a slot becomes free
  again.
  
  The environment variable C<PERL_ANYEVENT_MAX_FORKS> is used to initialise
  this value.
  
  =cut
  
  our $MAX_FORKS = int 1 * $ENV{PERL_ANYEVENT_MAX_FORKS};
  $MAX_FORKS = 10 if $MAX_FORKS <= 0;
  
  my $forks;
  my @fork_queue;
  
  sub _fork_schedule;
  sub _fork_schedule {
     require Storable unless $Storable::VERSION;
     require POSIX    unless $POSIX::VERSION;
  
     while ($forks < $MAX_FORKS) {
        my $job = shift @fork_queue
           or last;
  
        ++$forks;
  
        my $coderef = shift @$job;
        my $cb = pop @$job;
        
        # gimme a break...
        my ($r, $w) = portable_pipe
           or ($forks and last) # allow failures when we have at least one job
           or die "fork_call: $!";
  
        my $pid = fork;
  
        if ($pid != 0) {
           # parent
           close $w;
  
           my $buf;
  
           my $ww; $ww = AE::io $r, 0, sub {
              my $len = sysread $r, $buf, 65536, length $buf;
  
              return unless defined $len or $! != Errno::EINTR;
  
              if (!$len) {
                 undef $ww;
                 close $r;
                 --$forks;
                 _fork_schedule;
                 
                 my $result = eval { Storable::thaw ($buf) };
                 $result = [$@] unless $result;
                 $@ = shift @$result;
  
                 $cb->(@$result);
  
                 # work around the endlessly broken windows perls
                 kill 9, $pid if AnyEvent::WIN32;
  
                 # clean up the pid
                 waitpid $pid, 0;
              }
           };
  
        } elsif (defined $pid) {
           # child
           close $r;
  
           my $result = eval {
              local $SIG{__DIE__};
  
              Storable::freeze ([undef, $coderef->(@$job)])
           };
  
           $result = Storable::freeze (["$@"])
              if $@;
  
           # windows forces us to these contortions
           my $ofs;
  
           while () {
              my $len = (length $result) - $ofs
                 or last;
  
              $len = syswrite $w, $result, $len < 65536 ? $len : 65536, $ofs;
  
              last unless $len || (!defined $len && $! == Errno::EINTR);
  
              $ofs += $len;
           }
  
           # on native windows, _exit KILLS YOUR FORKED CHILDREN!
           if (AnyEvent::WIN32) {
              shutdown $w, 1; # signal parent to please kill us
              sleep 10; # give parent a chance to clean up
              sysread $w, (my $buf), 1; # this *might* detect the parent exiting in some cases.
           }
           POSIX::_exit (0);
           exit 1;
           
        } elsif (($! != &Errno::EAGAIN && $! != &Errno::ENOMEM) || !$forks) {
           # we ignore some errors as long as we can run at least one job
           # maybe we should wait a few seconds and retry instead
           die "fork_call: $!";
        }
     }
  }
  
  sub fork_call(&@) {
     push @fork_queue, [@_];
     _fork_schedule;
  }
  
  END {
     if (AnyEvent::WIN32) {
        while ($forks) {
           @fork_queue = ();
           AnyEvent->one_event;
        }
     }
  }
  
  # to be removed
  sub dotted_quad($) {
     $_[0] =~ /^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)$/x
  }
  
  # just a forwarder
  sub inet_aton {
     require AnyEvent::Socket;
     *inet_aton = \&AnyEvent::Socket::inet_aton;
     goto &inet_aton
  }
  
  =item fh_nonblocking $fh, $nonblocking
  
  Sets the blocking state of the given filehandle (true == nonblocking,
  false == blocking). Uses fcntl on anything sensible and ioctl FIONBIO on
  broken (i.e. windows) platforms.
  
  =cut
  
  BEGIN {
     *fh_nonblocking = AnyEvent::WIN32
        ? sub($$) {
            ioctl $_[0], 0x8004667e, pack "L", $_[1]; # FIONBIO
          }
        : sub($$) {
            fcntl $_[0], AnyEvent::F_SETFL, $_[1] ? AnyEvent::O_NONBLOCK : 0;
          }
     ;
  }
  
  =item $guard = guard { CODE }
  
  This function creates a special object that, when called, will execute
  the code block.
  
  This is often handy in continuation-passing style code to clean up some
  resource regardless of where you break out of a process.
  
  The L<Guard> module will be used to implement this function, if it is
  available. Otherwise a pure-perl implementation is used.
  
  While the code is allowed to throw exceptions in unusual conditions, it is
  not defined whether this exception will be reported (at the moment, the
  Guard module and AnyEvent's pure-perl implementation both try to report
  the error and continue).
  
  You can call one method on the returned object:
  
  =item $guard->cancel
  
  This simply causes the code block not to be invoked: it "cancels" the
  guard.
  
  =cut
  
  BEGIN {
     if (!$ENV{PERL_ANYEVENT_AVOID_GUARD} && eval { require Guard; $Guard::VERSION >= 0.5 }) {
        *guard = \&Guard::guard;
        AE::log 8 => "AnyEvent::Util: using Guard module to implement guards.";
     } else {
        *AnyEvent::Util::guard::DESTROY = sub {
           local $@;
  
           eval {
              local $SIG{__DIE__};
              ${$_[0]}->();
           };
  
           AE::log 4 => "runtime error in AnyEvent::guard callback: $@" if $@;
        };
  
        *AnyEvent::Util::guard::cancel = sub ($) {
           ${$_[0]} = sub { };
        };
  
        *guard = sub (&) {
           bless \(my $cb = shift), "AnyEvent::Util::guard"
        };
  
        AE::log 8 => "AnyEvent::Util: using pure-perl guard implementation.";
     }
  }
  
  =item AnyEvent::Util::close_all_fds_except @fds
  
  This rarely-used function simply closes all file descriptors (or tries to)
  of the current process except the ones given as arguments.
  
  When you want to start a long-running background server, then it is often
  beneficial to do this, as too many C-libraries are too stupid to mark
  their internal fd's as close-on-exec.
  
  The function expects to be called shortly before an C<exec> call.
  
  Example: close all fds except 0, 1, 2.
  
     close_all_fds_except 0, 2, 1;
  
  =cut
  
  sub close_all_fds_except {
     my %except; @except{@_} = ();
  
     require POSIX unless $POSIX::VERSION;
  
     # some OSes have a usable /dev/fd, sadly, very few
     if ($^O =~ /(freebsd|cygwin|linux)/) {
        # netbsd, openbsd, solaris have a broken /dev/fd
        my $dir;
        if (opendir $dir, "/dev/fd" or opendir $dir, "/proc/self/fd") {
           my @fds = sort { $a <=> $b } grep /^\d+$/, readdir $dir;
           # broken OS's have device nodes for 0..63 usually, solaris 0..255
           if (@fds < 20 or "@fds" ne join " ", 0..$#fds) {
              # assume the fds array is valid now
              exists $except{$_} or POSIX::close ($_)
                 for @fds;
              return;
           }
        }
     }
  
     my $fd_max = eval { POSIX::sysconf (POSIX::_SC_OPEN_MAX ()) - 1 } || 1023;
  
     exists $except{$_} or POSIX::close ($_)
        for 0..$fd_max;
  }
  
  =item $cv = run_cmd $cmd, key => value...
  
  Run a given external command, potentially redirecting file descriptors and
  return a condition variable that gets sent the exit status (like C<$?>)
  when the program exits I<and> all redirected file descriptors have been
  exhausted.
  
  The C<$cmd> is either a single string, which is then passed to a shell, or
  an arrayref, which is passed to the C<execvp> function.
  
  The key-value pairs can be:
  
  =over 4
  
  =item ">" => $filename
  
  Redirects program standard output into the specified filename, similar to C<<
  >filename >> in the shell.
  
  =item ">" => \$data
  
  Appends program standard output to the referenced scalar. The condvar will
  not be signalled before EOF or an error is signalled.
  
  =item ">" => $filehandle
  
  Redirects program standard output to the given filehandle (or actually its
  underlying file descriptor).
  
  =item ">" => $callback->($data)
  
  Calls the given callback each time standard output receives some data,
  passing it the data received. On EOF or error, the callback will be
  invoked once without any arguments.
  
  The condvar will not be signalled before EOF or an error is signalled.
  
  =item "fd>" => $see_above
  
  Like ">", but redirects the specified fd number instead.
  
  =item "<" => $see_above
  
  The same, but redirects the program's standard input instead. The same
  forms as for ">" are allowed.
  
  In the callback form, the callback is supposed to return data to be
  written, or the empty list or C<undef> or a zero-length scalar to signal
  EOF.
  
  Similarly, either the write data must be exhausted or an error is to be
  signalled before the condvar is signalled, for both string-reference and
  callback forms.
  
  =item "fd<" => $see_above
  
  Like "<", but redirects the specified file descriptor instead.
  
  =item on_prepare => $cb
  
  Specify a callback that is executed just before the command is C<exec>'ed,
  in the child process. Be careful not to use any event handling or other
  services not available in the child.
  
  This can be useful to set up the environment in special ways, such as
  changing the priority of the command or manipulating signal handlers (e.g.
  setting C<SIGINT> to C<IGNORE>).
  
  =item close_all => $boolean
  
  When C<close_all> is enabled (default is disabled), then all extra file
  descriptors will be closed, except the ones that were redirected and C<0>,
  C<1> and C<2>.
  
  See C<close_all_fds_except> for more details.
  
  =item '$$' => \$pid
  
  A reference to a scalar which will receive the PID of the newly-created
  subprocess after C<run_cmd> returns.
  
  Note the the PID might already have been recycled and used by an unrelated
  process at the time C<run_cmd> returns, so it's not useful to send
  signals, use a unique key in data structures and so on.
  
  =back
  
  Example: run C<rm -rf />, redirecting standard input, output and error to
  F</dev/null>.
  
     my $cv = run_cmd [qw(rm -rf /)],
        "<", "/dev/null",
        ">", "/dev/null",
        "2>", "/dev/null";
     $cv->recv and die "d'oh! something survived!"
  
  Example: run F<openssl> and create a self-signed certificate and key,
  storing them in C<$cert> and C<$key>. When finished, check the exit status
  in the callback and print key and certificate.
  
     my $cv = run_cmd [qw(openssl req 
                       -new -nodes -x509 -days 3650
                       -newkey rsa:2048 -keyout /dev/fd/3
                       -batch -subj /CN=AnyEvent
                      )],
        "<", "/dev/null",
        ">" , \my $cert,
        "3>", \my $key,
        "2>", "/dev/null";
  
     $cv->cb (sub {
        shift->recv and die "openssl failed";
  
        print "$key\n$cert\n";
     });
  
  =cut
  
  sub run_cmd {
     my $cmd = shift;
  
     require POSIX unless $POSIX::VERSION;
  
     my $cv = AE::cv;
  
     my %arg;
     my %redir;
     my @exe;
  
     while (@_) {
        my ($type, $ob) = splice @_, 0, 2;
  
        my $fd = $type =~ s/^(\d+)// ? $1 : undef;
  
        if ($type eq ">") {
           $fd = 1 unless defined $fd;
  
           if (defined eval { fileno $ob }) {
              $redir{$fd} = $ob;
           } elsif (ref $ob) {
              my ($pr, $pw) = AnyEvent::Util::portable_pipe;
              $cv->begin;
  
              fcntl $pr, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              my $w; $w = AE::io $pr, 0,
                 "SCALAR" eq ref $ob
                    ? sub {
                         defined (sysread $pr, $$ob, 16384, length $$ob
                                  and return)
                            or ($! == Errno::EINTR and return);
                         undef $w; $cv->end;
                      }
                    : sub {
                         my $buf;
                         defined (sysread $pr, $buf, 16384
                                  and return $ob->($buf))
                            or ($! == Errno::EINTR and return);
                         undef $w; $cv->end;
                         $ob->();
                      }
              ;
              $redir{$fd} = $pw;
           } else {
              push @exe, sub {
                 open my $fh, ">", $ob
                    or POSIX::_exit (125);
                 $redir{$fd} = $fh;
              };
           }
  
        } elsif ($type eq "<") {
           $fd = 0 unless defined $fd;
  
           if (defined eval { fileno $ob }) {
              $redir{$fd} = $ob;
           } elsif (ref $ob) {
              my ($pr, $pw) = AnyEvent::Util::portable_pipe;
              $cv->begin;
  
              my $data;
              if ("SCALAR" eq ref $ob) {
                 $data = $$ob;
                 $ob = sub { };
              } else {
                 $data = $ob->();
              }
  
              fcntl $pw, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              my $w; $w = AE::io $pw, 1, sub {
                 my $len = syswrite $pw, $data;
  
                 return unless defined $len or $! != Errno::EINTR;
  
                 if (!$len) {
                    undef $w; $cv->end;
                 } else {
                    substr $data, 0, $len, "";
                    unless (length $data) {
                       $data = $ob->();
                       unless (length $data) {
                          undef $w; $cv->end
                       }
                    }
                 }
              };
  
              $redir{$fd} = $pr;
           } else {
              push @exe, sub {
                 open my $fh, "<", $ob
                    or POSIX::_exit (125);
                 $redir{$fd} = $fh;
              };
           }
  
        } else {
           $arg{$type} = $ob;
        }
     }
  
     my $pid = fork;
  
     defined $pid
        or Carp::croak "fork: $!";
  
     unless ($pid) {
        # step 1, execute
        $_->() for @exe;
  
        # step 2, move any existing fd's out of the way
        # this also ensures that dup2 is never called with fd1==fd2
        # so the cloexec flag is always cleared
        my (@oldfh, @close);
        for my $fh (values %redir) {
           push @oldfh, $fh; # make sure we keep it open
           $fh = fileno $fh; # we only want the fd
  
           # dup if we are in the way
           # if we "leak" fds here, they will be dup2'ed over later
           defined ($fh = POSIX::dup ($fh)) or POSIX::_exit (124)
              while exists $redir{$fh};
        }
  
        # step 3, execute redirects
        while (my ($k, $v) = each %redir) {
           defined POSIX::dup2 ($v, $k)
              or POSIX::_exit (123);
        }
  
        # step 4, close everything else, except 0, 1, 2
        if ($arg{close_all}) {
           close_all_fds_except 0, 1, 2, keys %redir
        } else {
           POSIX::close ($_)
              for values %redir;
        }
  
        eval { $arg{on_prepare}(); 1 } or POSIX::_exit (123)
           if exists $arg{on_prepare};
  
        ref $cmd
           ? exec {$cmd->[0]} @$cmd
           : exec $cmd;
  
        POSIX::_exit (126);
     }
  
     ${$arg{'$$'}} = $pid
        if $arg{'$$'};
  
     %redir = (); # close child side of the fds
  
     my $status;
     $cv->begin (sub { shift->send ($status) });
     my $cw; $cw = AE::child $pid, sub {
        $status = $_[1];
        undef $cw; $cv->end;
     };
  
     $cv
  }
  
  =item AnyEvent::Util::punycode_encode $string
  
  Punycode-encodes the given C<$string> and returns its punycode form. Note
  that uppercase letters are I<not> casefolded - you have to do that
  yourself.
  
  Croaks when it cannot encode the string.
  
  =item AnyEvent::Util::punycode_decode $string
  
  Tries to punycode-decode the given C<$string> and return its unicode
  form. Again, uppercase letters are not casefoled, you have to do that
  yourself.
  
  Croaks when it cannot decode the string.
  
  =cut
  
  sub punycode_encode($) {
     require "AnyEvent/Util/idna.pl";
     goto &punycode_encode;
  }
  
  sub punycode_decode($) {
     require "AnyEvent/Util/idna.pl";
     goto &punycode_decode;
  }
  
  =item AnyEvent::Util::idn_nameprep $idn[, $display]
  
  Implements the IDNA nameprep normalisation algorithm. Or actually the
  UTS#46 algorithm. Or maybe something similar - reality is complicated
  between IDNA2003, UTS#46 and IDNA2008. If C<$display> is true then the name
  is prepared for display, otherwise it is prepared for lookup (default).
  
  If you have no clue what this means, look at C<idn_to_ascii> instead.
  
  This function is designed to avoid using a lot of resources - it uses
  about 1MB of RAM (most of this due to Unicode::Normalize). Also, names
  that are already "simple" will only be checked for basic validity, without
  the overhead of full nameprep processing.
  
  =cut
  
  our ($uts46_valid, $uts46_imap);
  
  sub idn_nameprep($;$) {
     local $_ = $_[0];
  
     # lowercasing these should always be valid, and is required for xn-- detection
     y/A-Z/a-z/;
  
     if (/[^0-9a-z\-.]/) {
        # load the mapping data
        unless (defined $uts46_imap) {
           require Unicode::Normalize;
           require "lib/AnyEvent/Util/uts46data.pl";
        }
  
        # uts46 nameprep
  
        # I naively tried to use a regex/transliterate approach first,
        # with one regex and one y///, but the compiled code was 4.5MB.
        # this version has a bit-table for the valid class, and
        # a char-replacement search string
  
        # for speed (cough) reasons, we skip-case 0-9a-z, -, ., which
        # really ought to be trivially valid. A-Z is valid, but already lowercased.
        s{
           ([^0-9a-z\-.])
        }{
           my $chr = $1;
           unless (vec $uts46_valid, ord $chr, 1) {
              # not in valid class, search for mapping
              utf8::encode $chr; # the imap table is in utf-8
              (my $rep = index $uts46_imap, "\x00$chr") >= 0
                 or Carp::croak "$_[0]: disallowed characters ($chr) during idn_nameprep" . unpack "H*", $chr;
  
              (substr $uts46_imap, $rep, 128) =~ /\x00 .[\x80-\xbf]* ([^\x00]*) \x00/x
                 or die "FATAL: idn_nameprep imap table has unexpected contents";
  
              $rep = $1;
              $chr = $rep unless $rep =~ s/^\x01// && $_[1]; # replace unless deviation and display
              utf8::decode $chr;
           }
           $chr
        }gex;
  
        # KC
        $_ = Unicode::Normalize::NFKC ($_);
     }
  
     # decode punycode components, check for invalid xx-- prefixes
     s{
        (^|\.)(..)--([^\.]*)
     }{
        my ($pfx, $ace, $pc) = ($1, $2, $3);
  
        if ($ace eq "xn") {
           $pc = punycode_decode $pc; # will croak on error (we hope :)
  
           require Unicode::Normalize;
           $pc eq Unicode::Normalize::NFC ($pc)
              or Carp::croak "$_[0]: punycode label not in NFC detected during idn_nameprep";
  
           "$pfx$pc"
        } elsif ($ace !~ /^[a-z0-9]{2}$/) {
           "$pfx$ace--$pc"
        } else {
           Carp::croak "$_[0]: hyphens in 3rd/4th position of a label are not allowed";
        }
     }gex;
  
     # uts46 verification
     /\.-|-\./
        and Carp::croak "$_[0]: invalid hyphens detected during idn_nameprep";
  
     # missing: label begin with combining mark, idna2008 bidi
  
     # now check validity of each codepoint
     if (/[^0-9a-z\-.]/) {
        # load the mapping data
        unless (defined $uts46_imap) {
           require "lib/AnyEvent/Util/uts46data.pl";
        }
  
        vec $uts46_valid, ord, 1
           or $_[1] && 0 <= index $uts46_imap, pack "C0U*", 0, ord, 1 # deviation == \x00$chr\x01
           or Carp::croak "$_[0]: disallowed characters during idn_nameprep"
           for split //;
     }
  
     $_
  }
  
  =item $domainname = AnyEvent::Util::idn_to_ascii $idn
  
  Converts the given unicode string (C<$idn>, international domain name,
  e.g. ) to a pure-ASCII domain name (this is usually
  called the "IDN ToAscii" transform). This transformation is idempotent,
  which means you can call it just in case and it will do the right thing.
  
  Unlike some other "ToAscii" implementations, this one works on full domain
  names and should never fail - if it cannot convert the name, then it will
  return it unchanged.
  
  This function is an amalgam of IDNA2003, UTS#46 and IDNA2008 - it tries to
  be reasonably compatible to other implementations, reasonably secure, as
  much as IDNs can be secure, and reasonably efficient when confronted with
  IDNs that are already valid DNS names.
  
  =cut
  
  sub idn_to_ascii($) {
     return $_[0]
        unless $_[0] =~ /[^\x00-\x7f]/;
  
     my @output;
  
     eval {
        # punycode by label
        for (split /\./, (idn_nameprep $_[0]), -1) {
           if (/[^\x00-\x7f]/) {
              eval {
                 push @output, "xn--" . punycode_encode $_;
                 1;
              } or do {
                 push @output, $_;
              };
           } else {
              push @output, $_;
           }
        }
  
        1
     } or return $_[0];
  
     shift @output
        while !length $output[0] && @output > 1;
  
     join ".", @output
  }
  
  =item $idn = AnyEvent::Util::idn_to_unicode $idn
  
  Converts the given unicode string (C<$idn>, international domain name,
  e.g. , www.deliantra.net, www.xn--l-0ga.de) to
  unicode form (this is usually called the "IDN ToUnicode" transform). This
  transformation is idempotent, which means you can call it just in case and
  it will do the right thing.
  
  Unlike some other "ToUnicode" implementations, this one works on full
  domain names and should never fail - if it cannot convert the name, then
  it will return it unchanged.
  
  This function is an amalgam of IDNA2003, UTS#46 and IDNA2008 - it tries to
  be reasonably compatible to other implementations, reasonably secure, as
  much as IDNs can be secure, and reasonably efficient when confronted with
  IDNs that are already valid DNS names.
  
  At the moment, this function simply calls C<idn_nameprep $idn, 1>,
  returning its argument when that function fails.
  
  =cut
  
  sub idn_to_unicode($) {
     my $res = eval { idn_nameprep $_[0], 1 };
     defined $res ? $res : $_[0]
  }
  
  
  1;
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_UTIL

$fatpacked{"darwin-2level/Digest/SHA1.pm"} = <<'DARWIN-2LEVEL_DIGEST_SHA1';
  package Digest::SHA1;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = '2.13';
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT_OK = qw(sha1 sha1_hex sha1_base64 sha1_transform);
  
  require DynaLoader;
  @ISA=qw(DynaLoader);
  
  eval {
      require Digest::base;
      push(@ISA, 'Digest::base');
  };
  if ($@) {
      my $err = $@;
      *add_bits = sub { die $err };
  }
  
  Digest::SHA1->bootstrap($VERSION);
  
  1;
  __END__
  
  =head1 NAME
  
  Digest::SHA1 - Perl interface to the SHA-1 algorithm
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::SHA1  qw(sha1 sha1_hex sha1_base64);
  
   $digest = sha1($data);
   $digest = sha1_hex($data);
   $digest = sha1_base64($data);
   $digest = sha1_transform($data);
  
  
   # OO style
   use Digest::SHA1;
  
   $sha1 = Digest::SHA1->new;
  
   $sha1->add($data);
   $sha1->addfile(*FILE);
  
   $sha1_copy = $sha1->clone;
  
   $digest = $sha1->digest;
   $digest = $sha1->hexdigest;
   $digest = $sha1->b64digest;
   $digest = $sha1->transform;
  
  =head1 DESCRIPTION
  
  The C<Digest::SHA1> module allows you to use the NIST SHA-1 message
  digest algorithm from within Perl programs.  The algorithm takes as
  input a message of arbitrary length and produces as output a 160-bit
  "fingerprint" or "message digest" of the input.
  
  In 2005, security flaws were identified in SHA-1, namely that a possible
  mathematical weakness might exist, indicating that a stronger hash function
  would be desirable.  The L<Digest::SHA> module implements the stronger
  algorithms in the SHA family.
  
  The C<Digest::SHA1> module provide a procedural interface for simple
  use, as well as an object oriented interface that can handle messages
  of arbitrary length and which can read files directly.
  
  =head1 FUNCTIONS
  
  The following functions can be exported from the C<Digest::SHA1>
  module.  No functions are exported by default.
  
  =over 4
  
  =item sha1($data,...)
  
  This function will concatenate all arguments, calculate the SHA-1
  digest of this "message", and return it in binary form.  The returned
  string will be 20 bytes long.
  
  The result of sha1("a", "b", "c") will be exactly the same as the
  result of sha1("abc").
  
  =item sha1_hex($data,...)
  
  Same as sha1(), but will return the digest in hexadecimal form.  The
  length of the returned string will be 40 and it will only contain
  characters from this set: '0'..'9' and 'a'..'f'.
  
  =item sha1_base64($data,...)
  
  Same as sha1(), but will return the digest as a base64 encoded string.
  The length of the returned string will be 27 and it will only contain
  characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+' and
  '/'.
  
  Note that the base64 encoded string returned is not padded to be a
  multiple of 4 bytes long.  If you want interoperability with other
  base64 encoded sha1 digests you might want to append the redundant
  string "=" to the result.
  
  =item sha1_transform($data)
  
  Implements the basic SHA1 transform on a 64 byte block. The $data
  argument and the returned $digest are in binary form. This algorithm
  is used in NIST FIPS 186-2
  
  =back
  
  =head1 METHODS
  
  The object oriented interface to C<Digest::SHA1> is described in this
  section.  After a C<Digest::SHA1> object has been created, you will add
  data to it and finally ask for the digest in a suitable format.  A
  single object can be used to calculate multiple digests.
  
  The following methods are provided:
  
  =over 4
  
  =item $sha1 = Digest::SHA1->new
  
  The constructor returns a new C<Digest::SHA1> object which encapsulate
  the state of the SHA-1 message-digest algorithm.
  
  If called as an instance method (i.e. $sha1->new) it will just reset the
  state the object to the state of a newly created object.  No new
  object is created in this case.
  
  =item $sha1->reset
  
  This is just an alias for $sha1->new.
  
  =item $sha1->clone
  
  This a copy of the $sha1 object. It is useful when you do not want to
  destroy the digests state, but need an intermediate value of the
  digest, e.g. when calculating digests iteratively on a continuous data
  stream.  Example:
  
      my $sha1 = Digest::SHA1->new;
      while (<>) {
  	$sha1->add($_);
  	print "Line $.: ", $sha1->clone->hexdigest, "\n";
      }
  
  =item $sha1->add($data,...)
  
  The $data provided as argument are appended to the message we
  calculate the digest for.  The return value is the $sha1 object itself.
  
  All these lines will have the same effect on the state of the $sha1
  object:
  
      $sha1->add("a"); $sha1->add("b"); $sha1->add("c");
      $sha1->add("a")->add("b")->add("c");
      $sha1->add("a", "b", "c");
      $sha1->add("abc");
  
  =item $sha1->addfile($io_handle)
  
  The $io_handle will be read until EOF and its content appended to the
  message we calculate the digest for.  The return value is the $sha1
  object itself.
  
  The addfile() method will croak() if it fails reading data for some
  reason.  If it croaks it is unpredictable what the state of the $sha1
  object will be in. The addfile() method might have been able to read
  the file partially before it failed.  It is probably wise to discard
  or reset the $sha1 object if this occurs.
  
  In most cases you want to make sure that the $io_handle is in
  C<binmode> before you pass it as argument to the addfile() method.
  
  =item $sha1->add_bits($data, $nbits)
  
  =item $sha1->add_bits($bitstring)
  
  This implementation of SHA-1 only supports byte oriented input so you
  might only add bits as multiples of 8.  If you need bit level support
  please consider using the C<Digest::SHA> module instead.  The
  add_bits() method is provided here for compatibility with other digest
  implementations.  See L<Digest> for description of the arguments that
  add_bits() take.
  
  =item $sha1->digest
  
  Return the binary digest for the message.  The returned string will be
  20 bytes long.
  
  Note that the C<digest> operation is effectively a destructive,
  read-once operation. Once it has been performed, the C<Digest::SHA1>
  object is automatically C<reset> and can be used to calculate another
  digest value.  Call $sha1->clone->digest if you want to calculate the
  digest without reseting the digest state.
  
  =item $sha1->hexdigest
  
  Same as $sha1->digest, but will return the digest in hexadecimal
  form. The length of the returned string will be 40 and it will only
  contain characters from this set: '0'..'9' and 'a'..'f'.
  
  =item $sha1->b64digest
  
  Same as $sha1->digest, but will return the digest as a base64 encoded
  string.  The length of the returned string will be 27 and it will only
  contain characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+'
  and '/'.
  
  
  The base64 encoded string returned is not padded to be a multiple of 4
  bytes long.  If you want interoperability with other base64 encoded
  SHA-1 digests you might want to append the string "=" to the result.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest>, L<Digest::HMAC_SHA1>, L<Digest::SHA>, L<Digest::MD5>
  
  http://www.itl.nist.gov/fipspubs/fip180-1.htm
  
  http://en.wikipedia.org/wiki/SHA_hash_functions
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 1999-2004 Gisle Aas.
   Copyright 1997 Uwe Hollerbach.
  
  =head1 AUTHORS
  
  Peter C. Gutmann,
  Uwe Hollerbach <uh@alumni.caltech.edu>,
  Gisle Aas <gisle@aas.no>
  
  =cut
DARWIN-2LEVEL_DIGEST_SHA1

$fatpacked{"darwin-2level/HTTP/Parser/XS.pm"} = <<'DARWIN-2LEVEL_HTTP_PARSER_XS';
  package HTTP::Parser::XS;
  
  use strict;
  use warnings;
  
  use base qw(Exporter);
  
  our %EXPORT_TAGS = (
      'all' => [ qw/parse_http_request parse_http_response
                    HEADERS_NONE HEADERS_AS_HASHREF HEADERS_AS_ARRAYREF/ ],
  );
  our @EXPORT_OK = @{$EXPORT_TAGS{all}};
  our @EXPORT = ();
  
  # header format for parse_http_response()
  use constant {
      HEADERS_NONE => 0,       # don't parse headers. It's fastest. if you want only special headers, also fastest.
      HEADERS_AS_HASHREF => 1,    # HTTP::Headers compatible HashRef, { header_name => "header_value" or ["val1", "val2"] }
      HEADERS_AS_ARRAYREF =>2,    # Ordered ArrayRef : [ name, value, name2, value2 ... ]
  };
  
  our $VERSION = '0.14';
  
  our $BACKEND;
  
  if (not __PACKAGE__->can('parse_http_response')) {
      $BACKEND = $ENV{PERL_HTTP_PARSER_XS} || ($ENV{PERL_ONLY} ? 'pp' : '');
      if ($BACKEND !~ /\b pp \b/xms) {
          eval {
              require XSLoader;
              XSLoader::load(__PACKAGE__, $VERSION);
              $BACKEND = 'xs';
          };
          die $@ if $@ && $BACKEND =~ /\bxs\b/;
      }
      if (not __PACKAGE__->can('parse_http_response')) {
          require HTTP::Parser::XS::PP;
          $BACKEND = 'pp';
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  HTTP::Parser::XS - a fast, primitive HTTP request parser
  
  =head1 SYNOPSIS
  
    use HTTP::Parser::XS qw(parse_http_request);
  
    # for HTTP servers
    my $ret = parse_http_request(
        "GET / HTTP/1.0\r\nHost: ...\r\n\r\n",
        \%env,
    );
    if ($ret == -2) {
        # request is incomplete
        ...
    } elsif ($ret == -1) {
        # request is broken
        ...
    } else {
        # $ret includes the size of the request, %env now contains a PSGI
        # request, if it is a POST / PUT request, read request content by
        # yourself
        ...
    }
  
  
    # for HTTP clients
    use HTTP::Parser::XS qw(parse_http_response HEADERS_AS_ARRAYREF);
    my %special_headers = (
      'content-length' => undef,
    );
    my($ret, $minor_version, $status, $message, $headers)
      = parse_http_response($response, HEADERS_AS_ARRAYREF, \%special_headers);
  
    if($ret == -1) }
      # response is incomplete
    }
    elsif($ret == -2) {
      # response is broken
    }
    else {
      # $ret is the length of the headers, starting the content body
  
      # the other values are the response messages. For example:
      # $status  = 200
      # $message = "OK"
      # $headers = [ 'content-type' => 'text/html', ... ]
  
      # and $special_headers{'content-length'} will be filled in
    }
  
  
  =head1 DESCRIPTION
  
  HTTP::Parser::XS is a fast, primitive HTTP request/response parser.
  
  The request parser can be used either for writing a synchronous HTTP server or a event-driven server.
  
  The response parser can be used for writing HTTP clients.
  
  Note that even if this distribution name ends C<::XS>, B<pure Perl>
  implementation is supported, so you can use this module on compiler-less
  environments.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item parse_http_request($request_string, \%env)
  
  Tries to parse given request string, and if successful, inserts variables into %env.  For the name of the variables inserted, please refer to the PSGI specification.  The return values are:
  
  =over 8
  
  =item >=0
  
  length of the request (request line and the request headers), in bytes
  
  =item -1
  
  given request is corrupt
  
  =item -2
  
  given request is incomplete
  
  =back
  
  =item parse_http_response($response_string, $header_format, \%special_headers)
  
  Tries to parse given response string. I<$header_format> must be
  C<HEADERS_AS_ARRAYREF>, C<HEADERS_AS_HASHREF>, or C<HEADERS_NONE>,
  which are exportable constants.
  
  The optional I<%special_headers> is for headers you specifically require.
  You can set any HTTP response header names, which must be lower-cased,
  and their default values, and then the values are filled in by
  C<parse_http_response()>.
  For example, if you want the C<Cointent-Length> field, set its name with
  default values like C<< %h = ('content-length' => undef) >> and pass it as
  I<%special_headers>. After parsing, C<$h{'content-length'}> is set
  if the response has the C<Content-Length> field, otherwise it's not touched.
  
  The return values are:
  
  =over 8
  
  =item C<$ret>
  
  The parsering status, which is the same as C<parse_http_response()>. i.e.
  the length of the response headers in bytes, C<-1> for incomplete headers,
  or C<-2> for errors.
  
  If the given response string is broken or imcomplete, C<parse_http_response()>
  returns only this value.
  
  =item C<$minor_version>
  
  The minor version of the given response.
  i.e. C<1> for HTTP/1.1, C<0> for HTTP/1.0.
  
  =item C<$status>
  
  The HTTP status of the given response. e.g. C<200> for success.
  
  =item C<$message>
  
  The HTTP status message. e.g. C<OK> for success.
  
  =item C<$headers>
  
  The HTTP headers for the given response. It is an ARRAY reference
  if I<$header_format> is C<HEADERS_AS_ARRAYREF>, a HASH reference on
  C<HEADERS_AS_HASHREF>, an C<undef> on C<HEADERS_NONE>.
  
  The names of the headers are normalized to lower-cased.
  
  =back
  
  =back
  
  =head1 LIMITATIONS
  
  Both C<parse_http_request()> and C<parse_http_response()> in XS
  implementation have some size limitations.
  
  =head2 The number of headers
  
  The number of headers is limited to C<128>. If it exceeds, both parsing
  routines report parsing errors, i.e. return C<-1> for C<$ret>.
  
  =head2 The size of header names
  
  The size of header names is limited to C<1024>, but the parsers do not the
  same action.
  
  C<parse_http_request()> returns C<-1> if too-long header names exist.
  
  C<parse_http_request()> simply ignores too-long header names.
  
  =head1 COPYRIGHT
  
  Copyright 2009- Kazuho Oku
  
  =head1 AUTHOR
  
  Kazuho Oku
  gfx
  mala
  tokuhirom
  
  =head1 THANKS TO
  
  nothingmuch
  charsbar
  
  =head1 SEE ALSO
  
  L<http://github.com/kazuho/picohttpparser>
  
  L<HTTP::Parser>
  L<HTTP::HeaderParser::XS>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_HTTP_PARSER_XS

$fatpacked{"darwin-2level/HTTP/Parser/XS/PP.pm"} = <<'DARWIN-2LEVEL_HTTP_PARSER_XS_PP';
  package HTTP::Parser::XS::PP;
  use strict;
  use warnings;
  use utf8;
  
  sub HTTP::Parser::XS::parse_http_request {
      my($chunk, $env) = @_;
      Carp::croak("second param to parse_http_request should be a hashref") unless (ref $env|| '') eq 'HASH';
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my $minor;
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/1\.(\d+)$/;
      $minor = $1;
  
      my($path, $query) = ( $uri =~ /^([^?#]*)(?:\?([^#]*))?/s );
      # following validations are just needed to pass t/01simple.t
      if ($path =~ /%(?:[0-9a-f][^0-9a-f]|[^0-9a-f][0-9a-f])/i) {
          # invalid char in url-encoded path
          return -1;
      }
      if ($path =~ /%(?:[0-9a-f])$/i) {
          # partially url-encoded
          return -1;
      }
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{REQUEST_URI}     = $uri;
      $env->{SERVER_PROTOCOL} = "HTTP/1.$minor";
      ($env->{PATH_INFO}      = $path) =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  # ----------------------------------------------------------
  
  my %PARSER_FUNC = (
      HTTP::Parser::XS::HEADERS_NONE()        => \&_parse_as_none,
      HTTP::Parser::XS::HEADERS_AS_HASHREF()  => \&_parse_as_hashref,
      HTTP::Parser::XS::HEADERS_AS_ARRAYREF() => \&_parse_as_arrayref,
  );
  
  sub HTTP::Parser::XS::parse_http_response {
      my ($str, $header_format, $special_headers) = @_;
      return -2 unless $str;
  
      my $len = length $str;
      
      my ($sl, $remain) = split /\r?\n/, $_[0], 2;
      my ($proto, $rc, $msg) = split(' ', $sl, 3);
      return -1 unless $proto =~m{^HTTP/1.(\d)};
      my $minor_version = $1;
      return -1 unless $rc =~m/^\d+$/;
  
      my ($header_str, $content) = split /\r?\n\r?\n/, $remain, 2;
  
      my $parser_func = $PARSER_FUNC{$header_format};
      die 'unknown header format: '. $header_format unless $parser_func;
  
      my $header = $parser_func->($header_str, $special_headers || +{});
  
      return -2 if ($str !~/\r?\n\r?\n/ && $remain !~/\r?\n\r?\n/ && !defined $content);
      my $parsed = $len - (defined $content ? length $content : 0);
  
      return ($parsed, $minor_version, $rc, $msg, $header);
  }
  
  # return special headers only
  sub _parse_as_none {
      my ($str, $special) = @_;
      return unless defined $str;
      return unless keys %$special;
  
      my ($field, $value, $f);
      for ( split /\r?\n/, $str ) {
          if ( defined $field ) {
              if ( ord == 9 || ord == 32 ) {
                  $value .= "\n$_";
                  next;
              }
              $f = lc($field); 
              exists $special->{$f} and $special->{$f} = $value;
          }
          ( $field, $value ) = split /[ \t]*: ?/, $_, 2;
      }
      if ( defined $field ) {
          $f = lc($field); 
          exists $special->{$f} and $special->{$f} = $value;
      }
  }
  
  # return headers as arrayref
  sub _parse_as_arrayref {
      my ($str, $special) = @_;
      return [] unless defined $str;
  
      my (@headers, $field, $value, $f );
      for ( split /\r?\n/, $str ) {
          if ( defined $field ) {
              if ( ord == 9 || ord == 32 ) {
                  $value .= "\n$_";
                  next;
              }
              $f = lc($field); 
              push @headers, $f, $value;
              exists $special->{$f} and $special->{$f} = $value;
          }
          ( $field, $value ) = split /[ \t]*: ?/, $_, 2;
      }
      if ( defined $field ) {
          $f = lc($field); 
          push @headers, $f, $value; 
          exists $special->{$f} and $special->{$f} = $value;
      }
      return \@headers;
  }
  
  # return headers as HTTP::Header compatible HashRef
  sub _parse_as_hashref {
      my ($str, $special) = @_;
      return +{} unless defined $str;
      
      my ( %self, $field, $value, $f );
      for ( split /\r?\n/, $str ) {
          if ( defined $field ) {
              if ( ord == 9 || ord == 32 ) {
                  $value .= "\n$_";
                  next;
              }
              $f = lc($field); 
              if ( defined $self{$f} ) {
                  my $h = $self{$f};
                  ref($h) eq 'ARRAY'
                    ? push( @$h, $value )
                    : ( $self{$f} = [ $h, $value ] );
              }
              else { $self{$f} = $value }
          }
          ( $field, $value ) = split /[ \t]*: ?/, $_, 2;
      }
      if ( defined $field ) {
          $f = lc($field); 
          if ( defined $self{$f} ) {
              my $h = $self{$f};
              ref($h) eq 'ARRAY'
                ? push( @$h, $value )
                : ( $self{$f} = [ $h, $value ] );
          }
          else { $self{$f} = $value }
      }
      return \%self;
  }
  
  1;
  
DARWIN-2LEVEL_HTTP_PARSER_XS_PP

$fatpacked{"darwin-2level/JSON/XS.pm"} = <<'DARWIN-2LEVEL_JSON_XS';
  =head1 NAME
  
  JSON::XS - JSON serialising/deserialising, done correctly and fast
  
  =encoding utf-8
  
  JSON::XS -  JSON /
             (http://fleur.hio.jp/perldoc/mix/lib/JSON/XS.html)
  
  =head1 SYNOPSIS
  
   use JSON::XS;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::XS->new->ascii->pretty->allow_nonref;
   $pretty_printed_unencoded = $coder->encode ($perl_scalar);
   $perl_scalar = $coder->decode ($unicode_json_text);
  
   # Note that JSON version 2.0 and above will automatically use JSON::XS
   # if available, at virtually no speed overhead either, so you should
   # be able to just:
   
   use JSON;
  
   # and do the same things, except that you have a pure-perl fallback now.
  
  =head1 DESCRIPTION
  
  This module converts Perl data structures to JSON and vice versa. Its
  primary goal is to be I<correct> and its secondary goal is to be
  I<fast>. To reach the latter goal it was written in C.
  
  Beginning with version 2.0 of the JSON module, when both JSON and
  JSON::XS are installed, then JSON will fall back on JSON::XS (this can be
  overridden) with no overhead due to emulation (by inheriting constructor
  and methods). If JSON::XS is not available, it will fall back to the
  compatible JSON::PP module as backend, so using JSON instead of JSON::XS
  gives you a portable JSON API that can be fast when you need and doesn't
  require a C compiler when that is a problem.
  
  As this is the n-th-something JSON module on CPAN, what was the reason
  to write yet another JSON module? While it seems there are many JSON
  modules, none of them correctly handle all corner cases, and in most cases
  their maintainers are unresponsive, gone missing, or not listening to bug
  reports for other reasons.
  
  See MAPPING, below, on how JSON::XS maps perl values to JSON values and
  vice versa.
  
  =head2 FEATURES
  
  =over 4
  
  =item * correct Unicode handling
  
  This module knows how to handle Unicode, documents how and when it does
  so, and even documents what "correct" means.
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  =item * fast
  
  Compared to other JSON modules and other serialisers such as Storable,
  this module usually compares favourably in terms of speed, too.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an object
  oriented interface interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format
  possible (nice for simple line-based protocols), a pure-ASCII format
  (for when your transport is not 8-bit clean, still supports the whole
  Unicode range), or a pretty-printed format (for when you want to read that
  stuff). Or you can combine those features in whatever way you like.
  
  =back
  
  =cut
  
  package JSON::XS;
  
  use common::sense;
  
  our $VERSION = '2.32';
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(encode_json decode_json to_json from_json);
  
  sub to_json($) {
     require Carp;
     Carp::croak ("JSON::XS::to_json has been renamed to encode_json, either downgrade to pre-2.0 versions of JSON::XS or rename the call");
  }
  
  sub from_json($) {
     require Carp;
     Carp::croak ("JSON::XS::from_json has been renamed to decode_json, either downgrade to pre-2.0 versions of JSON::XS or rename the call");
  }
  
  use Exporter;
  use XSLoader;
  
  =head1 FUNCTIONAL INTERFACE
  
  The following convenience methods are provided by this module. They are
  exported by default:
  
  =over 4
  
  =item $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
     $json_text = JSON::XS->new->utf8->encode ($perl_scalar)
  
  Except being faster.
  
  =item $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
     $perl_scalar = JSON::XS->new->utf8->decode ($json_text)
  
  Except being faster.
  
  =item $is_boolean = JSON::XS::is_bool $scalar
  
  Returns true if the passed scalar represents either JSON::XS::true or
  JSON::XS::false, two constants that act like C<1> and C<0>, respectively
  and are used to represent JSON C<true> and C<false> values in Perl.
  
  See MAPPING, below, for more information on how JSON values are mapped to
  Perl.
  
  =back
  
  
  =head1 A FEW NOTES ON UNICODE AND PERL
  
  Since this often leads to confusion, here are a few very clear words on
  how Unicode works in Perl, modulo bugs.
  
  =over 4
  
  =item 1. Perl strings can store characters with ordinal values > 255.
  
  This enables you to store Unicode characters as single characters in a
  Perl string - very natural.
  
  =item 2. Perl does I<not> associate an encoding with your strings.
  
  ... until you force it to, e.g. when matching it against a regex, or
  printing the scalar to a file, in which case Perl either interprets your
  string as locale-encoded text, octets/binary, or as Unicode, depending
  on various settings. In no case is an encoding stored together with your
  data, it is I<use> that decides encoding, not any magical meta data.
  
  =item 3. The internal utf-8 flag has no meaning with regards to the
  encoding of your string.
  
  Just ignore that flag unless you debug a Perl bug, a module written in
  XS or want to dive into the internals of perl. Otherwise it will only
  confuse you, as, despite the name, it says nothing about how your string
  is encoded. You can have Unicode strings with that flag set, with that
  flag clear, and you can have binary data with that flag set and that flag
  clear. Other possibilities exist, too.
  
  If you didn't know about that flag, just the better, pretend it doesn't
  exist.
  
  =item 4. A "Unicode String" is simply a string where each character can be
  validly interpreted as a Unicode code point.
  
  If you have UTF-8 encoded data, it is no longer a Unicode string, but a
  Unicode string encoded in UTF-8, giving you a binary string.
  
  =item 5. A string containing "high" (> 255) character values is I<not> a UTF-8 string.
  
  It's a fact. Learn to live with it.
  
  =back
  
  I hope this helps :)
  
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =over 4
  
  =item $json = new JSON::XS
  
  Creates a new JSON::XS object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::XS->new->utf8->space_after->encode ({a => [1,2]})
     => {"a": [1, 2]}
  
  =item $json = $json->ascii ([$enable])
  
  =item $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON::XS->new->ascii (1)->encode ([chr 0x10401])
    => ["\ud801\udc01"]
  
  =item $json = $json->latin1 ([$enable])
  
  =item $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =item $json = $json->utf8 ([$enable])
  
  =item $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  =item $json = $json->pretty ([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Example, pretty-print some simple structure:
  
     my $json = JSON::XS->new->pretty(1)->encode ({a => [1,2]})
     =>
     {
        "a" : [
           1,
           2
        ]
     }
  
  =item $json = $json->indent ([$enable])
  
  =item $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =item $json = $json->space_before ([$enable])
  
  =item $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =item $json = $json->space_after ([$enable])
  
  =item $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =item $json = $json->relaxed ([$enable])
  
  =item $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =item $json = $json->canonical ([$enable])
  
  =item $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =item $json = $json->allow_nonref ([$enable])
  
  =item $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON::XS->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =item $json = $json->allow_unknown ([$enable])
  
  =item $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_nonref>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =item $json = $json->allow_blessed ([$enable])
  
  =item $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  =item $json = $json->convert_blessed ([$enable])
  
  =item $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way, but in the
  future, global hooks might get installed that influence C<decode> and are
  enabled by this setting.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =item $json = $json->filter_json_object ([$coderef->($hashref)])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::XS->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]')
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =item $json = $json->filter_json_single_key_object ($key [=> $coderef->($value)])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::XS
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =item $json = $json->shrink ([$enable])
  
  =item $enabled = $json->get_shrink
  
  Perl usually over-allocates memory a bit when allocating space for
  strings. This flag optionally resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk-to-fit, while all strings generated by C<decode> will also be
  shrunk-to-fit.
  
  If C<$enable> is false, then the normal perl allocation algorithms are used.
  If you work with your data, then this is likely to be faster.
  
  In the future, this setting might control other things, such as converting
  strings that look like integers or floats into integers or floats
  internally (there is no difference on the Perl level), saving space.
  
  =item $json = $json->max_depth ([$maximum_nesting_depth])
  
  =item $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing.
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json = $json->max_size ([$maximum_string_size])
  
  =item $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json_text = $json->encode ($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values. Neither C<true>
  nor C<false> values will be generated.
  
  =item $perl_scalar = $json->decode ($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1>, C<false> becomes C<0> and C<null> becomes C<undef>.
  
  =item ($perl_scalar, $characters) = $json->decode_prefix ($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  (which is not the brightest thing to do in the first place) and you need
  to know where the JSON text ends.
  
     JSON::XS->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =back
  
  
  =head1 INCREMENTAL PARSING
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  JSON::XS will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =over 4
  
  =item [void, scalar or list context] = $json->incr_parse ([$string])
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the errornous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
     my @objs = JSON::XS->new->incr_parse ("[5][7][1,2]");
  
  =item $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =item $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occured is removed.
  
  =item $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =back
  
  =head2 LIMITATIONS
  
  All options that affect decoding are supported, except
  C<allow_nonref>. The reason for this is that it cannot be made to
  work sensibly: JSON objects and arrays are self-delimited, i.e. you can concatenate
  them back to back and still decode them perfectly. This does not hold true
  for JSON numbers, however.
  
  For example, is the string C<1> a single JSON number, or is it simply the
  start of C<12>? Or is C<12> a single JSON number, or the concatenation
  of C<1> and C<2>? In neither case you can tell, and this is why JSON::XS
  takes the conservative route and disallows this case.
  
  =head2 EXAMPLES
  
  Some examples will make all this clearer. First, a simple example that
  works similarly to C<decode_prefix>: We want to decode the JSON object at
  the start of a string and identify the portion after the JSON object:
  
     my $text = "[1,2,3] hello";
  
     my $json = new JSON::XS;
  
     my $obj = $json->incr_parse ($text)
        or die "expected JSON object or array at beginning of string";
  
     my $tail = $json->incr_text;
     # $tail now contains " hello"
  
  Easy, isn't it?
  
  Now for a more complicated example: Imagine a hypothetical protocol where
  you read some requests from a TCP stream, and each request is a JSON
  array, without any separation between them (in fact, it is often useful to
  use newlines as "separators", as these get interpreted as whitespace at
  the start of the JSON text, which makes it possible to test said protocol
  with C<telnet>...).
  
  Here is how you'd do it (it is trivial to write this in an event-based
  manner):
  
     my $json = new JSON::XS;
  
     # read some data from the socket
     while (sysread $socket, my $buf, 4096) {
  
        # split and decode as many requests as possible
        for my $request ($json->incr_parse ($buf)) {
           # act on the $request
        }
     }
  
  Another complicated example: Assume you have a string with JSON objects
  or arrays, all separated by (optional) comma characters (e.g. C<[1],[2],
  [3]>). To parse them, we have to skip the commas between the JSON texts,
  and here is where the lvalue-ness of C<incr_text> comes in useful:
  
     my $text = "[1],[2], [3]";
     my $json = new JSON::XS;
  
     # void context, so no parsing done
     $json->incr_parse ($text);
  
     # now extract as many objects as possible. note the
     # use of scalar context so incr_text can be called.
     while (my $obj = $json->incr_parse) {
        # do something with $obj
  
        # now skip the optional comma
        $json->incr_text =~ s/^ \s* , //x;
     }
  
  Now lets go for a very complex example: Assume that you have a gigantic
  JSON array-of-objects, many gigabytes in size, and you want to parse it,
  but you cannot load it into memory fully (this has actually happened in
  the real world :).
  
  Well, you lost, you have to implement your own JSON parser. But JSON::XS
  can still help you: You implement a (very simple) array parser and let
  JSON decode the array elements, which are all full JSON objects on their
  own (this wouldn't work if the array elements could be JSON numbers, for
  example):
  
     my $json = new JSON::XS;
  
     # open the monster
     open my $fh, "<bigfile.json"
        or die "bigfile: $!";
  
     # first parse the initial "["
     for (;;) {
        sysread $fh, my $buf, 65536
           or die "read error: $!";
        $json->incr_parse ($buf); # void context, so no parsing
  
        # Exit the loop once we found and removed(!) the initial "[".
        # In essence, we are (ab-)using the $json object as a simple scalar
        # we append data to.
        last if $json->incr_text =~ s/^ \s* \[ //x;
     }
  
     # now we have the skipped the initial "[", so continue
     # parsing all the elements.
     for (;;) {
        # in this loop we read data until we got a single JSON object
        for (;;) {
           if (my $obj = $json->incr_parse) {
              # do something with $obj
              last;
           }
  
           # add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
        # in this loop we read data until we either found and parsed the
        # separating "," between elements, or the final "]"
        for (;;) {
           # first skip whitespace
           $json->incr_text =~ s/^\s*//;
  
           # if we find "]", we are done
           if ($json->incr_text =~ s/^\]//) {
              print "finished.\n";
              exit;
           }
  
           # if we find ",", we can continue with the next element
           if ($json->incr_text =~ s/^,//) {
              last;
           }
  
           # if we find anything else, we have a parse error!
           if (length $json->incr_text) {
              die "parse error near ", $json->incr_text;
           }
  
           # else add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
  This is a complex example, but most of the complexity comes from the fact
  that we are trying to be correct (bear with me if I am wrong, I never ran
  the above example :).
  
  
  
  =head1 MAPPING
  
  This section describes how JSON::XS maps Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, JSON::XS will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded toa JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, JSON::XS only guarantees precision up to but not including
  the leats significant bit.
  
  =item true, false
  
  These JSON atoms become C<JSON::XS::true> and C<JSON::XS::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::XS::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. JSON::XS can
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same datastructure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::XS::false> and C<JSON::XS::true> to improve readability.
  
     encode_json [\0, JSON::XS::true]      # yields [false,true]
  
  =item JSON::XS::true, JSON::XS::false
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a JSON string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a JSON number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =back
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no canges to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  
  =head2 JSON and ECMAscript
  
  JSON syntax is based on how literals are represented in javascript (the
  not-standardised predecessor of ECMAscript) which is presumably why it is
  called "JavaScript Object Notation".
  
  However, JSON is not a subset (and also not a superset of course) of
  ECMAscript (the standard) or javascript (whatever browsers actually
  implement).
  
  If you want to use javascript's C<eval> function to "parse" JSON, you
  might run into parse errors for valid JSON texts, or the resulting data
  structure might not be queryable:
  
  One of the problems is that U+2028 and U+2029 are valid characters inside
  JSON strings, but are not allowed in ECMAscript string literals, so the
  following Perl fragment will not output something that can be guaranteed
  to be parsable by javascript's C<eval>:
  
     use JSON::XS;
  
     print encode_json [chr 0x2028];
  
  The right fix for this is to use a proper JSON parser in your javascript
  programs, and not rely on C<eval> (see for example Douglas Crockford's
  F<json2.js> parser).
  
  If this is not an option, you can, as a stop-gap measure, simply encode to
  ASCII-only JSON:
  
     use JSON::XS;
  
     print JSON::XS->new->ascii->encode ([chr 0x2028]);
  
  Note that this will enlarge the resulting JSON text quite a bit if you
  have many non-ASCII characters. You might be tempted to run some regexes
  to only escape U+2028 and U+2029, e.g.:
  
     # DO NOT USE THIS!
     my $json = JSON::XS->new->utf8->encode ([chr 0x2028]);
     $json =~ s/\xe2\x80\xa8/\\u2028/g; # escape U+2028
     $json =~ s/\xe2\x80\xa9/\\u2029/g; # escape U+2029
     print $json;
  
  Note that I<this is a bad idea>: the above only works for U+2028 and
  U+2029 and thus only for fully ECMAscript-compliant parsers. Many existing
  javascript implementations, however, have issues with other characters as
  well - using C<eval> naively simply I<will> cause problems.
  
  Another problem is that some javascript implementations reserve
  some property names for their own purposes (which probably makes
  them non-ECMAscript-compliant). For example, Iceweasel reserves the
  C<__proto__> property name for its own purposes.
  
  If that is a problem, you could parse try to filter the resulting JSON
  output for these property strings, e.g.:
  
     $json =~ s/"__proto__"\s*:/"__proto__renamed":/g;
  
  This works because C<__proto__> is not valid outside of strings, so every
  occurence of C<"__proto__"\s*:> must be a string used as property name.
  
  If you know of other incompatibilities, please let me know.
  
  
  =head2 JSON and YAML
  
  You often hear that JSON is a subset of YAML. This is, however, a mass
  hysteria(*) and very far from the truth (as of the time of this writing),
  so let me state it clearly: I<in general, there is no way to configure
  JSON::XS to output a data structure as valid YAML> that works in all
  cases.
  
  If you really must use JSON::XS to generate YAML, you should use this
  algorithm (subject to change in future versions):
  
     my $to_yaml = JSON::XS->new->utf8->space_after (1);
     my $yaml = $to_yaml->encode ($ref) . "\n";
  
  This will I<usually> generate JSON texts that also parse as valid
  YAML. Please note that YAML has hardcoded limits on (simple) object key
  lengths that JSON doesn't have and also has different and incompatible
  unicode character escape syntax, so you should make sure that your hash
  keys are noticeably shorter than the 1024 "stream characters" YAML allows
  and that you do not have characters with codepoint values outside the
  Unicode BMP (basic multilingual page). YAML also does not allow C<\/>
  sequences in strings (which JSON::XS does not I<currently> generate, but
  other JSON generators might).
  
  There might be other incompatibilities that I am not aware of (or the YAML
  specification has been changed yet again - it does so quite often). In
  general you should not try to generate YAML with a JSON generator or vice
  versa, or try to parse JSON with a YAML parser or vice versa: chances are
  high that you will run into severe interoperability problems when you
  least expect it.
  
  =over 4
  
  =item (*)
  
  I have been pressured multiple times by Brian Ingerson (one of the
  authors of the YAML specification) to remove this paragraph, despite him
  acknowledging that the actual incompatibilities exist. As I was personally
  bitten by this "JSON is YAML" lie, I refused and said I will continue to
  educate people about these issues, so others do not run into the same
  problem again and again. After this, Brian called me a (quote)I<complete
  and worthless idiot>(unquote).
  
  In my opinion, instead of pressuring and insulting people who actually
  clarify issues with YAML and the wrong statements of some of its
  proponents, I would kindly suggest reading the JSON spec (which is not
  that difficult or long) and finally make YAML compatible to it, and
  educating users about the changes, instead of spreading lies about the
  real compatibility for many I<years> and trying to silence people who
  point out that it isn't true.
  
  Addendum/2009: the YAML 1.2 spec is still incompatible with JSON, even
  though the incompatibilities have been documented (and are known to Brian)
  for many years and the spec makes explicit claims that YAML is a superset
  of JSON. It would be so easy to fix, but apparently, bullying people and
  corrupting userdata is so much easier.
  
  =back
  
  
  =head2 SPEED
  
  It seems that JSON::XS is surprisingly fast, as shown in the following
  tables. They have been generated with the help of the C<eg/bench> program
  in the JSON::XS distribution, to make it easy to compare on your own
  system.
  
  First comes a comparison between various modules using
  a very short single-line JSON string (also available at
  L<http://dist.schmorp.de/misc/json/short.json>).
  
     {"method": "handleMessage", "params": ["user1",
     "we were just talking"], "id": null, "array":[1,11,234,-5,1e5,1e7,
     1,  0]}
  
  It shows the number of encodes/decodes per second (JSON::XS uses
  the functional interface, while JSON::XS/2 uses the OO interface
  with pretty-printing and hashkey sorting enabled, JSON::XS/3 enables
  shrink. JSON::DWIW/DS uses the deserialise function, while JSON::DWIW::FJ
  uses the from_json method). Higher is better:
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |  86302.551 | 102300.098 |
     JSON::DWIW/FJ |  86302.551 |  75983.768 |
     JSON::PP      |  15827.562 |   6638.658 |
     JSON::Syck    |  63358.066 |  47662.545 |
     JSON::XS      | 511500.488 | 511500.488 |
     JSON::XS/2    | 291271.111 | 388361.481 |
     JSON::XS/3    | 361577.931 | 361577.931 |
     Storable      |  66788.280 | 265462.278 |
     --------------+------------+------------+
  
  That is, JSON::XS is almost six times faster than JSON::DWIW on encoding,
  about five times faster on decoding, and over thirty to seventy times
  faster than JSON's pure perl implementation. It also compares favourably
  to Storable for small amounts of data.
  
  Using a longer test string (roughly 18KB, generated from Yahoo! Locals
  search API (L<http://dist.schmorp.de/misc/json/long.json>).
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |   1647.927 |   2673.916 |
     JSON::DWIW/FJ |   1630.249 |   2596.128 |
     JSON::PP      |    400.640 |     62.311 |
     JSON::Syck    |   1481.040 |   1524.869 |
     JSON::XS      |  20661.596 |   9541.183 |
     JSON::XS/2    |  10683.403 |   9416.938 |
     JSON::XS/3    |  20661.596 |   9400.054 |
     Storable      |  19765.806 |  10000.725 |
     --------------+------------+------------+
  
  Again, JSON::XS leads by far (except for Storable which non-surprisingly
  decodes a bit faster).
  
  On large strings containing lots of high Unicode characters, some modules
  (such as JSON::PC) seem to decode faster than JSON::XS, but the result
  will be broken due to missing (or wrong) Unicode handling. Others refuse
  to decode or encode properly, so it was impossible to prepare a fair
  comparison table for that case.
  
  
  =head1 SECURITY CONSIDERATIONS
  
  When you are using JSON in a protocol, talking to untrusted potentially
  hostile creatures requires relatively few measures.
  
  First of all, your JSON decoder should be secure, that is, should not have
  any buffer overflows. Obviously, this module should ensure that and I am
  trying hard on making that true, but you never know.
  
  Second, you need to avoid resource-starving attacks. That means you should
  limit the size of JSON texts you accept, or make sure then when your
  resources run out, that's just fine (e.g. by using a separate process that
  can crash safely). The size of a JSON text in octets or characters is
  usually a good indication of the size of the resources required to decode
  it into a Perl structure. While JSON::XS can check the size of the JSON
  text, it might be too late when you already have it in memory, so you
  might want to check the size before you accept the string.
  
  Third, JSON::XS recurses using the C stack when decoding objects and
  arrays. The C stack is a limited resource: for instance, on my amd64
  machine with 8MB of stack size I can decode around 180k nested arrays but
  only 14k nested JSON objects (due to perl itself recursing deeply on croak
  to free the temporary). If that is exceeded, the program crashes. To be
  conservative, the default nesting limit is set to 512. If your process
  has a smaller stack, you should adjust this setting accordingly with the
  C<max_depth> method.
  
  Something else could bomb you, too, that I forgot to think of. In that
  case, you get to keep the pieces. I am always open for hints, though...
  
  Also keep in mind that JSON::XS might leak contents of your Perl data
  structures in its error messages, so when you serialise sensitive
  information you might want to make sure that exceptions thrown by JSON::XS
  will not end up in front of untrusted eyes.
  
  If you are using JSON::XS to return packets to consumption
  by JavaScript scripts in a browser you should have a look at
  L<http://blog.archive.jpsykes.com/47/practical-csrf-and-json-security/> to
  see whether you are vulnerable to some common attack vectors (which really
  are browser design bugs, but it is still you who will have to deal with
  it, as major browser developers care only for features, not about getting
  security right).
  
  
  =head1 THREADS
  
  This module is I<not> guaranteed to be thread safe and there are no
  plans to change this until Perl gets thread support (as opposed to the
  horribly slow so-called "threads" which are simply slow and bloated
  process simulations - use fork, it's I<much> faster, cheaper, better).
  
  (It might actually work, but you have been warned).
  
  
  =head1 BUGS
  
  While the goal of this module is to be correct, that unfortunately does
  not mean it's bug-free, only that I think its design is bug-free. If you
  keep reporting bugs they will be fixed swiftly, though.
  
  Please refrain from using rt.cpan.org or any other bug reporting
  service. I put the contact address into my modules for a reason.
  
  =cut
  
  our $true  = do { bless \(my $dummy = 1), "JSON::XS::Boolean" };
  our $false = do { bless \(my $dummy = 0), "JSON::XS::Boolean" };
  
  sub true()  { $true  }
  sub false() { $false }
  
  sub is_bool($) {
     UNIVERSAL::isa $_[0], "JSON::XS::Boolean"
  #      or UNIVERSAL::isa $_[0], "JSON::Literal"
  }
  
  XSLoader::load "JSON::XS", $VERSION;
  
  package JSON::XS::Boolean;
  
  use overload
     "0+"     => sub { ${$_[0]} },
     "++"     => sub { $_[0] = ${$_[0]} + 1 },
     "--"     => sub { $_[0] = ${$_[0]} - 1 },
     fallback => 1;
  
  1;
  
  =head1 SEE ALSO
  
  The F<json_xs> command line utility for quick experiments.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_JSON_XS

$fatpacked{"darwin-2level/JSON/XS/Boolean.pm"} = <<'DARWIN-2LEVEL_JSON_XS_BOOLEAN';
  =head1 NAME
  
  JSON::XS::Boolean - dummy module providing JSON::XS::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules. See
  L<JSON::XS> for more info about this class.
  
  =cut
  
  use JSON::XS ();
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_JSON_XS_BOOLEAN

$fatpacked{"darwin-2level/Sub/Name.pm"} = <<'DARWIN-2LEVEL_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.05';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
DARWIN-2LEVEL_SUB_NAME

$fatpacked{"oo.pm"} = <<'OO';
  package oo;
  
  use strictures 1;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
OO

$fatpacked{"state51/MonitoringJS/Updater.pm"} = <<'STATE51_MONITORINGJS_UPDATER';
  package state51::MonitoringJS::Updater;
  use strict;
  use warnings;
  use AnyEvent;
  use AnyEvent::Handle;
  use AnyEvent::Util qw/ portable_pipe fh_nonblocking /;
  use Moo;
  
  has filename => (
      is => 'ro',
      required => 1,
  );
  
  has on_read => (
      is => 'ro',
      required => 1,
  );
  
  sub run {
      my $self = shift;
      my $r;
      my $child_pid = open($r, "-|", "tail", "-f", $self->filename)
         // die "can't fork: $!";
      fh_nonblocking $r, 1;
      $self->{hdl} = AnyEvent::Handle->new(
          fh => $r,
          on_read => sub {
              my $hdl = shift;
              my $buf = $hdl->rbuf;
              $hdl->rbuf('');
              $self->on_read->($_) for split("\n", $buf);
          },
      );
      return $self;
  }
  
  1;
  
STATE51_MONITORINGJS_UPDATER

$fatpacked{"strictures.pm"} = <<'STRICTURES';
  package strictures;
  
  use strict;
  use warnings FATAL => 'all';
  
  our $VERSION = '1.002002'; # 1.2.2
  
  sub VERSION {
    for ($_[1]) {
      last unless defined && !ref && int != 1;
      die "Major version specified as $_ - this is strictures version 1";
    }
    # disable this since Foo->VERSION(undef) correctly returns the version
    # and that can happen either if our caller passes undef explicitly or
    # because the for above autovivified $_[1] - I could make it stop but
    # it's pointless since we don't want to blow up if the caller does
    # something valid either.
    no warnings 'uninitialized';
    shift->SUPER::VERSION(@_);
  }
  
  sub import {
    strict->import;
    warnings->import(FATAL => 'all');
    my $extra_tests = do {
      if (exists $ENV{PERL_STRICTURES_EXTRA}) {
        $ENV{PERL_STRICTURES_EXTRA}
      } else {
        !!($0 =~ /^x?t\/.*(?:load|compile|coverage|use_ok).*\.t$/
           and (-e '.git' or -e '.svn'))
      }
    };
    if ($extra_tests) {
      if (eval {
            require indirect;
            require multidimensional;
            require bareword::filehandles;
            1
          }) {
        indirect->unimport(':fatal');
        multidimensional->unimport;
        bareword::filehandles->unimport;
      } else {
        die "strictures.pm extra testing active but couldn't load modules.
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  
  Error loading modules was: $@";
      }
    }
  }
  
  1;
  
  __END__
  =head1 NAME
  
  strictures - turn on strict and make all warnings fatal
  
  =head1 SYNOPSIS
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
  
  except when called from a file where $0 matches:
  
    /^x?t\/.*(?:load|compile|coverage|use_ok).*\.t$/
  
  and when either '.git' or '.svn' is present in the current directory (with
  the intention of only forcing extra tests on the author side) - or when the
  PERL_STRICTURES_EXTRA environment variable is set, in which case
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  Note that _EXTRA may at some point add even more tests, with only a minor
  version increase, but any changes to the effect of 'use strictures' in
  normal mode will involve a major version bump.
  
  Be aware: THIS MEANS THE EXTRA TEST MODULES ARE REQUIRED FOR AUTHORS OF
  STRICTURES USING CODE - but not by end users thereof.
  
  =head1 DESCRIPTION
  
  I've been writing the equivalent of this module at the top of my code for
  about a year now. I figured it was time to make it shorter.
  
  Things like the importer in 'use Moose' don't help me because they turn
  warnings on but don't make them fatal - which from my point of view is
  useless because I want an exception to tell me my code isn't warnings clean.
  
  Any time I see a warning from my code, that indicates a mistake.
  
  Any time my code encounters a mistake, I want a crash - not spew to STDERR
  and then unknown (and probably undesired) subsequent behaviour.
  
  I also want to ensure that obvious coding mistakes, like indirect object
  syntax (and not so obvious mistakes that cause things to accidentally compile
  as such) get caught, but not at the cost of an XS dependency and not at the
  cost of blowing things up on another machine.
  
  Therefore, strictures turns on indirect checking only when it thinks it's
  running in a compilation (or pod coverage) test - though if this causes
  undesired behaviour this can be overridden by setting the
  PERL_STRICTURES_EXTRA environment variable.
  
  If additional useful author side checks come to mind, I'll add them to the
  _EXTRA code path only - this will result in a minor version increase (i.e.
  1.000000 to 1.001000 (1.1.0) or similar). Any fixes only to the mechanism of
  this code will result in a subversion increas (i.e. 1.000000 to 1.000001
  (1.0.1)).
  
  If the behaviour of 'use strictures' in normal mode changes in any way, that
  will constitute a major version increase - and the code already checks
  when its version is tested to ensure that
  
    use strictures 1;
  
  will continue to only introduce the current set of strictures even if 2.0 is
  installed.
  
  =head1 METHODS
  
  =head2 import
  
  This method does the setup work described above in L</DESCRIPTION>
  
  =head2 VERSION
  
  This method traps the strictures->VERSION(1) call produced by a use line
  with a version number on it and does the version check.
  
  =head1 COMMUNITY AND SUPPORT
  
  =head2 IRC channel
  
  irc.perl.org #toolchain
  
  (or bug 'mst' in query on there or freenode)
  
  =head2 Git repository
  
  Gitweb is on http://git.shadowcat.co.uk/ and the clone URL is:
  
    git clone git://git.shadowcat.co.uk/p5sagit/strictures.git
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  None required yet. Maybe this module is perfect (hahahahaha ...).
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the strictures L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
STRICTURES

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/usr/bin/env perl

# WARNING - Do not edit this file unless you have the perl
#           dependencies installed which are noted in the README, otherwise
#           the Makefile in this directory will try to rebuild the server script

use strict;
use warnings;
use FindBin qw/$Bin/;
use lib "$Bin/lib";
use Cwd qw/ abs_path /;
use File::Spec;

use Plack::Runner;
use Plack::App::File;
use Plack::Builder;
use Plack::Loader;
use Cwd qw/ abs_path /;
use File::stat;
use File::Find;

# Work out where the root is, no matter where we were run
use constant ROOT =>
    abs_path(
        -d File::Spec->catdir($Bin, "js")
        ? $Bin
      : -d File::Spec->catdir($Bin, "..", "js")
        ? File::Spec->catdir($Bin, "..")
      : die("Cannot find js/ folder for app root")
    );

# Find the newest js or CSS file's mtime
my $youngest = 0;
my $wanted = sub {
    return if -d $File::Find::name;
    my $time = stat($File::Find::name)->mtime;
    $youngest = $time if $time > $youngest;
};
find($wanted, map { File::Spec->catdir(ROOT, $_) } qw/ js css /);
{   # Find app.html's mtime
    local $File::Find::name = File::Spec->catdir(ROOT, "maint", "app.html");
    $wanted->();
}

# Find mtime for minified version
my $minified_mtime = stat(File::Spec->catdir(ROOT, 'index.html'))->mtime;

# And use the minified version if possible, or the multi-file version if
# the application has been edited.
my @index = $minified_mtime > $youngest ? ("index.html") : ("maint", "app.html");

# Helper function to locate a file
sub file {
    Plack::App::File->new(file => File::Spec->catdir(ROOT, @_))
}

# Load AnyEvent correctly in PP mode.
BEGIN { $ENV{PERL_ANYEVENT_MODEL} = 'Perl' }
use AnyEvent;
BEGIN { AnyEvent::detect() }
use Scalar::Util qw/ refaddr /;
use state51::MonitoringJS::Updater;
use Web::Hippie;
use Devel::StackTrace::AsHTML;

my %update_handles;

my $production_log = "/var/log/nagios3/nagios.log";
my $nagios_log_file = -r $production_log
    ? $production_log
    : File::Spec->catpath(ROOT, "test", "nagios.log");

my $updater = state51::MonitoringJS::Updater->new(
    filename => $nagios_log_file,
    on_read => sub {
        my $line = shift;
        $_->send_msg({
            type => 'nagios_result',
            line => $line,
        }) for values %update_handles;
    },
)->run;

# Build the app coderef
my $app = builder {
    mount "/favicon.ico"                => file("favicon.ico");
    mount "/puppet/nodes/"              => file(qw/testdata mongodb_nodes.json/);
    mount "/puppet/nagios_host_groups/" => file(qw/testdata mongodb_nagios_host_groups.json/);
    mount "/nagios-api/state"           => file(qw/testdata nagios-api-state.json/);
    mount "/"                           => file(@index);
    mount "/dev"                        => file("maint", "app.html");
    mount "/js"                         => Plack::App::File->new(root => File::Spec->catdir(ROOT, "js"));
    mount "/css"                        => Plack::App::File->new(root => File::Spec->catdir(ROOT, "css"));
    mount "/img"                        => Plack::App::File->new(root => File::Spec->catdir(ROOT, "img"));
    mount "/test"                       => file(qw/test index.html/);
    mount "/test/vendor/qunit.js"       => file(qw/test vendor qunit.js/);
    mount "/test/vendor/qunit.css"      => file(qw/test vendor qunit.css/);
    mount "/test/model.js"              => file(qw/test model.js/);
    mount "/test/view.js"              => file(qw/test view.js/);
    mount "/test/collections.js"        => file(qw/test collections.js/);
    mount '/_hippie' => builder {
        enable "+Web::Hippie";
        sub {
            my $env = shift;
            my $interval = $env->{'hippie.args'} || 5;
            my $h = $env->{'hippie.handle'};
 
            if ($env->{PATH_INFO} eq '/init') {
                $update_handles{refaddr($h)} = $h;
            }
            elsif ($env->{PATH_INFO} eq '/message') {
                my $msg = $env->{'hippie.message'};
                warn "==> got msg from client: ".Dumper($msg);
            }
            else {
                return [ '400', [ 'Content-Type' => 'text/plain' ], [ "" ] ]
                    unless $h;
 
                if ($env->{PATH_INFO} eq '/error') {
                    warn "==> disconnecting $h";
                    delete $update_handles{refaddr($h)};
                }
                else {
                    die "unknown hippie message";
                }
            }
            return [ '200', [ 'Content-Type' => 'application/hippie' ], [ "" ] ]
        }
    };
};

# Use Plack::Runner here so we can be directly run with perl
# as a perl script. The caller magic also allows us to be used
# as a psgi script, as we don't run anything when require'd
use Fliggy::Server;
$ENV{PLACK_SERVER} = "Fliggy";

unless (caller()) {
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
}

# And return the app as the final value to be a valid psgi.
return $app;

