#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"HTTP/Config.pm"} = <<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use URI;
  use vars qw($VERSION);
  
  $VERSION = "6.00";
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          return 1 if $request->header($k) eq $v;
          return 1 if $response && $response->header($k) eq $v;
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuation object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 2008, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_CONFIG

$fatpacked{"HTTP/Date.pm"} = <<'HTTP_DATE';
  package HTTP::Date;
  
  $VERSION = "6.00";
  
  require 5.004;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(time2str str2time);
  @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  use strict;
  require Time::Local;
  
  use vars qw(@DoW @MoY %MoY);
  @DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = (1..12);
  
  my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);
  
  
  sub time2str (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
      sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
  	    $DoW[$wday],
  	    $mday, $MoY[$mon], $year+1900,
  	    $hour, $min, $sec);
  }
  
  
  sub str2time ($;$)
  {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
  	return eval {
  	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
  	    $t < 0 ? undef : $t;
  	};
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;        # month
  
      my $tz = pop(@d);
      unless (defined $tz) {
  	unless (defined($tz = shift)) {
  	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  			  my $t = Time::Local::timelocal(reverse @d) + $frac;
  			  $t < 0 ? undef : $t;
  		        };
  	}
      }
  
      my $offset = 0;
      if ($GMT_ZONE{uc $tz}) {
  	# offset already zero
      }
      elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
  	$offset = 3600 * $2;
  	$offset += 60 * $3 if $3;
  	$offset *= -1 if $1 && $1 eq '-';
      }
      else {
  	eval { require Time::Zone } || return undef;
  	$offset = Time::Zone::tz_offset($tz);
  	return undef unless defined $offset;
      }
  
      return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  		  my $t = Time::Local::timegm(reverse @d) + $frac;
  		  $t < 0 ? undef : $t - $offset;
  		};
  }
  
  
  sub parse_date ($)
  {
      local($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;  # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday
  
      my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);
  
      # Then we are able to check for most of the formats with this regexp
      (($day,$mon,$yr,$hr,$min,$sec,$tz) =
          /^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\))?	       # ASCII representation of timezone in parens.
  	    \s*$
  	/x)
  
      ||
  
      # Try the ctime and asctime format
      (($mon, $day, $hr, $min, $sec, $tz, $yr) =
  	/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)
  
      ||
  
      # Then the Unix 'ls -l' date format
      (($mon, $day, $yr, $hr, $min, $sec) =
  	/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)
  
      ||
  
      # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
      (($yr, $mon, $day, $hr, $min, $sec, $tz) =
  	/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)
  
      ||
  
      # Windows 'dir' 11-12-96  03:52PM
      (($mon, $day, $yr, $hr, $min, $ampm) =
          /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)
  
      ||
      return;  # unrecognized format
  
      # Translate month name to number
      $mon = $MoY{$mon} ||
             $MoY{"\u\L$mon"} ||
  	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
             return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless (defined $yr) {
  	my $cur_mon;
  	($cur_mon, $yr) = (localtime)[4, 5];
  	$yr += 1900;
  	$cur_mon++;
  	$yr-- if $mon > $cur_mon;
      }
      elsif (length($yr) < 3) {
  	# Find "obvious" year
  	my $cur_yr = (localtime)[5] + 1900;
  	my $m = $cur_yr % 100;
  	my $tmp = $yr;
  	$yr += $cur_yr - $m;
  	$m -= $tmp;
  	$yr += ($m > 0) ? 100 : -100
  	    if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
  	$ampm = uc $ampm;
  	$hr = 0 if $hr == 12 && $ampm eq 'AM';
  	$hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return($yr, $mon, $day, $hr, $min, $sec, $tz)
  	if wantarray;
  
      if (defined $tz) {
  	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
  	$tz = "";
      }
      return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
  		   $yr, $mon, $day, $hr, $min, $sec, $tz);
  }
  
  
  sub time2iso (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02d",
  	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  
  sub time2isoz (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
              $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Date - date conversion routines
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  returned will B<not> have the number 1900 subtracted from it and the
  $month numbers start with 1.
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned.
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_DATE

$fatpacked{"HTTP/Headers.pm"} = <<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use Carp ();
  
  use vars qw($VERSION $TRANSLATE_UNDERSCORE);
  $VERSION = "6.00";
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless(defined $standard_case{$field}) {
  	    # generate a %standard_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $standard_case{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	next if substr($key, 0, 1) eq '_';
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $key, $vals);
  	}
      }
  }
  
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		my $field = $standard_case{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    my $field = $standard_case{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # intial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  
  if (eval { require Storable; 1 }) {
      *clone = \&Storable::dclone;
  } else {
      *clone = sub {
  	my $self = shift;
  	my $clone = HTTP::Headers->new;
  	$self->scan(sub { $clone->push_header(@_);} );
  	$clone;
      };
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promise that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS

$fatpacked{"HTTP/Headers/Auth.pm"} = <<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  use HTTP::Headers;
  
  package HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
HTTP_HEADERS_AUTH

$fatpacked{"HTTP/Headers/ETag.pm"} = <<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
HTTP_HEADERS_ETAG

$fatpacked{"HTTP/Headers/Util.pm"} = <<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = "6.00";
  
  require Exporter;
  @ISA=qw(Exporter);
  
  @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessary be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS_UTIL

$fatpacked{"HTTP/Message.pm"} = <<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use vars qw($VERSION $AUTOLOAD);
  $VERSION = "6.02";
  
  require HTTP::Headers;
  require Carp;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  $HTTP::URI_CLASS ||= $ENV{PERL_HTTP_URI_CLASS} || "URI";
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
      }, $class;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = $_[1];
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = $_[1];
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32-LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32-BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16-LE" if /^\xFF\xFE/;
  	return "UTF-16-BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32-BE" if /^\x00\x00\x00</;
  	    return "UTF-32-LE" if /^<\x00\x00\x00/;
  	    return "UTF-16-BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16-LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	my $charset;
  	require HTML::Parser;
  	my $p = HTML::Parser->new(
  	    start_h => [sub {
  		my($tag, $attr, $self) = @_;
  		$charset = $attr->{charset};
  		unless ($charset) {
  		    # look at $attr->{content} ...
  		    if (my $c = $attr->{content}) {
  			require HTTP::Headers::Util;
  			my @v = HTTP::Headers::Util::split_header_words($c);
  			return unless @v;
  			my($ct, undef, %ct_param) = @{$v[0]};
  			$charset = $ct_param{charset};
  		    }
  		    return unless $charset;
  		}
  		if ($charset =~ /^utf-?16/i) {
  		    # converted document, assume UTF-8
  		    $charset = "UTF-8";
  		}
  		$self->eof;
  	    }, "tagname, attr, self"],
  	    report_tags => [qw(meta)],
  	    utf8_mode => 1,
  	);
  	$p->parse($$cref);
  	return $charset if $charset;
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require IO::Uncompress::Gunzip;
  		    my $output;
  		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
  			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2") {
  		    require IO::Uncompress::Bunzip2;
  		    my $output;
  		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
  			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    if ($charset eq "none") {
  		# leave it asis
  	    }
  	    elsif ($charset eq "us-ascii" || $charset eq "iso-8859-1") {
  		if ($$content_ref =~ /[^\x00-\x7F]/ && defined &utf8::upgrade) {
  		    unless ($content_ref_iscopy) {
  			my $copy = $$content_ref;
  			$content_ref = \$copy;
  			$content_ref_iscopy++;
  		    }
  		    utf8::upgrade($$content_ref);
  		}
  	    }
  	    else {
  		require Encode;
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset eq "none";
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require IO::Uncompress::Gunzip;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require IO::Uncompress::Bunzip2;
          push(@enc, "x-bzip2");
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = "(no content)";
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = "(no content)";
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = HTTP::Message->new($self->remove_content_headers,
  				   $self->content(""));
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  
  # delegate all other method calls the the headers object.
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->headers->$method(@_) };
      goto &$method;
  }
  
  
  sub DESTROY {}  # avoid AUTOLOADing it
  
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--\r?\n.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map HTTP::Message->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ HTTP::Message->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 SYNOPSIS
  
   use base 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and for textual content
  the raw content encoded to Perl's Unicode strings.  If the C<Content-Encoding>
  or C<charset> of the message is unknown this method will fail by returning
  C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This override the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This override the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2" and "base64".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If an @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_MESSAGE

$fatpacked{"HTTP/Message/PSGI.pm"} = <<'HTTP_MESSAGE_PSGI';
  package HTTP::Message::PSGI;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw( req_to_psgi res_from_psgi );
  
  use Carp ();
  use HTTP::Status qw(status_message);
  use URI::Escape ();
  use Plack::Util;
  use Try::Tiny;
  
  my $TRUE  = (1 == 1);
  my $FALSE = !$TRUE;
  
  sub req_to_psgi {
      my $req = shift;
  
      unless (try { $req->isa('HTTP::Request') }) {
          Carp::croak("Request is not HTTP::Request: $req");
      }
  
      # from HTTP::Request::AsCGI
      my $host = $req->header('Host');
      my $uri  = $req->uri->clone;
      $uri->scheme('http')    unless $uri->scheme;
      $uri->host('localhost') unless $uri->host;
      $uri->port(80)          unless $uri->port;
      $uri->host_port($host)  unless !$host || ( $host eq $uri->host_port );
  
      # STUPID: If the request URI is utf-8 decoded, methods like ->path
      # and ->host returns decoded strings in ascii, which causes double
      # encoded strings in uri_unescape and URI concatenation in
      # Plack::Request :/
      utf8::downgrade $$uri;
  
      my $input;
      my $content = $req->content;
      if (ref $content eq 'CODE') {
          if (defined $req->content_length) {
              $input = HTTP::Message::PSGI::ChunkedInput->new($content);
          } else {
              $req->header("Transfer-Encoding" => "chunked");
              $input = HTTP::Message::PSGI::ChunkedInput->new($content, 1);
          }
      } else {
          open $input, "<", \$content;
          $req->content_length(length $content)
              unless defined $req->content_length;
      }
  
      my $env = {
          PATH_INFO         => URI::Escape::uri_unescape($uri->path || '/'),
          QUERY_STRING      => $uri->query || '',
          SCRIPT_NAME       => '',
          SERVER_NAME       => $uri->host,
          SERVER_PORT       => $uri->port,
          SERVER_PROTOCOL   => $req->protocol || 'HTTP/1.1',
          REMOTE_ADDR       => '127.0.0.1',
          REMOTE_HOST       => 'localhost',
          REMOTE_PORT       => int( rand(64000) + 1000 ),                   # not in RFC 3875
          REQUEST_URI       => $uri->path_query || '/',                     # not in RFC 3875
          REQUEST_METHOD    => $req->method,
          'psgi.version'      => [ 1, 1 ],
          'psgi.url_scheme'   => $uri->scheme eq 'https' ? 'https' : 'http',
          'psgi.input'        => $input,
          'psgi.errors'       => *STDERR,
          'psgi.multithread'  => $FALSE,
          'psgi.multiprocess' => $FALSE,
          'psgi.run_once'     => $TRUE,
          'psgi.streaming'    => $TRUE,
          'psgi.nonblocking'  => $FALSE,
          @_,
      };
  
      for my $field ( $req->headers->header_field_names ) {
          my $key = uc("HTTP_$field");
          $key =~ tr/-/_/;
          $key =~ s/^HTTP_// if $field =~ /^Content-(Length|Type)$/;
  
          unless ( exists $env->{$key} ) {
              $env->{$key} = $req->headers->header($field);
          }
      }
  
      if ($env->{SCRIPT_NAME}) {
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E/\//;
          $env->{PATH_INFO} =~ s/^\/+/\//;
      }
  
      return $env;
  }
  
  sub res_from_psgi {
      my ($psgi_res) = @_;
  
      my $res;
      if (ref $psgi_res eq 'ARRAY') {
          _res_from_psgi($psgi_res, \$res);
      }
      elsif (ref $psgi_res eq 'CODE') {
          $psgi_res->(sub {
              _res_from_psgi($_[0], \$res);
          });
      }
  
      return $res;
  }
  
  sub _res_from_psgi {
      my ($status, $headers, $body) = @{+shift};
      my $res_ref = shift;
  
      my $convert_resp = sub {
          my $res = HTTP::Response->new($status);
          $res->message(status_message($status));
          $res->headers->header(@$headers) if @$headers;
  
          if (ref $body eq 'ARRAY') {
              $res->content(join '', grep defined, @$body);
          } else {
              local $/ = \4096;
              my $content;
              while (defined(my $buf = $body->getline)) {
                  $content .= $buf;
              }
              $body->close;
              $res->content($content);
          }
  
          ${ $res_ref } = $res;
  
          return;
      };
  
      if (!defined $body) {
          my $o = Plack::Util::inline_object
              write => sub { push @{ $body ||= [] }, @_ },
              close => $convert_resp;
  
          return $o;
      }
  
      $convert_resp->();
  }
  
  sub HTTP::Request::to_psgi {
      req_to_psgi(@_);
  }
  
  sub HTTP::Response::from_psgi {
      my $class = shift;
      res_from_psgi(@_);
  }
  
  package
      HTTP::Message::PSGI::ChunkedInput;
  
  sub new {
      my($class, $content, $chunked) = @_;
  
      my $content_cb;
      if ($chunked) {
          my $done;
          $content_cb = sub {
              my $chunk = $content->();
              return if $done;
              unless (defined $chunk) {
                  $done = 1;
                  return "0\015\012\015\012";
              }
              return '' unless length $chunk;
              return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
          };
      } else {
          $content_cb = $content;
      }
  
      bless { content => $content_cb }, $class;
  }
  
  sub read {
      my $self = shift;
  
      my $chunk = $self->{content}->();
      return 0 unless defined $chunk;
  
      $_[0] = '';
      substr($_[0], $_[2] || 0, length $chunk) = $chunk;
  
      return length $chunk;
  }
  
  sub close { }
  
  package HTTP::Message::PSGI;
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Message::PSGI - Converts HTTP::Request and HTTP::Response from/to PSGI env and response
  
  =head1 SYNOPSIS
  
    use HTTP::Message::PSGI;
  
    # $req is HTTP::Request, $res is HTTP::Response
    my $env = req_to_psgi($req);
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
    # Adds methods to HTTP::Request/Response class as well
    my $env = $req->to_psgi;
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  =head1 DESCRIPTION
  
  HTTP::Message::PSGI gives you convenient methods convert HTTP::Request
  object to PSGI env hash and convert PSGI response array ref to
  HTTP::Response object.
  
  If you want the other way round, see L<Plack::Request> and
  L<Plack::Response>.
  
  =head1 METHODS
  
  =over 4
  
  =item req_to_psgi
  
    my $env = req_to_psgi($req [, $key => $val ... ]);
  
  Converts HTTP::Request object into PSGI env hash reference.
  
  =item HTTP::Request::to_psgi
  
    my $env = $req->to_psgi;
  
  Same as C<req_to_psgi> but an instance method in L<HTTP::Request>.
  
  =item res_from_psgi
  
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
  Creates HTTP::Response object from PSGI response array ref.
  
  =item HTTP::Response->from_psgi
  
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  Same as C<res_from_psgi> but a class method in L<HTTP::Response>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Request::AsCGI> L<HTTP::Message> L<Plack::Test>
  
  =cut
  
HTTP_MESSAGE_PSGI

$fatpacked{"HTTP/Request.pm"} = <<'HTTP_REQUEST';
  package HTTP::Request;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.00";
  
  use strict;
  
  
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $request_line;
      if ($str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($method, $uri, $protocol) = split(' ', $request_line);
      $self->method($method) if defined($method);
      $self->uri($uri) if defined($uri);
      $self->protocol($protocol) if $protocol;
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
      return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parseable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_REQUEST

$fatpacked{"HTTP/Request/Common.pm"} = <<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use vars qw(@EXPORT @EXPORT_OK $VERSION $DYNAMIC_FILE_UPLOAD);
  
  $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT =qw(GET HEAD PUT POST);
  @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  
  $VERSION = "6.00";
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub PUT  { _simple_req('PUT' , @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  
  sub POST
  {
      my $url = shift;
      my $req = HTTP::Request->new(POST => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      my($k,$v);
      while (($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename =~ s,.*/,, if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.  
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, 2048, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf 
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);
  
  =head1 DESCRIPTION
  
  This module provide functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.  The
  following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The GET() function returns an C<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the PUT() and POST()
  functions described below.
  
  The get(...) method of C<LWP::UserAgent> exists as a shortcut for
  $ua->request(GET ...).
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The head(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(HEAD ...).
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $content
  
  Like GET() but the method in the request is "PUT".
  
  The content of the request can be specified using the "Content"
  pseudo-header.  This steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like GET() but the method in the request is "DELETE".  This function
  is not exported by default.
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  This works mostly like PUT() with "POST" as the method, but this
  function also takes a second optional array or hash reference
  parameter $form_ref.  As for PUT() the content can also be specified
  directly using the "Content" pseudo-header, and you may also provide
  the $form_ref this way.
  
  The $form_ref argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate a HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create a HTTP::Request object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the $form_ref is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by LWP::MediaTypes::guess_media_type()
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create a HTTP::Request object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the $DYNAMIC_FILE_UPLOAD variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no Content-Length header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the Content-Length is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The post(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(POST ...).
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  
  =head1 COPYRIGHT
  
  Copyright 1997-2004, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
HTTP_REQUEST_COMMON

$fatpacked{"HTTP/Response.pm"} = <<'HTTP_RESPONSE';
  package HTTP::Response;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.01";
  
  use strict;
  use HTTP::Status ();
  
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $status_line;
      if ($str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($protocol, $code, $message);
      if ($status_line =~ /^\d{3} /) {
         # Looks like a response created by HTTP::Response->new
         ($code, $message) = split(' ', $status_line, 2);
      } else {
         ($protocol, $code, $message) = split(' ', $status_line, 3);
      }
      $self->protocol($protocol) if $protocol;
      $self->code($code) if defined($code);
      $self->message($message) if defined($message);
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Content-Location'),    # HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require Encode::Locale;
  			Encode::from_to($encfile, $charset, "locale_fs");
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      require HTTP::Status;
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = $self->status_line;
      $body =~ s/&/&amp;/g;
      $body =~ s/</&lt;/g;
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request)
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meaning these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of a HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" or a "Content-Location:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  When the LWP protocol modules produce the HTTP::Response object, then
  any base URI embedded in the document (step 1) will already have
  initialized the "Content-Base:" header. This means that this method
  only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_RESPONSE

$fatpacked{"HTTP/Server/PSGI.pm"} = <<'HTTP_SERVER_PSGI';
  package HTTP::Server::PSGI;
  use strict;
  use warnings;
  
  use Carp ();
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Plack::TempBuffer;
  use Plack::Middleware::ContentLength;
  use POSIX qw(EINTR);
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use Try::Tiny;
  use Time::HiRes qw(time);
  
  my $alarm_interval;
  BEGIN {
      if ($^O eq 'MSWin32') {
          $alarm_interval = 1;
      } else {
          Time::HiRes->import('alarm');
          $alarm_interval = 0.1;
      }
  }
  
  use constant MAX_REQUEST_SIZE => 131072;
  use constant MSWin32          => $^O eq 'MSWin32';
  
  sub new {
      my($class, %args) = @_;
  
      my $self = bless {
          host               => $args{host} || 0,
          port               => $args{port} || 8080,
          timeout            => $args{timeout} || 300,
          server_software    => $args{server_software} || $class,
          server_ready       => $args{server_ready} || sub {},
          ssl                => $args{ssl},
          ipv6               => $args{ipv6},
          ssl_key_file       => $args{ssl_key_file},
          ssl_cert_file      => $args{ssl_cert_file},
      }, $class;
  
      if ($args{max_workers} && $args{max_workers} > 1) {
          Carp::carp(
              "Preforking in $class is deprecated. Falling back to the non-forking mode. ",
              "If you need preforking, use Starman or Starlet instead and run like `plackup -s Starlet`",
          );
      }
  
      $self;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub prepare_socket_class {
      my($self, $args) = @_;
  
      if ($self->{ssl} && $self->{ipv6}) {
          Carp::croak("SSL and IPv6 are not supported at the same time (yet). Choose one.");
      }
  
      if ($self->{ssl}) {
          eval { require IO::Socket::SSL; 1 }
              or Carp::croak("SSL suport requires IO::Socket::SSL");
          $args->{SSL_key_file}  = $self->{ssl_key_file};
          $args->{SSL_cert_file} = $self->{ssl_cert_file};
          return "IO::Socket::SSL";
      } elsif ($self->{ipv6}) {
          eval { require IO::Socket::IP; 1 }
              or Carp::croak("IPv6 support requires IO::Socket::IP");
          $self->{host}      ||= '::';
          $args->{LocalAddr} ||= '::';
          return "IO::Socket::IP";
      }
  
      return "IO::Socket::INET";
  }
  
  sub setup_listener {
      my $self = shift;
  
      my %args = (
          Listen    => SOMAXCONN,
          LocalPort => $self->{port},
          LocalAddr => $self->{host},
          Proto     => 'tcp',
          ReuseAddr => 1,
      );
  
      my $class = $self->prepare_socket_class(\%args);
      $self->{listen_sock} ||= $class->new(%args)
          or die "failed to listen to port $self->{port}: $!";
  
      $self->{server_ready}->($self);
  }
  
  sub accept_loop {
      my($self, $app) = @_;
  
      $app = Plack::Middleware::ContentLength->wrap($app);
  
      while (1) {
          local $SIG{PIPE} = 'IGNORE';
          if (my $conn = $self->{listen_sock}->accept) {
              $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                  or die "setsockopt(TCP_NODELAY) failed:$!";
              my $env = {
                  SERVER_PORT => $self->{port},
                  SERVER_NAME => $self->{host},
                  SCRIPT_NAME => '',
                  REMOTE_ADDR => $conn->peerhost,
                  'psgi.version' => [ 1, 1 ],
                  'psgi.errors'  => *STDERR,
                  'psgi.url_scheme' => $self->{ssl} ? 'https' : 'http',
                  'psgi.run_once'     => Plack::Util::FALSE,
                  'psgi.multithread'  => Plack::Util::FALSE,
                  'psgi.multiprocess' => Plack::Util::FALSE,
                  'psgi.streaming'    => Plack::Util::TRUE,
                  'psgi.nonblocking'  => Plack::Util::FALSE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'          => $conn,
              };
  
              $self->handle_connection($env, $conn, $app);
              $conn->close;
          }
      }
  }
  
  sub handle_connection {
      my($self, $env, $conn, $app) = @_;
  
      my $buf = '';
      my $res = [ 400, [ 'Content-Type' => 'text/plain' ], [ 'Bad Request' ] ];
  
      while (1) {
          my $rlen = $self->read_timeout(
              $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
              $self->{timeout},
          ) or return;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
              $buf = substr $buf, $reqlen;
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Plack::TempBuffer->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout})
                              or return;
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  open my $input, "<", \$buf;
                  $env->{'psgi.input'} = $input;
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res, $conn);
      } elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0], $conn);
          });
      } else {
          die "Bad response $res";
      }
  
      return;
  }
  
  sub _handle_response {
      my($self, $res, $conn) = @_;
  
      my @lines = (
          "Date: @{[HTTP::Date::time2str()]}\015\012",
          "Server: $self->{server_software}\015\012",
      );
  
      Plack::Util::header_iter($res->[1], sub {
          my ($k, $v) = @_;
          push @lines, "$k: $v\015\012";
      });
  
      unshift @lines, "HTTP/1.0 $res->[0] @{[ HTTP::Status::status_message($res->[0]) ]}\015\012";
      push @lines, "\015\012";
  
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $res->[2]) {
          my $err;
          my $done;
          {
              local $@;
              eval {
                  Plack::Util::foreach(
                      $res->[2],
                      sub {
                          $self->write_all($conn, $_[0], $self->{timeout})
                              or die "failed to send all data\n";
                      },
                  );
                  $done = 1;
              };
              $err = $@;
          };
          unless ($done) {
              if ($err =~ /^failed to send all data\n/) {
                  return;
              } else {
                  die $err;
              }
          }
      } else {
          return Plack::Util::inline_object
              write => sub { $self->write_all($conn, $_[0], $self->{timeout}) },
              close => sub { };
      }
  }
  
  # returns 1 if socket is ready, undef on timeout
  sub do_timeout {
      my ($self, $cb, $timeout) = @_;
      local $SIG{ALRM} = sub {};
      my $wait_until = time + $timeout;
      alarm($timeout);
      my $ret;
      while (1) {
          if ($ret = $cb->()) {
              last;
          } elsif (! (! defined($ret) && $! == EINTR)) {
              undef $ret;
              last;
          }
          # got EINTR
          my $left = $wait_until - time;
          last if $left <= 0;
          alarm($left + $alarm_interval);
      }
      alarm(0);
      $ret;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->sysread($$buf, $len, $off) }, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->syswrite($buf, $len, $off) }, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      return 0 unless defined $buf;
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Server::PSGI - Standalone PSGI compatible HTTP server
  
  =head1 SYNOPSIS
  
    use HTTP::Server::PSGI;
  
    my $server = HTTP::Server::PSGI->new(
        host => "127.0.0.1",
        port => 9091,
        timeout => 120,
    );
  
    $server->run($app);
  
  =head1 DESCRIPTION
  
  HTTP::Server::PSGI is a standalone, single-process and PSGI compatible
  HTTP server implementations.
  
  This server should be great for the development and testing, but might
  not be suitable for a production use.
  
  Some features in HTTP/1.1, notably chunked requests, responses and
  pipeline requests are B<NOT> supported. See L<Starman> if you want
  those features.
  
  =head1 PREFORKING
  
  L<HTTP::Server::PSGI> does B<NOT> support preforking. See L<Starman>
  or L<Starlet> if you want a multi-process prefork web servers.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Standalone> L<Starman> L<Starlet>
  
  =cut
HTTP_SERVER_PSGI

$fatpacked{"HTTP/Status.pm"} = <<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  require 5.002;   # because we use prototypes
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  @EXPORT_OK = qw(is_client_error is_server_error);
  $VERSION = "6.00";
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 2616
  # See also: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ tr/a-z \-/A-Z__/;
      $mnemonicCode .= "sub HTTP_$message () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  
  sub is_info         ($) { $_[0] >= 100 && $_[0] < 200; }
  sub is_success      ($) { $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect     ($) { $_[0] >= 300 && $_[0] < 400; }
  sub is_error        ($) { $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error ($) { $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error ($) { $_[0] >= 500 && $_[0] < 600; }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of a HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
     HTTP_REQUEST_URI_TOO_LARGE           (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_NO_CODE                         (425)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_RETRY_WITH                      (449)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
     HTTP_NOT_EXTENDED                    (510)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above.  If the $code is unknown, then C<undef> is returned.
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  return TRUE for both client error or a server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is an I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is an I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explict imports and
  the C<:constants> tag instead of relying on this.
HTTP_STATUS

$fatpacked{"Plack.pm"} = <<'PLACK';
  package Plack;
  
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack - Perl Superglue for Web frameworks and Web Servers (PSGI toolkit)
  
  =head1 DESCRIPTION
  
  Plack is a set of tools for using the PSGI stack. It contains
  middleware components, a reference server and utilities for Web
  application frameworks. Plack is like Ruby's Rack or Python's Paste
  for WSGI.
  
  See L<PSGI> for the PSGI specification and L<PSGI::FAQ> to know what
  PSGI and Plack are and why we need them.
  
  =head1 MODULES AND UTILITIES
  
  =head2 Plack::Handler
  
  L<Plack::Handler> and its subclasses contains adapters for web
  servers. We have adapters for the built-in standalone web server
  L<HTTP::Server::PSGI>, L<CGI|Plack::Handler::CGI>,
  L<FCGI|Plack::Handler::FCGI>, L<Apache1|Plack::Handler::Apache1>,
  L<Apache2|Plack::Handler::Apache2> and
  L<HTTP::Server::Simple|Plack::Handler::HTTP::Server::Simple> included
  in the core Plack distribution.
  
  There are also many HTTP server implementations on CPAN that have Plack
  handlers.
  
  See L<Plack::Handler> when writing your own adapters.
  
  =head2 Plack::Loader
  
  L<Plack::Loader> is a loader to load one L<Plack::Handler> adapter
  and run a PSGI application code reference with it.
  
  =head2 Plack::Util
  
  L<Plack::Util> contains a lot of utility functions for server
  implementors as well as middleware authors.
  
  =head2 .psgi files
  
  A PSGI application is a code reference but it's not easy to pass code
  reference via the command line or configuration files, so Plack uses a
  convention that you need a file named C<app.psgi> or similar, which
  would be loaded (via perl's core function C<do>) to return the PSGI
  application code reference.
  
    # Hello.psgi
    my $app = sub {
        my $env = shift;
        # ...
        return [ $status, $headers, $body ];
    };
  
  If you use a web framework, chances are that they provide a helper
  utility to automatically generate these C<.psgi> files for you, such
  as:
  
    # MyApp.psgi
    use MyApp;
    my $app = sub { MyApp->run_psgi(@_) };
  
  It's important that the return value of C<.psgi> file is the code
  reference. See C<eg/dot-psgi> directory for more examples of C<.psgi>
  files.
  
  =head2 plackup, Plack::Runner
  
  L<plackup> is a command line launcher to run PSGI applications from
  command line using L<Plack::Loader> to load PSGI backends. It can be
  used to run standalone servers and FastCGI daemon processes. Other
  server backends like Apache2 needs a separate configuration but
  C<.psgi> application file can still be the same.
  
  If you want to write your own frontend that replaces, or adds
  functionalities to L<plackup>, take a look at the L<Plack::Runner> module.
  
  =head2 Plack::Middleware
  
  PSGI middleware is a PSGI application that wraps an existing PSGI
  application and plays both side of application and servers. From the
  servers the wrapped code reference still looks like and behaves
  exactly the same as PSGI applications.
  
  L<Plack::Middleware> gives you an easy way to wrap PSGI applications
  with a clean API, and compatibility with L<Plack::Builder> DSL.
  
  =head2 Plack::Builder
  
  L<Plack::Builder> gives you a DSL that you can enable Middleware in
  C<.psgi> files to wrap existent PSGI applications.
  
  =head2 Plack::Request, Plack::Response
  
  L<Plack::Request> gives you a nice wrapper API around PSGI C<$env>
  hash to get headers, cookies and query parameters much like
  L<Apache::Request> in mod_perl.
  
  L<Plack::Response> does the same to construct the response array
  reference.
  
  =head2 Plack::Test
  
  L<Plack::Test> is a unified interface to test your PSGI application
  using standard L<HTTP::Request> and L<HTTP::Response> pair with simple
  callbacks.
  
  =head2 Plack::Test::Suite
  
  L<Plack::Test::Suite> is a test suite to test a new PSGI server backend.
  
  =head1 CONTRIBUTING
  
  =head2 Patches and Bug Fixes
  
  Small patches and bug fixes can be either submitted via nopaste on IRC
  L<irc://irc.perl.org/#plack> or L<the github issue
  tracker|http://github.com/miyagawa/Plack/issues>.  Forking on
  L<github|http://github.com/miyagawa/Plack> is another good way if you
  intend to make larger fixes.
  
  See also L<http://contributing.appspot.com/plack> when you think this
  document is terribly outdated.
  
  =head2 Module Namespaces
  
  Modules added to the Plack:: sub-namespaces should be reasonably generic
  components which are useful as building blocks and not just simply using
  Plack.
  
  Middleware authors are free to use the Plack::Middleware:: namespace for
  their middleware components. Middleware must be written in the pipeline
  style such that they can chained together with other middleware components.
  The Plack::Middleware:: modules in the core distribution are good examples
  of such modules. It is recommended that you inherit from L<Plack::Middleware>
  for these types of modules.
  
  Not all middleware components are wrappers, but instead are more like
  endpoints in a middleware chain. These types of components should use the
  Plack::App:: namespace. Again, look in the core modules to see excellent
  examples of these (L<Plack::App::File>, L<Plack::App::Directory>, etc.).
  It is recommended that you inherit from L<Plack::Component> for these
  types of modules.
  
  B<DO NOT USE> Plack:: namespace to build a new web application or a
  framework. It's like naming your application under CGI:: namespace if
  it's supposed to run on CGI and that is a really bad choice and
  would confuse people badly.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 COPYRIGHT
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  Copyright 2009-2011 Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Yuval Kogman (nothingmuch)
  
  Tokuhiro Matsuno (tokuhirom)
  
  Kazuhiro Osawa (Yappo)
  
  Kazuho Oku
  
  Florian Ragwitz (rafl)
  
  Chia-liang Kao (clkao)
  
  Masahiro Honma (hiratara)
  
  Daisuke Murase (typester)
  
  John Beppu
  
  Matt S Trout (mst)
  
  Shawn M Moore (Sartak)
  
  Stevan Little
  
  Hans Dieter Pearcey (confound)
  
  Tomas Doran (t0m)
  
  mala
  
  Mark Stosberg
  
  Aaron Trevena
  
  =head1 SEE ALSO
  
  The L<PSGI> specification upon which Plack is based.
  
  L<http://plackperl.org/>
  
  The Plack wiki: L<https://github.com/miyagawa/Plack/wiki>
  
  The Plack FAQ: L<https://github.com/miyagawa/Plack/wiki/Faq>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK

$fatpacked{"Plack/App/CGIBin.pm"} = <<'PLACK_APP_CGIBIN';
  package Plack::App::CGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util::Accessor qw( exec_cb );
  use Plack::App::WrapCGI;
  
  sub allow_path_info { 1 }
  
  my %exec_cache;
  
  sub would_exec {
      my($self, $file) = @_;
  
      return $exec_cache{$file} if exists $exec_cache{$file};
  
      my $exec_cb = $self->exec_cb || sub { $self->exec_cb_default(@_) };
  
      return $exec_cache{$file} = $exec_cb->($file);
  }
  
  sub exec_cb_default {
      my($self, $file) = @_;
  
      if ($file =~ /\.pl$/i) {
          return 0;
      } elsif ($self->shebang_for($file) =~ /^\#\!.*perl/) {
          return 0;
      } else {
          return 1;
      }
  }
  
  sub shebang_for {
      my($self, $file) = @_;
  
      open my $fh, "<", $file or return '';
      my $line = <$fh>;
      return $line;
  }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::App::WrapCGI->new(
          script => $file, execute => $self->would_exec($file),
      );
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::CGIBin - cgi-bin replacement for Plack servers
  
  =head1 SYNOPSIS
  
    use Plack::App::CGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app;
    builder {
        mount "/cgi-bin" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::CGIBin -e 'Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app'
  
  =head1 DESCRIPTION
  
  Plack::App::CGIBin allows you to load CGI scripts from a directory and
  convert them into a PSGI application.
  
  This would give you the extreme easiness when you have bunch of old
  CGI scripts that is loaded using I<cgi-bin> of Apache web server.
  
  =head1 HOW IT WORKS
  
  This application checks if a given file path is a perl script and if
  so, uses L<CGI::Compile> to compile a CGI script into a sub (like
  L<ModPerl::Registry>) and then run it as a persistent application
  using L<CGI::Emulate::PSGI>.
  
  If the give file is not a perl script, it executes the script just
  like a normal CGI script with fork & exec. This is like a normal web
  server mode and no performance benefit is achieved.
  
  The default mechanism to determine if a given file is a Perl script is
  as follows:
  
  =over 4
  
  =item *
  
  Check if the filename ends with C<.pl>
  
  =item *
  
  Open the file and see if the shebang (first line of the file) contains the word C<perl>
  
  =back
  
  You can customize this behavior by passing C<exec_cb> callback, which
  takes a file path to its first argument.
  
  For example, if your perl-based CGI script uses lots of global
  variables and such and are not ready to run on a persistent
  environment, you can do:
  
    my $app = Plack::App::CGIBin->new(
        root => "/path/to/cgi-bin",
        exec_cb => sub { 1 },
    )->to_app;
  
  to always force the execute option for any files.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File> L<CGI::Emulate::PSGI> L<CGI::Compile> L<Plack::App::WrapCGI>
  
  See also L<Plack::App::WrapCGI> if you compile one CGI script into a
  PSGI application without serving CGI scripts from a directory, to
  remove overhead of filesystem lookups, etc.
  
  =cut
PLACK_APP_CGIBIN

$fatpacked{"Plack/App/Cascade.pm"} = <<'PLACK_APP_CASCADE';
  package Plack::App::Cascade;
  use strict;
  use base qw(Plack::Component);
  
  use Plack::Util;
  use Plack::Util::Accessor qw(apps catch codes);
  
  sub add {
      my $self = shift;
      $self->apps([]) unless $self->apps;
      push @{$self->apps}, @_;
  }
  
  sub prepare_app {
      my $self = shift;
      my %codes = map { $_ => 1 } @{ $self->catch || [ 404 ] };
      $self->codes(\%codes);
  }
  
  sub call {
      my($self, $env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $res = [ 404, [ 'Content-Type' => 'text/html' ], [ '404 Not Found' ] ];
  
          my $done;
          my $respond_wrapper = sub {
              my $res = shift;
              if ($self->codes->{$res->[0]}) {
                  return Plack::Util::inline_object
                      write => sub { }, close => sub { };
              } else {
                  $done = 1;
                  return $respond->($res);
              }
          };
  
          for my $app (@{$self->apps || []}) {
              my $res = $app->($env);
              if (ref $res eq 'CODE') {
                  $res->($respond_wrapper);
              } else {
                  $respond_wrapper->($res);
              }
              return if $done;
          }
  
          $respond->($res);
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Cascade - Cascadable compound application
  
  =head1 SYNOPSIS
  
    use Plack::App::Cascade;
    use Plack::App::URLMap;
    use Plack::App::File;
  
    # Serve static files from multiple search paths
    my $cascade = Plack::App::Cascade->new;
    $cascade->add( Plack::App::File->new(root => "/www/example.com/foo")->to_app );
    $cascade->add( Plack::App::File->new(root => "/www/example.com/bar")->to_app );
  
    my $app = Plack::App::URLMap->new;
    $app->map("/static", $cascade);
    $app->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::Cascade is a Plack middleware component that compounds
  several apps and tries them to return the first response that is not
  404.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $app = Plack::App::Cascade->new(apps => [ $app1, $app2 ]);
  
  Creates a new Cascade application.
  
  =item add
  
    $app->add($app1);
    $app->add($app2, $app3);
  
  Appends a new application to the list of apps to try. You can pass the
  multiple apps to the one C<add> call.
  
  =item catch
  
    $app->catch([ 403, 404 ]);
  
  Sets which error codes to catch and process onwards. Defaults to C<404>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::URLMap> Rack::Cascade
  
  =cut
PLACK_APP_CASCADE

$fatpacked{"Plack/App/Directory.pm"} = <<'PLACK_APP_DIRECTORY';
  package Plack::App::Directory;
  use parent qw(Plack::App::File);
  use strict;
  use warnings;
  use Plack::Util;
  use HTTP::Date;
  use Plack::MIME;
  use DirHandle;
  use URI::Escape;
  use Plack::Request;
  
  # Stolen from rack/directory.rb
  my $dir_file = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>";
  my $dir_page = <<PAGE;
  <html><head>
    <title>%s</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style type='text/css'>
  table { width:100%%; }
  .name { text-align:left; }
  .size, .mtime { text-align:right; }
  .type { width:11em; }
  .mtime { width:15em; }
    </style>
  </head><body>
  <h1>%s</h1>
  <hr />
  <table>
    <tr>
      <th class='name'>Name</th>
      <th class='size'>Size</th>
      <th class='type'>Type</th>
      <th class='mtime'>Last Modified</th>
    </tr>
  %s
  </table>
  <hr />
  </body></html>
  PAGE
  
  sub should_handle {
      my($self, $file) = @_;
      return -d $file || -f $file;
  }
  
  sub return_dir_redirect {
      my ($self, $env) = @_;
      my $uri = Plack::Request->new($env)->uri;
      return [ 301,
          [
              'Location' => $uri . '/',
              'Content-Type' => 'text/plain',
              'Content-Length' => 8,
          ],
          [ 'Redirect' ],
      ];
  }
  
  sub serve_path {
      my($self, $env, $dir, $fullpath) = @_;
  
      if (-f $dir) {
          return $self->SUPER::serve_path($env, $dir, $fullpath);
      }
  
      my $dir_url = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
  
      if ($dir_url !~ m{/$}) {
          return $self->return_dir_redirect($env);
      }
  
      my @files = ([ "../", "Parent Directory", '', '', '' ]);
  
      my $dh = DirHandle->new($dir);
      my @children;
      while (defined(my $ent = $dh->read)) {
          next if $ent eq '.';
          push @children, $ent;
      }
  
      for my $basename (sort { $a cmp $b } @children) {
          my $file = "$dir/$basename";
          my $url = $dir_url . $basename;
  
          my $is_dir = -d $file;
          my @stat = stat _;
  
          $url = join '/', map {uri_escape($_)} split m{/}, $url;
  
          if ($is_dir) {
              $basename .= "/";
              $url      .= "/";
          }
  
          my $mime_type = $is_dir ? 'directory' : ( Plack::MIME->mime_type($file) || 'text/plain' );
          push @files, [ $url, $basename, $stat[7], $mime_type, HTTP::Date::time2str($stat[9]) ];
      }
  
      my $path  = Plack::Util::encode_html("Index of $env->{PATH_INFO}");
      my $files = join "\n", map {
          my $f = $_;
          sprintf $dir_file, map Plack::Util::encode_html($_), @$f;
      } @files;
      my $page  = sprintf $dir_page, $path, $path, $files;
  
      return [ 200, ['Content-Type' => 'text/html; charset=utf-8'], [ $page ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Directory - Serve static files from document root with directory index
  
  =head1 SYNOPSIS
  
    # app.psgi
    use Plack::App::Directory;
    my $app = Plack::App::Directory->new({ root => "/path/to/htdocs" })->to_app;
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application with directory index a la Apache's mod_autoindex.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to the current directory.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File>
  
  =cut
PLACK_APP_DIRECTORY

$fatpacked{"Plack/App/File.pm"} = <<'PLACK_APP_FILE';
  package Plack::App::File;
  use strict;
  use warnings;
  use parent qw/Plack::Component/;
  use File::Spec::Unix;
  use Cwd ();
  use Plack::Util;
  use Plack::MIME;
  use HTTP::Date;
  
  use Plack::Util::Accessor qw( root file content_type encoding );
  
  sub should_handle {
      my($self, $file) = @_;
      return -f $file;
  }
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my($file, $path_info) = $self->file || $self->locate_file($env);
      return $file if ref $file eq 'ARRAY';
  
      if ($path_info) {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.SCRIPT_NAME'} =~ s/\Q$path_info\E$//;
          $env->{'plack.file.PATH_INFO'}   = $path_info;
      } else {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.PATH_INFO'}   = '';
      }
  
      return $self->serve_path($env, $file);
  }
  
  sub locate_file {
      my($self, $env) = @_;
  
      my $path = $env->{PATH_INFO} || '';
  
      if ($path =~ /\0/) {
          return $self->return_400;
      }
  
      my $docroot = $self->root || ".";
      my @path = split '/', $path;
      if (@path) {
          shift @path if $path[0] eq '';
      } else {
          @path = ('.');
      }
  
      if (grep $_ eq '..', @path) {
          return $self->return_403;
      }
  
      my($file, @path_info);
      while (@path) {
          my $try = File::Spec::Unix->catfile($docroot, @path);
          if ($self->should_handle($try)) {
              $file = $try;
              last;
          } elsif (!$self->allow_path_info) {
              last;
          }
          unshift @path_info, pop @path;
      }
  
      if (!$file) {
          return $self->return_404;
      }
  
      if (!-r $file) {
          return $self->return_403;
      }
  
      return $file, join("/", "", @path_info);
  }
  
  sub allow_path_info { 0 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $content_type = $self->content_type || Plack::MIME->mime_type($file)
                         || 'text/plain';
  
      if ($content_type =~ m!^text/!) {
          $content_type .= "; charset=" . ($self->encoding || "utf-8");
      }
  
      open my $fh, "<:raw", $file
          or return $self->return_403;
  
      my @stat = stat $file;
  
      Plack::Util::set_io_path($fh, Cwd::realpath($file));
  
      return [
          200,
          [
              'Content-Type'   => $content_type,
              'Content-Length' => $stat[7],
              'Last-Modified'  => HTTP::Date::time2str( $stat[9] )
          ],
          $fh,
      ];
  }
  
  sub return_403 {
      my $self = shift;
      return [403, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['forbidden']];
  }
  
  sub return_400 {
      my $self = shift;
      return [400, ['Content-Type' => 'text/plain', 'Content-Length' => 11], ['Bad Request']];
  }
  
  # Hint: subclasses can override this to return undef to pass through 404
  sub return_404 {
      my $self = shift;
      return [404, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['not found']];
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::App::File - Serve static files from root directory
  
  =head1 SYNOPSIS
  
    use Plack::App::File;
    my $app = Plack::App::File->new(root => "/path/to/htdocs")->to_app;
  
    # Or map the path to a specific file
    use Plack::Builder;
    builder {
        mount "/favicon.ico" => Plack::App::File->new(file => '/path/to/favicon.ico');
    };
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application, and internally used by
  L<Plack::Middleware::Static>. This application serves file from
  document root if the path matches with the local file. Use
  L<Plack::App::Directory> if you want to list files in the directory
  as well.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to C<.> (current directory)
  
  =item file
  
  The file path to create responses from. Optional.
  
  If it's set the application would B<ALWAYS> create a response out of
  the file and there will be no security check etc. (hence fast). If
  it's not set, the application uses C<root> to find the matching file.
  
  =item encoding
  
  Set the file encoding for text files. Defaults to C<utf-8>.
  
  =item content_type
  
  Set the file content type. If not set L<Plack::MIME> will try to detect it
  based on the file extension or fall back to C<text/plain>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::Static> L<Plack::App::Directory>
  
  =cut
  
  
PLACK_APP_FILE

$fatpacked{"Plack/App/PSGIBin.pm"} = <<'PLACK_APP_PSGIBIN';
  package Plack::App::PSGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util;
  
  sub allow_path_info { 1 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::Util::load_psgi($file);
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::PSGIBin - Run .psgi files from a directory
  
  =head1 SYNOPSIS
  
    use Plack::App::PSGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::PSGIBin->new(root => "/path/to/psgi/scripts")->to_app;
    builder {
        mount "/psgi" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::PSGIBin -e 'Plack::App::PSGIBin->new(root => "/path/psgi/scripts")->to_app'
  
  =head1 DESCRIPTION
  
  This application loads I<.psgi> files (or actually whichever filename
  extensions) from the root directory and run it as a PSGI
  application. Suppose you have a directory containing C<foo.psgi> and
  C<bar.psgi>, map this application to C</app> with
  L<Plack::App::URLMap> and you can access them via the URL:
  
    http://example.com/app/foo.psgi
    http://example.com/app/bar.psgi
  
  to load them. You can rename the file to the one without C<.psgi>
  extension to make the URL look nicer, or use the URL rewriting tools
  like L<Plack::Middleware::Rewrite> to do the same thing.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
PLACK_APP_PSGIBIN

$fatpacked{"Plack/App/URLMap.pm"} = <<'PLACK_APP_URLMAP';
  package Plack::App::URLMap;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use constant DEBUG => $ENV{PLACK_URLMAP_DEBUG};
  
  use Carp ();
  
  sub mount { shift->map(@_) }
  
  sub map {
      my $self = shift;
      my($location, $app) = @_;
  
      my $host;
      if ($location =~ m!^https?://(.*?)(/.*)!) {
          $host     = $1;
          $location = $2;
      }
  
      if ($location !~ m!^/!) {
          Carp::croak("Paths need to start with /");
      }
      $location =~ s!/$!!;
  
      push @{$self->{_mapping}}, [ $host, $location, $app ];
  }
  
  sub prepare_app {
      my $self = shift;
      # sort by path length
      $self->{_sorted_mapping} = [
          map  { [ @{$_}[2..4] ] }
          sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] }
          map  { [ ($_->[0] ? length $_->[0] : 0), length($_->[1]), @$_ ] } @{$self->{_mapping}},
      ];
  }
  
  sub call {
      my ($self, $env) = @_;
  
      my $path_info   = $env->{PATH_INFO};
      my $script_name = $env->{SCRIPT_NAME};
  
      my($http_host, $server_name) = @{$env}{qw( HTTP_HOST SERVER_NAME )};
  
      if ($http_host and my $port = $env->{SERVER_PORT}) {
          $http_host =~ s/:$port$//;
      }
  
      for my $map (@{ $self->{_sorted_mapping} }) {
          my($host, $location, $app) = @$map;
          my $path = $path_info; # copy
          no warnings 'uninitialized';
          DEBUG && warn "Matching request (Host=$http_host Path=$path) and the map (Host=$host Path=$location)\n";
          next unless not defined $host     or
                      $http_host   eq $host or
                      $server_name eq $host;
          next unless $location eq '' or $path =~ s!^\Q$location\E!!;
          next unless $path eq '' or $path =~ m!^/!;
          DEBUG && warn "-> Matched!\n";
  
          my $orig_path_info   = $env->{PATH_INFO};
          my $orig_script_name = $env->{SCRIPT_NAME};
  
          $env->{PATH_INFO}  = $path;
          $env->{SCRIPT_NAME} = $script_name . $location;
          return $self->response_cb($app->($env), sub {
              $env->{PATH_INFO} = $orig_path_info;
              $env->{SCRIPT_NAME} = $orig_script_name;
          });
      }
  
      DEBUG && warn "All matching failed.\n";
  
      return [404, [ 'Content-Type' => 'text/plain' ], [ "Not Found" ]];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::URLMap - Map multiple apps in different paths
  
  =head1 SYNOPSIS
  
    use Plack::App::URLMap;
  
    my $app1 = sub { ... };
    my $app2 = sub { ... };
    my $app3 = sub { ... };
  
    my $urlmap = Plack::App::URLMap->new;
    $urlmap->map("/" => $app1);
    $urlmap->map("/foo" => $app2);
    $urlmap->map("http://bar.example.com/" => $app3);
  
    my $app = $urlmap->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::URLMap is a PSGI application that can dispatch multiple
  applications based on URL path and hostnames (a.k.a "virtual hosting")
  and takes care of rewriting C<SCRIPT_NAME> and C<PATH_INFO> (See
  L</"HOW THIS WORKS"> for details). This module is inspired by
  Rack::URLMap.
  
  =head1 METHODS
  
  =over 4
  
  =item map
  
    $urlmap->map("/foo" => $app);
    $urlmap->map("http://bar.example.com/" => $another_app);
  
  Maps URL path or an absolute URL to a PSGI application. The match
  order is sorted by host name length and then path length.
  
  URL paths need to match from the beginning and should match completely
  till the path separator (or the end of the path). For example, if you
  register the path C</foo>, it B<will> match with the request C</foo>,
  C</foo/> or C</foo/bar> but it B<won't> match with C</foox>.
  
  Mapping URL with host names is also possible, and in that case the URL
  mapping works like a virtual host.
  
  Mappings will nest.  If $app is already mapped to C</baz> it will
  match a request for C</foo/baz> but not C</foo>. See L</"HOW THIS
  WORKS"> for more details.
  
  =item mount
  
  Alias for C<map>.
  
  =item to_app
  
    my $handler = $urlmap->to_app;
  
  Returns the PSGI application code reference. Note that the
  Plack::App::URLMap object is callable (by overloading the code
  dereference), so returning the object itself as a PSGI application
  should also work.
  
  =back
  
  =head1 DEBUGGING
  
  You can set the environment variable C<PLACK_URLMAP_DEBUG> to see how
  this application matches with the incoming request host names and
  paths.
  
  =head1 HOW THIS WORKS
  
  This application works by I<fixing> C<SCRIPT_NAME> and C<PATH_INFO>
  before dispatching the incoming request to the relocated
  applications.
  
  Say you have a Wiki application that takes C</index> and C</page/*>
  and makes a PSGI application C<$wiki_app> out of it, using one of
  supported web frameworks, you can put the whole application under
  C</wiki> by:
  
    # MyWikiApp looks at PATH_INFO and handles /index and /page/*
    my $wiki_app = sub { MyWikiApp->run(@_) };
    
    use Plack::App::URLMap;
    my $app = Plack::App::URLMap->new;
    $app->mount("/wiki" => $wiki_app);
  
  When a request comes in with C<PATH_INFO> set to C</wiki/page/foo>,
  the URLMap application C<$app> strips the C</wiki> part from
  C<PATH_INFO> and B<appends> that to C<SCRIPT_NAME>.
  
  That way, if the C<$app> is mounted under the root
  (i.e. C<SCRIPT_NAME> is C<"">) with standalone web servers like
  L<Starman>, C<SCRIPT_NAME> is now locally set to C</wiki> and
  C<PATH_INFO> is changed to C</page/foo> when C<$wiki_app> gets called.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_APP_URLMAP

$fatpacked{"Plack/App/WrapCGI.pm"} = <<'PLACK_APP_WRAPCGI';
  package Plack::App::WrapCGI;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use Plack::Util::Accessor qw(script execute _app);
  use CGI::Emulate::PSGI;
  use CGI::Compile;
  use Carp;
  use POSIX ":sys_wait_h";
  
  sub prepare_app {
      my $self = shift;
      my $script = $self->script
          or croak "'script' is not set";
  
      if ($self->execute) {
          my $app = sub {
              my $env = shift;
  
              pipe( my $stdoutr, my $stdoutw );
              pipe( my $stdinr,  my $stdinw );
  
  
              my $pid = fork();
              Carp::croak("fork failed: $!") unless defined $pid;
  
  
              if ($pid == 0) { # child
                  local $SIG{__DIE__} = sub {
                      print STDERR @_;
                      exit(1);
                  };
  
                  close $stdoutr;
                  close $stdinw;
  
                  local %ENV = (%ENV, CGI::Emulate::PSGI->emulate_environment($env));
  
                  open( STDOUT, ">&=" . fileno($stdoutw) )
                    or Carp::croak "Cannot dup STDOUT: $!";
                  open( STDIN, "<&=" . fileno($stdinr) )
                    or Carp::croak "Cannot dup STDIN: $!";
  
                  exec($script) or Carp::croak("cannot exec: $!");
  
                  exit(2);
              }
  
              close $stdoutw;
              close $stdinr;
  
              syswrite($stdinw, do {
                  local $/;
                  my $fh = $env->{'psgi.input'};
                  <$fh>;
              });
              # close STDIN so child will stop waiting
              close $stdinw;
  
              my $res = '';
              while (waitpid($pid, WNOHANG) <= 0) {
                  $res .= do { local $/; <$stdoutr> };
              }
              $res .= do { local $/; <$stdoutr> };
  
              if (POSIX::WIFEXITED($?)) {
                  return CGI::Parse::PSGI::parse_cgi_output(\$res);
              } else {
                  Carp::croak("Error at run_on_shell CGI: $!");
              }
          };
          $self->_app($app);
      } else {
          my $sub = CGI::Compile->compile($script);
          my $app = CGI::Emulate::PSGI->handler($sub);
  
          $self->_app($app);
      }
  }
  
  sub call {
      my($self, $env) = @_;
      $self->_app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::WrapCGI - Compiles a CGI script as PSGI application
  
  =head1 SYNOPSIS
  
    use Plack::App::WrapCGI;
  
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.pl")->to_app;
  
    # if you want to execute as a real CGI script
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.rb", execute => 1)->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::WrapCGI compiles a CGI script into a PSGI application
  using L<CGI::Compile> and L<CGI::Emulate::PSGI>, and runs it with any
  PSGI server as a PSGI application.
  
  See also L<Plack::App::CGIBin> if you have a directory that contains a
  lot of CGI scripts and serve them like Apache's mod_cgi.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    my $app = Plack::App::WrapCGI->new(%args);
  
  Creates a new PSGI application using the given script. I<%args> has two
  parameters:
  
  =over 8
  
  =item script
  
  The path to a CGI-style program. This is a required parameter.
  
  =item execute
  
  An optional parameter. When set to a true value, this app will run the script
  with a CGI-style C<fork>/C<exec> model. Note that you may run programs written
  in other languages with this approach.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
  
  =cut
PLACK_APP_WRAPCGI

$fatpacked{"Plack/Builder.pm"} = <<'PLACK_BUILDER';
  package Plack::Builder;
  use strict;
  use parent qw( Exporter );
  our @EXPORT = qw( builder add enable enable_if mount );
  
  use Carp ();
  use Plack::App::URLMap;
  use Plack::Middleware::Conditional; # TODO delayed load?
  
  sub new {
      my $class = shift;
      bless { middlewares => [ ] }, $class;
  }
  
  sub add_middleware {
      my($self, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, $mw;
  }
  
  sub add_middleware_if {
      my($self, $cond, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, sub {
          Plack::Middleware::Conditional->wrap($_[0], condition => $cond, builder => $mw);
      };
  }
  
  # do you want remove_middleware() etc.?
  
  sub _mount {
      my ($self, $location, $app) = @_;
  
      if (!$self->{_urlmap}) {
          $self->{_urlmap} = Plack::App::URLMap->new;
      }
  
      $self->{_urlmap}->map($location => $app);
      $self->{_urlmap};
  }
  
  sub to_app {
      my($self, $app) = @_;
  
      for my $mw (reverse @{$self->{middlewares}}) {
          $app = $mw->($app);
      }
  
      $app;
  }
  
  # DSL goes here
  our $_add = our $_add_if = our $_mount = sub {
      Carp::croak("enable/mount should be called inside builder {} block");
  };
  
  sub add      { Carp::carp("add is deprecated. Use 'enable'"); $_add->(@_) }
  sub enable         { $_add->(@_) }
  sub enable_if(&$@) { $_add_if->(@_) }
  
  sub mount {
      my $self = shift;
      if (Scalar::Util::blessed($self)) {
          $self->_mount(@_);
      }else{
          $_mount->($self, @_);
      }
  }
  
  sub builder(&) {
      my $block = shift;
  
      my $self = __PACKAGE__->new;
  
      my $mount_is_called;
      my $urlmap = Plack::App::URLMap->new;
      local $_mount = sub {
          $mount_is_called++;
          $urlmap->map(@_);
          $urlmap;
      };
      local $_add = sub {
          $self->add_middleware(@_);
      };
      local $_add_if = sub {
          $self->add_middleware_if(@_);
      };
  
      my $app = $block->();
  
      if ($mount_is_called) {
          if ($app ne $urlmap) {
              Carp::carp("You used mount() in a builder block, but the last line (app) isn't using mount().\n" .
                         "This causes all mount() mappings to be ignored. See perldoc Plack::Builder for details.");
          } else {
              $app = $app->to_app;
          }
      }
  
      $self->to_app($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Builder - OO and DSL to enable Plack Middlewares
  
  =head1 SYNOPSIS
  
    # in .psgi
    use Plack::Builder;
  
    my $app = sub { ... };
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", opt => "val";
        enable "Plack::Middleware::Baz";
        $app;
    };
  
    # use URLMap
  
    builder {
        mount "/foo" => builder {
            enable "Plack::Middleware::Foo";
            $app;
        };
  
        mount "/bar" => $app2;
        mount "http://example.com/" => builder { $app3 };
    };
  
    # using OO interface
  
    my $builder = Plack::Builder->new();
    $builder->add_middleware('Foo', opt => 1);
    $app = $builder->mount('/app' => $app);
    $app = $builder->to_app($app);
  
  =head1 DESCRIPTION
  
  Plack::Builder gives you a quick domain specific language (DSL) to
  wrap your application with Plack::Middleware subclasses. The
  middleware you're trying to use should use L<Plack::Middleware> as a
  base class to use this DSL, inspired by Rack::Builder.
  
  Whenever you call C<enable> on any middleware, the middleware app is
  pushed to the stack inside the builder, and then reversed when it
  actually creates a wrapped application handler, so:
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", opt => "val";
        $app;
    };
  
  is syntactically equal to:
  
    $app = Plack::Middleware::Bar->wrap($app, opt => "val");
    $app = Plack::Middleware::Foo->wrap($app);
  
  In other words, you're supposed to C<enable> middleware from outer to inner.
  
  =head1 INLINE MIDDLEWARE
  
  Plack::Builder allows you to code middleware inline using a nested
  code reference.
  
  If the first argument to C<enable> is a code reference, it will be
  passed an C<$app> and is supposed to return another code reference
  which is PSGI application that consumes C<$env> in runtime. So:
  
    builder {
        enable sub {
            my $app = shift;
            sub {
                my $env = shift;
                # do preprocessing
                my $res = $app->($env);
                # do postprocessing
                return $res;
            };
        };
        $app;
    };
  
  is equal to:
  
    my $mw = sub {
        my $app = shift;
        sub { my $env = shift; $app->($env) };
    };
  
    $app = $mw->($app);
  
  =head1 URLMap support
  
  Plack::Builder has a native support for L<Plack::App::URLMap> with C<mount> method.
  
    use Plack::Builder;
    my $app = builder {
        mount "/foo" => $app1;
        mount "/bar" => builder {
            enable "Plack::Middleware::Foo";
            $app2;
        };
    };
  
  See L<Plack::App::URLMap>'s C<map> method to see what they mean. With
  builder you can't use C<map> as a DSL, for the obvious reason :)
  
  B<NOTE>: Once you use C<mount> in your builder code, you have to use
  C<mount> for all the paths, including the root path (C</>). You can't
  have the default app in the last line of C<builder> like:
  
    my $app = sub {
        my $env = shift;
        ...
    };
  
    builder {
        mount "/foo" => sub { ... };
        $app; # THIS DOESN'T WORK
    };
  
  You'll get warnings saying that your mount configuration will be
  ignored. Instead you should use C<< mount "/" => ... >> in the last
  line to set the default fallback app.
  
    builder {
        mount "/foo" => sub { ... };
        mount "/" => $app;
    }
  
  Note that the C<builder> DSL returns a whole new PSGI application, which means
  
  =over 4
  
  =item *
  
  C<builder { ... }> should normally the last statement of a C<.psgi>
  file, because the return value of C<builder> is the application that
  actually is executed.
  
  =item *
  
  You can nest your C<builder> block, mixed with C<mount> (see URLMap
  support above):
  
    builder {
        mount "/foo" => builder {
            mount "/bar" => $app;
        }
    }
  
  will locate the C<$app> under C</foo/bar> since the inner C<builder>
  block puts it under C</bar> and it results a new PSGI application
  which is located under C</foo> because of the outer C<builder> block.
  
  =back
  
  =head1 CONDITIONAL MIDDLEWARE SUPPORT
  
  You can use C<enable_if> to conditionally enable middleware based on
  the runtime environment. See L<Plack::Middleware::Conditional> for
  details.
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::App::URLMap> L<Plack::Middleware::Conditional>
  
  =cut
  
  
  
PLACK_BUILDER

$fatpacked{"Plack/Component.pm"} = <<'PLACK_COMPONENT';
  package Plack::Component;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use overload '&{}' => sub { shift->to_app(@_) }, fallback => 1;
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self;
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          $self = bless {%{$_[0]}}, $class;
      } else {
          $self = bless {@_}, $class;
      }
  
      $self;
  }
  
  # NOTE:
  # this is for back-compat only,
  # future modules should use
  # Plack::Util::Accessor directly
  # or their own favorite accessor
  # generator.
  # - SL
  sub mk_accessors {
      my $self = shift;
      Plack::Util::Accessor::mk_accessors( ref( $self ) || $self, @_ )
  }
  
  sub prepare_app { return }
  
  sub to_app {
      my $self = shift;
      $self->prepare_app;
      return sub { $self->call(@_) };
  }
  
  
  sub response_cb {
      my($self, $res, $cb) = @_;
      Plack::Util::response_cb($res, $cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Component - Base class for PSGI endpoints
  
  =head1 SYNOPSIS
  
    package Plack::App::Foo;
    use parent qw( Plack::Component );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        my $res = ...; # create a response ...
  
        # return the response
        return $res;
    }
  
  =head1 DESCRIPTION
  
  Plack::Component is the base class shared between Plack::Middleware
  and Plack::App::* modules. If you are writing middleware, you should
  inherit from L<Plack::Middleware>, but if you are writing a
  Plack::App::* you should inherit from this directly.
  
  =head1 REQUIRED METHOD
  
  =over 4
  
  =item call ($env)
  
  You are expected to implement a C<call> method in your component. This
  is where all the work gets done. It receives the PSGI C<$env> hash-ref
  as an argument and is expected to return a proper PSGI response value.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new (%opts | \%opts)
  
  The constructor accepts either a hash or a hash-ref and uses that to
  create the instance with. It will call no other methods and simply return
  the instance that is created.
  
  =item prepare_app
  
  This method is called by C<to_app> and is meant as a hook to be used to
  prepare your component before it is packaged as a PSGI C<$app>.
  
  =item to_app
  
  This is the method used in several parts of the Plack infrastructure to
  convert your component into a PSGI C<$app>. You should not ever need to
  override this method, it is recommended to use C<prepare_app> and C<call>
  instead.
  
  =item response_cb
  
  This is a wrapper for C<response_cb> in L<Plack::Util>. See
  L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =head1 OBJECT LIFECYCLE
  
  Objects for the derived classes (Plack::App::* or
  Plack::Middleware::*) are created at the PSGI application compile
  phase using C<new>, C<prepare_app> and C<to_app>, and the created
  object persists during the web server lifecycle, unless it is running
  on the non-persistent environment like CGI. C<call> is invoked against
  the same object whenever a new request comes in.
  
  You can check if it is running in a persistent environment by checking
  C<psgi.run_once> key in the C<$env> being true (non-persistent) or
  false (persistent), but it is best for you to write your middleware
  safely for a persistent environment. To accomplish that, you should
  avoid saving per-request data like C<$env> in your object.
  
  =head1 BACKWARDS COMPATIBILITY
  
  The L<Plack::Middleware> module used to inherit from L<Class::Accessor::Fast>,
  which has been removed in favor of the L<Plack::Util::Accessor> module. When
  developing new components it is recommended to use L<Plack::Util::Accessor>
  like so:
  
    use Plack::Util::Accessor qw( foo bar baz );
  
  However, in order to keep backwards compatibility this module provides a
  C<mk_accessors> method similar to L<Class::Accessor::Fast>. New code should
  not use this and use L<Plack::Util::Accessor> instead.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Middleware>
  
  =cut
PLACK_COMPONENT

$fatpacked{"Plack/HTTPParser.pm"} = <<'PLACK_HTTPPARSER';
  package Plack::HTTPParser;
  use strict;
  use parent qw(Exporter);
  
  our @EXPORT = qw( parse_http_request );
  
  use Try::Tiny;
  
  {
      if (!$ENV{PLACK_HTTP_PARSER_PP} && try { require HTTP::Parser::XS; 1 }) {
          *parse_http_request = \&HTTP::Parser::XS::parse_http_request;
      } else {
          require Plack::HTTPParser::PP;
          *parse_http_request = \&Plack::HTTPParser::PP::parse_http_request;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser - Parse HTTP headers
  
  =head1 SYNOPSIS
  
    use Plack::HTTPParser qw(parse_http_request);
  
    my $ret = parse_http_request($header_str, \%env);
    # see HTTP::Parser::XS docs
  
  =head1 DESCRIPTION
  
  Plack::HTTPParser is a wrapper class to dispatch C<parse_http_request>
  to Kazuho Oku's XS based HTTP::Parser::XS or pure perl fallback based
  on David Robins HTTP::Parser.
  
  If you want to force the use of the slower pure perl version even if the
  fast XS version is available, set the environment variable
  C<PLACK_HTTP_PARSER_PP> to 1.
  
  =head1 SEE ALSO
  
  L<HTTP::Parser::XS> L<HTTP::Parser>
  
  =cut
PLACK_HTTPPARSER

$fatpacked{"Plack/HTTPParser/PP.pm"} = <<'PLACK_HTTPPARSER_PP';
  package Plack::HTTPParser::PP;
  use strict;
  use warnings;
  use URI::Escape;
  
  sub parse_http_request {
      my($chunk, $env) = @_;
      $env ||= {};
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my ($major, $minor);
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/(\d+)\.(\d+)$/i;
      ($major, $minor) = ($1, $2);
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{SERVER_PROTOCOL} = "HTTP/$major.$minor";
      $env->{REQUEST_URI}     = $uri;
  
      my($path, $query) = ( $uri =~ /^([^?]*)(?:\?(.*))?$/s );
      for ($path, $query) { s/\#.*$// if defined && length } # dumb clients sending URI fragments
  
      $env->{PATH_INFO}    = URI::Escape::uri_unescape($path);
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser::PP - Pure perl fallback of HTTP::Parser::XS
  
  =head1 DESCRIPTION
  
  Do not use this module directly. Use L<Plack::HTTPParser> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
  
PLACK_HTTPPARSER_PP

$fatpacked{"Plack/Handler.pm"} = <<'PLACK_HANDLER';
  package Plack::Handler;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler - Connects PSGI applications and Web servers
  
  =head1 SYNOPSIS
  
    package Plack::Handler::AwesomeWebServer;
    sub new {
        my($class, %opt) = @_;
        ...
        return $self;
    }
  
    sub run {
        my($self, $app) = @_;
        # launch the AwesomeWebServer and run $app in the loop
    }
  
    # then from command line
    plackup -s AwesomeWebServer -a app.psgi
  
  =head1 DESCRIPTION
  
  Plack::Handler defines an adapter (connector) interface to adapt
  L<plackup> and L<Plack::Runner> to various PSGI web servers, such as
  Apache2 for mod_perl and Standalone for L<HTTP::Server::PSGI>.
  
  It is an empty class, and as long as they implement the methods
  defined as an Server adapter interface, they do not need to inherit
  Plack::Handler.
  
  If you write a new handler for existing web servers, I recommend you
  to include the full name of the server module after I<Plack::Handler>
  prefix, like L<Plack::Handler::Net::Server::Coro> if you write a
  handler for L<Net::Server::Coro>. That way you'll be using plackup
  command line option like:
  
    plackup -s Net::Server::Coro
  
  that makes it easy to figure out which web server you're going to use.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $server = FooBarServer->new(%args);
  
  Creates a new adapter object. I<%args> can take arbitrary parameters
  to configure server environments but common parameters are:
  
  =over 8
  
  =item port
  
  Port number the server listens to.
  
  =item host
  
  Address the server listens to. Set to undef to listen any interface.
  
  =back
  
  =item run
  
    $server->run($app);
  
  Starts the server process and when a request comes in, run the PSGI
  application passed in C<$app> in the loop.
  
  =item register_service
  
    $server->register_service($app);
  
  Optional interface if your server should run in parallel with other
  event loop, particularly L<AnyEvent>. This is the same as C<run> but
  doesn't run the main loop.
  
  =back
  
  =head1 SEE ALSO
  
  rackup
  
  =cut
  
PLACK_HANDLER

$fatpacked{"Plack/Handler/Apache1.pm"} = <<'PLACK_HANDLER_APACHE1';
  package Plack::Handler::Apache1;
  use strict;
  use Apache::Request;
  use Apache::Constants qw(:common :response);
  
  use Plack::Util;
  use Scalar::Util;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          local $ENV{MOD_PERL}; # trick Catalyst/CGI.pm etc.
          Plack::Util::load_psgi $app;
      };
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      my $vpath    = $env->{SCRIPT_NAME} . ($env->{PATH_INFO} || '');
  
      my $location = $r->location || "/";
         $location =~ s{/$}{};
      (my $path_info = $vpath) =~ s/^\Q$location\E//;
  
      $env->{SCRIPT_NAME} = $location;
      $env->{PATH_INFO}   = $path_info;
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return OK;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
      $r->send_http_header;
  
      if (defined $body) {
          if (Plack::Util::is_real_fh($body)) {
              $r->send_fd($body);
          } else {
              Plack::Util::foreach($body, sub { $r->print(@_) });
          }
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_) },
              close => sub { };
      }
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Plack::Handler::Apache1 - Apache 1.3.x handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlHandler Plack::Handler::Apache1
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    <Perl>
    use Plack::Handler::Apache1;
    Plack::Handler::Apache1->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application with mod_perl on Apache 1.3.x.
  
  =head1 AUTHOR
  
  Aaron Trevena
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_APACHE1

$fatpacked{"Plack/Handler/Apache2.pm"} = <<'PLACK_HANDLER_APACHE2';
  package Plack::Handler::Apache2;
  use strict;
  use warnings;
  use Apache2::RequestRec;
  use Apache2::RequestIO;
  use Apache2::RequestUtil;
  use Apache2::Response;
  use Apache2::Const -compile => qw(OK);
  use Apache2::Log;
  use APR::Table;
  use IO::Handle;
  use Plack::Util;
  use Scalar::Util;
  use URI;
  use URI::Escape;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          local $ENV{MOD_PERL}; # trick Catalyst/CGI.pm etc.
          Plack::Util::load_psgi $app;
      };
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      # Actually, we can not trust PATH_INFO from mod_perl because mod_perl squeezes multiple slashes into one slash.
      my $uri = URI->new("http://".$r->hostname.$r->unparsed_uri);
  
      $env->{PATH_INFO} = uri_unescape($uri->path);
  
      $class->fixup_path($r, $env);
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return Apache2::Const::OK;
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  # The method for PH::Apache2::Registry to override.
  sub fixup_path {
      my ($class, $r, $env) = @_;
  
      # $env->{PATH_INFO} is created from unparsed_uri so it is raw.
      my $path_info = $env->{PATH_INFO} || '';
  
      # Get argument of <Location> or <LocationMatch> directive
      # This may be string or regexp and we can't know either.
      my $location = $r->location;
  
      # Let's *guess* if we're in a LocationMatch directive
      if ($location eq '/') {
          # <Location /> could be handled as a 'root' case where we make
          # everything PATH_INFO and empty SCRIPT_NAME as in the PSGI spec
          $env->{SCRIPT_NAME} = '';
      } elsif ($path_info =~ s{^($location)/?}{/}) {
          $env->{SCRIPT_NAME} = $1 || '';
      } else {
          # Apache's <Location> is matched but here is not.
          # This is something wrong. We can only respect original.
          $r->server->log_error(
              "Your request path is '$path_info' and it doesn't match your Location(Match) '$location'. " .
              "This should be due to the configuration error. See perldoc Plack::Handler::Apache2 for details."
          );
      }
  
      $env->{PATH_INFO}   = $path_info;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
  
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } elsif (lc $h eq 'content-length') {
              $r->set_content_length($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
  
      if (Scalar::Util::blessed($body) and $body->can('path') and my $path = $body->path) {
          $r->sendfile($path);
      } elsif (defined $body) {
          Plack::Util::foreach($body, sub { $r->print(@_) });
          $r->rflush;
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_); $r->rflush },
              close => sub { $r->rflush };
      }
  
      return Apache2::Const::OK;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2 - Apache 2.0 handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlResponseHandler Plack::Handler::Apache2
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    # Optional, preload the application in the parent like startup.pl
    <Perl>
    use Plack::Handler::Apache2;
    Plack::Handler::Apache2->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application with mod_perl on Apache 2.x.
  
  =head1 CREATING CUSTOM HANDLER
  
  If you want to create a custom handler that loads or creates PSGI
  applications using other means than loading from C<.psgi> files, you
  can create your own handler class and use C<call_app> class method to
  run your application.
  
    package My::ModPerl::Handler;
    use Plack::Handler::Apache2;
  
    sub get_app {
      # magic!
    }
  
    sub handler {
      my $r = shift;
      my $app = get_app();
      Plack::Handler::Apache2->call_app($r, $app);
    }
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Paul Driver
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_HANDLER_APACHE2

$fatpacked{"Plack/Handler/Apache2/Registry.pm"} = <<'PLACK_HANDLER_APACHE2_REGISTRY';
  package Plack::Handler::Apache2::Registry;
  use strict;
  use warnings;
  use Try::Tiny;
  use Apache2::Const;
  use Apache2::Log;
  use parent qw/Plack::Handler::Apache2/;
  
  sub handler {
      my $class = __PACKAGE__;
      my ($r) = @_;
  
      return try {
          my $app = $class->load_app( $r->filename );
          $class->call_app( $r, $app );
      }catch{
          if(/no such file/i){
              $r->log_error( $_ );
              return Apache2::Const::NOT_FOUND;
          }else{
              $r->log_error( $_ );
              return Apache2::Const::SERVER_ERROR;
          }
      };
  }
  
  # Overriding
  sub fixup_path {
      my ($class, $r, $env) = @_;
      $env->{PATH_INFO} =~ s{^$env->{SCRIPT_NAME}}{};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2::Registry - Runs .psgi files.
  
  =head1 SYNOPSIS
  
    PerlModule Plack::Handler::Apache2::Registry;
    <Location /psgi-bin>
    SetHandler modperl
    PerlHandler Plack::Handler::Apache2::Registry
    </Location>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any *.psgi files with mod_perl2,
  just like ModPerl::Registry.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Apache2>
  
  =cut
  
PLACK_HANDLER_APACHE2_REGISTRY

$fatpacked{"Plack/Handler/CGI.pm"} = <<'PLACK_HANDLER_CGI';
  package Plack::Handler::CGI;
  use strict;
  use warnings;
  use IO::Handle;
  
  # copied from HTTP::Status
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  sub new { bless {}, shift }
  
  sub run {
      my ($self, $app) = @_;
  
      my $env = $self->setup_env();
  
      my $res = $app->($env);
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  }
  
  sub setup_env {
      my ( $self, $override_env ) = @_;
  
      $override_env ||= {};
  
      binmode STDIN;
      binmode STDERR;
  
      my $env = {
          %ENV,
          'psgi.version'    => [ 1, 1 ],
          'psgi.url_scheme' => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'      => *STDIN,
          'psgi.errors'     => *STDERR,
          'psgi.multithread'  => 0,
          'psgi.multiprocess' => 1,
          'psgi.run_once'     => 1,
          'psgi.streaming'    => 1,
          'psgi.nonblocking'  => 1,
          %{ $override_env },
      };
  
      delete $env->{HTTP_CONTENT_TYPE};
      delete $env->{HTTP_CONTENT_LENGTH};
      $env->{'HTTP_COOKIE'} ||= $ENV{COOKIE}; # O'Reilly server bug
  
      if (!exists $env->{PATH_INFO}) {
          $env->{PATH_INFO} = '';
      }
  
      if ($env->{SCRIPT_NAME} eq '/') {
          $env->{SCRIPT_NAME} = '';
          $env->{PATH_INFO}   = '/' . $env->{PATH_INFO};
      }
  
      return $env;
  }
  
  
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = $StatusCode{$res->[0]};
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice(@$headers, 0, 2)) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $body = $res->[2];
      my $cb = sub { print STDOUT $_[0] };
  
      # inline Plack::Util::foreach here
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      }
      elsif (defined $body) {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
      else {
          return Plack::Handler::CGI::Writer->new;
      }
  }
  
  package Plack::Handler::CGI::Writer;
  sub new   { bless \do { my $x }, $_[0] }
  sub write { print STDOUT $_[1] }
  sub close { }
  
  package Plack::Handler::CGI;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::CGI - CGI handler for Plack
  
  =head1 SYNOPSIS
  
  Want to run PSGI application as a CGI script? Rename .psgi to .cgi and
  change the shebang line like:
  
    #!/usr/bin/env plackup
    # rest of the file can be the same as other .psgi file
  
  You can alternatively create a .cgi file that contains something like:
  
    #!/usr/bin/perl
    use Plack::Loader;
    my $app = Plack::Util::load_psgi("/path/to/app.psgi");
    Plack::Loader->auto->run($app);
  
  This will auto-recognize the CGI environment variable to load this class.
  
  If you really want to explicitly load the CGI handler, you can. For instance
  you might do this when you want to embed a PSGI application server built into
  CGI-compatible perl-based web server:
  
    use Plack::Handler::CGI;
    Plack::Handler::CGI->new->run($app);
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a CGI script.
  
  =head1 UTILITY METHODS
  
  =head2 setup_env()
  
    my $env = Plack::Handler::CGI->setup_env();
    my $env = Plack::Handler::CGI->setup_env(\%override_env);
  
  Sets up the PSGI environment hash for a CGI request from C<< %ENV >>> and returns it.
  You can can provide a hashref of key/value pairs to override the defaults if you would like.
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
  
PLACK_HANDLER_CGI

$fatpacked{"Plack/Handler/FCGI.pm"} = <<'PLACK_HANDLER_FCGI';
  package Plack::Handler::FCGI;
  use strict;
  use warnings;
  use constant RUNNING_IN_HELL => $^O eq 'MSWin32';
  
  use Scalar::Util qw(blessed);
  use Plack::Util;
  use FCGI;
  use HTTP::Status qw(status_message);
  use URI;
  use URI::Escape;
  
  sub new {
      my $class = shift;
      my $self  = bless {@_}, $class;
  
      $self->{leave_umask} ||= 0;
      $self->{keep_stderr} ||= 0;
      $self->{nointr}      ||= 0;
      $self->{daemonize}   ||= $self->{detach}; # compatibility
      $self->{nproc}       ||= 1 unless blessed $self->{manager};
      $self->{pid}         ||= $self->{pidfile}; # compatibility
      $self->{listen}      ||= [ ":$self->{port}" ] if $self->{port}; # compatibility
      $self->{manager}     = 'FCGI::ProcManager' unless exists $self->{manager};
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $sock = 0;
      if (-S STDIN) {
          # running from web server. Do nothing
          # Note it should come before listen check because of plackup's default
      } elsif ($self->{listen}) {
          my $old_umask = umask;
          unless ($self->{leave_umask}) {
              umask(0);
          }
          $sock = FCGI::OpenSocket( $self->{listen}->[0], 100 )
              or die "failed to open FastCGI socket: $!";
          unless ($self->{leave_umask}) {
              umask($old_umask);
          }
      } elsif (!RUNNING_IN_HELL) {
          die "STDIN is not a socket: specify a listen location";
      }
  
      my %env;
      my $request = FCGI::Request(
          \*STDIN, \*STDOUT,
          ($self->{keep_stderr} ? \*STDOUT : \*STDERR), \%env, $sock,
          ($self->{nointr} ? 0 : &FCGI::FAIL_ACCEPT_ON_INTR),
      );
  
      my $proc_manager;
  
      if ($self->{listen}) {
          $self->daemon_fork if $self->{daemonize};
  
          if ($self->{manager}) {
              if (blessed $self->{manager}) {
                  for (qw(nproc pid)) {
                      die "Don't use '$_' when passing in a 'manager' object"
                          if $self->{$_};
                  }
                  $proc_manager = $self->{manager};
              } else {
                  Plack::Util::load_class($self->{manager});
                  $proc_manager = $self->{manager}->new({
                      n_processes => $self->{nproc},
                      pid_fname   => $self->{pid},
                      (exists $self->{proc_title}
                           ? (pm_title => $self->{proc_title}) : ()),
                  });
              }
  
              # detach *before* the ProcManager inits
              $self->daemon_detach if $self->{daemonize};
  
              $proc_manager->pm_manage;
          }
          elsif ($self->{daemonize}) {
              $self->daemon_detach;
          }
      }
  
      while ($request->Accept >= 0) {
          $proc_manager && $proc_manager->pm_pre_dispatch;
  
          my $env = {
              %env,
              'psgi.version'      => [1,1],
              'psgi.url_scheme'   => ($env{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
              'psgi.input'        => *STDIN,
              'psgi.errors'       => *STDERR, # FCGI.pm redirects STDERR in Accept() loop, so just print STDERR
                                              # print to the correct error handle based on keep_stderr
              'psgi.multithread'  => Plack::Util::FALSE,
              'psgi.multiprocess' => Plack::Util::TRUE,
              'psgi.run_once'     => Plack::Util::FALSE,
              'psgi.streaming'    => Plack::Util::TRUE,
              'psgi.nonblocking'  => Plack::Util::FALSE,
              'psgix.harakiri'    => defined $proc_manager,
          };
  
          delete $env->{HTTP_CONTENT_TYPE};
          delete $env->{HTTP_CONTENT_LENGTH};
  
          # lighttpd munges multiple slashes in PATH_INFO into one. Try recovering it
          my $uri = URI->new("http://localhost" .  $env->{REQUEST_URI});
          $env->{PATH_INFO} = uri_unescape($uri->path);
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E//;
  
          if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ m!lighttpd[-/]1\.(\d+\.\d+)!) {
              no warnings;
              if ($ENV{PLACK_ENV} eq 'development' && $1 < 4.23 && $env->{PATH_INFO} eq '') {
                  warn "You're using lighttpd 1.$1 and appear to mount your FastCGI handler under the root ('/'). ",
                       "It's known to be causing issues because of the lighttpd bug. You're recommended to enable ",
                       "LighttpdScriptNameFix middleware, or upgrade lighttpd to 1.4.23 or later and include ",
                       "'fix-root-scriptname' flag in 'fastcgi.server'. See perldoc Plack::Handler::FCGI for details. ",
                       "This friendly warning will go away in the next major release of Plack.";
              }
              $env->{SERVER_NAME} =~ s/:\d+$//; # cut off port number
          }
  
          # root access for mod_fastcgi
          if (!exists $env->{PATH_INFO}) {
              $env->{PATH_INFO} = '';
          }
  
          my $res = Plack::Util::run_app $app, $env;
  
          if (ref $res eq 'ARRAY') {
              $self->_handle_response($res);
          }
          elsif (ref $res eq 'CODE') {
              $res->(sub {
                  $self->_handle_response($_[0]);
              });
          }
          else {
              die "Bad response $res";
          }
  
          # give pm_post_dispatch the chance to do things after the client thinks
          # the request is done
          $request->Finish;
  
          $proc_manager && $proc_manager->pm_post_dispatch();
  
          if ($proc_manager && $env->{'psgix.harakiri.commit'}) {
              $proc_manager->pm_exit("safe exit with harakiri");
          }
      }
  }
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = status_message($res->[0]);
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice @$headers, 0, 2) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $cb = sub { print STDOUT $_[0] };
      my $body = $res->[2];
      if (defined $body) {
          Plack::Util::foreach($body, $cb);
      }
      else {
          return Plack::Util::inline_object
              write => $cb,
              close => sub { };
      }
  }
  
  sub daemon_fork {
      require POSIX;
      fork && exit;
  }
  
  sub daemon_detach {
      my $self = shift;
      print "FastCGI daemon started (pid $$)\n";
      open STDIN,  "+</dev/null" or die $!; ## no critic
      open STDOUT, ">&STDIN"     or die $!;
      open STDERR, ">&STDIN"     or die $!;
      POSIX::setsid();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::FCGI - FastCGI handler for Plack
  
  =head1 SYNOPSIS
  
    # Run as a standalone daemon
    plackup -s FCGI --listen /tmp/fcgi.sock --daemonize --nproc 10
  
    # Run from your web server like mod_fastcgi
    #!/usr/bin/env plackup -s FCGI
    my $app = sub { ... };
  
    # Roll your own
    my $server = Plack::Handler::FCGI->new(
        nproc  => $num_proc,
        listen => [ $port_or_socket ],
        detach => 1,
    );
    $server->run($app);
  
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a standalone
  FastCGI daemon or a .fcgi script.
  
  =head2 OPTIONS
  
  =over 4
  
  =item listen
  
      listen => [ '/path/to/socket' ]
      listen => [ ':8080' ]
  
  Listen on a socket path, hostname:port, or :port.
  
  =item port
  
  listen via TCP on port on all interfaces (Same as C<< listen => ":$port" >>)
  
  =item leave-umask
  
  Set to 1 to disable setting umask to 0 for socket open
  
  =item nointr
  
  Do not allow the listener to be interrupted by Ctrl+C
  
  =item nproc
  
  Specify a number of processes for FCGI::ProcManager
  
  =item pid
  
  Specify a filename for the pid file
  
  =item manager
  
  Specify a FCGI::ProcManager sub-class
  
  =item daemonize
  
  Daemonize the process.
  
  =item keep-stderr
  
  Send STDERR to STDOUT instead of the webserver
  
  =back
  
  =head2 WEB SERVER CONFIGURATIONS
  
  =head3 nginx
  
  This is an example nginx configuration to run your FCGI daemon on a
  Unix domain socket and run it at the server's root URL (/).
  
    http {
      server {
        listen 3001;
        location / {
          set $script "";
          set $path_info $uri;
          fastcgi_pass unix:/tmp/fastcgi.sock;
          fastcgi_param  SCRIPT_NAME      $script;
          fastcgi_param  PATH_INFO        $path_info;
          fastcgi_param  QUERY_STRING     $query_string;
          fastcgi_param  REQUEST_METHOD   $request_method;
          fastcgi_param  CONTENT_TYPE     $content_type;
          fastcgi_param  CONTENT_LENGTH   $content_length;
          fastcgi_param  REQUEST_URI      $request_uri;
          fastcgi_param  SERVER_PROTOCOL  $server_protocol;
          fastcgi_param  REMOTE_ADDR      $remote_addr;
          fastcgi_param  REMOTE_PORT      $remote_port;
          fastcgi_param  SERVER_ADDR      $server_addr;
          fastcgi_param  SERVER_PORT      $server_port;
          fastcgi_param  SERVER_NAME      $server_name;
        }
      }
    }
  
  If you want to host your application in a non-root path, then you
  should mangle this configuration to set the path to C<SCRIPT_NAME> and
  the rest of the path in C<PATH_INFO>.
  
  See L<http://wiki.nginx.org/NginxFcgiExample> for more details.
  
  =head3 Apache mod_fastcgi
  
  You can use C<FastCgiExternalServer> as normal.
  
    FastCgiExternalServer /tmp/myapp.fcgi -socket /tmp/fcgi.sock
  
  See L<http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html#FastCgiExternalServer> for more details.
  
  =head3 lighttpd
  
  To host the app in the root path, you're recommended to use lighttpd
  1.4.23 or newer with C<fix-root-scriptname> flag like below.
  
    fastcgi.server = ( "/" =>
       ((
         "socket" => "/tmp/fcgi.sock",
         "check-local" => "disable"
         "fix-root-scriptname" => "enable",
       ))
  
  If you use lighttpd older than 1.4.22 where you don't have
  C<fix-root-scriptname>, mouting apps under the root causes wrong
  C<SCRIPT_NAME> and C<PATH_INFO> set. Also, mouting under the empty
  root (C<"">) or a path that has a trailing slash would still cause
  weird values set even with C<fix-root-scriptname>. In such cases you
  can use L<Plack::Middleware::LighttpdScriptNameFix> to fix it.
  
  To mount in the non-root path over TCP:
  
    fastcgi.server = ( "/foo" =>
       ((
         "host" = "127.0.0.1"
         "port" = "5000"
         "check-local" => "disable"
       ))
  
  It's recommended that your mount path does B<NOT> have the trailing
  slash. If you I<really> need to have one, you should consider using
  L<Plack::Middleware::LighttpdScriptNameFix> to fix the wrong
  B<PATH_INFO> values set by lighttpd.
  
  =cut
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_FCGI

$fatpacked{"Plack/Handler/HTTP/Server/PSGI.pm"} = <<'PLACK_HANDLER_HTTP_SERVER_PSGI';
  package Plack::Handler::HTTP::Server::PSGI;
  use strict;
  
  # for temporary backward compat
  use parent qw( HTTP::Server::PSGI );
  
  sub new {
      my($class, %args) = @_;
      bless { %args }, $class;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->_server->run($app);
  }
  
  sub _server {
      my $self = shift;
      HTTP::Server::PSGI->new(%$self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::PSGI - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s HTTP::Server::PSGI \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 BACKWARD COMPATIBLITY
  
  Since Plack 0.99_22 this handler doesn't support preforking
  configuration i.e. C<--max-workers>. Use L<Starman> or L<Starlet> if
  you need preforking PSGI web server.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item host
  
  Host the server binds to. Defaults to all interfaces.
  
  =item port
  
  Port number the server listens on. Defaults to 8080.
  
  =item timeout
  
  Number of seconds a request times out. Defaults to 300.
  
  =item max-reqs-per-child
  
  Number of requests per worker to process. Defaults to 100.
  
  =back
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack> L<HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_HTTP_SERVER_PSGI

$fatpacked{"Plack/Handler/HTTP/Server/Simple.pm"} = <<'PLACK_HANDLER_HTTP_SERVER_SIMPLE';
  package Plack::Handler::HTTP::Server::Simple;
  use strict;
  
  sub new {
      my($class, %args) = @_;
      bless {%args}, $class;
  }
  
  sub run {
      my($self, $app) = @_;
  
      my $server = Plack::Handler::HTTP::Server::Simple::PSGIServer->new($self->{port});
      $server->host($self->{host}) if $self->{host};
      $server->app($app);
      $server->{_server_ready} = delete $self->{server_ready} || sub {};
  
      $server->run;
  }
  
  package Plack::Handler::HTTP::Server::Simple::PSGIServer;
  use parent qw(HTTP::Server::Simple::PSGI);
  
  sub print_banner {
      my $self = shift;
  
      $self->{_server_ready}->({
          host => $self->host,
          port => $self->port,
          server_software => 'HTTP::Server::Simple::PSGI',
      });
  }
  
  package Plack::Handler::HTTP::Server::Simple;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::Simple - Adapter for HTTP::Server::Simple
  
  =head1 SYNOPSIS
  
    plackup -s HTTP::Server::Simple --port 9090
  
  =head1 DESCRIPTION
  
  Plack::Handler::HTTP::Server::Simple is an adapter to run PSGI
  applications on L<HTTP::Server::Simple>.
  
  =head1 SEE ALSO
  
  L<Plack>, L<HTTP::Server::Simple::PSGI>
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  
  =cut
PLACK_HANDLER_HTTP_SERVER_SIMPLE

$fatpacked{"Plack/Handler/Standalone.pm"} = <<'PLACK_HANDLER_STANDALONE';
  package Plack::Handler::Standalone;
  use strict;
  use warnings;
  use parent qw( Plack::Handler::HTTP::Server::PSGI );
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Standalone - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s Standalone \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 DESCRIPTION
  
  Plack::Handler::Standalone is an adapter for default Plack server
  implementation L<HTTP::Server::PSGI>. This is just an alias for
  L<Plack::Handler::HTTP::Server::PSGI>.
  
  =head1 SEE ALSO
  
  L<Plack::Handler::HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_STANDALONE

$fatpacked{"Plack/Loader.pm"} = <<'PLACK_LOADER';
  package Plack::Loader;
  use strict;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {}, $class;
  }
  
  sub watch {
      # do nothing. Override in subclass
  }
  
  sub auto {
      my($class, @args) = @_;
  
      my $backend = $class->guess
          or Carp::croak("Couldn't auto-guess server server implementation. Set it with PLACK_SERVER");
  
      my $server = try {
          $class->load($backend, @args);
      } catch {
          if (($ENV{PLACK_ENV}||'') eq 'development' or !/^Can't locate /) {
              warn "Autoloading '$backend' backend failed. Falling back to the Standalone. ",
                  "(You might need to install Plack::Handler::$backend from CPAN.  Caught error was: $_)\n"
                      if $ENV{PLACK_ENV} && $ENV{PLACK_ENV} eq 'development';
          }
          $class->load('Standalone' => @args);
      };
  
      return $server;
  }
  
  sub load {
      my($class, $server, @args) = @_;
  
      my($server_class, $error);
      for my $prefix (qw( Plack::Handler Plack::Server )) {
          try {
              $server_class = Plack::Util::load_class($server, $prefix);
          } catch {
              $error ||= $_;
          };
          last if $server_class;
          last if $error && $error !~ /^Can't locate Plack\/Handler\//;
      }
  
      if ($server_class) {
          $server_class->new(@args);
      } else {
          die $error;
      }
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{app} = $builder->();
  }
  
  sub guess {
      my $class = shift;
  
      my $env = $class->env;
  
      return $env->{PLACK_SERVER} if $env->{PLACK_SERVER};
  
      if ($env->{PHP_FCGI_CHILDREN} || $env->{FCGI_ROLE} || $env->{FCGI_SOCKET_PATH}) {
          return "FCGI";
      } elsif ($env->{GATEWAY_INTERFACE}) {
          return "CGI";
      } elsif (exists $INC{"Coro.pm"}) {
          return "Corona";
      } elsif (exists $INC{"AnyEvent.pm"}) {
          return "Twiggy";
      } elsif (exists $INC{"POE.pm"}) {
          return "POE";
      } else {
          return "Standalone";
      }
  }
  
  sub env { \%ENV }
  
  sub run {
      my($self, $server, $builder) = @_;
      $server->run($self->{app});
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader - (auto)load Plack Servers
  
  =head1 SYNOPSIS
  
    # auto-select server backends based on env vars
    use Plack::Loader;
    Plack::Loader->auto(%args)->run($app);
  
    # specify the implementation with a name
    Plack::Loader->load('FCGI', %args)->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Loader is a factory class to load one of Plack::Handler subclasses based on the environment.
  
  =head1 AUTOLOADING
  
  C<< Plack::Loader->auto(%args) >> will autoload the most correct
  server implementation by guessing from environment variables and Perl INC
  hashes.
  
  =over 4
  
  =item PLACK_SERVER
  
    env PLACK_SERVER=AnyEvent ...
  
  Plack users can specify the specific implementation they want to load
  using the C<PLACK_SERVER> environment variable.
  
  =item PHP_FCGI_CHILDREN, GATEWAY_INTERFACE
  
  If there's one of FastCGI or CGI specific environment variables set,
  use the corresponding server implementation.
  
  =item %INC
  
  If one of L<AnyEvent>, L<Coro> or L<POE> is loaded, the relevant
  server implementation such as L<Twiggy>, L<Corona> or
  L<POE::Component::Server::PSGI> will be loaded, if they're available.
  
  =back
  
  =cut
  
  
PLACK_LOADER

$fatpacked{"Plack/Loader/Delayed.pm"} = <<'PLACK_LOADER_DELAYED';
  package Plack::Loader::Delayed;
  use strict;
  use parent qw(Plack::Loader);
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $compiled;
      my $app = sub {
          $compiled ||= $self->{builder}->();
          $compiled->(@_);
      };
  
      $server->{psgi_app_builder} = $self->{builder};
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Delayed - Delay the loading of .psgi until the first run
  
  =head1 SYNOPSIS
  
    plackup -s Starlet -L Delayed myapp.psgi
  
  =head1 DESCRIPTION
  
  This loader delays the compilation of specified PSGI application until
  the first request time. This prevents bad things from happening with
  preforking web servers like L<Starlet>, when your application
  manipulates resources such as sockets or database connections in the
  master startup process and then shared by children.
  
  You can combine this loader with C<-M> command line option, like:
  
    plackup -s Starlet -MCatalyst -L Delayed myapp.psgi
  
  loads the module Catalyst in the master process for the better process
  management with copy-on-write, however the application C<myapp.psgi>
  is loaded per children.
  
  L<Starman> since version 0.2000 loads this loader by default unless
  you specify the command line option C<--preload-app> for the
  L<starman> executable.
  
  =head1 DEVELOPERS
  
  Web server developers can make use of C<psgi_app_builder> attribute
  callback set in Plack::Handler, to load the application earlier than
  the first request time.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_LOADER_DELAYED

$fatpacked{"Plack/Loader/Restarter.pm"} = <<'PLACK_LOADER_RESTARTER';
  package Plack::Loader::Restarter;
  use strict;
  use warnings;
  use parent qw(Plack::Loader);
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my($class, $runner) = @_;
      bless { watch => [] }, $class;
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub watch {
      my($self, @dir) = @_;
      push @{$self->{watch}}, @dir;
  }
  
  sub _fork_and_start {
      my($self, $server) = @_;
  
      delete $self->{pid}; # re-init in case it's a restart
  
      my $pid = fork;
      die "Can't fork: $!" unless defined $pid;
  
      if ($pid == 0) { # child
          return $server->run($self->{builder}->());
      } else {
          $self->{pid} = $pid;
      }
  }
  
  sub _kill_child {
      my $self = shift;
  
      my $pid = $self->{pid} or return;
      warn "Killing the existing server (pid:$pid)\n";
      kill 'TERM' => $pid;
      waitpid($pid, 0);
  }
  
  sub valid_file {
      my($self, $file) = @_;
      $file->{path} !~ m![/\\][\._]|\.bak$|~$|_flymake\.p[lm]!;
  }
  
  sub run {
      my($self, $server, $builder) = @_;
  
      $self->_fork_and_start($server, $builder);
      return unless $self->{pid};
  
      require Filesys::Notify::Simple;
      my $watcher = Filesys::Notify::Simple->new($self->{watch});
      warn "Watching @{$self->{watch}} for file updates.\n";
      local $SIG{TERM} = sub { $self->_kill_child; exit(0); };
  
      while (1) {
          my @restart;
  
          # this is blocking
          $watcher->wait(sub {
              my @events = @_;
              @events = grep $self->valid_file($_), @events;
              return unless @events;
  
              @restart = @events;
          });
  
          next unless @restart;
  
          for my $ev (@restart) {
              warn "-- $ev->{path} updated.\n";
          }
  
          $self->_kill_child;
          warn "Successfully killed! Restarting the new server process.\n";
          $self->_fork_and_start($server, $builder);
          return unless $self->{pid};
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Restarter - Restarting loader
  
  =head1 SYNOPSIS
  
    plackup -r -R paths
  
  =head1 DESCRIPTION
  
  Plack::Loader::Restarter is a loader backend that implements C<-r> and
  C<-R> option for the L<plackup> script. It forks the server as a child
  process and the parent watches the directories for file updates, and
  whenever it receives the notification, kills the child server and
  restart.
  
  =head1 SEE ALSO
  
  L<Plack::Runner>, L<Catalyst::Restarter>
  
  =cut
PLACK_LOADER_RESTARTER

$fatpacked{"Plack/Loader/Shotgun.pm"} = <<'PLACK_LOADER_SHOTGUN';
  package Plack::Loader::Shotgun;
  use strict;
  use parent qw(Plack::Loader);
  use Storable;
  use Try::Tiny;
  use Plack::Middleware::BufferedStreaming;
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = sub { Plack::Middleware::BufferedStreaming->wrap($builder->()) };
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $app = sub {
          my $env = shift;
  
          pipe my $read, my $write;
  
          my $pid = fork;
          if ($pid) {
              # parent
              close $write;
              my $res = Storable::thaw(join '', <$read>);
              close $read;
              waitpid($pid, 0);
  
              return $res;
          } else {
              # child
              close $read;
  
              my $res;
              try {
                  $env->{'psgi.streaming'} = 0;
                  $res = $self->{builder}->()->($env);
                  my @body;
                  Plack::Util::foreach($res->[2], sub { push @body, $_[0] });
                  $res->[2] = \@body;
              } catch {
                  $env->{'psgi.errors'}->print($_);
                  $res = [ 500, [ "Content-Type", "text/plain" ], [ "Internal Server Error" ] ];
              };
  
              print {$write} Storable::freeze($res);
              close $write;
              exit;
          }
      };
  
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Shotgun - forking implementation of plackup
  
  =head1 SYNOPSIS
  
    plackup -L Shotgun
  
  =head1 DESCRIPTION
  
  Shotgun loader delays the compilation and execution of your
  application until the runtime. When a new request comes in, this forks
  a new child, compiles your code and runs the application.
  
  This should be an ultimate alternative solution when reloading with
  L<Plack::Middleware::Refresh> doesn't work, or plackup's default C<-r>
  filesystem watcher causes problems. I can imagine this is useful for
  applications which expects their application is only evaluated once
  (like in-file templates) or on operating systems with broken fork
  implementation, etc.
  
  This is much like good old CGI's fork and run but you don't need a web
  server, and there's a benefit of preloading modules that are not
  likely to change. For instance if you develop a web application using
  Moose and DBIx::Class,
  
    plackup -MMoose -MDBIx::Class -L Shotgun yourapp.psgi
  
  would preload those modules and only re-evaluates your code in every
  request.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa with an inspiration from L<http://github.com/rtomayko/shotgun>
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_LOADER_SHOTGUN

$fatpacked{"Plack/MIME.pm"} = <<'PLACK_MIME';
  package Plack::MIME;
  use strict;
  
  # stolen from rack.mime.rb
  our $MIME_TYPES = {
      ".3gp"     => "video/3gpp",
      ".a"       => "application/octet-stream",
      ".ai"      => "application/postscript",
      ".aif"     => "audio/x-aiff",
      ".aiff"    => "audio/x-aiff",
      ".asc"     => "application/pgp-signature",
      ".asf"     => "video/x-ms-asf",
      ".asm"     => "text/x-asm",
      ".asx"     => "video/x-ms-asf",
      ".atom"    => "application/atom+xml",
      ".au"      => "audio/basic",
      ".avi"     => "video/x-msvideo",
      ".bat"     => "application/x-msdownload",
      ".bin"     => "application/octet-stream",
      ".bmp"     => "image/bmp",
      ".bz2"     => "application/x-bzip2",
      ".c"       => "text/x-c",
      ".cab"     => "application/vnd.ms-cab-compressed",
      ".cc"      => "text/x-c",
      ".chm"     => "application/vnd.ms-htmlhelp",
      ".class"   => "application/octet-stream",
      ".com"     => "application/x-msdownload",
      ".conf"    => "text/plain",
      ".cpp"     => "text/x-c",
      ".crt"     => "application/x-x509-ca-cert",
      ".css"     => "text/css",
      ".csv"     => "text/csv",
      ".cxx"     => "text/x-c",
      ".deb"     => "application/x-debian-package",
      ".der"     => "application/x-x509-ca-cert",
      ".diff"    => "text/x-diff",
      ".djv"     => "image/vnd.djvu",
      ".djvu"    => "image/vnd.djvu",
      ".dll"     => "application/x-msdownload",
      ".dmg"     => "application/octet-stream",
      ".doc"     => "application/msword",
      ".dot"     => "application/msword",
      ".dtd"     => "application/xml-dtd",
      ".dvi"     => "application/x-dvi",
      ".ear"     => "application/java-archive",
      ".eml"     => "message/rfc822",
      ".eps"     => "application/postscript",
      ".exe"     => "application/x-msdownload",
      ".f"       => "text/x-fortran",
      ".f77"     => "text/x-fortran",
      ".f90"     => "text/x-fortran",
      ".flv"     => "video/x-flv",
      ".for"     => "text/x-fortran",
      ".gem"     => "application/octet-stream",
      ".gemspec" => "text/x-script.ruby",
      ".gif"     => "image/gif",
      ".gz"      => "application/x-gzip",
      ".h"       => "text/x-c",
      ".hh"      => "text/x-c",
      ".htm"     => "text/html",
      ".html"    => "text/html",
      ".ico"     => "image/vnd.microsoft.icon",
      ".ics"     => "text/calendar",
      ".ifb"     => "text/calendar",
      ".iso"     => "application/octet-stream",
      ".jar"     => "application/java-archive",
      ".java"    => "text/x-java-source",
      ".jnlp"    => "application/x-java-jnlp-file",
      ".jpeg"    => "image/jpeg",
      ".jpg"     => "image/jpeg",
      ".js"      => "application/javascript",
      ".json"    => "application/json",
      ".log"     => "text/plain",
      ".m3u"     => "audio/x-mpegurl",
      ".m4v"     => "video/mp4",
      ".man"     => "text/troff",
      ".manifest"=> "text/cache-manifest",
      ".mathml"  => "application/mathml+xml",
      ".mbox"    => "application/mbox",
      ".mdoc"    => "text/troff",
      ".me"      => "text/troff",
      ".mid"     => "audio/midi",
      ".midi"    => "audio/midi",
      ".mime"    => "message/rfc822",
      ".mml"     => "application/mathml+xml",
      ".mng"     => "video/x-mng",
      ".mov"     => "video/quicktime",
      ".mp3"     => "audio/mpeg",
      ".mp4"     => "video/mp4",
      ".mp4v"    => "video/mp4",
      ".mpeg"    => "video/mpeg",
      ".mpg"     => "video/mpeg",
      ".ms"      => "text/troff",
      ".msi"     => "application/x-msdownload",
      ".odp"     => "application/vnd.oasis.opendocument.presentation",
      ".ods"     => "application/vnd.oasis.opendocument.spreadsheet",
      ".odt"     => "application/vnd.oasis.opendocument.text",
      ".ogg"     => "application/ogg",
      ".ogv"     => "video/ogg",
      ".p"       => "text/x-pascal",
      ".pas"     => "text/x-pascal",
      ".pbm"     => "image/x-portable-bitmap",
      ".pdf"     => "application/pdf",
      ".pem"     => "application/x-x509-ca-cert",
      ".pgm"     => "image/x-portable-graymap",
      ".pgp"     => "application/pgp-encrypted",
      ".pkg"     => "application/octet-stream",
      ".pl"      => "text/x-script.perl",
      ".pm"      => "text/x-script.perl-module",
      ".png"     => "image/png",
      ".pnm"     => "image/x-portable-anymap",
      ".ppm"     => "image/x-portable-pixmap",
      ".pps"     => "application/vnd.ms-powerpoint",
      ".ppt"     => "application/vnd.ms-powerpoint",
      ".ps"      => "application/postscript",
      ".psd"     => "image/vnd.adobe.photoshop",
      ".py"      => "text/x-script.python",
      ".qt"      => "video/quicktime",
      ".ra"      => "audio/x-pn-realaudio",
      ".rake"    => "text/x-script.ruby",
      ".ram"     => "audio/x-pn-realaudio",
      ".rar"     => "application/x-rar-compressed",
      ".rb"      => "text/x-script.ruby",
      ".rdf"     => "application/rdf+xml",
      ".roff"    => "text/troff",
      ".rpm"     => "application/x-redhat-package-manager",
      ".rss"     => "application/rss+xml",
      ".rtf"     => "application/rtf",
      ".ru"      => "text/x-script.ruby",
      ".s"       => "text/x-asm",
      ".sgm"     => "text/sgml",
      ".sgml"    => "text/sgml",
      ".sh"      => "application/x-sh",
      ".sig"     => "application/pgp-signature",
      ".snd"     => "audio/basic",
      ".so"      => "application/octet-stream",
      ".svg"     => "image/svg+xml",
      ".svgz"    => "image/svg+xml",
      ".swf"     => "application/x-shockwave-flash",
      ".t"       => "text/troff",
      ".tar"     => "application/x-tar",
      ".tbz"     => "application/x-bzip-compressed-tar",
      ".tcl"     => "application/x-tcl",
      ".tex"     => "application/x-tex",
      ".texi"    => "application/x-texinfo",
      ".texinfo" => "application/x-texinfo",
      ".text"    => "text/plain",
      ".tif"     => "image/tiff",
      ".tiff"    => "image/tiff",
      ".torrent" => "application/x-bittorrent",
      ".tr"      => "text/troff",
      ".txt"     => "text/plain",
      ".vcf"     => "text/x-vcard",
      ".vcs"     => "text/x-vcalendar",
      ".vrml"    => "model/vrml",
      ".war"     => "application/java-archive",
      ".wav"     => "audio/x-wav",
      ".wma"     => "audio/x-ms-wma",
      ".wmv"     => "video/x-ms-wmv",
      ".wmx"     => "video/x-ms-wmx",
      ".wrl"     => "model/vrml",
      ".wsdl"    => "application/wsdl+xml",
      ".xbm"     => "image/x-xbitmap",
      ".xhtml"   => "application/xhtml+xml",
      ".xls"     => "application/vnd.ms-excel",
      ".xml"     => "application/xml",
      ".xpm"     => "image/x-xpixmap",
      ".xsl"     => "application/xml",
      ".xslt"    => "application/xslt+xml",
      ".yaml"    => "text/yaml",
      ".yml"     => "text/yaml",
      ".zip"     => "application/zip",
  };
  
  my $fallback = sub { };
  
  sub mime_type {
      my($class, $file) = @_;
      $file =~ /(\.[a-zA-Z0-9]+)$/ or return;
      $MIME_TYPES->{lc $1} || $fallback->(lc $1);
  }
  
  sub add_type {
      my $class = shift;
      while (my($ext, $type) = splice @_, 0, 2) {
          $MIME_TYPES->{lc $ext} = $type;
      }
  }
  
  sub set_fallback {
      my($class, $cb) = @_;
      $fallback = $cb;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::MIME - MIME type registry
  
  =head1 SYNOPSIS
  
    use Plack::MIME;
  
    my $mime = Plack::MIME->mime_type(".png"); # image/png
  
    # register new type(s)
    Plack::MIME->add_type(".foo" => "application/x-foo");
  
    # Use MIME::Types as a fallback
    use MIME::Types 'by_suffix';
    Plack::MIME->set_fallback(sub { (by_suffix $_[0])[0] });
  
  =head1 DESCRIPTION
  
  Plack::MIME is a simple MIME type registry for Plack applications. The
  selection of MIME types is based on Rack's Rack::Mime module.
  
  =head1 SEE ALSO
  
  Rack::Mime L<MIME::Types>
  
  =cut
  
  
PLACK_MIME

$fatpacked{"Plack/Middleware.pm"} = <<'PLACK_MIDDLEWARE';
  package Plack::Middleware;
  use strict;
  use warnings;
  use Carp ();
  use parent qw(Plack::Component);
  use Plack::Util;
  use Plack::Util::Accessor qw( app );
  
  sub import {
      my $class = shift;
      if (@_) {
          Carp::carp("use Plack::Middleware qw(Foo) is deprecated. See perldoc Plack::Builder");
      }
  }
  
  sub wrap {
      my($self, $app, @args) = @_;
      if (ref $self) {
          $self->{app} = $app;
      } else {
          $self = $self->new({ app => $app, @args });
      }
      return $self->to_app;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware - Base class for easy-to-use PSGI middleware
  
  =head1 SYNOPSIS
  
    package Plack::Middleware::Foo;
    use parent qw( Plack::Middleware );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        # $self->app is the original app
        my $res = $self->app->($env);
  
        # Do something with $res
        return $res;
    }
  
    # then in app.psgi
    use Plack::Builder;
  
    my $app = sub { ... } # as usual
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", %options;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware is a utility base class to write PSGI
  middleware. All you have to do is to inherit from Plack::Middleware
  and then implement the callback C<call> method (or C<to_app> method
  that would return the PSGI code reference) to do the actual work. You
  can use C<< $self->app >> to call the original (wrapped) application.
  
  Your middleware object is created at a PSGI application compile time
  and is persistent during the web server life cycle (unless it is a
  non-persistent environment such as CGI), so you should never set or
  cache per-request data like C<$env> in your middleware object. See
  also L<Plack::Component/"OBJECT LIFECYCLE">.
  
  See L<Plack::Builder> how to actually enable middleware in your
  I<.psgi> application file using the DSL. If you do not like our
  builder DSL, you can also use C<wrap> method to wrap your application
  with a middleware:
  
    use Plack::Middleware::Foo;
  
    my $app = sub { ... };
    $app = Plack::Middleware::Foo->wrap($app, %options);
    $app = Plack::Middleware::Bar->wrap($app, %options);
  
  =head1 RESPONSE CALLBACK
  
  The typical middleware is written like this:
  
    package Plack::Middleware::Something;
    use parent qw(Plack::Middleware);
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $self->app->($env);
        # post-processing $res
        return $res;
    }
  
  The tricky thing about post processing the response is that it could
  either be an immediate 3 element array ref, or a code reference that
  implements the delayed (streaming) interface.
  
  Dealing with these two types of response in each piece of middleware
  is pointless, so you're recommended to use the C<response_cb> wrapper
  function in L<Plack::Util> when implementing a post processing
  middleware.
  
    my $res = $app->($env);
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        # do something with $res;
    });
  
  The callback function gets a PSGI response as a 3 element array
  reference, and you can update the reference to implement the post
  processing.
  
    package Plack::Middleware::Always500;
    use parent qw(Plack::Middleware);
    use Plack::Util;
  
    sub call {
        my($self, $env) = @_;
        my $res  = $self->app->($env);
        Plack::Util::response_cb($res, sub {
            my $res = shift;
            $res->[0] = 500;
            return;
        });
    }
  
  In this example, the callback gets the C<$res> and updates its first
  element (status code) to 500. Using C<response_cb> makes sure that
  this works with the delayed response too.
  
  You're not required (and not recommended either) to return a new array
  reference - they will be simply ignored. You're suggested to
  explicitly return, unless you fiddle with the content filter callback
  (see below).
  
  Similarly, note that you have to keep the C<$res> reference when you
  swap the entire response.
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        $res = [ $new_status, $new_headers, $new_body ]; # THIS DOES NOT WORK
        return;
    });
  
  This does not work, since assigning a new anonymous array to C<$res>
  doesn't update the original PSGI response value. You should instead
  do:
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        @$res = ($new_status, $new_headers, $new_body); # THIS WORKS
        return;
    });
  
  The third element of PSGI response array ref is a body, and it could
  be either array ref or IO::Handle-ish object. The application could
  also make use of C<$writer> object if C<psgi.streaming> is in
  effect. Dealing with these variants is again really painful, and
  C<response_cb> can take care of that too, by allowing you to return a
  content filter as a code reference.
  
    # replace all "Foo" in content body with "Bar"
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        return sub {
            my $chunk = shift;
            return unless defined $chunk;
            $chunk =~ s/Foo/Bar/g;
            return $chunk;
        }
    });
  
  The callback takes one argument C<$chunk> and your callback is
  expected to return the updated chunk. If the given C<$chunk> is undef,
  it means the stream has reached the end, so your callback should also
  return undef, or return the final chunk and return undef when called
  next time.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Component>
  
  =cut
PLACK_MIDDLEWARE

$fatpacked{"Plack/Middleware/AccessLog.pm"} = <<'PLACK_MIDDLEWARE_ACCESSLOG';
  package Plack::Middleware::AccessLog;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  use Plack::Util::Accessor qw( logger format );
  
  use Carp ();
  use Plack::Util;
  
  my %formats = (
      common => "%h %l %u %t \"%r\" %>s %b",
      combined => "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"",
  );
  
  use POSIX ();
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
          my $content_length = Plack::Util::content_length($res->[2]);
          $logger->( $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length }) );
      });
  }
  
  sub log_line {
      my($self, $status, $headers, $env, $opts) = @_;
  
      my $h = Plack::Util::headers($headers);
  
      my $strftime = sub {
          my $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
          POSIX::setlocale(&POSIX::LC_ALL, 'en');
          my $out = POSIX::strftime(@_);
          POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
          return $out;
      };
  
      my $block_handler = sub {
          my($block, $type) = @_;
          if ($type eq 'i') {
              $block =~ s/-/_/g;
              my $val = _safe($env->{"HTTP_" . uc($block)});
              return defined $val ? $val : "-";
          } elsif ($type eq 'o') {
              return scalar $h->get($block) || "-";
          } elsif ($type eq 't') {
              return "[" . $strftime->($block, localtime) . "]";
          } else {
              Carp::carp("{$block}$type not supported");
              return "-";
          }
      };
  
  
      my %char_handler = (
          '%' => sub { '%' },
          h => sub { $env->{REMOTE_ADDR} || '-' },
          l => sub { '-' },
          u => sub { $env->{REMOTE_USER} || '-' },
          t => sub { "[" . $strftime->("%d/%b/%Y:%H:%M:%S %z", localtime) . "]" },
          r => sub { _safe($env->{REQUEST_METHOD}) . " " . _safe($env->{REQUEST_URI}) .
                     " " . $env->{SERVER_PROTOCOL} },
          s => sub { $status },
          b => sub { $opts->{content_length} || $h->get('Content-Length') || "-" },
          T => sub { $opts->{time} ? int($opts->{time}) : "-" },
          D => sub { $opts->{time} ? $opts->{time} * 1000000 : "-" },
          v => sub { $env->{SERVER_NAME} || '-' },
          V => sub { $env->{HTTP_HOST} || $env->{SERVER_NAME} || '-' },
      );
  
      my $char_handler = sub {
          my $char = shift;
  
          my $cb = $char_handler{$char};
          unless ($cb) {
              Carp::carp "\%$char not supported.";
              return "-";
          }
          $cb->($char);
      };
  
      my $fmt = $self->format || "combined";
      $fmt = $formats{$fmt} if exists $formats{$fmt};
  
      $fmt =~ s{
          (?:
           \%\{(.+?)\}([a-z]) |
           \%(?:[<>])?([a-zA-Z\%])
          )
      }{ $1 ? $block_handler->($1, $2) : $char_handler->($3) }egx;
  
      return $fmt . "\n";
  }
  
  sub _safe {
      my $string = shift;
      $string =~ s/([^[:print:]])/"\\x" . unpack("H*", $1)/eg
          if defined $string;
      $string;
  }
  
  
  __END__
  
  =for stopwords
  LogFormat
  
  =head1 NAME
  
  Plack::Middleware::AccessLog - Logs requests like Apache's log format
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog", format => "combined";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog forwards the request to the given app and
  logs request and response details to the logger callback. The format
  can be specified using Apache-like format strings (or C<combined> or
  C<common> for the default formats). If none is specified C<combined> is
  used.
  
  This middleware uses calculable content-length by checking body type,
  and can not log the time taken to serve requests. It also logs the
  request B<before> the response is actually sent to the client. Use
  L<Plack::Middleware::AccessLog::Timed> if you want to log details
  B<after> the response is transmitted (more like a real web server) to
  the client.
  
  This middleware is enabled by default when you run L<plackup> as a
  default C<development> environment.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item format
  
    enable "Plack::Middleware::AccessLog",
        format => "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"";
  
  Takes a format string (or a preset template C<combined> or C<custom>)
  to specify the log format. This middleware implements subset of
  Apache's LogFormat templates.
  
  =item logger
  
    my $logger = Log::Dispatch->new(...);
    enable "Plack::Middleware::AccessLog",
        logger => sub { $logger->log(debug => @_) };
  
  Sets a callback to print log message to. It prints to C<psgi.errors>
  output stream by default.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://httpd.apache.org/docs/2.2/mod/mod_log_config.html> Rack::CustomLogger
  
  =cut
  
PLACK_MIDDLEWARE_ACCESSLOG

$fatpacked{"Plack/Middleware/AccessLog/Timed.pm"} = <<'PLACK_MIDDLEWARE_ACCESSLOG_TIMED';
  package Plack::Middleware::AccessLog::Timed;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware::AccessLog );
  
  use Time::HiRes;
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $time = Time::HiRes::gettimeofday;
      my $length = 0;
      my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my($status, $header, $body) = @$res;
  
          if (!defined $body) {
              $logger->( $self->log_line($status, $header, $env) );
              return;
          }
  
          my $getline = ref $body eq 'ARRAY' ? sub { shift @$body } : sub { $body->getline };
  
          my $timer_body = Plack::Util::inline_object(
              getline => sub {
                  my $line = $getline->();
                  $length += length $line if defined $line;
                  return $line;
              },
              close => sub {
                  $body->close if ref $body ne 'ARRAY';
  
                  my $now = Time::HiRes::gettimeofday;
                  $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
              },
          );
  
          @$res = ($status, $header, $timer_body);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::AccessLog::Timed - Logs requests with time and accurate body size
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog::Timed",
            format => "%v %h %l %u %t \"%r\" %>s %b %D";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog::Timed is a subclass of
  Plack::Middleware::AccessLog but uses a wrapped body handle to get the
  actual response body size C<%b> (even if it's not a chunk of array or
  a real filehandle) and the time taken to serve the request: C<%T> or
  C<%D>.
  
  This wraps the response body output stream so some server
  optimizations like sendfile(2) will be disabled if you use this
  middleware.
  
  =head1 CONFIGURATION
  
  Same as L<Plack::Middleware::AccessLog>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::AccessLog>
  
  =cut
PLACK_MIDDLEWARE_ACCESSLOG_TIMED

$fatpacked{"Plack/Middleware/Auth/Basic.pm"} = <<'PLACK_MIDDLEWARE_AUTH_BASIC';
  package Plack::Middleware::Auth::Basic;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw( realm authenticator );
  use Scalar::Util;
  use MIME::Base64;
  
  sub prepare_app {
      my $self = shift;
  
      my $auth = $self->authenticator or die 'authenticator is not set';
      if (Scalar::Util::blessed($auth) && $auth->can('authenticate')) {
          $self->authenticator(sub { $auth->authenticate(@_[0,1]) }); # because Authen::Simple barfs on 3 params
      } elsif (ref $auth ne 'CODE') {
          die 'authenticator should be a code reference or an object that responds to authenticate()';
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $auth = $env->{HTTP_AUTHORIZATION}
          or return $self->unauthorized;
  
      if ($auth =~ /^Basic (.*)$/) {
          my($user, $pass) = split /:/, (MIME::Base64::decode($1) || ":");
          $pass = '' unless defined $pass;
          if ($self->authenticator->($user, $pass, $env)) {
              $env->{REMOTE_USER} = $user;
              return $self->app->($env);
          }
      }
  
      return $self->unauthorized;
  }
  
  sub unauthorized {
      my $self = shift;
      my $body = 'Authorization required';
      return [
          401,
          [ 'Content-Type' => 'text/plain',
            'Content-Length' => length $body,
            'WWW-Authenticate' => 'Basic realm="' . ($self->realm || "restricted area") . '"' ],
          [ $body ],
      ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Auth::Basic - Simple basic authentication middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    my $app = sub { ... };
  
    builder {
        enable "Auth::Basic", authenticator => \&authen_cb;
        $app;
    };
  
    sub authen_cb {
        my($username, $password) = @_;
        return $username eq 'admin' && $password eq 's3cr3t';
    }
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Auth::Basic is a basic authentication handler for Plack.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item authenticator
  
  A callback function that takes username and password supplied and
  returns whether the authentication succeeds. Required.
  
  Authenticator can also be an object that responds to C<authenticate>
  method that takes username and password and returns boolean, so
  backends for L<Authen::Simple> is perfect to use:
  
    use Authen::Simple::LDAP;
    enable "Auth::Basic", authenticator => Authen::Simple::LDAP->new(...);
  
  =item realm
  
  Realm name to display in the basic authentication dialog. Defaults to I<restricted area>.
  
  =back
  
  =head1 LIMITATIONS
  
  This middleware expects that the application has a full access to the
  headers sent by clients in PSGI environment. That is normally the case
  with standalone Perl PSGI web servers such as L<Starman> or
  L<HTTP::Server::Simple::PSGI>.
  
  However, in a web server configuration where you can't achieve this
  (i.e. using your application via Apache's mod_cgi), this middleware
  does not work since your application can't know the value of
  C<Authorization:> header.
  
  If you use Apache as a web server and CGI to run your PSGI
  application, you can either a) compile Apache with
  C<-DSECURITY_HOLE_PASS_AUTHORIZATION> option, or b) use mod_rewrite to
  pass the Authorization header to the application with the rewrite rule
  like following.
  
    RewriteEngine on
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_MIDDLEWARE_AUTH_BASIC

$fatpacked{"Plack/Middleware/BufferedStreaming.pm"} = <<'PLACK_MIDDLEWARE_BUFFEREDSTREAMING';
  package Plack::Middleware::BufferedStreaming;
  use strict;
  no warnings;
  use Carp;
  use Plack::Util;
  use Scalar::Util qw(weaken);
  use parent qw(Plack::Middleware);
  
  sub call {
      my ( $self, $env ) = @_;
  
      my $caller_supports_streaming = $env->{'psgi.streaming'};
      $env->{'psgi.streaming'} = Plack::Util::TRUE;
  
      my $res = $self->app->($env);
      return $res if $caller_supports_streaming;
  
      if ( ref($res) eq 'CODE' ) {
          my $ret;
  
          $res->(sub {
              my $write = shift;
  
              if ( @$write == 2 ) {
                  my @body;
  
                  $ret = [ @$write, \@body ];
  
                  return Plack::Util::inline_object(
                      write => sub { push @body, $_[0] },
                      close => sub { },
                  );
              } else {
                  $ret = $write;
                  return;
              }
          });
  
          return $ret;
      } else {
          return $res;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::BufferedStreaming - Enable buffering for non-streaming aware servers
  
  =head1 SYNOPSIS
  
    enable "BufferedStreaming";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::BufferedStreaming is a PSGI middleware component
  that wraps the application that uses C<psgi.streaming> interface to
  run on the servers that do not support the interface, by buffering the
  writer output to a temporary buffer.
  
  This middleware doesn't do anything and bypass the application if the
  server supports C<psgi.streaming> interface.
  
  =head1 AUTHOR
  
  Yuval Kogman
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_BUFFEREDSTREAMING

$fatpacked{"Plack/Middleware/Chunked.pm"} = <<'PLACK_MIDDLEWARE_CHUNKED';
  package Plack::Middleware::Chunked;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($env->{'SERVER_PROTOCOL'} ne 'HTTP/1.0' and
              ! Plack::Util::status_with_no_entity_body($res->[0]) and
              ! $h->exists('Content-Length') and
              ! $h->exists('Transfer-Encoding')
          ) {
              $h->set('Transfer-Encoding' => 'chunked');
              my $done;
              return sub {
                  my $chunk = shift;
                  return if $done;
                  unless (defined $chunk) {
                      $done = 1;
                      return "0\015\012\015\012";
                  }
                  return '' unless length $chunk;
                  return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Chunked - Applies chunked encoding to the response body
  
  =head1 SYNOPSIS
  
    # Mostly from server implemenations
    $app = Plack::Middeware::Chunked->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middeware::Chunked is a middleware, or rather a library for
  PSGI server to automatically add chunked encoding to the response body
  when Content-Length is not set in the response header.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Chunked
  
  =cut
PLACK_MIDDLEWARE_CHUNKED

$fatpacked{"Plack/Middleware/Conditional.pm"} = <<'PLACK_MIDDLEWARE_CONDITIONAL';
  package Plack::Middleware::Conditional;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util::Accessor qw( condition middleware builder );
  
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
  
      $self->middleware( $self->builder->($self->app) );
      $self;
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $app = $self->condition->($env) ? $self->middleware : $self->app;
      return $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Conditional - Conditional wrapper for Plack middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace';
        $app;
    };
  
    # Or more raw version of it
    $app = Plack::Middleware::Conditional->wrap(
        $app,
        condition  => sub { my $env = shift; $env->{HTTP_USER_AGENT} =~ /WebKit/ },
        builder => sub { Plack::Middleware::SuperAdminConsole->wrap($_[0], @args) },
    );
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Conditional is a piece of meta-middleware, to run a
  specific middleware component under the runtime condition. The goal of
  this middleware is to avoid baking runtime configuration options in
  individual middleware components, and rather share them as another
  middleware component.
  
  =head1 EXAMPLES
  
  Note that some of the middleware component names are just made up for
  the explanation and might not exist.
  
    # Minify JavaScript if the browser is Firefox
    enable_if { $_[0]->{HTTP_USER_AGENT} =~ /Firefox/ } 'JavaScriptMinifier';
  
    # Enable Stacktrace when being accessed from the local network
    enable_if { $_[0]->{REMOTE_ADDR} =~ /^10\.0\.1\.*/ } 'StackTrace';
  
    # Work with other conditional setter middleware:
    # Transcode Jpeg on the fly for mobile clients
    builder {
        enable 'MobileDetector';
        enable_if { $_[0]->{'plack.mobile_detected'} }
          'TranscodeJpeg', max_size => 30_000;
        $app;
    };
  
  Note that in the last example I<MobileDetector> should come first
  because the conditional check runs in I<pre-run> condition, which is
  from outer to inner and that is from the top to the bottom in the
  Builder DSL code.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Steve Cook
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_MIDDLEWARE_CONDITIONAL

$fatpacked{"Plack/Middleware/ConditionalGET.pm"} = <<'PLACK_MIDDLEWARE_CONDITIONALGET';
  package Plack::Middleware::ConditionalGET;
  use strict;
  use parent qw( Plack::Middleware );
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      return $res unless $env->{REQUEST_METHOD} =~ /^(GET|HEAD)$/;
  
      $self->response_cb($res, sub {
          my $res = shift;
          return unless $res->[2]; # do not support streaming interface
  
          my $h = Plack::Util::headers($res->[1]);
          if ( $self->etag_matches($h, $env) || $self->not_modified_since($h, $env) ) {
              $res->[0] = 304;
              $h->remove($_) for qw( Content-Type Content-Length Content-Disposition );
              $res->[2] = [];
          }
      });
  }
  
  no warnings 'uninitialized';
  
  # RFC 2616 14.25 says it's OK and expected to use 'eq' :)
  # > Note: When handling an If-Modified-Since header field, some
  # > servers will use an exact date comparison function, rather than a
  # > less-than function, for deciding whether to send a 304 ...
  
  sub etag_matches {
      my($self, $h, $env) = @_;
      $h->exists('ETag') && $h->get('ETag') eq _value($env->{HTTP_IF_NONE_MATCH});
  }
  
  sub not_modified_since {
      my($self, $h, $env) = @_;
      $h->exists('Last-Modified') && $h->get('Last-Modified') eq _value($env->{HTTP_IF_MODIFIED_SINCE});
  }
  
  sub _value {
      my $str = shift;
      # IE sends wrong formatted value(i.e. "Thu, 03 Dec 2009 01:46:32 GMT; length=17936")
      $str =~ s/;.*$//;
      return $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ConditionalGET - Middleware to enable conditional GET
  
  =head1 SYNOPSIS
  
    builder {
        enable "ConditionalGET";
        ....
    };
  
  =head1 DESCRIPTION
  
  This middleware enables conditional GET and HEAD using
  C<If-None-Match> and C<If-Modified-Since> header. The application
  should set either or both of C<Last-Modified> or C<ETag> response
  headers per RFC 2616. When either of the conditions is met, the
  response body is set to be zero length and the status is set to 304
  Not Modified.
  
  =head1 SEE ALSO
  
  Rack::ConditionalGet
  
  =cut
PLACK_MIDDLEWARE_CONDITIONALGET

$fatpacked{"Plack/Middleware/ContentLength.pm"} = <<'PLACK_MIDDLEWARE_CONTENTLENGTH';
  package Plack::Middleware::ContentLength;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if (!Plack::Util::status_with_no_entity_body($res->[0]) &&
              !$h->exists('Content-Length') &&
              !$h->exists('Transfer-Encoding') &&
              defined(my $content_length = Plack::Util::content_length($res->[2]))) {
              $h->push('Content-Length' => $content_length);
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentLength - Adds Content-Length header automatically
  
  =head1 SYNOPSIS
  
    # in app.psgi
  
    builder {
        enable "Plack::Middleware::ContentLength";
        $app;
    }
  
    # Or in Plack::Handler::*
    $app = Plack::Middleware::ContentLength->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ContentLength is a middleware that automatically
  adds C<Content-Length> header when it's appropriate i.e. the response
  has a content body with calculable size (array of chunks or a real
  filehandle).
  
  This middleware can also be used as a library from PSGI server
  implementations to automatically set C<Content-Length> rather than in
  the end user level.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::ContentLength
  
  =cut
  
PLACK_MIDDLEWARE_CONTENTLENGTH

$fatpacked{"Plack/Middleware/ContentMD5.pm"} = <<'PLACK_MIDDLEWARE_CONTENTMD5';
  package Plack::Middleware::ContentMD5;
  
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Digest::MD5 qw/md5_hex/;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
      
      $self->response_cb($res, sub {
          my $res = shift;
  
          return unless defined $res->[2];
          return if (Plack::Util::status_with_no_entity_body($res->[0]));
          
          my $h = Plack::Util::headers($res->[1]);
          return if ( $h->exists('Content-MD5') );
          
          my $body = $res->[2];
          if (ref $body eq 'ARRAY') {
              $h->set('Content-MD5', md5_hex(@$body));
          }
          # Do we need support $fh?
  
          return;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentMD5 - Automatically sets the Content-MD5 header on all String bodies
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::ContentMD5";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Automatically sets the Content-MD5 header on all String bodies
  
  =head1 AUTHOR
  
  Fayland Lam
  
  =cut
PLACK_MIDDLEWARE_CONTENTMD5

$fatpacked{"Plack/Middleware/ErrorDocument.pm"} = <<'PLACK_MIDDLEWARE_ERRORDOCUMENT';
  package Plack::Middleware::ErrorDocument;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  use Plack::MIME;
  use Plack::Util;
  use Plack::Util::Accessor qw( subrequest );
  
  use HTTP::Status qw(is_error);
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $r = $self->app->($env);
  
      $self->response_cb($r, sub {
          my $r = shift;
          unless (is_error($r->[0]) && exists $self->{$r->[0]}) {
              return;
          }
  
          my $path = $self->{$r->[0]};
          if ($self->subrequest) {
              for my $key (keys %$env) {
                  unless ($key =~ /^psgi/) {
                      $env->{'psgix.errordocument.' . $key} = $env->{$key};
                  }
              }
  
              # TODO: What if SCRIPT_NAME is not empty?
              $env->{REQUEST_METHOD} = 'GET';
              $env->{REQUEST_URI}    = $path;
              $env->{PATH_INFO}      = $path;
              $env->{QUERY_STRING}   = '';
              delete $env->{CONTENT_LENGTH};
  
              my $sub_r = $self->app->($env);
              if ($sub_r->[0] == 200) {
                  $r->[1] = $sub_r->[1];
                  $r->[2] = $sub_r->[2];
              }
              # TODO: allow 302 here?
          } else {
              open my $fh, "<", $path or die "$path: $!";
              $r->[2] = $fh;
              my $h = Plack::Util::headers($r->[1]);
              $h->remove('Content-Length');
              $h->set('Content-Type', Plack::MIME->mime_type($path));
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ErrorDocument - Set Error Document based on HTTP status code
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            500 => '/uri/errors/500.html', 404 => '/uri/errors/404.html',
            subrequest => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ErrorDocument allows you to customize error screen
  by setting paths (file system path or URI path) of error pages per
  status code.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item subrequest
  
  A boolean flag to serve error pages using a new GET sub request.
  Defaults to false, which means it serves error pages using file
  system path.
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            502 => '/home/www/htdocs/errors/maint.html';
        enable "Plack::Middleware::ErrorDocument",
            404 => '/static/404.html', 403 => '/static/403.html', subrequest => 1;
        $app;
    };
  
  This configuration serves 502 error pages from file system directly
  assuming that's when you probably maintain database etc. but serves
  404 and 403 pages using a sub request so your application can do some
  logic there like logging or doing suggestions.
  
  When using a subrequest, the subrequest should return a regular '200' response.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  =cut
PLACK_MIDDLEWARE_ERRORDOCUMENT

$fatpacked{"Plack/Middleware/HTTPExceptions.pm"} = <<'PLACK_MIDDLEWARE_HTTPEXCEPTIONS';
  package Plack::Middleware::HTTPExceptions;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(rethrow);
  
  use Carp ();
  use Try::Tiny;
  use Scalar::Util 'blessed';
  use HTTP::Status ();
  
  sub prepare_app {
      my $self = shift;
      $self->rethrow(1) if ($ENV{PLACK_ENV} || '') eq 'development';
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $res = try {
          $self->app->($env);
      } catch {
          $self->transform_error($_, $env);
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if ($writer) {
                  Carp::cluck $_;
                  $writer->close;
              } else {
                  my $res = $self->transform_error($_, $env);
                  $respond->($res);
              }
          };
      };
  }
  
  sub transform_error {
      my($self, $e, $env) = @_;
  
      my($code, $message);
      if (blessed $e && $e->can('as_psgi')) {
          return $e->as_psgi;
      }
      if (blessed $e && $e->can('code')) {
          $code = $e->code;
          $message =
              $e->can('as_string')       ? $e->as_string :
              overload::Method($e, '""') ? "$e"          : undef;
      } else {
          if ($self->rethrow) {
              die $e;
          }
          else {
              $code = 500;
              $env->{'psgi.errors'}->print($e);
          }
      }
  
      if ($code !~ /^[3-5]\d\d$/) {
          die $e; # rethrow
      }
  
      $message ||= HTTP::Status::status_message($code);
  
      my @headers = (
           'Content-Type'   => 'text/plain',
           'Content-Length' => length($message),
      );
  
      if ($code =~ /^3/ && (my $loc = eval { $e->location })) {
          push(@headers, Location => $loc);
      }
  
      return [ $code, \@headers, [ $message ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::HTTPExceptions - Catch HTTP exceptions
  
  =head1 SYNOPSIS
  
    use HTTP::Exception;
  
    my $app = sub {
        # ...
        HTTP::Exception::500->throw;
    };
  
    builder {
        enable "HTTPExceptions", rethrow => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::HTTPExceptions is a PSGI middleware component to
  catch exceptions from applications that can be translated into HTTP
  status codes.
  
  Your application is supposed to throw an object that implements a
  C<code> method which returns the HTTP status code, such as 501 or
  404. This middleware catches them and creates a valid response out of
  the code. If the C<code> method returns a code that is not an HTTP
  redirect or error code (3xx, 4xx, or 5xx), the exception will be
  rethrown.
  
  The exception object may also implement C<as_string> or overload
  stringification to represent the text of the error. The text defaults to
  the status message of the error code, such as I<Service Unavailable> for
  C<503>.
  
  Finally, the exception object may implement C<as_psgi>, and the result
  of this will be returned directly as the PSGI response.
  
  If the code is in the 3xx range and the exception implements the 'location'
  method (HTTP::Exception::3xx does), the Location header will be set in the
  response, so you can do redirects this way.
  
  There are CPAN modules L<HTTP::Exception> and L<HTTP::Throwable>, and
  they are perfect to throw from your application to let this middleware
  catch and display, but you can also implement your own exception class
  to throw.
  
  If the thrown exception is not an object that implements either a
  C<code> or an C<as_psgi> method, a 500 error will be returned.
  Alternatively, you can pass a true value for the C<rethrow> parameter
  for this middleware, and the exception will instead be rethrown. This is
  enabled by default when C<PLACK_ENV> is set to C<development>, so that
  the L<StackTrace|Plack::Middleware::StackTrace> middleware can catch it
  instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  paste.httpexceptions L<HTTP::Exception> L<HTTP::Throwable>
  
  =cut
PLACK_MIDDLEWARE_HTTPEXCEPTIONS

$fatpacked{"Plack/Middleware/Head.pm"} = <<'PLACK_MIDDLEWARE_HEAD';
  package Plack::Middleware::Head;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  sub call {
      my($self, $env) = @_;
  
      return $self->app->($env)
          unless $env->{REQUEST_METHOD} eq 'HEAD';
  
      $self->response_cb($self->app->($env), sub {
          my $res = shift;
          $res->[2] = [];
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Head - auto delete response body in HEAD requests
  
  =head1 SYNOPSIS
  
    enable "Head";
  
  =head1 DESCRIPTION
  
  This middleware deletes response body in HEAD requests.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Head
  
  =cut
  
PLACK_MIDDLEWARE_HEAD

$fatpacked{"Plack/Middleware/IIS6ScriptNameFix.pm"} = <<'PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX';
  package Plack::Middleware::IIS6ScriptNameFix;
  
  use strict;
  use parent 'Plack::Middleware';
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /IIS\/[6-9]\.[0-9]/) {
          my @script_name = split(m!/!, $env->{PATH_INFO});
          my @path_translated = split(m!/|\\\\?!, $env->{PATH_TRANSLATED});
          my @path_info;
  
          while ($script_name[$#script_name] eq $path_translated[$#path_translated]) {
              pop(@path_translated);
              unshift(@path_info, pop(@script_name));
          }
  
          unshift(@path_info, '', '');
  
          $env->{PATH_INFO} = join('/', @path_info);
          $env->{SCRIPT_NAME} = join('/', @script_name);
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS6ScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that IIS6 sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS6ScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS6ScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by IIS6.
  
  =head1 AUTHORS
  
  Florian Ragwitz
  
  =cut
PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/JSONP.pm"} = <<'PLACK_MIDDLEWARE_JSONP';
  package Plack::Middleware::JSONP;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use URI::Escape ();
  
  use Plack::Util::Accessor qw/callback_key/;
  
  sub prepare_app {
      my $self = shift;
      unless (defined $self->callback_key) {
          $self->callback_key('callback');
      }
  }
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          if (defined $res->[2]) {
              my $h = Plack::Util::headers($res->[1]);
              my $callback_key = $self->callback_key;
              if ($h->get('Content-Type') =~ m!/(?:json|javascript)! &&
                  $env->{QUERY_STRING} =~ /(?:^|&)$callback_key=([^&]+)/) {
                  my $cb = URI::Escape::uri_unescape($1);
                  if ($cb =~ /^[\w\.\[\]]+$/) {
                      my $body;
                      Plack::Util::foreach($res->[2], sub { $body .= $_[0] });
                      my $jsonp = "$cb($body)";
                      $res->[2] = [ $jsonp ];
                      $h->set('Content-Length', length $jsonp);
                      $h->set('Content-Type', 'text/javascript');
                  }
              }
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::JSONP - Wraps JSON response in JSONP if callback parameter is specified
  
  =head1 SYNOPSIS
  
      enable "JSONP", callback_key => 'jsonp';
  
  =head1 DESCRIPTION
  
  Plack::Middleware::JSONP wraps JSON response, which has Content-Type
  value either C<text/javascript> or C<application/json> as a JSONP
  response which is specified with the C<callback> query parameter. The
  name of the parameter can be set while enabling the middleware.
  
  This middleware only works with a non-streaming response, and doesn't
  touch the response otherwise.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_JSONP

$fatpacked{"Plack/Middleware/LighttpdScriptNameFix.pm"} = <<'PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX';
  package Plack::Middleware::LighttpdScriptNameFix;
  use strict;
  use parent qw/Plack::Middleware/;
  use Plack::Util::Accessor qw(script_name);
  
  sub prepare_app {
      my $self = shift;
  
      my $script_name = $self->script_name;
      $script_name = '' unless defined($script_name);
      $script_name =~ s!/$!!;
      $self->script_name($script_name);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /lighttpd/) {
          $env->{PATH_INFO}   = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{SCRIPT_NAME} = $self->script_name;
          $env->{PATH_INFO}  =~ s/^\Q$env->{SCRIPT_NAME}\E//;
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LighttpdScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that lighttpd sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "LighttpdScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "LighttpdScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by
  lighttpd when you mount your app under the root path ("/"). If you use
  lighttpd 1.4.23 or later you can instead enable C<fix-root-scriptname>
  flag inside C<fastcgi.server> instead of using this middleware.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item script_name
  
  Even with C<fix-root-scriptname>, lighttpd I<still> sets weird
  C<SCRIPT_NAME> and C<PATH_INFO> if you mount your application at C<"">
  or something that ends with C</>. Setting C<script_name> option tells
  the middleware how to reconstruct the new correct C<SCRIPT_NAME> and
  C<PATH_INFO>.
  
  If you mount the app under C</something/>, you should set:
  
    enable "LighttpdScriptNameFix", script_name => "/something";
  
  and when a request for C</something/a/b?param=1> comes, C<SCRIPT_NAME>
  becomes C</something> and C<PATH_INFO> becomes C</a/b>.
  
  C<script_name> option is set to empty by default, which means all the
  request path is set to C<PATH_INFO> and it behaves like your fastcgi
  application is mounted in the root path.
  
  =back
  
  =head1 AUTHORS
  
  Yury Zavarin
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::FCGI>
  L<http://github.com/miyagawa/Plack/issues#issue/68>
  L<https://redmine.lighttpd.net/issues/729>
  
  =cut
  
PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/Lint.pm"} = <<'PLACK_MIDDLEWARE_LINT';
  package Plack::Middleware::Lint;
  use strict;
  no warnings;
  use Carp ();
  use parent qw(Plack::Middleware);
  use Scalar::Util qw(blessed);
  use Plack::Util;
  
  sub wrap {
      my($self, $app) = @_;
  
      unless (ref $app eq 'CODE' or overload::Method($app, '&{}')) {
          die("PSGI app should be a code reference: ", (defined $app ? $app : "undef"));
      }
  
      $self->SUPER::wrap($app);
  }
  
  sub call {
      my $self = shift;
      my $env = shift;
  
      $self->validate_env($env);
      my $res = $self->app->($env);
      return $self->validate_res($res);
  }
  
  sub validate_env {
      my ($self, $env) = @_;
      unless ($env->{REQUEST_METHOD}) {
          die('Missing env param: REQUEST_METHOD');
      }
      unless ($env->{REQUEST_METHOD} =~ /^[A-Z]+$/) {
          die("Invalid env param: REQUEST_METHOD($env->{REQUEST_METHOD})");
      }
      unless (defined($env->{SCRIPT_NAME})) { # allows empty string
          die('Missing mandatory env param: SCRIPT_NAME');
      }
      if ($env->{SCRIPT_NAME} eq '/') {
          die('SCRIPT_NAME must not be /');
      }
      unless (defined($env->{PATH_INFO})) { # allows empty string
          die('Missing mandatory env param: PATH_INFO');
      }
      unless (defined($env->{SERVER_NAME})) {
          die('Missing mandatory env param: SERVER_NAME');
      }
      if ($env->{SERVER_NAME} eq '') {
          die('SERVER_NAME must not be empty string');
      }
      unless (defined($env->{SERVER_PORT})) {
          die('Missing mandatory env param: SERVER_PORT');
      }
      if ($env->{SERVER_PORT} eq '') {
          die('SERVER_PORT must not be empty string');
      }
      if (defined($env->{SERVER_PROTOCOL}) and $env->{SERVER_PROTOCOL} !~ m{^HTTP/1.\d$}) {
          die("Invalid SERVER_PROTOCOL: $env->{SEREVR_PROTOCOL}");
      }
      for my $param (qw/version url_scheme input errors multithread multiprocess/) {
          unless (exists $env->{"psgi.$param"}) {
              die("Missing psgi.$param");
          }
      }
      unless (ref($env->{'psgi.version'}) eq 'ARRAY') {
          die("psgi.version should be ArrayRef: $env->{'psgi.version'}");
      }
      unless (scalar(@{$env->{'psgi.version'}}) == 2) {
          die('psgi.version should contain 2 elements, not ', scalar(@{$env->{'psgi.version'}}));
      }
      unless ($env->{'psgi.url_scheme'} =~ /^https?$/) {
          die("psgi.url_scheme should be 'http' or 'https': ", $env->{'psgi.url_scheme'});
      }
      if ($env->{"psgi.version"}->[1] == 1) { # 1.1
          for my $param (qw(streaming nonblocking run_once)) {
              unless (exists $env->{"psgi.$param"}) {
                  die("Missing psgi.$param");
              }
          }
      }
      if ($env->{HTTP_CONTENT_TYPE}) {
          die('HTTP_CONTENT_TYPE should not exist');
      }
      if ($env->{HTTP_CONTENT_LENGTH}) {
          die('HTTP_CONTENT_LENGTH should not exist');
      }
  }
  
  sub is_possibly_fh {
      my $fh = shift;
  
      ref $fh eq 'GLOB' &&
      *{$fh}{IO} &&
      *{$fh}{IO}->can('getline');
  }
  
  sub validate_res {
      my ($self, $res, $streaming) = @_;
  
      unless (ref($res) eq 'ARRAY' or ref($res) eq 'CODE') {
          die("Response should be array ref or code ref: $res");
      }
  
      if (ref $res eq 'CODE') {
          return $self->response_cb($res, sub { $self->validate_res(@_, 1) });
      }
  
      unless (@$res == 3 || ($streaming && @$res == 2)) {
          die('Response needs to be 3 element array, or 2 element in streaming');
      }
  
      unless ($res->[0] =~ /^\d+$/ && $res->[0] >= 100) {
          die("Status code needs to be an integer greater than or equal to 100: $res->[0]");
      }
  
      unless (ref $res->[1] eq 'ARRAY') {
          die("Headers needs to be an array ref: $res->[1]");
      }
  
      my @copy = @{$res->[1]};
      unless (@copy % 2 == 0) {
          die('The number of response headers needs to be even, not odd(', scalar(@copy), ')');
      }
  
      while(my($key, $val) = splice(@copy, 0, 2)) {
          if (lc $key eq 'status') {
              die('Response headers MUST NOT contain a key named Status');
          }
          if ($key =~ /[:\r\n]|[-_]$/) {
              die("Response headers MUST NOT contain a key with : or newlines, or that end in - or _: $key");
          }
          unless ($key =~ /^[a-zA-Z][0-9a-zA-Z\-_]*$/) {
              die("Response headers MUST consist only of letters, digits, _ or - and MUST start with a letter: $key");
          }
          if ($val =~ /[\000-\037]/) {
              die("Response headers MUST NOT contain characters below octal \037: $val");
          }
          if (!defined $val) {
              die("Response headers MUST be a defined string");
          }
      }
  
      # @$res == 2 is only right in psgi.streaming, and it's already checked.
      unless (@$res == 2 ||
              ref $res->[2] eq 'ARRAY' ||
              Plack::Util::is_real_fh($res->[2]) ||
              is_possibly_fh($res->[2]) ||
              (blessed($res->[2]) && $res->[2]->can('getline'))) {
          die("Body should be an array ref or filehandle: $res->[2]");
      }
  
      if (ref $res->[2] eq 'ARRAY' && grep _is_really_utf8($_), @{$res->[2]}) {
          die("Body must be bytes and should not contain wide characters (UTF-8 strings)");
      }
  
      return $res;
  }
  
  # NOTE: Some modules like HTML:: or XML:: could possibly generate
  # ASCII only strings with utf8 flags on. They're actually safe to
  # print, so there's no need to give warnings about it.
  sub _is_really_utf8 {
      my $str = shift;
      utf8::is_utf8($str) && $str =~ /[^\x00-\x7f]/;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Lint - Validate request and response
  
  =head1 SYNOPSIS
  
    use Plack::Middleware::Lint;
  
    my $app = sub { ... }; # your app or middleware
    $app = Plack::Middleware::Lint->wrap($app);
  
    # Or from plackup
    plackup -e 'enable "Lint"' myapp.psgi
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Lint is a middleware component to validate request
  and response environment formats. You are strongly suggested to use
  this middleware when you develop a new framework adapter or a new PSGI
  web server that implements the PSGI interface.
  
  This middleware is enabled by default when you run plackup or other
  launcher tools with the default environment I<development> value.
  
  =head1 DEBUGGING
  
  Because of how this middleware works, it may not be easy to debug Lint
  errors when you encounter one, unless you're writing a PSGI web server
  or a framework.
  
  For example, when you're an application developer (user of some
  framework) and see errors like:
  
    Body should be an array ref or filehandle at lib/Plack/Middleware/Lint.pm line XXXX
  
  there's no clue about which line of I<your application> produces that
  error.
  
  We're aware of the issue, and have a plan to spit out more helpful
  errors to diagnose the issue. But until then, currently there are some
  workarounds to make this easier. For now, the easiest one would be to
  enable L<Plack::Middleware::REPL> outside of the Lint middleware,
  like:
  
    plackup -e 'enable "REPL"; enable "Lint"' app.psgi
  
  so that the Lint errors are caught by the REPL shell, where you can
  inspect all the variables in the response.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_LINT

$fatpacked{"Plack/Middleware/Log4perl.pm"} = <<'PLACK_MIDDLEWARE_LOG4PERL';
  package Plack::Middleware::Log4perl;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(category logger conf);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
  
      if ($self->conf) {
          require Log::Log4perl;
          Log::Log4perl::init($self->conf);
      }
  
      $self->logger( Log::Log4perl->get_logger($self->category || '') );
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          my $level = $args->{level};
          local $Log::Log4perl::caller_depth
              = $Log::Log4perl::caller_depth + 1;
          $self->logger->$level($args->{message});
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Log4perl - Uses Log::Log4perl to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
    Log::Log4perl::init('/path/to/log4perl.conf');
  
    builder {
        enable "Log4perl", category => "plack";
        $app;
    }
  
    # in log4perl.conf
    log4perl.logger.plack = INFO, Logfile
    log4perl.appender.Logfile = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = /path/to/logfile.log
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::SimpleLayout
  
    # Or let middleware to configure log4perl
    enable "Log4perl", category => "plack", conf => '/path/to/log.conf';
  
  =head1 DESCRIPTION
  
  Log4perl is a Plack::Middleware component that allows you to use
  L<Log::Log4perl> to configure logging object.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item category
  
  The log4perl category to send logs to. Defaults to C<''> which means
  it send to the root logger.
  
  =item conf
  
  The configuration file path (or a scalar ref containing the config
  string) for Log::Log4perl to automatically configure.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOG4PERL

$fatpacked{"Plack/Middleware/LogDispatch.pm"} = <<'PLACK_MIDDLEWARE_LOGDISPATCH';
  package Plack::Middleware::LogDispatch;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(logger);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
      unless ($self->logger) {
          Carp::croak "logger is not defined";
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          $args->{level} = 'critical' if $args->{level} eq 'fatal';
          $self->logger->log(%$args);
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LogDispatch - Uses Log::Dispatch to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Dispatch;
  
    my $logger = Log::Dispatch->new;
    $logger->add( Log::Dispatch::File->new(...) );
    $logger->add( Log::Dispatch::DesktopNotification->new(...) );
  
    builder {
        enable "LogDispatch", logger => $logger;
        $app;
    }
  
    # use with Log::Dispatch::Config
    use Log::Dispatch::Config;
    Log::Dispatch::Config->configure('/path/to/log.conf');
  
    builder {
        enable "LogDispatch", logger => Log::Dispatch::Config->instance;
        ...
    }
  
  =head1 DESCRIPTION
  
  LogDispatch is a Plack::Middleware component that allows you to use
  L<Log::Dispatch> to configure logging object.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item logger
  
  Log::Dispatch object to send logs to. Required.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOGDISPATCH

$fatpacked{"Plack/Middleware/NullLogger.pm"} = <<'PLACK_MIDDLEWARE_NULLLOGGER';
  package Plack::Middleware::NullLogger;
  use strict;
  use parent qw/Plack::Middleware/;
  
  sub call {
      my($self, $env) = @_;
      $env->{'psgix.logger'} = sub { };
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::NullLogger - Send logs to /dev/null
  
  =head1 SYNOPSIS
  
    enable "NullLogger";
  
  =head1 DESCRIPTION
  
  NullLogger is a middleware component that receives logs and does
  nothing but discarding them. Might be useful to shut up all the logs
  from frameworks in one shot.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_NULLLOGGER

$fatpacked{"Plack/Middleware/RearrangeHeaders.pm"} = <<'PLACK_MIDDLEWARE_REARRANGEHEADERS';
  package Plack::Middleware::RearrangeHeaders;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use HTTP::Headers;
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = HTTP::Headers->new(@{$res->[1]});
          my @new_headers;
          $h->scan(sub { push @new_headers, @_ });
  
          $res->[1] = \@new_headers;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::RearrangeHeaders - Reorder HTTP headers for buggy clients
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [
            'Last-Modified' => 'Wed, 23 Sep 2009 13:36:33 GMT',
            'Content-Type' => 'text/plain',
            'ETag' => 'foo bar',
        ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::RearrangeHeaders";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::RearrangeHeaders sorts HTTP headers based on "Good Practice" i.e.:
  
    # "Good Practice" order of HTTP message headers:
    #    - Response-Headers
    #    - Entity-Headers
  
  to work around buggy clients like very old MSIE or broken HTTP proxy
  servers. Most clients today don't (and shouldn't) care about HTTP
  header order but if you're too pedantic or have some environments
  where you need to deal with buggy clients like above, this might be
  useful.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =cut
PLACK_MIDDLEWARE_REARRANGEHEADERS

$fatpacked{"Plack/Middleware/Recursive.pm"} = <<'PLACK_MIDDLEWARE_RECURSIVE';
  package Plack::Middleware::Recursive;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Try::Tiny;
  use Scalar::Util qw(blessed);
  
  open my $null_io, "<", \"";
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'plack.recursive.include'} = $self->recurse_callback($env, 1);
  
      my $res = try {
          $self->app->($env);
      } catch {
          if (blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
              return $self->recurse_callback($env)->($_->path);
          } else {
              die $_; # rethrow
          }
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if (!$writer && blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
                  $res = $self->recurse_callback($env)->($_->path);
                  return ref $res eq 'CODE' ? $res->($respond) : $respond->($res);
              } else {
                  die $_;
              }
          };
      };
  }
  
  sub recurse_callback {
      my($self, $env, $include) = @_;
  
      my $old_path_info = $env->{PATH_INFO};
  
      return sub {
          my $new_path_info = shift;
          my($path, $query) = split /\?/, $new_path_info, 2;
  
          Scalar::Util::weaken($env);
  
          $env->{PATH_INFO}      = $path;
          $env->{QUERY_STRING}   = $query;
          $env->{REQUEST_METHOD} = 'GET';
          $env->{CONTENT_LENGTH} = 0;
          $env->{CONTENT_TYPE}   = '';
          $env->{'psgi.input'}   = $null_io;
          push @{$env->{'plack.recursive.old_path_info'}}, $old_path_info;
  
          $include ? $self->app->($env) : $self->call($env);
      };
  }
  
  package Plack::Recursive::ForwardRequest;
  use overload q("") => \&as_string, fallback => 1;
  
  sub new {
      my($class, $path) = @_;
      bless { path => $path }, $class;
  }
  
  sub path { $_[0]->{path} }
  
  sub throw {
      my($class, @args) = @_;
      die $class->new(@args);
  }
  
  sub as_string {
      my $self = shift;
      return "Forwarding to $self->{path}: Your application should be wrapped with Plack::Middleware::Recursive.";
  }
  
  package Plack::Middleware::Recursive;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Recursive - Allows PSGI apps to include or forward requests recursively
  
  =head1 SYNOPSIS
  
    # with Builder
    enable "Recursive";
  
    # in apps
    my $res = $env->{'plack.recursive.include'}->("/new_path");
  
    # Or, use exceptions
    my $app = sub {
        # ...
        Plack::Recursive::ForwardRequest->throw("/new_path");
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Recursive allows PSGI applications to recursively
  include or forward requests to other paths. Applications can make use
  of callbacks stored in C<< $env->{'plack.recursive.include'} >> to
  I<include> another path to get the response (whether it's an array ref
  or a code ref depending on your application), or throw an exception
  Plack::Recursive::ForwardRequest anywhere in the code to I<forward>
  the current request (i.e. abort the current and redo the request).
  
  =head1 EXCEPTIONS
  
  This middleware passes through unknown exceptions to the outside
  middleware stack, so if you use this middleware with other exception
  handlers such as L<Plack::Middleware::StackTrace> or
  L<Plack::Middleware::HTTPExceptions>, be sure to wrap this so
  L<Plack::Middleware::Recursive> gets as inner as possible.
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Honma
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Middleware::HTTPExceptions>
  
  The idea, code and interface are stolen from Rack::Recursive and paste.recursive.
  
  =cut
  
  
PLACK_MIDDLEWARE_RECURSIVE

$fatpacked{"Plack/Middleware/Refresh.pm"} = <<'PLACK_MIDDLEWARE_REFRESH';
  package Plack::Middleware::Refresh;
  use strict;
  use parent qw(Plack::Middleware);
  use Module::Refresh;
  use Plack::Util::Accessor qw(last cooldown);
  
  sub prepare_app {
      my $self = shift;
      $self->cooldown(10) unless defined $self->cooldown;
  
      Module::Refresh->new;
      $self->last(time - $self->cooldown);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if (time > $self->last + $self->cooldown) {
          Module::Refresh->refresh;
          $self->last(time);
      }
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Refresh - Refresh all modules in %INC
  
  =head1 SYNOPSIS
  
    enable "Refresh", cooldown => 3;
    $app;
  
  =head1 DESCRIPTION
  
  This is I<yet another> approach to refresh modules in C<%INC> during
  the development cycle, without the need to have a forking process to
  watch for filesystem updates. This middleware, in a request time,
  compares the last refresh time and the current time and if the
  difference is bigger than I<cooldown> seconds which defaults to 10,
  call L<Module::Refresh> to reload all Perl modules in C<%INC> if the
  files have been modified.
  
  Note that this only reloads modules and not other files such as
  templates.
  
  This middleware is quite similar to what Rack::Reoader does. If you
  have issues with this reloading technique, for instance when you have
  in-file templates that needs to be recompiled, or Moose classes that
  has C<make_immutable>, take a look at L<plackup>'s default -r option
  or L<Plack::Loader::Shotgun> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Module::Refresh> Rack::Reloader
  
  =cut
  
PLACK_MIDDLEWARE_REFRESH

$fatpacked{"Plack/Middleware/Runtime.pm"} = <<'PLACK_MIDDLEWARE_RUNTIME';
  package Plack::Middleware::Runtime;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use Plack::Util::Accessor qw(header_name);
  use Time::HiRes;
  
  sub call {
      my($self, $env) = @_;
  
      my $start = [ Time::HiRes::gettimeofday ];
      my $res = $self->app->($env);
  
      $self->response_cb($res, sub {
          my $res = shift;
          my $req_time = sprintf '%.6f', Time::HiRes::tv_interval($start);
          Plack::Util::header_set($res->[1], 'X-Runtime', $req_time);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Runtime - Sets an X-Runtime response header
  
  =head1 SYNOPSIS
  
    enable "Runtime";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Runtime is a Plack middleware component that sets
  application's response time, in seconds to I<X-Runtime> HTTP response
  header.
  
  =head1 OPTIONS
  
  =over 4
  
  =item header_name
  
  Name of the header. Defaults to I<X-Runtime>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Time::HiRes> Rack::Runtime
  
  =cut
PLACK_MIDDLEWARE_RUNTIME

$fatpacked{"Plack/Middleware/SimpleContentFilter.pm"} = <<'PLACK_MIDDLEWARE_SIMPLECONTENTFILTER';
  package Plack::Middleware::SimpleContentFilter;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Plack::Util::Accessor qw( filter );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($h->get('Content-Type') =~ m!^text/!) {
              return sub {
                  my $chunk = shift;
                  return unless defined $chunk;
                  local $_ = $chunk;
                  $self->filter->();
                  return $_;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleContentFilter - Filters response content
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::SimpleContentFilter",
            filter => sub { s/Foo/Bar/g; };
        $app;
    };
  
  =head1 DESCRIPTION
  
  B<This middleware should be considered as a demo. Running this against
  your application might break your HTML unless you code the filter
  callback carefully>.
  
  Plack::Middleware::SimpleContentFilter is a simple content text filter
  to run against response body. This middleware is only enabled against
  responses with C<text/*> Content-Type.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLECONTENTFILTER

$fatpacked{"Plack/Middleware/SimpleLogger.pm"} = <<'PLACK_MIDDLEWARE_SIMPLELOGGER';
  package Plack::Middleware::SimpleLogger;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(level);
  use POSIX ();
  use Scalar::Util ();
  
  # Should this be in Plack::Util?
  my $i = 0;
  my %level_numbers = map { $_ => $i++ } qw(debug info warn error fatal);
  
  sub call {
      my($self, $env) = @_;
  
      my $min = $level_numbers{ $self->level || "debug" };
  
      my $env_ref = $env;
      Scalar::Util::weaken($env_ref);
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
  
          if ($level_numbers{$args->{level}} >= $min) {
              $env_ref->{'psgi.errors'}->print($self->format_message($args->{level}, $args->{message}));
          }
      };
  
      $self->app->($env);
  }
  
  sub format_time {
      my $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
      POSIX::setlocale(&POSIX::LC_ALL, 'en');
      my $out = POSIX::strftime(@_);
      POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
      return $out;
  }
  
  sub format_message {
      my($self, $level, $message) = @_;
  
      my $time = format_time("%Y-%m-%dT%H:%M:%S", localtime);
      sprintf "%s [%s #%d] %s: %s\n", uc substr($level, 0, 1), $time, $$, uc $level, $message;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleLogger - Simple logger that prints to psgi.errors
  
  =head1 SYNOPSIS
  
    enable "SimpleLogger", level => "warn";
  
  =head1 DESCRIPTION
  
  SimpleLogger is a middleware component that formats the log message
  with information such as the time and PID and prints them to
  I<psgi.errors> stream, which is mostly STDERR or server log output.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLELOGGER

$fatpacked{"Plack/Middleware/StackTrace.pm"} = <<'PLACK_MIDDLEWARE_STACKTRACE';
  package Plack::Middleware::StackTrace;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Devel::StackTrace;
  use Devel::StackTrace::AsHTML;
  use Try::Tiny;
  use Plack::Util::Accessor qw( force no_print_errors );
  
  our $StackTraceClass = "Devel::StackTrace";
  
  # Optional since it needs PadWalker
  if (try { require Devel::StackTrace::WithLexicals; Devel::StackTrace::WithLexicals->VERSION(0.08); 1 }) {
      $StackTraceClass = "Devel::StackTrace::WithLexicals";
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $trace;
      local $SIG{__DIE__} = sub {
          $trace = $StackTraceClass->new(
              indent => 1, message => munge_error($_[0], [ caller ]),
              ignore_package => __PACKAGE__,
          );
          die @_;
      };
  
      my $caught;
      my $res = try {
          $self->app->($env);
      } catch {
          $caught = $_;
          [ 500, [ "Content-Type", "text/plain; charset=utf-8" ], [ no_trace_error(utf8_safe($caught)) ] ];
      };
  
      if ($trace && ($caught || ($self->force && ref $res eq 'ARRAY' && $res->[0] == 500)) ) {
          my $text = $trace->as_string;
          my $html = $trace->as_html;
          $env->{'plack.stacktrace.text'} = $text;
          $env->{'plack.stacktrace.html'} = $html;
          $env->{'psgi.errors'}->print($text) unless $self->no_print_errors;
          if (($env->{HTTP_ACCEPT} || '*/*') =~ /html/) {
              $res = [500, ['Content-Type' => 'text/html; charset=utf-8'], [ utf8_safe($html) ]];
          } else {
              $res = [500, ['Content-Type' => 'text/plain; charset=utf-8'], [ utf8_safe($text) ]];
          }
      }
  
      # break $trace here since $SIG{__DIE__} holds the ref to it, and
      # $trace has refs to Standalone.pm's args ($conn etc.) and
      # prevents garbage collection to be happening.
      undef $trace;
  
      return $res;
  }
  
  sub no_trace_error {
      my $msg = shift;
      chomp($msg);
  
      return <<EOF;
  The application raised the following error:
  
    $msg
  
  and the StackTrace middleware couldn't catch its stack trace, possibly because your application overrides \$SIG{__DIE__} by itself, preventing the middleware from working correctly. Remove the offending code or module that does it: known examples are CGI::Carp and Carp::Always.
  EOF
  }
  
  sub munge_error {
      my($err, $caller) = @_;
      return $err if ref $err;
  
      # Ugly hack to remove " at ... line ..." automatically appended by perl
      # If there's a proper way to do this, please let me know.
      $err =~ s/ at \Q$caller->[1]\E line $caller->[2]\.\n$//;
  
      return $err;
  }
  
  sub utf8_safe {
      my $str = shift;
  
      # NOTE: I know messing with utf8:: in the code is WRONG, but
      # because we're running someone else's code that we can't
      # guarnatee which encoding an exception is encoded, there's no
      # better way than doing this. The latest Devel::StackTrace::AsHTML
      # (0.08 or later) encodes high-bit chars as HTML entities, so this
      # path won't be executed.
      if (utf8::is_utf8($str)) {
          utf8::encode($str);
      }
  
      $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::StackTrace - Displays stack trace when your app dies
  
  =head1 SYNOPSIS
  
    enable "StackTrace";
  
  =head1 DESCRIPTION
  
  This middleware catches exceptions (run-time errors) happening in your
  application and displays nice stack trace screen. The stack trace is
  also stored in the environment as a plaintext and HTML under the key
  C<plack.stacktrace.text> and C<plack.stacktrace.html> respectively, so
  that middleware futher up the stack can reference it.
  
  This middleware is enabled by default when you run L<plackup> in the
  default I<development> mode.
  
  You're recommended to use this middleware during the development and
  use L<Plack::Middleware::HTTPExceptions> in the deployment mode as a
  replacement, so that all the exceptions thrown from your application
  still get caught and rendered as a 500 error response, rather than
  crashing the web server.
  
  Catching errors in streaming response is not supported.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item force
  
    enable "StackTrace", force => 1;
  
  Force display the stack trace when an error occurs within your
  application and the response code from your application is
  500. Defaults to off.
  
  The use case of this option is that when your framework catches all
  the exceptions in the main handler and returns all failures in your
  code as a normal 500 PSGI error response. In such cases, this
  middleware would never have a chance to display errors because it
  can't tell if it's an application error or just random C<eval> in your
  code. This option enforces the middleware to display stack trace even
  if it's not the direct error thrown by the application.
  
  =item no_print_errors
  
    enable "StackTrace", no_print_errors => 1;
  
  Skips printing the text stacktrace to console
  (C<psgi.errors>). Defaults to 0, which means the text version of the
  stack trace error is printed to the errors handle, which usually is a
  standard error.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace::AsHTML> L<Plack::Middleware> L<Plack::Middleware::HTTPExceptions>
  
  =cut
  
PLACK_MIDDLEWARE_STACKTRACE

$fatpacked{"Plack/Middleware/Static.pm"} = <<'PLACK_MIDDLEWARE_STATIC';
  package Plack::Middleware::Static;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Plack::App::File;
  
  use Plack::Util::Accessor qw( path root encoding pass_through );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->_handle_static($env);
      if ($res && not ($self->pass_through and $res->[0] == 404)) {
          return $res;
      }
  
      return $self->app->($env);
  }
  
  sub _handle_static {
      my($self, $env) = @_;
  
      my $path_match = $self->path or return;
      my $path = $env->{PATH_INFO};
  
      for ($path) {
          my $matched = 'CODE' eq ref $path_match ? $path_match->($_) : $_ =~ $path_match;
          return unless $matched;
      }
  
      $self->{file} ||= Plack::App::File->new({ root => $self->root || '.', encoding => $self->encoding });
      local $env->{PATH_INFO} = $path; # rewrite PATH
      return $self->{file}->call($env);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Static - serve static files with Plack
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::Static",
            path => qr{^/(images|js|css)/}, root => './htdocs/';
        $app;
    };
  
  =head1 DESCRIPTION
  
  Enable this middleware to allow your Plack-based application to serve
  static files.
  
  If the given request matches with the pattern defined in C<path>, this
  middleware will try to locate the file in C<root>. If the file exists
  it will be served but otherwise C<404> response will be returned. See
  C<pass_through> option below to change this behavior.
  
  If the requested document is not within the C<root> (i.e. directory
  traversal) or the file is there but not readable, a 403 Forbidden
  response will be returned.
  
  The content type returned will be determined from the file extension
  based on L<Plack::MIME>.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item path, root
  
    enable "Plack::Middleware::Static",
        path => qr{^/static/}, root => 'htdocs/';
  
  C<path> specifies the URL pattern (regular expression) or a callback
  to match with requests to serve static files for. C<root> specifies
  the root directory to serve those static files from. The default value
  of C<root> is the current directory.
  
  This examples configuration serves C</static/foo.jpg> from
  C<htdocs/static/foo.jpg>. Note that the matched C</static/> portion is
  still appears in the local mapped path. If you don't like it, use a
  callback instead to munge C<$_>:
  
    enable "Plack::Middleware::Static",
        path => sub { s!^/static/!! }, root => 'static-files/';
  
  This configuration would serve C</static/foo.png> from
  C<static-files/foo.png> (not C<static-files/static/foo.png>). The
  callback specified in C<path> option matches against C<$_> and then
  updates the value since it does s///, and returns the number of
  matches, so it will pass through when C</static/> doesn't match.
  
  If you want to map multiple static directories from different root,
  simply add "this", middleware multiple times with different
  configuration options.
  
  =item pass_through
  
  By turning on this option, this middleware will pass the request
  back to the application for further processing, if the incoming
  request path matches with the C<path> but the requested file is not
  found on the file system.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno, Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::Builder>
  
  =cut
  
  
PLACK_MIDDLEWARE_STATIC

$fatpacked{"Plack/Middleware/Writer.pm"} = <<'PLACK_MIDDLEWARE_WRITER';
  package Plack::Middleware::Writer;
  use strict;
  use parent qw(Plack::Middleware::BufferedStreaming);
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Writer - DEPRECATED
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::BufferedStreaming>
  
  =cut
PLACK_MIDDLEWARE_WRITER

$fatpacked{"Plack/Middleware/XFramework.pm"} = <<'PLACK_MIDDLEWARE_XFRAMEWORK';
  package Plack::Middleware::XFramework;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  
  use Plack::Util;
  use Plack::Util::Accessor qw( framework );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->( @_ );
      $self->response_cb($res, sub {
          my $res = shift;
          if ($self->framework) {
              Plack::Util::header_set $res->[1], 'X-Framework' => $self->framework;
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XFramework - Sample middleware to add X-Framework
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XFramework", framework => "Catalyst";
  
  =head1 DESCRIPTION
  
  This middleware adds C<X-Framework> header to the HTTP response.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item framework
  
  Sets the string value of C<X-Framework> header. If not set, the header is not set to the response.
  
  =back
  
  =head1 SEE ALSO
  
  L<Plack::Middleware>
  
  =cut
  
PLACK_MIDDLEWARE_XFRAMEWORK

$fatpacked{"Plack/Middleware/XSendfile.pm"} = <<'PLACK_MIDDLEWARE_XSENDFILE';
  package Plack::Middleware::XSendfile;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  use Scalar::Util;
  use Plack::Util::Accessor qw( variation );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my($status, $headers, $body) = @$res;
          return unless defined $body;
  
          if (Scalar::Util::blessed($body) && $body->can('path')) {
              my $type = $self->_variation($env) || '';
              my $h = Plack::Util::headers($headers);
              if ($type && !$h->exists($type)) {
                  if ($type eq 'X-Accel-Redirect') {
                      my $path = $body->path;
                      my $url = $self->map_accel_path($env, $path);
                      $h->set($type => $url) if $url;
                      $body = [];
                  } elsif ($type eq 'X-Sendfile' or $type eq 'X-Lighttpd-Send-File') {
                      my $path = $body->path;
                      $h->set($type => $path) if defined $path;
                      $body = [];
                  } else {
                      $env->{'psgi.errors'}->print("Unknown x-sendfile variation: $type");
                  }
              }
          }
  
          @$res = ( $status, $headers, $body );
      });
  }
  
  sub map_accel_path {
      my($self, $env, $path) = @_;
  
      if (my $mapping = $env->{HTTP_X_ACCEL_MAPPING}) {
          my($internal, $external) = split /=/, $mapping, 2;
          $path =~ s!^\Q$internal\E!$external!i;
      }
  
      return $path;
  }
  
  sub _variation {
      my($self, $env) = @_;
      $self->variation || $env->{'plack.xsendfile.type'} || $env->{HTTP_X_SENDFILE_TYPE};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XSendfile - Sets X-Sendfile (or a like) header for frontends
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XSendfile";
  
  =head1 DESCRIPTION
  
  You should use L<IO::File::WithPath> or L<Plack::Util>'s
  C<set_io_path> to add C<path> method to an IO object in the body.
  
  See L<http://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/sendfile.rb>
  for the frontend configuration.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_XSENDFILE

$fatpacked{"Plack/Request.pm"} = <<'PLACK_REQUEST';
  package Plack::Request;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  use HTTP::Headers;
  use Carp ();
  use Hash::MultiValue;
  use HTTP::Body;
  
  use Plack::Request::Upload;
  use Plack::TempBuffer;
  use URI;
  use URI::Escape ();
  
  sub _deprecated {
      my $alt = shift;
      my $method = (caller(1))[3];
      Carp::carp("$method is deprecated. Use '$alt' instead.");
  }
  
  sub new {
      my($class, $env) = @_;
      Carp::croak(q{$env is required})
          unless defined $env && ref($env) eq 'HASH';
  
      bless { env => $env }, $class;
  }
  
  sub env { $_[0]->{env} }
  
  sub address     { $_[0]->env->{REMOTE_ADDR} }
  sub remote_host { $_[0]->env->{REMOTE_HOST} }
  sub protocol    { $_[0]->env->{SERVER_PROTOCOL} }
  sub method      { $_[0]->env->{REQUEST_METHOD} }
  sub port        { $_[0]->env->{SERVER_PORT} }
  sub user        { $_[0]->env->{REMOTE_USER} }
  sub request_uri { $_[0]->env->{REQUEST_URI} }
  sub path_info   { $_[0]->env->{PATH_INFO} }
  sub path        { $_[0]->env->{PATH_INFO} || '/' }
  sub script_name { $_[0]->env->{SCRIPT_NAME} }
  sub scheme      { $_[0]->env->{'psgi.url_scheme'} }
  sub secure      { $_[0]->scheme eq 'https' }
  sub body        { $_[0]->env->{'psgi.input'} }
  sub input       { $_[0]->env->{'psgi.input'} }
  
  sub content_length   { $_[0]->env->{CONTENT_LENGTH} }
  sub content_type     { $_[0]->env->{CONTENT_TYPE} }
  
  sub session         { $_[0]->env->{'psgix.session'} }
  sub session_options { $_[0]->env->{'psgix.session.options'} }
  sub logger          { $_[0]->env->{'psgix.logger'} }
  
  sub cookies {
      my $self = shift;
  
      return {} unless $self->env->{HTTP_COOKIE};
  
      # HTTP_COOKIE hasn't changed: reuse the parsed cookie
      if (   $self->env->{'plack.cookie.parsed'}
          && $self->env->{'plack.cookie.string'} eq $self->env->{HTTP_COOKIE}) {
          return $self->env->{'plack.cookie.parsed'};
      }
  
      $self->env->{'plack.cookie.string'} = $self->env->{HTTP_COOKIE};
  
      my %results;
      my @pairs = grep /=/, split "[;,] ?", $self->env->{'plack.cookie.string'};
      for my $pair ( @pairs ) {
          # trim leading trailing whitespace
          $pair =~ s/^\s+//; $pair =~ s/\s+$//;
  
          my ($key, $value) = map URI::Escape::uri_unescape($_), split( "=", $pair, 2 );
  
          # Take the first one like CGI.pm or rack do
          $results{$key} = $value unless exists $results{$key};
      }
  
      $self->env->{'plack.cookie.parsed'} = \%results;
  }
  
  sub query_parameters {
      my $self = shift;
      $self->env->{'plack.request.query'} ||= Hash::MultiValue->new($self->uri->query_form);
  }
  
  sub content {
      my $self = shift;
  
      unless ($self->env->{'psgix.input.buffered'}) {
          $self->_parse_request_body;
      }
  
      my $fh = $self->input                 or return '';
      my $cl = $self->env->{CONTENT_LENGTH} or return'';
      $fh->read(my($content), $cl, 0);
      $fh->seek(0, 0);
  
      return $content;
  }
  
  sub raw_body { $_[0]->content }
  
  # XXX you can mutate headers with ->headers but it's not written through to the env
  
  sub headers {
      my $self = shift;
      if (!defined $self->{headers}) {
          my $env = $self->env;
          $self->{headers} = HTTP::Headers->new(
              map {
                  (my $field = $_) =~ s/^HTTPS?_//;
                  ( $field => $env->{$_} );
              }
                  grep { /^(?:HTTP|CONTENT|COOKIE)/i } keys %$env
              );
      }
      $self->{headers};
  }
  
  sub content_encoding { shift->headers->content_encoding(@_) }
  sub header           { shift->headers->header(@_) }
  sub referer          { shift->headers->referer(@_) }
  sub user_agent       { shift->headers->user_agent(@_) }
  
  sub body_parameters {
      my $self = shift;
  
      unless ($self->env->{'plack.request.body'}) {
          $self->_parse_request_body;
      }
  
      return $self->env->{'plack.request.body'};
  }
  
  # contains body + query
  sub parameters {
      my $self = shift;
  
      $self->env->{'plack.request.merged'} ||= do {
          my $query = $self->query_parameters;
          my $body  = $self->body_parameters;
          Hash::MultiValue->new($query->flatten, $body->flatten);
      };
  }
  
  sub uploads {
      my $self = shift;
  
      if ($self->env->{'plack.request.upload'}) {
          return $self->env->{'plack.request.upload'};
      }
  
      $self->_parse_request_body;
      return $self->env->{'plack.request.upload'};
  }
  
  sub hostname     { _deprecated 'remote_host';      $_[0]->remote_host || $_[0]->address }
  sub url_scheme   { _deprecated 'scheme';           $_[0]->scheme }
  sub params       { _deprecated 'parameters';       shift->parameters(@_) }
  sub query_params { _deprecated 'query_parameters'; shift->query_parameters(@_) }
  sub body_params  { _deprecated 'body_parameters';  shift->body_parameters(@_) }
  
  sub cookie {
      my $self = shift;
      _deprecated 'cookies';
  
      return keys %{ $self->cookies } if @_ == 0;
  
      my $name = shift;
      return $self->cookies->{$name};
  }
  
  sub param {
      my $self = shift;
  
      return keys %{ $self->parameters } if @_ == 0;
  
      my $key = shift;
      return $self->parameters->{$key} unless wantarray;
      return $self->parameters->get_all($key);
  }
  
  sub upload {
      my $self = shift;
  
      return keys %{ $self->uploads } if @_ == 0;
  
      my $key = shift;
      return $self->uploads->{$key} unless wantarray;
      return $self->uploads->get_all($key);
  }
  
  sub raw_uri {
      my $self = shift;
      _deprecated 'base';
  
      my $base = $self->base;
      $base->path_query($self->env->{REQUEST_URI});
  
      $base;
  }
  
  sub uri {
      my $self = shift;
  
      my $base = $self->_uri_base;
  
      # We have to escape back PATH_INFO in case they include stuff like
      # ? or # so that the URI parser won't be tricked. However we should
      # preserve '/' since encoding them into %2f doesn't make sense.
      # This means when a request like /foo%2fbar comes in, we recognize
      # it as /foo/bar which is not ideal, but that's how the PSGI PATH_INFO
      # spec goes and we can't do anything about it. See PSGI::FAQ for details.
      # http://github.com/miyagawa/Plack/issues#issue/118
      my $path_escape_class = '^A-Za-z0-9\-\._~/';
  
      my $path = URI::Escape::uri_escape($self->env->{PATH_INFO} || '', $path_escape_class);
      $path .= '?' . $self->env->{QUERY_STRING}
          if defined $self->env->{QUERY_STRING} && $self->env->{QUERY_STRING} ne '';
  
      $base =~ s!/$!! if $path =~ m!^/!;
  
      return URI->new($base . $path)->canonical;
  }
  
  sub base {
      my $self = shift;
      URI->new($self->_uri_base)->canonical;
  }
  
  sub _uri_base {
      my $self = shift;
  
      my $env = $self->env;
  
      my $uri = ($env->{'psgi.url_scheme'} || "http") .
          "://" .
          ($env->{HTTP_HOST} || (($env->{SERVER_NAME} || "") . ":" . ($env->{SERVER_PORT} || 80))) .
          ($env->{SCRIPT_NAME} || '/');
  
      return $uri;
  }
  
  sub new_response {
      my $self = shift;
      require Plack::Response;
      Plack::Response->new(@_);
  }
  
  sub _parse_request_body {
      my $self = shift;
  
      my $ct = $self->env->{CONTENT_TYPE};
      my $cl = $self->env->{CONTENT_LENGTH};
      if (!$ct && !$cl) {
          # No Content-Type nor Content-Length -> GET/HEAD
          $self->env->{'plack.request.body'}   = Hash::MultiValue->new;
          $self->env->{'plack.request.upload'} = Hash::MultiValue->new;
          return;
      }
  
      my $body = HTTP::Body->new($ct, $cl);
  
      # HTTP::Body will create temporary files in case there was an
      # upload.  Those temporary files can be cleaned up by telling
      # HTTP::Body to do so. It will run the cleanup when the request
      # env is destroyed. That the object will not go out of scope by
      # the end of this sub we will store a reference here.
      $self->env->{'plack.request.http.body'} = $body;
      $body->cleanup(1);
  
      my $input = $self->input;
  
      my $buffer;
      if ($self->env->{'psgix.input.buffered'}) {
          # Just in case if input is read by middleware/apps beforehand
          $input->seek(0, 0);
      } else {
          $buffer = Plack::TempBuffer->new($cl);
      }
  
      my $spin = 0;
      while ($cl) {
          $input->read(my $chunk, $cl < 8192 ? $cl : 8192);
          my $read = length $chunk;
          $cl -= $read;
          $body->add($chunk);
          $buffer->print($chunk) if $buffer;
  
          if ($read == 0 && $spin++ > 2000) {
              Carp::croak "Bad Content-Length: maybe client disconnect? ($cl bytes remaining)";
          }
      }
  
      if ($buffer) {
          $self->env->{'psgix.input.buffered'} = 1;
          $self->env->{'psgi.input'} = $buffer->rewind;
      } else {
          $input->seek(0, 0);
      }
  
      $self->env->{'plack.request.body'}   = Hash::MultiValue->from_mixed($body->param);
  
      my @uploads = Hash::MultiValue->from_mixed($body->upload)->flatten;
      my @obj;
      while (my($k, $v) = splice @uploads, 0, 2) {
          push @obj, $k, $self->_make_upload($v);
      }
  
      $self->env->{'plack.request.upload'} = Hash::MultiValue->new(@obj);
  
      1;
  }
  
  sub _make_upload {
      my($self, $upload) = @_;
      my %copy = %$upload;
      $copy{headers} = HTTP::Headers->new(%{$upload->{headers}});
      Plack::Request::Upload->new(%copy);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request - Portable HTTP request object from PSGI env hash
  
  =head1 SYNOPSIS
  
    use Plack::Request;
  
    my $app_or_middleware = sub {
        my $env = shift; # PSGI env
  
        my $req = Plack::Request->new($env);
  
        my $path_info = $req->path_info;
        my $query     = $req->param('query');
  
        my $res = $req->new_response(200); # new Plack::Response
        $res->finalize;
    };
  
  =head1 DESCRIPTION
  
  L<Plack::Request> provides a consistent API for request objects across
  web server environments.
  
  =head1 CAVEAT
  
  Note that this module is intended to be used by Plack middleware
  developers and web application framework developers rather than
  application developers (end users).
  
  Writing your web application directly using Plack::Request is
  certainly possible but not recommended: it's like doing so with
  mod_perl's Apache::Request: yet too low level.
  
  If you're writing a web application, not a framework, then you're
  encouraged to use one of the web application frameworks that support PSGI (L<http://plackperl.org/#frameworks>),
  or see modules like L<HTTP::Engine> to provide higher level
  Request and Response API on top of PSGI.
  
  =head1 METHODS
  
  Some of the methods defined in the earlier versions are deprecated in
  version 0.99. Take a look at L</"INCOMPATIBILITIES">.
  
  Unless otherwise noted, all methods and attributes are B<read-only>,
  and passing values to the method like an accessor doesn't work like
  you expect it to.
  
  =head2 new
  
      Plack::Request->new( $env );
  
  Creates a new request object.
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item env
  
  Returns the shared PSGI environment hash reference. This is a
  reference, so writing to this environment passes through during the
  whole PSGI request/response cycle.
  
  =item address
  
  Returns the IP address of the client (C<REMOTE_ADDR>).
  
  =item remote_host
  
  Returns the remote host (C<REMOTE_HOST>) of the client. It may be
  empty, in which case you have to get the IP address using C<address>
  method and resolve on your own.
  
  =item method
  
  Contains the request method (C<GET>, C<POST>, C<HEAD>, etc).
  
  =item protocol
  
  Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.
  
  =item request_uri
  
  Returns the raw, undecoded request URI path. You probably do B<NOT>
  want to use this to dispatch requests.
  
  =item path_info
  
  Returns B<PATH_INFO> in the environment. Use this to get the local
  path for the requests.
  
  =item path
  
  Similar to C<path_info> but returns C</> in case it is empty. In other
  words, it returns the virtual path of the request URI after C<<
  $req->base >>. See L</"DISPATCHING"> for details.
  
  =item script_name
  
  Returns B<SCRIPT_NAME> in the environment. This is the absolute path
  where your application is hosted.
  
  =item scheme
  
  Returns the scheme (C<http> or C<https>) of the request.
  
  =item secure
  
  Returns true or false, indicating whether the connection is secure (https).
  
  =item body, input
  
  Returns C<psgi.input> handle.
  
  =item session
  
  Returns (optional) C<psgix.session> hash. When it exists, you can
  retrieve and store per-session data from and to this hash.
  
  =item session_options
  
  Returns (optional) C<psgix.session.options> hash.
  
  =item logger
  
  Returns (optional) C<psgix.logger> code reference. When it exists,
  your application is supposed to send the log message to this logger,
  using:
  
    $req->logger->({ level => 'debug', message => "This is a debug message" });
  
  =item cookies
  
  Returns a reference to a hash containing the cookies. Values are
  strings that are sent by clients and are URI decoded.
  
  =item query_parameters
  
  Returns a reference to a hash containing query string (GET)
  parameters. This hash reference is L<Hash::MultiValue> object.
  
  =item body_parameters
  
  Returns a reference to a hash containing posted parameters in the
  request body (POST). As with C<query_parameters>, the hash
  reference is a L<Hash::MultiValue> object.
  
  =item parameters
  
  Returns a L<Hash::MultiValue> hash reference containing (merged) GET
  and POST parameters.
  
  =item content, raw_body
  
  Returns the request content in an undecoded byte string for POST requests.
  
  =item uri
  
  Returns an URI object for the current request. The URI is constructed
  using various environment values such as C<SCRIPT_NAME>, C<PATH_INFO>,
  C<QUERY_STRING>, C<HTTP_HOST>, C<SERVER_NAME> and C<SERVER_PORT>.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item base
  
  Returns an URI object for the base path of current request. This is
  like C<uri> but only contains up to C<SCRIPT_NAME> where your
  application is hosted at.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item user
  
  Returns C<REMOTE_USER> if it's set.
  
  =item headers
  
  Returns an L<HTTP::Headers> object containing the headers for the current request.
  
  =item uploads
  
  Returns a reference to a hash containing uploads. The hash reference
  is a L<Hash::MultiValue> object and values are L<Plack::Request::Upload>
  objects.
  
  =item content_encoding
  
  Shortcut to $req->headers->content_encoding.
  
  =item content_length
  
  Shortcut to $req->headers->content_length.
  
  =item content_type
  
  Shortcut to $req->headers->content_type.
  
  =item header
  
  Shortcut to $req->headers->header.
  
  =item referer
  
  Shortcut to $req->headers->referer.
  
  =item user_agent
  
  Shortcut to $req->headers->user_agent.
  
  =item param
  
  Returns GET and POST parameters with a CGI.pm-compatible param
  method. This is an alternative method for accessing parameters in
  $req->parameters. Unlike CGI.pm, it does I<not> allow
  setting or modifying query parameters.
  
      $value  = $req->param( 'foo' );
      @values = $req->param( 'foo' );
      @params = $req->param;
  
  =item upload
  
  A convenient method to access $req->uploads.
  
      $upload  = $req->upload('field');
      @uploads = $req->upload('field');
      @fields  = $req->upload;
  
      for my $upload ( $req->upload('field') ) {
          print $upload->filename;
      }
  
  =item new_response
  
    my $res = $req->new_response;
  
  Creates a new L<Plack::Response> object. Handy to remove dependency on
  L<Plack::Response> in your code for easy subclassing and duck typing
  in web application frameworks, as well as overriding Response
  generation in middlewares.
  
  =back
  
  =head2 Hash::MultiValue parameters
  
  Parameters that can take one or multiple values (i.e. C<parameters>,
  C<query_parameters>, C<body_parameters> and C<uploads>) store the
  hash reference as a L<Hash::MultiValue> object. This means you can use
  the hash reference as a plain hash where values are B<always> scalars
  (B<NOT> array references), so you don't need to code ugly and unsafe
  C<< ref ... eq 'ARRAY' >> anymore.
  
  And if you explicitly want to get multiple values of the same key, you
  can call the C<get_all> method on it, such as:
  
    my @foo = $req->query_parameters->get_all('foo');
  
  You can also call C<get_one> to always get one parameter independent
  of the context (unlike C<param>), and even call C<mixed> (with
  Hash::MultiValue 0.05 or later) to get the I<traditional> hash
  reference,
  
    my $params = $req->parameters->mixed;
  
  where values are either a scalar or an array reference depending on
  input, so it might be useful if you already have the code to deal with
  that ugliness.
  
  =head2 PARSING POST BODY and MULTIPLE OBJECTS
  
  The methods to parse request body (C<content>, C<body_parameters> and
  C<uploads>) are carefully coded to save the parsed body in the
  environment hash as well as in the temporary buffer, so you can call
  them multiple times and create Plack::Request objects multiple times
  in a request and they should work safely, and won't parse request body
  more than twice for the efficiency.
  
  =head1 DISPATCHING
  
  If your application or framework wants to dispatch (or route) actions
  based on request paths, be sure to use C<< $req->path_info >> not C<<
  $req->uri->path >>.
  
  This is because C<path_info> gives you the virtual path of the request,
  regardless of how your application is mounted. If your application is
  hosted with mod_perl or CGI scripts, or even multiplexed with tools
  like L<Plack::App::URLMap>, request's C<path_info> always gives you
  the action path.
  
  Note that C<path_info> might give you an empty string, in which case
  you should assume that the path is C</>.
  
  You will also want to use C<< $req->base >> as a base prefix when
  building URLs in your templates or in redirections. It's a good idea
  for you to subclass Plack::Request and define methods such as:
  
    sub uri_for {
        my($self, $path, $args) = @_;
        my $uri = $self->base;
        $uri->path($uri->path . $path);
        $uri->query_form(@$args) if $args;
        $uri;
    }
  
  So you can say:
  
    my $link = $req->uri_for('/logout', [ signoff => 1 ]);
  
  and if C<< $req->base >> is C</app> you'll get the full URI for
  C</app/logout?signoff=1>.
  
  =head1 INCOMPATIBILITIES
  
  In version 0.99, many utility methods are removed or deprecated, and
  most methods are made read-only.
  
  The following methods are deprecated: C<hostname>, C<url_scheme>,
  C<params>, C<query_params>, C<body_params>, C<cookie> and
  C<raw_uri>. They will be removed in the next major release.
  
  All parameter-related methods such as C<parameters>,
  C<body_parameters>, C<query_parameters> and C<uploads> now contains
  L<Hash::MultiValue> objects, rather than I<scalar or an array
  reference depending on the user input> which is insecure. See
  L<Hash::MultiValue> for more about this change.
  
  C<< $req->path >> method had a bug, where the code and the document
  was mismatching. The document was suggesting it returns the sub
  request path after C<< $req->base >> but the code was always returning
  the absolute URI path. The code is now updated to be an alias of C<<
  $req->path_info >> but returns C</> in case it's empty. If you need
  the older behavior, just call C<< $req->uri->path >> instead.
  
  Cookie handling is simplified, and doesn't use L<CGI::Simple::Cookie>
  anymore, which means you B<CAN NOT> set array reference or hash
  reference as a cookie value and expect it be serialized. You're always
  required to set string value, and encoding or decoding them is totally
  up to your application or framework. Also, C<cookies> hash reference
  now returns I<strings> for the cookies rather than CGI::Simple::Cookie
  objects, which means you no longer have to write a wacky code such as:
  
    $v = $req->cookie->{foo} ? $req->cookie->{foo}->value : undef;
  
  and instead, simply do:
  
    $v = $req->cookie->{foo};
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Kazuhiro Osawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Response> L<HTTP::Request>, L<Catalyst::Request>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_REQUEST

$fatpacked{"Plack/Request/Upload.pm"} = <<'PLACK_REQUEST_UPLOAD';
  package Plack::Request::Upload;
  use strict;
  use warnings;
  use Carp ();
  
  sub new {
      my($class, %args) = @_;
  
      bless {
          headers  => $args{headers},
          tempname => $args{tempname},
          size     => $args{size},
          filename => $args{filename},
      }, $class;
  }
  
  sub filename { $_[0]->{filename} }
  sub headers  { $_[0]->{headers} }
  sub size     { $_[0]->{size} }
  sub tempname { $_[0]->{tempname} }
  sub path     { $_[0]->{tempname} }
  
  sub content_type {
      my $self = shift;
      $self->{headers}->content_type(@_);
  }
  
  sub type { shift->content_type(@_) }
  
  sub basename {
      my $self = shift;
      unless (defined $self->{basename}) {
          require File::Spec::Unix;
          my $basename = $self->{filename};
          $basename =~ s|\\|/|g;
          $basename = ( File::Spec::Unix->splitpath($basename) )[2];
          $basename =~ s|[^\w\.-]+|_|g;
          $self->{basename} = $basename;
      }
      $self->{basename};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request::Upload - handles file upload requests
  
  =head1 SYNOPSIS
  
    # $req is Plack::Request
    my $upload = $req->uploads->{field};
  
    $upload->size;
    $upload->path;
    $upload->content_type;
    $upload->basename;
  
  =head1 METHODS
  
  =over 4
  
  =item size
  
  Returns the size of Uploaded file.
  
  =item path
  
  Returns the path to the temporary file where uploaded file is saved.
  
  =item content_type
  
  Returns the content type of the uploaded file.
  
  =item filename
  
  Returns the original filename in the client.
  
  =item basename
  
  Returns basename for "filename".
  
  =back
  
  =head1 AUTHORS
  
  Kazuhiro Osawa
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>, L<Catalyst::Request::Upload>
  
  =cut
PLACK_REQUEST_UPLOAD

$fatpacked{"Plack/Response.pm"} = <<'PLACK_RESPONSE';
  package Plack::Response;
  use strict;
  use warnings;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  use Plack::Util::Accessor qw(body status);
  use Carp ();
  use Scalar::Util ();
  use HTTP::Headers;
  use URI::Escape ();
  
  sub code    { shift->status(@_) }
  sub content { shift->body(@_)   }
  
  sub new {
      my($class, $rc, $headers, $content) = @_;
  
      my $self = bless {}, $class;
      $self->status($rc)       if defined $rc;
      $self->headers($headers) if defined $headers;
      $self->body($content)    if defined $content;
  
      $self;
  }
  
  sub headers {
      my $self = shift;
  
      if (@_) {
          my $headers = shift;
          if (ref $headers eq 'ARRAY') {
              Carp::carp("Odd number of headers") if @$headers % 2 != 0;
              $headers = HTTP::Headers->new(@$headers);
          } elsif (ref $headers eq 'HASH') {
              $headers = HTTP::Headers->new(%$headers);
          }
          return $self->{headers} = $headers;
      } else {
          return $self->{headers} ||= HTTP::Headers->new();
      }
  }
  
  sub cookies {
      my $self = shift;
      if (@_) {
          $self->{cookies} = shift;
      } else {
          return $self->{cookies} ||= +{ };
      }
  }
  
  sub header { shift->headers->header(@_) } # shortcut
  
  sub content_length {
      shift->headers->content_length(@_);
  }
  
  sub content_type {
      shift->headers->content_type(@_);
  }
  
  sub content_encoding {
      shift->headers->content_encoding(@_);
  }
  
  sub location {
      my $self = shift;
      return $self->headers->header('Location' => @_);
  }
  
  sub redirect {
      my $self = shift;
  
      if (@_) {
          my $url = shift;
          my $status = shift || 302;
          $self->location($url);
          $self->status($status);
      }
  
      return $self->location;
  }
  
  sub finalize {
      my $self = shift;
      Carp::croak "missing status" unless $self->status();
  
      my $headers = $self->headers->clone;
      $self->_finalize_cookies($headers);
  
      return [
          $self->status,
          +[
              map {
                  my $k = $_;
                  map {
                      my $v = $_;
                      $v =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
                      $v =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
  
                      ( $k => $v )
                  } $headers->header($_);
  
              } $headers->header_field_names
          ],
          $self->_body,
      ];
  }
  
  sub _body {
      my $self = shift;
      my $body = $self->body;
         $body = [] unless defined $body;
      if (!ref $body or Scalar::Util::blessed($body) && overload::Method($body, q("")) && !$body->can('getline')) {
          return [ $body ];
      } else {
          return $body;
      }
  }
  
  sub _finalize_cookies {
      my($self, $headers) = @_;
  
      while (my($name, $val) = each %{$self->cookies}) {
          my $cookie = $self->_bake_cookie($name, $val);
          $headers->push_header('Set-Cookie' => $cookie);
      }
  }
  
  sub _bake_cookie {
      my($self, $name, $val) = @_;
  
      return '' unless defined $val;
      $val = { value => $val } unless ref $val eq 'HASH';
  
      my @cookie = ( URI::Escape::uri_escape($name) . "=" . URI::Escape::uri_escape($val->{value}) );
      push @cookie, "domain=" . $val->{domain}   if $val->{domain};
      push @cookie, "path=" . $val->{path}       if $val->{path};
      push @cookie, "expires=" . $self->_date($val->{expires}) if $val->{expires};
      push @cookie, "secure"                     if $val->{secure};
      push @cookie, "HttpOnly"                   if $val->{httponly};
  
      return join "; ", @cookie;
  }
  
  my @MON  = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
  my @WDAY = qw( Sun Mon Tue Wed Thu Fri Sat );
  
  sub _date {
      my($self, $expires) = @_;
  
      if ($expires =~ /^\d+$/) {
          # all numbers -> epoch date
          # (cookies use '-' as date separator, HTTP uses ' ')
          my($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($expires);
          $year += 1900;
  
          return sprintf("%s, %02d-%s-%04d %02d:%02d:%02d GMT",
                         $WDAY[$wday], $mday, $MON[$mon], $year, $hour, $min, $sec);
  
      }
  
      return $expires;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Response - Portable HTTP Response object for PSGI response
  
  =head1 SYNOPSIS
  
    use Plack::Response;
  
    sub psgi_handler {
        my $env = shift;
  
        my $res = Plack::Response->new(200);
        $res->content_type('text/html');
        $res->body("Hello World");
  
        return $res->finalize;
    }
  
  =head1 DESCRIPTION
  
  Plack::Response allows you a way to create PSGI response array ref through a simple API.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $res = Plack::Response->new;
    $res = Plack::Response->new($status);
    $res = Plack::Response->new($status, $headers);
    $res = Plack::Response->new($status, $headers, $body);
  
  Creates a new Plack::Response object.
  
  =item status
  
    $res->status(200);
    $status = $res->status;
  
  Sets and gets HTTP status code. C<code> is an alias.
  
  =item headers
  
    $headers = $res->headers;
    $res->headers([ 'Content-Type' => 'text/html' ]);
    $res->headers({ 'Content-Type' => 'text/html' });
    $res->headers( HTTP::Headers->new );
  
  Sets and gets HTTP headers of the response. Setter can take either an
  array ref, a hash ref or L<HTTP::Headers> object containing a list of
  headers.
  
  =item body
  
    $res->body($body_str);
    $res->body([ "Hello", "World" ]);
    $res->body($io);
  
  Gets and sets HTTP response body. Setter can take either a string, an
  array ref, or an IO::Handle-like object. C<content> is an alias.
  
  Note that this method doesn't automatically set I<Content-Length> for
  the response. You have to set it manually if you want, with the
  C<content_length> method (see below).
  
  =item header
  
    $res->header('X-Foo' => 'bar');
    my $val = $res->header('X-Foo');
  
  Shortcut for C<< $res->headers->header >>.
  
  =item content_type, content_length, content_encoding
  
    $res->content_type('text/plain');
    $res->content_length(123);
    $res->content_encoding('gzip');
  
  Shortcut for the equivalent get/set methods in C<< $res->headers >>.
  
  =item redirect
  
    $res->redirect($url);
    $res->redirect($url, 301);
  
  Sets redirect URL with an optional status code, which defaults to 302.
  
  Note that this method doesn't normalize the given URI string. Users of
  this module have to be responsible about properly encoding URI paths
  and parameters.
  
  =item location
  
  Gets and sets C<Location> header.
  
  Note that this method doesn't normalize the given URI string in the
  setter. See above in C<redirect> for details.
  
  =item cookies
  
    $res->cookies->{foo} = 123;
    $res->cookies->{foo} = { value => '123' };
  
  Returns a hash reference containing cookies to be set in the
  response. The keys of the hash are the cookies' names, and their
  corresponding values are a plain string (for C<value> with everything
  else defaults) or a hash reference that can contain keys such as
  C<value>, C<domain>, C<expires>, C<path>, C<httponly>, C<secure>.
  
  C<expires> can take a string or an integer (as an epoch time) and
  B<does not> convert string formats such as C<+3M>.
  
    $res->cookies->{foo} = {
        value => 'test',
        path  => "/",
        domain => '.example.com',
        expires => time + 24 * 60 * 60,
    };
  
  =item finalize
  
    $res->finalize;
  
  Returns the status code, headers, and body of this response as a PSGI
  response array reference.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>
  
  =cut
PLACK_RESPONSE

$fatpacked{"Plack/Runner.pm"} = <<'PLACK_RUNNER';
  package Plack::Runner;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {
          env      => $ENV{PLACK_ENV},
          loader   => 'Plack::Loader',
          includes => [],
          modules  => [],
          @_,
      }, $class;
  }
  
  # delay the build process for reloader
  sub build(&;$) {
      my $block = shift;
      my $app   = shift || sub { };
      return sub { $block->($app->()) };
  }
  
  sub parse_options {
      my $self = shift;
  
      local @ARGV = @_;
  
      # From 'prove': Allow cuddling the paths with -I, -M and -e
      @ARGV = map { /^(-[IMe])(.+)/ ? ($1,$2) : $_ } @ARGV;
  
      my($host, $port, $socket, @listen);
  
      require Getopt::Long;
      my $parser = Getopt::Long::Parser->new(
          config => [ "no_ignore_case", "pass_through" ],
      );
  
      $parser->getoptions(
          "a|app=s"      => \$self->{app},
          "o|host=s"     => \$host,
          "p|port=i"     => \$port,
          "s|server=s"   => \$self->{server},
          "S|socket=s"   => \$socket,
          'l|listen=s@'  => \@listen,
          'D|daemonize'  => \$self->{daemonize},
          "E|env=s"      => \$self->{env},
          "e=s"          => \$self->{eval},
          'I=s@'         => $self->{includes},
          'M=s@'         => $self->{modules},
          'r|reload'     => sub { $self->{loader} = "Restarter" },
          'R|Reload=s'   => sub { $self->{loader} = "Restarter"; $self->loader->watch(split ",", $_[1]) },
          'L|loader=s'   => \$self->{loader},
          "access-log=s" => \$self->{access_log},
          "h|help"       => \$self->{help},
          "v|version"    => \$self->{version},
      );
  
      my(@options, @argv);
      while (defined(my $arg = shift @ARGV)) {
          if ($arg =~ s/^--?//) {
              my @v = split '=', $arg, 2;
              $v[0] =~ tr/-/_/;
              if (@v == 2) {
                  push @options, @v;
              } elsif ($v[0] =~ s/^(disable|enable)_//) {
                  push @options, $v[0], $1 eq 'enable';
              } else {
                  push @options, $v[0], shift @ARGV;
              }
          } else {
              push @argv, $arg;
          }
      }
  
      push @options, $self->mangle_host_port_socket($host, $port, $socket, @listen);
      push @options, daemonize => 1 if $self->{daemonize};
  
      $self->{options} = \@options;
      $self->{argv}    = \@argv;
  }
  
  sub set_options {
      my $self = shift;
      push @{$self->{options}}, @_;
  }
  
  sub mangle_host_port_socket {
      my($self, $host, $port, $socket, @listen) = @_;
  
      for my $listen (reverse @listen) {
          if ($listen =~ /:\d+$/) {
              ($host, $port) = split /:/, $listen, 2;
              $host = undef if $host eq '';
          } else {
              $socket ||= $listen;
          }
      }
  
      unless (@listen) {
          if ($socket) {
              @listen = ($socket);
          } else {
              $port ||= 5000;
              @listen = ($host ? "$host:$port" : ":$port");
          }
      }
  
      return host => $host, port => $port, listen => \@listen, socket => $socket;
  }
  
  sub version_cb {
      my $self = shift;
      $self->{version_cb} || sub {
          require Plack;
          print "Plack $Plack::VERSION\n";
      };
  }
  
  sub setup {
      my $self = shift;
  
      if ($self->{help}) {
          require Pod::Usage;
          Pod::Usage::pod2usage(0);
      }
  
      if ($self->{version}) {
          $self->version_cb->();
          exit;
      }
  
      if (@{$self->{includes}}) {
          require lib;
          lib->import(@{$self->{includes}});
      }
  
      if ($self->{eval}) {
          push @{$self->{modules}}, 'Plack::Builder';
      }
  
      for (@{$self->{modules}}) {
          my($module, @import) = split /[=,]/;
          eval "require $module" or die $@;
          $module->import(@import);
      }
  }
  
  sub locate_app {
      my($self, @args) = @_;
  
      my $psgi = $self->{app} || $args[0];
  
      if (ref $psgi eq 'CODE') {
          return sub { $psgi };
      }
  
      if ($self->{eval}) {
          $self->loader->watch("lib");
          return build {
              no strict;
              no warnings;
              my $eval = "builder { $self->{eval};";
              $eval .= "Plack::Util::load_psgi(\$psgi);" if $psgi;
              $eval .= "}";
              eval $eval or die $@;
          };
      }
  
      $psgi ||= "app.psgi";
  
      require File::Basename;
      $self->loader->watch( File::Basename::dirname($psgi) . "/lib", $psgi );
      build { Plack::Util::load_psgi $psgi };
  }
  
  sub watch {
      my($self, @dir) = @_;
  
      push @{$self->{watch}}, @dir
          if $self->{loader} eq 'Restarter';
  }
  
  sub apply_middleware {
      my($self, $app, $class, @args) = @_;
  
      my $mw_class = Plack::Util::load_class($class, 'Plack::Middleware');
      build { $mw_class->wrap($_[0], @args) } $app;
  }
  
  sub prepare_devel {
      my($self, $app) = @_;
  
      $app = $self->apply_middleware($app, 'Lint');
      $app = $self->apply_middleware($app, 'StackTrace');
      if (!$ENV{GATEWAY_INTERFACE} and !$self->{access_log}) {
          $app = $self->apply_middleware($app, 'AccessLog');
      }
  
      push @{$self->{options}}, server_ready => sub {
          my($args) = @_;
          my $name  = $args->{server_software} || ref($args); # $args is $server
          my $host  = $args->{host} || 0;
          my $proto = $args->{proto} || 'http';
          print STDERR "$name: Accepting connections at $proto://$host:$args->{port}/\n";
      };
  
      $app;
  }
  
  sub loader {
      my $self = shift;
      $self->{_loader} ||= Plack::Util::load_class($self->{loader}, 'Plack::Loader')->new;
  }
  
  sub load_server {
      my($self, $loader) = @_;
  
      if ($self->{server}) {
          return $loader->load($self->{server}, @{$self->{options}});
      } else {
          return $loader->auto(@{$self->{options}});
      }
  }
  
  sub run {
      my $self = shift;
  
      unless (ref $self) {
          $self = $self->new;
          $self->parse_options(@_);
          return $self->run;
      }
  
      unless ($self->{options}) {
          $self->parse_options();
      }
  
      my @args = @_ ? @_ : @{$self->{argv}};
  
      $self->setup;
  
      my $app = $self->locate_app(@args);
  
      $ENV{PLACK_ENV} ||= $self->{env} || 'development';
      if ($ENV{PLACK_ENV} eq 'development') {
          $app = $self->prepare_devel($app);
      }
  
      if ($self->{access_log}) {
          open my $logfh, ">>", $self->{access_log}
              or die "open($self->{access_log}): $!";
          $logfh->autoflush(1);
          $app = $self->apply_middleware($app, 'AccessLog', logger => sub { $logfh->print( @_ ) });
      }
  
      my $loader = $self->loader;
      $loader->preload_app($app);
  
      my $server = $self->load_server($loader);
      $loader->run($server);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Runner - plackup core
  
  =head1 SYNOPSIS
  
    # Your bootstrap script
    use Plack::Runner;
    my $app = sub { ... };
  
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Runner is the core of L<plackup> runner script. You can create
  your own frontend to run your application or framework, munge command
  line options and pass that to C<run> method of this class.
  
  C<run> method does exactly the same thing as the L<plackup> script
  does, but one notable addition is that you can pass a PSGI application
  code reference directly with C<--app> option, rather than via C<.psgi>
  file path or with C<-e> switch. This would be useful if you want to
  make an installable PSGI application.
  
  Also, when C<-h> or C<--help> switch is passed, the usage text is
  automatically extracted from your own script using L<Pod::Usage>.
  
  =head1 NOTES
  
  Do not directly call this module from your C<.psgi>, since that makes
  your PSGI application unnecessarily depend on L<plackup> and won't run
  other backends like L<Plack::Handler::Apache2> or mod_psgi.
  
  If you I<really> want to make your C<.psgi> runnable as a standalone
  script, you can do this:
  
    my $app = sub { ... };
  
    unless (caller) {
        require Plack::Runner;
        my $runner = Plack::Runner->new;
        $runner->parse_options(@ARGV);
        return $runner->run($app);
    }
  
    return $app;
  
  B<WARNING>: this section used to recommend C<if (__FILE__ eq $0)> but
  it's known to be broken since Plack 0.9971, since C<$0> is now
  I<always> set to the .psgi file path even when you run it from
  plackup.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
  
PLACK_RUNNER

$fatpacked{"Plack/Server.pm"} = <<'PLACK_SERVER';
  package Plack::Server;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server - DEPRECATED. See Plack::Handler
  
  =head1 SEE ALSO
  
  L<Plack::Handler>
  
  =cut
  
PLACK_SERVER

$fatpacked{"Plack/Server/Apache1.pm"} = <<'PLACK_SERVER_APACHE1';
  package Plack::Server::Apache1;
  use strict;
  use parent qw(Plack::Handler::Apache1);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Apache1 or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Apache1 - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Apache1>.
  
  =cut
PLACK_SERVER_APACHE1

$fatpacked{"Plack/Server/Apache2.pm"} = <<'PLACK_SERVER_APACHE2';
  package Plack::Server::Apache2;
  use strict;
  use parent qw(Plack::Handler::Apache2);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Apache2 or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Apache2 - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Apache2>.
  
  =cut
PLACK_SERVER_APACHE2

$fatpacked{"Plack/Server/CGI.pm"} = <<'PLACK_SERVER_CGI';
  package Plack::Server::CGI;
  use strict;
  use parent qw(Plack::Handler::CGI);
  
  sub new {
      my $class = shift;
      print STDERR "Use of $class is deprecated. Use Plack::Handler::CGI or Plack::Loader to upgrade.\n";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::CGI - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::CGI>.
  
  =cut
PLACK_SERVER_CGI

$fatpacked{"Plack/Server/FCGI.pm"} = <<'PLACK_SERVER_FCGI';
  package Plack::Server::FCGI;
  use strict;
  use parent qw(Plack::Handler::FCGI);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::FCGI or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::FCGI - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::FCGI>.
  
  =cut
PLACK_SERVER_FCGI

$fatpacked{"Plack/Server/ServerSimple.pm"} = <<'PLACK_SERVER_SERVERSIMPLE';
  package Plack::Server::ServerSimple;
  use strict;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  use parent qw(Plack::Handler::HTTP::Server::Simple);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "$class is deprecated. Use -s HTTP::Server::Simple";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::ServerSimple - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<DEPRECATED>. Use Plack::Handler::HTTP::Server::Simple.
  
  =cut
PLACK_SERVER_SERVERSIMPLE

$fatpacked{"Plack/Server/Standalone.pm"} = <<'PLACK_SERVER_STANDALONE';
  package Plack::Server::Standalone;
  use strict;
  use parent qw(Plack::Handler::Standalone);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Standalone or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Standalone - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Standalone>.
  
  =cut
PLACK_SERVER_STANDALONE

$fatpacked{"Plack/Server/Standalone/Prefork.pm"} = <<'PLACK_SERVER_STANDALONE_PREFORK';
  package Plack::Server::Standalone::Prefork;
  use strict;
  use parent qw(HTTP::Server::PSGI); # because Standalone is a wrapper
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Starman or Starlet for preforking servers.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Standalone::Prefork - DEPRECATED use Starman or Starlet instead
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>.
  
  =head1 SEE ALSO
  
  L<HTTP::Server::PSGI> L<Starman> L<Starlet>
  
  =cut
PLACK_SERVER_STANDALONE_PREFORK

$fatpacked{"Plack/TempBuffer.pm"} = <<'PLACK_TEMPBUFFER';
  package Plack::TempBuffer;
  use strict;
  use warnings;
  use Plack::Util;
  use FileHandle; # for seek etc.
  
  our $MaxMemoryBufferSize = 1024 * 1024;
  
  sub new {
      my($class, $length) = @_;
  
      # $MaxMemoryBufferSize = 0  -> Always temp file
      # $MaxMemoryBufferSize = -1 -> Always PerlIO
      my $backend;
      if ($MaxMemoryBufferSize < 0) {
          $backend = "PerlIO";
      } elsif ($MaxMemoryBufferSize == 0) {
          $backend = "File";
      } elsif (!$length) {
          $backend = "Auto";
      } elsif ($length > $MaxMemoryBufferSize) {
          $backend = "File";
      } else {
          $backend = "PerlIO";
      }
  
      $class->create($backend, $length, $MaxMemoryBufferSize);
  }
  
  sub create {
      my($class, $backend, $length, $max) = @_;
      Plack::Util::load_class($backend, $class)->new($length, $max);
  }
  
  sub print;
  sub rewind;
  sub size;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::TempBuffer - temporary buffer to save bytes
  
  =head1 SYNOPSIS
  
    my $buf = Plack::TempBuffer->new($length);
    $buf->print($bytes);
  
    my $size = $buf->size;
    my $fh   = $buf->rewind;
  
  =head1 DESCRIPTION
  
  Plack::TempBuffer is a buffer class to store arbitrary length of byte
  strings and then get a seekable filehandle once everything is
  buffered. It uses PerlIO and/or temporary file to save the buffer
  depending on the length of the size.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Request>
  
  =cut
  
PLACK_TEMPBUFFER

$fatpacked{"Plack/TempBuffer/Auto.pm"} = <<'PLACK_TEMPBUFFER_AUTO';
  package Plack::TempBuffer::Auto;
  use strict;
  use parent 'Plack::TempBuffer';
  
  sub new {
      my($class, undef, $max_memory_size) = @_;
      bless {
          _buffer => Plack::TempBuffer->create('PerlIO'),
          _max => $max_memory_size,
      }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{_buffer}->print(@_);
  
      if ($self->{_max} && $self->{_buffer}->size > $self->{_max}) {
          my $buf = $self->{_buffer}->{buffer};
          $self->{_buffer} = Plack::TempBuffer->create('File'),
          $self->{_buffer}->print($buf);
          delete $self->{_max};
      }
  }
  
  sub size {
      my $self = shift;
      $self->{_buffer}->size;
  }
  
  sub rewind {
      my $self = shift;
      $self->{_buffer}->rewind;
  }
  
  1;
PLACK_TEMPBUFFER_AUTO

$fatpacked{"Plack/TempBuffer/File.pm"} = <<'PLACK_TEMPBUFFER_FILE';
  package Plack::TempBuffer::File;
  use strict;
  use parent 'Plack::TempBuffer';
  
  use IO::File;
  
  sub new {
      my $class = shift;
  
      my $fh = IO::File->new_tmpfile;
      $fh->binmode;
  
      bless { fh => $fh }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{fh}->print(@_);
  }
  
  sub size {
      my $self = shift;
      $self->{fh}->flush;
      -s $self->{fh};
  }
  
  sub rewind {
      my $self = shift;
      $self->{fh}->seek(0, 0);
      $self->{fh};
  }
  
  1;
PLACK_TEMPBUFFER_FILE

$fatpacked{"Plack/TempBuffer/PerlIO.pm"} = <<'PLACK_TEMPBUFFER_PERLIO';
  package Plack::TempBuffer::PerlIO;
  use strict;
  use parent 'Plack::TempBuffer';
  
  sub new {
      my $class = shift;
      bless { buffer => '' }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{buffer} .= "@_";
  }
  
  sub size {
      my $self = shift;
      length $self->{buffer};
  }
  
  sub rewind {
      my $self = shift;
      my $buffer = $self->{buffer};
      open my $io, "<", \$buffer;
      bless $io, 'FileHandle'; # This makes $io work as FileHandle under 5.8, .10 and .11 :/
      return $io;
  }
  
  1;
PLACK_TEMPBUFFER_PERLIO

$fatpacked{"Plack/Test.pm"} = <<'PLACK_TEST';
  package Plack::Test;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw(test_psgi);
  
  our $Impl;
  $Impl ||= $ENV{PLACK_TEST_IMPL} || "MockHTTP";
  
  sub test_psgi {
      eval "require Plack::Test::$Impl;";
      die $@ if $@;
      no strict 'refs';
      if (ref $_[0] && @_ == 2) {
          @_ = (app => $_[0], client => $_[1]);
      }
      &{"Plack::Test::$Impl\::test_psgi"}(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test - Test PSGI applications with various backends
  
  =head1 SYNOPSIS
  
    use Plack::Test;
  
    # named params
    test_psgi
        app => sub {
            my $env = shift;
            return [ 200, [ 'Content-Type' => 'text/plain' ], [ "Hello World" ] ],
        },
        client => sub {
            my $cb  = shift;
            my $req = HTTP::Request->new(GET => "http://localhost/hello");
            my $res = $cb->($req);
            like $res->content, qr/Hello World/;
        };
  
     use HTTP::Request::Common;
  
     # positional params (app, client)
     my $app = sub { return [ 200, [], [ "Hello "] ] };
     test_psgi $app, sub {
         my $cb  = shift;
         my $res = $cb->(GET "/");
         is $res->content, "Hello";
     };
  
  
  =head1 DESCRIPTION
  
  Plack::Test is a unified interface to test PSGI applications using
  L<HTTP::Request> and L<HTTP::Response> objects. It also allows you to run PSGI
  applications in various ways. The default backend is C<Plack::Test::MockHTTP>,
  but you may also use any L<Plack::Handler> implementation to run live HTTP
  requests against at web server
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item test_psgi
  
    test_psgi $app, $client;
    test_psgi app => $app, client => $client;
  
  Runs the client test code C<$client> against a PSGI application
  C<$app>. The client callback gets one argument C<$cb>, a
  callback that accepts an C<HTTP::Request> object and returns an
  C<HTTP::Response> object.
  
  Use L<HTTP::Request::Common> to import shortcuts for creating requests for
  C<GET>, C<POST>, C<DELETE>, and C<PUT> operations.
  
  For your convenience, the C<HTTP::Request> given to the callback automatically
  uses the HTTP protocol and the localhost (I<127.0.0.1> by default), so the
  following code just works:
  
    use HTTP::Request::Common;
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/hello");
    };
  
  Note that however, it is not a good idea to pass an arbitrary
  (i.e. user-input) string to C<GET> or even C<<
  HTTP::Request->new >> by assuming that it always represents a path,
  because:
  
    my $req = GET "//foo/bar";
  
  would represent a request for a URL that has no scheme, has a hostname
  I<foo> and a path I</bar>, instead of a path I<//foo/bar> which you
  might actually want.
  
  =back
  
  =head1 OPTIONS
  
  Specify the L<Plack::Test> backend using the environment
  variable C<PLACK_TEST_IMPL> or C<$Plack::Test::Impl> package variable.
  
  The available values for the backend are:
  
  =over 4
  
  =item MockHTTP
  
  (Default) Creates a PSGI env hash out of HTTP::Request object, runs
  the PSGI application in-process and returns HTTP::Response.
  
  =item Server
  
  Runs one of Plack::Handler backends (C<Standalone> by default) and
  sends live HTTP requests to test.
  
  =item ExternalServer
  
  Runs tests against an external server specified in the
  C<PLACK_TEST_EXTERNALSERVER_URI> environment variable instead of spawning the
  application in a server locally.
  
  =back
  
  For instance, test your application with the C<HTTP::Server::ServerSimple>
  server backend with:
  
    > env PLACK_TEST_IMPL=Server PLACK_SERVER=HTTP::Server::ServerSimple \
      prove -l t/test.t
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_TEST

$fatpacked{"Plack/Test/MockHTTP.pm"} = <<'PLACK_TEST_MOCKHTTP';
  package Plack::Test::MockHTTP;
  use strict;
  use warnings;
  
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use HTTP::Message::PSGI;
  use Try::Tiny;
  
  sub test_psgi {
      my %args = @_;
  
      my $client = delete $args{client} or croak "client test code needed";
      my $app    = delete $args{app}    or croak "app needed";
  
      my $cb = sub {
          my $req = shift;
          $req->uri->scheme('http')    unless defined $req->uri->scheme;
          $req->uri->host('localhost') unless defined $req->uri->host;
          my $env = $req->to_psgi;
  
          my $res = try {
              HTTP::Response->from_psgi($app->($env));
          } catch {
              HTTP::Response->from_psgi([ 500, [ 'Content-Type' => 'text/plain' ], [ $_ ] ]);
          };
  
          $res->request($req);
          return $res;
      };
  
      $client->($cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::MockHTTP - Run mocked HTTP tests through PSGI applications
  
  =head1 DESCRIPTION
  
  Plack::Test::MockHTTP is a utility to run PSGI application given
  HTTP::Request objects and return HTTP::Response object out of PSGI
  application response. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Test>
  
  =cut
  
  
PLACK_TEST_MOCKHTTP

$fatpacked{"Plack/Test/Server.pm"} = <<'PLACK_TEST_SERVER';
  package Plack::Test::Server;
  use strict;
  use warnings;
  use Carp;
  use LWP::UserAgent;
  use Test::TCP;
  use Plack::Loader;
  
  sub test_psgi {
      my %args = @_;
  
      my $client = delete $args{client} or croak "client test code needed";
      my $app    = delete $args{app}    or croak "app needed";
      my $ua     = delete $args{ua} || LWP::UserAgent->new;
  
      test_tcp(
          client => sub {
              my $port = shift;
              my $cb = sub {
                  my $req = shift;
                  $req->uri->scheme('http');
                  $req->uri->host($args{host} || '127.0.0.1');
                  $req->uri->port($port);
                  return $ua->request($req);
              };
              $client->($cb);
          },
          server => $args{server} || sub {
              my $port = shift;
              my $server = Plack::Loader->auto(port => $port, host => ($args{host} || '127.0.0.1'));
              $server->run($app);
          },
      );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::Server - Run HTTP tests through live Plack servers
  
  =head1 DESCRIPTION
  
  Plack::Test::Server is a utility to run PSGI application with Plack
  server implementations, and run the live HTTP tests with the server
  using a callback. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Loader> L<Test::TCP> L<Plack::Test>
  
  =cut
  
PLACK_TEST_SERVER

$fatpacked{"Plack/Test/Suite.pm"} = <<'PLACK_TEST_SUITE';
  package Plack::Test::Suite;
  use strict;
  use warnings;
  use Digest::MD5;
  use File::ShareDir;
  use HTTP::Request;
  use HTTP::Request::Common;
  use LWP::UserAgent;
  use Test::More;
  use Test::TCP;
  use Plack::Loader;
  use Plack::Middleware::Lint;
  use Plack::Util;
  use Plack::Request;
  use Try::Tiny;
  
  my $share_dir = try { File::ShareDir::dist_dir('Plack') } || 'share';
  
  $ENV{PLACK_TEST_SCRIPT_NAME} = '';
  
  # 0: test name
  # 1: request generator coderef.
  # 2: request handler
  # 3: test case for response
  our @TEST = (
      [
          'SCRIPT_NAME',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME};
          },
          sub {
              my $env = shift;
              return [ 200, ["Content-Type", "text/plain"], [ $env->{SCRIPT_NAME} ] ];
          },
      ],
      [
          'GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ 'Hello, ' . $env->{QUERY_STRING} ],
              ];
          },
      ],
      [
          'POST',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/", [name => 'tatsuhiko']);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), 14;
              is $res->header('Client-Content-Type'), 'application/x-www-form-urlencoded';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=tatsuhiko';
          },
          sub {
              my $env = shift;
              my $body;
              $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH});
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ 'Hello, ' . $body ],
              ];
          },
      ],
      [
          'big POST',
          sub {
              my $cb = shift;
              my $chunk = "abcdefgh" x 12000;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content_length(length $chunk);
              $req->content_type('application/octet-stream');
              $req->content($chunk);
  
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), length $chunk;
              is length $res->content, length $chunk;
              is Digest::MD5::md5_hex($res->content), Digest::MD5::md5_hex($chunk);
          },
          sub {
              my $env = shift;
              my $len = $env->{CONTENT_LENGTH};
              my $body = '';
              my $spin;
              while ($len > 0) {
                  my $rc = $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH}, length $body);
                  $len -= $rc;
                  last if $spin++ > 2000;
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ $body ],
              ];
          },
      ],
      [
          'psgi.url_scheme',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'http';
          },
          sub {
              my $env = $_[0];
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{'psgi.url_scheme'} ],
              ];
          },
      ],
      [
          'return glob',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr/^package /;
              like $res->content, qr/END_MARK_FOR_TESTING$/;
          },
          sub {
              my $env = shift;
              open my $fh, '<', __FILE__ or die $!;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  $fh,
              ];
          },
      ],
      [
          'filehandle',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'bigger file',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/baybridge.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 79838;
              is Digest::MD5::md5_hex($res->content), '983726ae0e4ce5081bef5fb2b7216950';
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/baybridge.jpg";
              binmode $fh;
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'handle HTTP-Header',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Foo => "Bar");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_FOO}],
              ];
          },
      ],
      [
          'handle HTTP-Cookie',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Cookie => "foo");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'foo';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_COOKIE}],
              ];
          },
      ],
      [
          'validate env',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, join("\n",
                  'REQUEST_METHOD:GET',
                  "SCRIPT_NAME:$ENV{PLACK_TEST_SCRIPT_NAME}",
                  'PATH_INFO:/foo/',
                  'QUERY_STRING:dankogai=kogaidan',
                  'SERVER_NAME:127.0.0.1',
                  "SERVER_PORT:" . $res->request->uri->port,
              )."\n";
          },
          sub {
              my $env = shift;
              my $body;
              $body .= $_ . ':' . $env->{$_} . "\n" for qw/REQUEST_METHOD SCRIPT_NAME PATH_INFO QUERY_STRING SERVER_NAME SERVER_PORT/;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$body],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%2cbaz");
              is $res->content, "/foo/bar,baz", "PATH_INFO should be decoded per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% double encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%252cbaz");
              is $res->content, "/foo/bar%2cbaz", "PATH_INFO should be decoded only once, per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO (outside of URI characters)',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo%E3%81%82");
              is $res->content, "/foo\x{e3}\x{81}\x{82}";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          'SERVER_PROTOCOL is required',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr{^HTTP/1\.[01]$};
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{SERVER_PROTOCOL}],
              ];
          },
      ],
      [
          'SCRIPT_NAME should not be undef',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $cont = defined $env->{'SCRIPT_NAME'};
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$cont],
              ];
          },
      ],
      [
          'call close after read IO::Handle-like',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/call_close");
              is($res->content, '1234');
          },
          sub {
              my $env = shift;
              {
                  our $closed = -1;
                  sub CalledClose::new { $closed = 0; my $i=0; bless \$i, 'CalledClose' }
                  sub CalledClose::getline {
                      my $self = shift;
                      return $$self++ < 4 ? $$self : undef;
                  }
                  sub CalledClose::close { ::ok(1, 'closed') if defined &::ok }
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  CalledClose->new(),
              ];
          },
      ],
      [
          'has errors',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/has_errors");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $err = $env->{'psgi.errors'};
              my $has_errors = defined $err;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$has_errors]
              ];
          },
      ],
      [
          'status line',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is($res->status_line, '200 OK');
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [1]
              ];
          },
      ],
      [
          'Do not crash when the app dies',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 500;
              is $res->message, 'Internal Server Error';
          },
          sub {
              my $env = shift;
              open my $io, '>', \my $error;
              $env->{'psgi.errors'} = $io;
              die "Throwing an exception from app handler. Server shouldn't crash.";
          },
      ],
      [
          'multi headers (request)',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Foo => "bar");
              $req->push_header(Foo => "baz");
              my $res = $cb->($req);
              like($res->content, qr/^bar,\s*baz$/);
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{HTTP_FOO} ]
              ];
          },
      ],
      [
          'multi headers (response)',
          sub {
              my $cb  = shift;
              my $res = $cb->(HTTP::Request->new(GET => "http://127.0.0.1/"));
              my $foo = $res->header('X-Foo');
              like $foo, qr/foo,\s*bar,\s*baz/;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Foo', 'foo', 'X-Foo', 'bar, baz' ],
                  [ 'hi' ]
              ];
          },
      ],
      [
          'Do not set $env->{COOKIE}',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Cookie => "foo=bar");
              my $res = $cb->($req);
              is($res->header('X-Cookie'), 0);
              is $res->content, 'foo=bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Cookie' => $env->{COOKIE} ? 1 : 0 ],
                  [ $env->{HTTP_COOKIE} ]
              ];
          },
      ],
      [
          'no entity headers on 304',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 304;
              is $res->message, 'Not Modified';
              is $res->content, '';
              ok ! defined $res->header('content_type'), "No Content-Type";
              ok ! defined $res->header('content_length'), "No Content-Length";
              ok ! defined $res->header('transfer_encoding'), "No Transfer-Encoding";
          },
          sub {
              my $env = shift;
              return [ 304, [], [] ];
          },
      ],
      [
          'REQUEST_URI is set',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%20baz%73?x=a");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME} . "/foo/bar%20baz%73?x=a";
          },
          sub {
              my $env = shift;
              return [ 200, [ 'Content-Type' => 'text/plain' ], [ $env->{REQUEST_URI} ] ];
          },
      ],
      [
          'filehandle with path()',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              Plack::Util::set_io_path($fh, "$share_dir/face.jpg");
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'a big header value > 128 bytes',
          sub {
              my $cb  = shift;
              my $req = GET "http://127.0.0.1/";
              my $v = ("abcdefgh" x 16);
              $req->header('X-Foo' => $v);
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->content, $v;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain' ],
                  [ $env->{HTTP_X_FOO} ],
              ];
          },
      ],
      [
          'coderef res',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
              return sub {
                  my $respond = shift;
                  $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                      [ 'Hello, ' . $env->{QUERY_STRING} ],
                  ]);
              }
          },
      ],
      [
          'coderef streaming',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
  
              return sub {
                  my $respond = shift;
  
                  my $writer = $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                  ]);
  
                  $writer->write("Hello, ");
                  $writer->write($env->{QUERY_STRING});
                  $writer->close();
              }
          },
      ],
      [
          'CRLF output and FCGI parse bug',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
  
              is $res->header("Foo"), undef;
              is $res->content, "Foo: Bar\r\n\r\nHello World";
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Foo: Bar\r\n\r\nHello World" ] ];
          },
      ],
      [
          'newlines',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is length($res->content), 7;
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Bar\nBaz" ] ];
          },
      ],
      [
          'test 404',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 404;
              is $res->message, 'Not Found';
              is $res->content, 'Not Found';
          },
          sub {
              return [ 404, [ "Content-Type", "text/plain" ], [ "Not Found" ] ];
          },
      ],
      [
          'request->input seekable',
          sub {
              my $cb = shift;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content("body");
              $req->content_type('text/plain');
              $req->content_length(4);
              my $res = $cb->($req);
              is $res->content, 'body';
          },
          sub {
              my $req = Plack::Request->new(shift);
              return [ 200, [ "Content-Type", "text/plain" ], [ $req->content ] ];
          },
      ],
      [
          'request->content on GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              ok $res->is_success;
          },
          sub {
              my $req = Plack::Request->new(shift);
              $req->content;
              return [ 200, [ "Content-Type", "text/plain" ], [ "OK" ] ];
          },
      ],
      [
          'handle Authorization header',
          sub {
              my $cb  = shift;
              SKIP: {
                  skip "Authorization header is unsupported under CGI", 4 if ($ENV{PLACK_TEST_HANDLER} || "") eq "CGI";
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      $req->push_header(Authorization => 'Basic XXXX');
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 1;
                      is $res->content, 'Basic XXXX';
                  };
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 0;
                      is $res->content, '';
                  };
              };
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-AUTHORIZATION' => exists($env->{HTTP_AUTHORIZATION}) ? 1 : 0 ],
                  [ $env->{HTTP_AUTHORIZATION} || '' ],
              ];
          },
      ],
      [
          'repeated slashes',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1//foo///bar/baz");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, '//foo///bar/baz';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
  );
  
  sub runtests {
      my($class, $runner) = @_;
      for my $test (@TEST) {
          $runner->(@$test);
      }
  }
  
  sub run_server_tests {
      my($class, $server, $server_port, $http_port, %args) = @_;
  
      if (ref $server ne 'CODE') {
          my $server_class = $server;
          $server = sub {
              my($port, $app) = @_;
              my $server = Plack::Loader->load($server_class, port => $port, host => "127.0.0.1", %args);
              $app = Plack::Middleware::Lint->wrap($app);
              $server->run($app);
          }
      }
  
      test_tcp(
          client => sub {
              my $port = shift;
  
              my $ua = LWP::UserAgent->new;
              for my $i (0..$#TEST) {
                  my $test = $TEST[$i];
                  note $test->[0];
                  my $cb = sub {
                      my $req = shift;
                      $req->uri->port($http_port || $port);
                      $req->uri->path(($ENV{PLACK_TEST_SCRIPT_NAME}||"") . $req->uri->path);
                      $req->header('X-Plack-Test' => $i);
                      return $ua->request($req);
                  };
  
                  $test->[1]->($cb);
              }
          },
          server => sub {
              my $port = shift;
              my $app  = $class->test_app_handler;
              $server->($port, $app);
              exit(0); # for Test::TCP
          },
          port => $server_port,
      );
  }
  
  sub test_app_handler {
      return sub {
          my $env = shift;
          $TEST[$env->{HTTP_X_PLACK_TEST}][2]->($env);
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Test::Suite - Test suite for Plack handlers
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Plack::Test::Suite;
    Plack::Test::Suite->run_server_tests('Your::Handler');
    done_testing;
  
  =head1 DESCRIPTION
  
  Plack::Test::Suite is a test suite to test a new PSGI server
  implementation. It automatically loads a new handler environment and
  uses LWP to send HTTP requests to the local server to make sure your
  handler implements the PSGI specification correctly.
  
  Note that the handler name doesn't include the C<Plack::Handler::>
  prefix, i.e. if you have a new Plack handler Plack::Handler::Foo, your
  test script would look like:
  
    Plack::Test::Suite->run_server_tests('Foo');
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  Kazuho Oku
  
  =cut
  
  END_MARK_FOR_TESTING
PLACK_TEST_SUITE

$fatpacked{"Plack/Util.pm"} = <<'PLACK_UTIL';
  package Plack::Util;
  use strict;
  use Carp ();
  use Scalar::Util;
  use IO::Handle;
  use overload ();
  
  sub TRUE()  { 1==1 }
  sub FALSE() { !TRUE }
  
  sub load_class {
      my($class, $prefix) = @_;
  
      if ($prefix) {
          unless ($class =~ s/^\+// || $class =~ /^$prefix/) {
              $class = "$prefix\::$class";
          }
      }
  
      my $file = $class;
      $file =~ s!::!/!g;
      require "$file.pm"; ## no critic
  
      return $class;
  }
  
  sub is_real_fh ($) {
      my $fh = shift;
  
      {
          no warnings 'uninitialized';
          return FALSE if -p $fh or -c _ or -b _;
      }
  
      my $reftype = Scalar::Util::reftype($fh) or return;
      if (   $reftype eq 'IO'
          or $reftype eq 'GLOB' && *{$fh}{IO}
      ) {
          # if it's a blessed glob make sure to not break encapsulation with
          # fileno($fh) (e.g. if you are filtering output then file descriptor
          # based operations might no longer be valid).
          # then ensure that the fileno *opcode* agrees too, that there is a
          # valid IO object inside $fh either directly or indirectly and that it
          # corresponds to a real file descriptor.
          my $m_fileno = $fh->fileno;
          return FALSE unless defined $m_fileno;
          return FALSE unless $m_fileno >= 0;
  
          my $f_fileno = fileno($fh);
          return FALSE unless defined $f_fileno;
          return FALSE unless $f_fileno >= 0;
          return TRUE;
      } else {
          # anything else, including GLOBS without IO (even if they are blessed)
          # and non GLOB objects that look like filehandle objects cannot have a
          # valid file descriptor in fileno($fh) context so may break.
          return FALSE;
      }
  }
  
  sub set_io_path {
      my($fh, $path) = @_;
      bless $fh, 'Plack::Util::IOWithPath';
      $fh->path($path);
  }
  
  sub content_length {
      my $body = shift;
  
      return unless defined $body;
  
      if (ref $body eq 'ARRAY') {
          my $cl = 0;
          for my $chunk (@$body) {
              $cl += length $chunk;
          }
          return $cl;
      } elsif ( is_real_fh($body) ) {
          return (-s $body) - tell($body);
      }
  
      return;
  }
  
  sub foreach {
      my($body, $cb) = @_;
  
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      } else {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
  }
  
  sub class_to_file {
      my $class = shift;
      $class =~ s!::!/!g;
      $class . ".pm";
  }
  
  sub _load_sandbox {
      my $_file = shift;
  
      my $_package = $_file;
      $_package =~ s/([^A-Za-z0-9_])/sprintf("_%2x", unpack("C", $1))/eg;
  
      _file_zero_check($_file) if $ENV{PLACK_ENV} eq 'development';
  
      local $0 = $_file; # so FindBin etc. works
      local @ARGV = ();  # Some frameworks might try to parse @ARGV
  
      return eval sprintf <<'END_EVAL', $_package;
  package Plack::Sandbox::%s;
  {
      my $app = do $_file;
      if ( !$app && ( my $error = $@ || $! )) { die $error; }
      $app;
  }
  END_EVAL
  }
  
  sub _file_zero_check {
      my $file = shift;
      open my $fh, "<", $file or return;
  
      my $code = join '', <$fh>;
      if ($code =~ /(__FILE__\s+eq\s+\$0|\$0\s+eq\s+__FILE__)/) {
          warn <<WARNING
  Your PSGI file ($file) seems to use the following idiom, which is known to be broken since Plack 0.9971:
  
    if ($1) {
        called_from_cmdline();
    }
  
  because now \$0 is _always_ localized to the PSGI file path you're evaluating. You should switch to other alternatives such as `unless (caller) {}`. See http://bit.ly/psgi-file-0 for details.
  
  This friendly warning and the code to generate this runs only when the Plack environment (-E) is set to 'development', and will go away in the next major release of Plack.
  
  WARNING
      }
  }
  
  sub load_psgi {
      my $stuff = shift;
  
      local $ENV{PLACK_ENV} = $ENV{PLACK_ENV} || 'development';
  
      my $file = $stuff =~ /^[a-zA-Z0-9\_\:]+$/ ? class_to_file($stuff) : $stuff;
      my $app = _load_sandbox($file);
      die "Error while loading $file: $@" if $@;
  
      return $app->to_app if $app and Scalar::Util::blessed($app) and $app->can('to_app');
      return $app;
  }
  
  sub run_app($$) {
      my($app, $env) = @_;
  
      return eval { $app->($env) } || do {
          my $body = "Internal Server Error";
          $env->{'psgi.errors'}->print($@);
          [ 500, [ 'Content-Type' => 'text/plain', 'Content-Length' => length($body) ], [ $body ] ];
      };
  }
  
  sub headers {
      my $headers = shift;
      inline_object(
          iter   => sub { header_iter($headers, @_) },
          get    => sub { header_get($headers, @_) },
          set    => sub { header_set($headers, @_) },
          push   => sub { header_push($headers, @_) },
          exists => sub { header_exists($headers, @_) },
          remove => sub { header_remove($headers, @_) },
          headers => sub { $headers },
      );
  }
  
  sub header_iter {
      my($headers, $code) = @_;
  
      my @headers = @$headers; # copy
      while (my($key, $val) = splice @headers, 0, 2) {
          $code->($key, $val);
      }
  }
  
  sub header_get {
      my($headers, $key) = (shift, lc shift);
  
      my @val;
      header_iter $headers, sub {
          push @val, $_[1] if lc $_[0] eq $key;
      };
  
      return wantarray ? @val : $val[0];
  }
  
  sub header_set {
      my($headers, $key, $val) = @_;
  
      my($set, @new_headers);
      header_iter $headers, sub {
          if (lc $key eq lc $_[0]) {
              return if $set;
              $_[1] = $val;
              $set++;
          }
          push @new_headers, $_[0], $_[1];
      };
  
      push @new_headers, $key, $val unless $set;
      @$headers = @new_headers;
  }
  
  sub header_push {
      my($headers, $key, $val) = @_;
      push @$headers, $key, $val;
  }
  
  sub header_exists {
      my($headers, $key) = (shift, lc shift);
  
      my $exists;
      header_iter $headers, sub {
          $exists = 1 if lc $_[0] eq $key;
      };
  
      return $exists;
  }
  
  sub header_remove {
      my($headers, $key) = (shift, lc shift);
  
      my @new_headers;
      header_iter $headers, sub {
          push @new_headers, $_[0], $_[1]
              unless lc $_[0] eq $key;
      };
  
      @$headers = @new_headers;
  }
  
  sub status_with_no_entity_body {
      my $status = shift;
      return $status < 200 || $status == 204 || $status == 304;
  }
  
  sub encode_html {
      my $str = shift;
      $str =~ s/&/&amp;/g;
      $str =~ s/>/&gt;/g;
      $str =~ s/</&lt;/g;
      $str =~ s/"/&quot;/g;
      $str =~ s/'/&#39;/g;
      return $str;
  }
  
  sub inline_object {
      my %args = @_;
      bless \%args, 'Plack::Util::Prototype';
  }
  
  sub response_cb {
      my($res, $cb) = @_;
  
      my $body_filter = sub {
          my($cb, $res) = @_;
          my $filter_cb = $cb->($res);
          # If response_cb returns a callback, treat it as a $body filter
          if (defined $filter_cb && ref $filter_cb eq 'CODE') {
              Plack::Util::header_remove($res->[1], 'Content-Length');
              if (defined $res->[2]) {
                  if (ref $res->[2] eq 'ARRAY') {
                      for my $line (@{$res->[2]}) {
                          $line = $filter_cb->($line);
                      }
                      # Send EOF.
                      my $eof = $filter_cb->( undef );
                      push @{ $res->[2] }, $eof if defined $eof;
                  } else {
                      my $body    = $res->[2];
                      my $getline = sub { $body->getline };
                      $res->[2] = Plack::Util::inline_object
                          getline => sub { $filter_cb->($getline->()) },
                          close => sub { $body->close };
                  }
              } else {
                  return $filter_cb;
              }
          }
      };
  
      if (ref $res eq 'ARRAY') {
          $body_filter->($cb, $res);
          return $res;
      } elsif (ref $res eq 'CODE') {
          return sub {
              my $respond = shift;
              my $cb = $cb;  # To avoid the nested closure leak for 5.8.x
              $res->(sub {
                  my $res = shift;
                  my $filter_cb = $body_filter->($cb, $res);
                  if ($filter_cb) {
                      my $writer = $respond->($res);
                      if ($writer) {
                          return Plack::Util::inline_object
                              write => sub { $writer->write($filter_cb->(@_)) },
                              close => sub {
                                  my $chunk = $filter_cb->(undef);
                                  $writer->write($chunk) if defined $chunk;
                                  $writer->close;
                              };
                      }
                  } else {
                      return $respond->($res);
                  }
              });
          };
      }
  
      return $res;
  }
  
  package Plack::Util::Prototype;
  
  our $AUTOLOAD;
  sub can {
      $_[0]->{$_[1]};
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $attr = $AUTOLOAD;
      $attr =~ s/.*://;
      if (ref($self->{$attr}) eq 'CODE') {
          $self->{$attr}->(@_);
      } else {
          Carp::croak(qq/Can't locate object method "$attr" via package "Plack::Util::Prototype"/);
      }
  }
  
  sub DESTROY { }
  
  package Plack::Util::IOWithPath;
  use parent qw(IO::Handle);
  
  sub path {
      my $self = shift;
      if (@_) {
          ${*$self}{+__PACKAGE__} = shift;
      }
      ${*$self}{+__PACKAGE__};
  }
  
  package Plack::Util;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util - Utility subroutines for Plack server and framework developers
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item TRUE, FALSE
  
    my $true  = Plack::Util::TRUE;
    my $false = Plack::Util::FALSE;
  
  Utility constants to include when you specify boolean variables in C<$env> hash (e.g. C<psgi.multithread>).
  
  =item load_class
  
    my $class = Plack::Util::load_class($class [, $prefix ]);
  
  Constructs a class name and C<require> the class. Throws an exception
  if the .pm file for the class is not found, just with the built-in
  C<require>.
  
  If C<$prefix> is set, the class name is prepended to the C<$class>
  unless C<$class> begins with C<+> sign, which means the class name is
  already fully qualified.
  
    my $class = Plack::Util::load_class("Foo");                   # Foo
    my $class = Plack::Util::load_class("Baz", "Foo::Bar");       # Foo::Bar::Baz
    my $class = Plack::Util::load_class("+XYZ::ZZZ", "Foo::Bar"); # XYZ::ZZZ
  
  =item is_real_fh
  
    if ( Plack::Util::is_real_fh($fh) ) { }
  
  returns true if a given C<$fh> is a real file handle that has a file
  descriptor. It returns false if C<$fh> is PerlIO handle that is not
  really related to the underlying file etc.
  
  =item content_length
  
    my $cl = Plack::Util::content_length($body);
  
  Returns the length of content from body if it can be calculated. If
  C<$body> is an array ref it's a sum of length of each chunk, if
  C<$body> is a real filehandle it's a remaining size of the filehandle,
  otherwise returns undef.
  
  =item set_io_path
  
    Plack::Util::set_io_path($fh, "/path/to/foobar.txt");
  
  Sets the (absolute) file path to C<$fh> filehandle object, so you can
  call C<< $fh->path >> on it. As a side effect C<$fh> is blessed to an
  internal package but it can still be treated as a normal file
  handle.
  
  This module doesn't normalize or absolutize the given path, and is
  intended to be used from Server or Middleware implementations. See
  also L<IO::File::WithPath>.
  
  =item foreach
  
    Plack::Util::foreach($body, $cb);
  
  Iterate through I<$body> which is an array reference or
  IO::Handle-like object and pass each line (which is NOT really
  guaranteed to be a I<line>) to the callback function.
  
  It internally sets the buffer length C<$/> to 4096 in case it reads
  the binary file, unless otherwise set in the caller's code.
  
  =item load_psgi
  
    my $app = Plack::Util::load_psgi $psgi_file_or_class;
  
  Load C<app.psgi> file or a class name (like C<MyApp::PSGI>) and
  require the file to get PSGI application handler. If the file can't be
  loaded (e.g. file doesn't exist or has a perl syntax error), it will
  throw an exception.
  
  B<Security>: If you give this function a class name or module name
  that is loadable from your system, it will load the module. This could
  lead to a security hole:
  
    my $psgi = ...; # user-input: consider "Moose.pm"
    $app = Plack::Util::load_psgi($psgi); # this does 'require "Moose.pm"'!
  
  Generally speaking, passing an external input to this function is
  considered very insecure. But if you really want to do that, be sure
  to validate the argument passed to this function. Also, if you do not
  want to accept an arbitrary class name but only load from a file path,
  make sure that the argument C<$psgi_file_or_class> begins with C</> so
  that Perl's built-in do function won't search the include path.
  
  =item run_app
  
    my $res = Plack::Util::run_app $app, $env;
  
  Runs the I<$app> by wrapping errors with I<eval> and if an error is
  found, logs it to C<< $env->{'psgi.errors'} >> and returns the
  template 500 Error response.
  
  =item header_get, header_exists, header_set, header_push, header_remove
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
  
    my $v = Plack::Util::header_get($hdrs, $key); # First found only
    my @v = Plack::Util::header_get($hdrs, $key);
    my $bool = Plack::Util::header_exists($hdrs, $key);
    Plack::Util::header_set($hdrs, $key, $val);   # overwrites existent header
    Plack::Util::header_push($hdrs, $key, $val);
    Plack::Util::header_remove($hdrs, $key);
  
  Utility functions to manipulate PSGI response headers array
  reference. The methods that read existent header value handles header
  name as case insensitive.
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
    my $v = Plack::Util::header_get($hdrs, 'content-type'); # 'text/plain'
  
  =item headers
  
    my $headers = [ 'Content-Type' => 'text/plain' ];
  
    my $h = Plack::Util::headers($headers);
    $h->get($key);
    if ($h->exists($key)) { ... }
    $h->set($key => $val);
    $h->push($key => $val);
    $h->remove($key);
    $h->headers; # same reference as $headers
  
  Given a header array reference, returns a convenient object that has
  an instance methods to access C<header_*> functions with an OO
  interface. The object holds a reference to the original given
  C<$headers> argument and updates the reference accordingly when called
  write methods like C<set>, C<push> or C<remove>. It also has C<headers>
  method that would return the same reference.
  
  =item status_with_no_entity_body
  
    if (status_with_no_entity_body($res->[0])) { }
  
  Returns true if the given status code doesn't have any Entity body in
  HTTP response, i.e. it's 100, 101, 204 or 304.
  
  =item inline_object
  
    my $o = Plack::Util::inline_object(
        write => sub { $h->push_write(@_) },
        close => sub { $h->push_shutdown },
    );
    $o->write(@stuff);
    $o->close;
  
  Creates an instant object that can react to methods passed in the
  constructor. Handy to create when you need to create an IO stream
  object for input or errors.
  
  =item response_cb
  
  See L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =cut
  
  
  
PLACK_UTIL

$fatpacked{"Plack/Util/Accessor.pm"} = <<'PLACK_UTIL_ACCESSOR';
  package Plack::Util::Accessor;
  use strict;
  use warnings;
  
  sub import {
      shift;
      return unless @_;
      my $package = caller();
      mk_accessors( $package, @_ );
  }
  
  sub mk_accessors {
      my $package = shift;
      no strict 'refs';
      foreach my $field ( @_ ) {
          *{ $package . '::' . $field } = sub {
              return $_[0]->{ $field } if scalar( @_ ) == 1;
              return $_[0]->{ $field }  = scalar( @_ ) == 2 ? $_[1] : [ @_[1..$#_] ];
          };
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util::Accessor - Accessor generation utility for Plack
  
  =head1 DESCRIPTION
  
  This module is just a simple accessor generator for Plack to replace
  the Class::Accessor::Fast usage and so our classes don't have to inherit
  from their accessor generator.
  
  =head1 SEE ALSO
  
  L<PSGI> L<http://plackperl.org/>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_UTIL_ACCESSOR

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  
  use strict;
  #use warnings;
  
  use vars qw(@EXPORT @EXPORT_OK $VERSION @ISA);
  
  BEGIN {
  	require Exporter;
  	@ISA = qw(Exporter);
  }
  
  $VERSION = "0.11";
  
  $VERSION = eval $VERSION;
  
  @EXPORT = @EXPORT_OK = qw(try catch finally);
  
  $Carp::Internal{+__PACKAGE__}++;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
  	my ( $try, @code_refs ) = @_;
  
  	# we need to save this here, the eval block will be in scalar context due
  	# to $failed
  	my $wantarray = wantarray;
  
  	my ( $catch, @finally );
  
  	# find labeled blocks in the argument list.
  	# catch and finally tag the blocks by blessing a scalar reference to them.
  	foreach my $code_ref (@code_refs) {
  		next unless $code_ref;
  
  		my $ref = ref($code_ref);
  
  		if ( $ref eq 'Try::Tiny::Catch' ) {
  			$catch = ${$code_ref};
  		} elsif ( $ref eq 'Try::Tiny::Finally' ) {
  			push @finally, ${$code_ref};
  		} else {
  			use Carp;
  			confess("Unknown code ref type given '${ref}'. Check your usage & try again");
  		}
  	}
  
  	# save the value of $@ so we can set $@ back to it in the beginning of the eval
  	my $prev_error = $@;
  
  	my ( @ret, $error, $failed );
  
  	# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
  	# not perfect, but we could provide a list of additional errors for
  	# $catch->();
  
  	{
  		# localize $@ to prevent clobbering of previous value by a successful
  		# eval.
  		local $@;
  
  		# failed will be true if the eval dies, because 1 will not be returned
  		# from the eval body
  		$failed = not eval {
  			$@ = $prev_error;
  
  			# evaluate the try block in the correct context
  			if ( $wantarray ) {
  				@ret = $try->();
  			} elsif ( defined $wantarray ) {
  				$ret[0] = $try->();
  			} else {
  				$try->();
  			};
  
  			return 1; # properly set $fail to false
  		};
  
  		# copy $@ to $error; when we leave this scope, local $@ will revert $@
  		# back to its previous value
  		$error = $@;
  	}
  
  	# set up a scope guard to invoke the finally block at the end
  	my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
  	# at this point $failed contains a true value if the eval died, even if some
  	# destructor overwrote $@ as the eval was unwinding.
  	if ( $failed ) {
  		# if we got an error, invoke the catch block.
  		if ( $catch ) {
  			# This works like given($error), but is backwards compatible and
  			# sets $_ in the dynamic scope for the body of C<$catch>
  			for ($error) {
  				return $catch->($error);
  			}
  
  			# in case when() was used without an explicit return, the C<for>
  			# loop will be aborted and there's no useful return value
  		}
  
  		return;
  	} else {
  		# no failure, $@ is back to what it was, everything is fine
  		return $wantarray ? @ret : $ret[0];
  	}
  }
  
  sub catch (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Catch'),
  		@rest,
  	);
  }
  
  sub finally (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Finally'),
  		@rest,
  	);
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my @guts = @{ shift() };
      my $code = shift @guts;
      $code->(@guts);
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper localization of $@
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
  	# handle errors with a catch handler
  	try {
  		die "foo";
  	} catch {
  		warn "caught error: $_"; # not $@
  	};
  
  You can also use it like a stanalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
  	# just silence errors
  	try {
  		die "foo";
  	};
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the try block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L<BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the try block dies, it returns the value of the last statement executed in
  the catch block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following two examples both
  assign C<"bar"> to C<$x>.
  
  	my $x = try { die "foo" } catch { "bar" };
  
  	my $x = eval { die "foo" } || "bar";
  
  You can add finally blocks making the following true.
  
  	my $x;
  	try { die 'foo' } finally { $x = 'bar' };
  	try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  Finally blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many finally blocks to a
  given try block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory try subroutine, an optional catch subroutine & finally
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the finally block if given will execute.
  
  =item catch (&;$)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
  	catch { ... }
  
  Inside the catch block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
  	local $@ = $_;
  
  =item finally (&;$)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. Finally blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the finally block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the finally block does not
  localize C<$_> with the error, since unlike in a catch block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the finally block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an eval block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (before
  the localization) in the beginning of the C<eval> block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an eval block C<die> behaves sort of like:
  
  	sub die {
  		$@ = $_[0];
  		return_undef_from_eval();
  	}
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
  	my $error = do {
  		local $@;
  		eval { ... };
  		$@;
  	};
  
  	...
  	die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
  	if ( $@ ) {
  		...
  	}
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
  	sub Object::DESTROY {
  		eval { ... }
  	}
  
  	eval {
  		my $obj = Object->new;
  
  		die "foo";
  	};
  
  	if ( $@ ) {
  
  	}
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the eval was aborted due to an error:
  
  	my $failed = not eval {
  		...
  
  		return 1;
  	};
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
  	try {
  		require Foo;
  	} catch {
  		when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
  		default { die $_ }
  	};
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
  	sub foo {
  		my ( $self, @args ) = @_;
  		try { $self->bar(@args) }
  	}
  
  or
  
  	sub bar_in_place {
  		my $self = shift;
  		my $args = \@_;
  		try { $_ = $self->bar($_) for @$args }
  	}
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
        try {
            die;
        }
        catch {
            return;
        };
  
        say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
        my $success = try {
            die;
            1;
        }
        return unless $success;
  
        say "This text WILL NEVER appear!";
    }
  
  Note that if you have a catch block, it must return undef for this to work,
  since if a catch block exists, its return value is returned in place of undef
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
  	my $obj = try {
  		MightFail->new;
  	} catch {
  		...
  
  		return; # avoid returning a true value;
  	};
  
  	return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
  	given ($foo) {
  		when (...) {
  			try {
  				...
  			} catch {
  				warn $_; # will print $foo, not the error
  				warn $_[0]; # instead, get the error like this
  			}
  		}
  	}
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://nothingmuch.woobling.org/talks/takahashi.xul?data=yapc_asia_2009/try_tiny.txt>
  
  Or read the source:
  
  L<http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/nothingmuch/try-tiny/>
  
  =head1 AUTHOR
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2009 Yuval Kogman. All rights reserved.
  	This program is free software; you can redistribute
  	it and/or modify it under the terms of the MIT license.
  
  =cut
  
TRY_TINY

$fatpacked{"darwin-2level/HTTP/Parser/XS.pm"} = <<'DARWIN-2LEVEL_HTTP_PARSER_XS';
  package HTTP::Parser::XS;
  
  use strict;
  use warnings;
  
  use base qw(Exporter);
  
  our %EXPORT_TAGS = (
      'all' => [ qw/parse_http_request parse_http_response
                    HEADERS_NONE HEADERS_AS_HASHREF HEADERS_AS_ARRAYREF/ ],
  );
  our @EXPORT_OK = @{$EXPORT_TAGS{all}};
  our @EXPORT = ();
  
  # header format for parse_http_response()
  use constant {
      HEADERS_NONE => 0,       # don't parse headers. It's fastest. if you want only special headers, also fastest.
      HEADERS_AS_HASHREF => 1,    # HTTP::Headers compatible HashRef, { header_name => "header_value" or ["val1", "val2"] }
      HEADERS_AS_ARRAYREF =>2,    # Ordered ArrayRef : [ name, value, name2, value2 ... ]
  };
  
  our $VERSION = '0.14';
  
  our $BACKEND;
  
  if (not __PACKAGE__->can('parse_http_response')) {
      $BACKEND = $ENV{PERL_HTTP_PARSER_XS} || ($ENV{PERL_ONLY} ? 'pp' : '');
      if ($BACKEND !~ /\b pp \b/xms) {
          eval {
              require XSLoader;
              XSLoader::load(__PACKAGE__, $VERSION);
              $BACKEND = 'xs';
          };
          die $@ if $@ && $BACKEND =~ /\bxs\b/;
      }
      if (not __PACKAGE__->can('parse_http_response')) {
          require HTTP::Parser::XS::PP;
          $BACKEND = 'pp';
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  HTTP::Parser::XS - a fast, primitive HTTP request parser
  
  =head1 SYNOPSIS
  
    use HTTP::Parser::XS qw(parse_http_request);
  
    # for HTTP servers
    my $ret = parse_http_request(
        "GET / HTTP/1.0\r\nHost: ...\r\n\r\n",
        \%env,
    );
    if ($ret == -2) {
        # request is incomplete
        ...
    } elsif ($ret == -1) {
        # request is broken
        ...
    } else {
        # $ret includes the size of the request, %env now contains a PSGI
        # request, if it is a POST / PUT request, read request content by
        # yourself
        ...
    }
  
  
    # for HTTP clients
    use HTTP::Parser::XS qw(parse_http_response HEADERS_AS_ARRAYREF);
    my %special_headers = (
      'content-length' => undef,
    );
    my($ret, $minor_version, $status, $message, $headers)
      = parse_http_response($response, HEADERS_AS_ARRAYREF, \%special_headers);
  
    if($ret == -1) }
      # response is incomplete
    }
    elsif($ret == -2) {
      # response is broken
    }
    else {
      # $ret is the length of the headers, starting the content body
  
      # the other values are the response messages. For example:
      # $status  = 200
      # $message = "OK"
      # $headers = [ 'content-type' => 'text/html', ... ]
  
      # and $special_headers{'content-length'} will be filled in
    }
  
  
  =head1 DESCRIPTION
  
  HTTP::Parser::XS is a fast, primitive HTTP request/response parser.
  
  The request parser can be used either for writing a synchronous HTTP server or a event-driven server.
  
  The response parser can be used for writing HTTP clients.
  
  Note that even if this distribution name ends C<::XS>, B<pure Perl>
  implementation is supported, so you can use this module on compiler-less
  environments.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item parse_http_request($request_string, \%env)
  
  Tries to parse given request string, and if successful, inserts variables into %env.  For the name of the variables inserted, please refer to the PSGI specification.  The return values are:
  
  =over 8
  
  =item >=0
  
  length of the request (request line and the request headers), in bytes
  
  =item -1
  
  given request is corrupt
  
  =item -2
  
  given request is incomplete
  
  =back
  
  =item parse_http_response($response_string, $header_format, \%special_headers)
  
  Tries to parse given response string. I<$header_format> must be
  C<HEADERS_AS_ARRAYREF>, C<HEADERS_AS_HASHREF>, or C<HEADERS_NONE>,
  which are exportable constants.
  
  The optional I<%special_headers> is for headers you specifically require.
  You can set any HTTP response header names, which must be lower-cased,
  and their default values, and then the values are filled in by
  C<parse_http_response()>.
  For example, if you want the C<Cointent-Length> field, set its name with
  default values like C<< %h = ('content-length' => undef) >> and pass it as
  I<%special_headers>. After parsing, C<$h{'content-length'}> is set
  if the response has the C<Content-Length> field, otherwise it's not touched.
  
  The return values are:
  
  =over 8
  
  =item C<$ret>
  
  The parsering status, which is the same as C<parse_http_response()>. i.e.
  the length of the response headers in bytes, C<-1> for incomplete headers,
  or C<-2> for errors.
  
  If the given response string is broken or imcomplete, C<parse_http_response()>
  returns only this value.
  
  =item C<$minor_version>
  
  The minor version of the given response.
  i.e. C<1> for HTTP/1.1, C<0> for HTTP/1.0.
  
  =item C<$status>
  
  The HTTP status of the given response. e.g. C<200> for success.
  
  =item C<$message>
  
  The HTTP status message. e.g. C<OK> for success.
  
  =item C<$headers>
  
  The HTTP headers for the given response. It is an ARRAY reference
  if I<$header_format> is C<HEADERS_AS_ARRAYREF>, a HASH reference on
  C<HEADERS_AS_HASHREF>, an C<undef> on C<HEADERS_NONE>.
  
  The names of the headers are normalized to lower-cased.
  
  =back
  
  =back
  
  =head1 LIMITATIONS
  
  Both C<parse_http_request()> and C<parse_http_response()> in XS
  implementation have some size limitations.
  
  =head2 The number of headers
  
  The number of headers is limited to C<128>. If it exceeds, both parsing
  routines report parsing errors, i.e. return C<-1> for C<$ret>.
  
  =head2 The size of header names
  
  The size of header names is limited to C<1024>, but the parsers do not the
  same action.
  
  C<parse_http_request()> returns C<-1> if too-long header names exist.
  
  C<parse_http_request()> simply ignores too-long header names.
  
  =head1 COPYRIGHT
  
  Copyright 2009- Kazuho Oku
  
  =head1 AUTHOR
  
  Kazuho Oku
  gfx
  mala
  tokuhirom
  
  =head1 THANKS TO
  
  nothingmuch
  charsbar
  
  =head1 SEE ALSO
  
  L<http://github.com/kazuho/picohttpparser>
  
  L<HTTP::Parser>
  L<HTTP::HeaderParser::XS>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_HTTP_PARSER_XS

$fatpacked{"darwin-2level/HTTP/Parser/XS/PP.pm"} = <<'DARWIN-2LEVEL_HTTP_PARSER_XS_PP';
  package HTTP::Parser::XS::PP;
  use strict;
  use warnings;
  use utf8;
  
  sub HTTP::Parser::XS::parse_http_request {
      my($chunk, $env) = @_;
      Carp::croak("second param to parse_http_request should be a hashref") unless (ref $env|| '') eq 'HASH';
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my $minor;
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/1\.(\d+)$/;
      $minor = $1;
  
      my($path, $query) = ( $uri =~ /^([^?#]*)(?:\?([^#]*))?/s );
      # following validations are just needed to pass t/01simple.t
      if ($path =~ /%(?:[0-9a-f][^0-9a-f]|[^0-9a-f][0-9a-f])/i) {
          # invalid char in url-encoded path
          return -1;
      }
      if ($path =~ /%(?:[0-9a-f])$/i) {
          # partially url-encoded
          return -1;
      }
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{REQUEST_URI}     = $uri;
      $env->{SERVER_PROTOCOL} = "HTTP/1.$minor";
      ($env->{PATH_INFO}      = $path) =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  # ----------------------------------------------------------
  
  my %PARSER_FUNC = (
      HTTP::Parser::XS::HEADERS_NONE()        => \&_parse_as_none,
      HTTP::Parser::XS::HEADERS_AS_HASHREF()  => \&_parse_as_hashref,
      HTTP::Parser::XS::HEADERS_AS_ARRAYREF() => \&_parse_as_arrayref,
  );
  
  sub HTTP::Parser::XS::parse_http_response {
      my ($str, $header_format, $special_headers) = @_;
      return -2 unless $str;
  
      my $len = length $str;
      
      my ($sl, $remain) = split /\r?\n/, $_[0], 2;
      my ($proto, $rc, $msg) = split(' ', $sl, 3);
      return -1 unless $proto =~m{^HTTP/1.(\d)};
      my $minor_version = $1;
      return -1 unless $rc =~m/^\d+$/;
  
      my ($header_str, $content) = split /\r?\n\r?\n/, $remain, 2;
  
      my $parser_func = $PARSER_FUNC{$header_format};
      die 'unknown header format: '. $header_format unless $parser_func;
  
      my $header = $parser_func->($header_str, $special_headers || +{});
  
      return -2 if ($str !~/\r?\n\r?\n/ && $remain !~/\r?\n\r?\n/ && !defined $content);
      my $parsed = $len - (defined $content ? length $content : 0);
  
      return ($parsed, $minor_version, $rc, $msg, $header);
  }
  
  # return special headers only
  sub _parse_as_none {
      my ($str, $special) = @_;
      return unless defined $str;
      return unless keys %$special;
  
      my ($field, $value, $f);
      for ( split /\r?\n/, $str ) {
          if ( defined $field ) {
              if ( ord == 9 || ord == 32 ) {
                  $value .= "\n$_";
                  next;
              }
              $f = lc($field); 
              exists $special->{$f} and $special->{$f} = $value;
          }
          ( $field, $value ) = split /[ \t]*: ?/, $_, 2;
      }
      if ( defined $field ) {
          $f = lc($field); 
          exists $special->{$f} and $special->{$f} = $value;
      }
  }
  
  # return headers as arrayref
  sub _parse_as_arrayref {
      my ($str, $special) = @_;
      return [] unless defined $str;
  
      my (@headers, $field, $value, $f );
      for ( split /\r?\n/, $str ) {
          if ( defined $field ) {
              if ( ord == 9 || ord == 32 ) {
                  $value .= "\n$_";
                  next;
              }
              $f = lc($field); 
              push @headers, $f, $value;
              exists $special->{$f} and $special->{$f} = $value;
          }
          ( $field, $value ) = split /[ \t]*: ?/, $_, 2;
      }
      if ( defined $field ) {
          $f = lc($field); 
          push @headers, $f, $value; 
          exists $special->{$f} and $special->{$f} = $value;
      }
      return \@headers;
  }
  
  # return headers as HTTP::Header compatible HashRef
  sub _parse_as_hashref {
      my ($str, $special) = @_;
      return +{} unless defined $str;
      
      my ( %self, $field, $value, $f );
      for ( split /\r?\n/, $str ) {
          if ( defined $field ) {
              if ( ord == 9 || ord == 32 ) {
                  $value .= "\n$_";
                  next;
              }
              $f = lc($field); 
              if ( defined $self{$f} ) {
                  my $h = $self{$f};
                  ref($h) eq 'ARRAY'
                    ? push( @$h, $value )
                    : ( $self{$f} = [ $h, $value ] );
              }
              else { $self{$f} = $value }
          }
          ( $field, $value ) = split /[ \t]*: ?/, $_, 2;
      }
      if ( defined $field ) {
          $f = lc($field); 
          if ( defined $self{$f} ) {
              my $h = $self{$f};
              ref($h) eq 'ARRAY'
                ? push( @$h, $value )
                : ( $self{$f} = [ $h, $value ] );
          }
          else { $self{$f} = $value }
      }
      return \%self;
  }
  
  1;
  
DARWIN-2LEVEL_HTTP_PARSER_XS_PP

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/usr/bin/env perl

# WARNING - Do not edit this file unless you have the perl
#           dependencies installed which are noted in the README, otherwise
#           the Makefile in this directory will try to rebuild the server script

use strict;
use warnings;
use FindBin qw/$Bin/;
use Cwd qw/ abs_path /;
use File::Spec;

use Plack::Runner;
use Plack::App::File;
use Plack::Builder;
use Plack::Loader;
use HTTP::Server::PSGI;
use Cwd qw/ abs_path /;
use File::stat;
use File::Find;

# Work out where the root is, no matter where we were run
use constant ROOT =>
    abs_path(
        -d File::Spec->catdir($Bin, "js")
        ? $Bin
      : -d File::Spec->catdir($Bin, "..", "js")
        ? File::Spec->catdir($Bin, "..")
      : die("Cannot find js/ folder for app root")
    );

# Find the newest js or CSS file's mtime
my $youngest = 0;
my $wanted = sub {
    return if -d $File::Find::name;
    my $time = stat($File::Find::name)->mtime;
    $youngest = $time if $time > $youngest;
};
find($wanted, map { File::Spec->catdir(ROOT, $_) } qw/ js css /);
{   # Find app.html's mtime
    local $File::Find::name = File::Spec->catdir(ROOT, "maint", "app.html");
    $wanted->();
}

# Find mtime for minified version
my $minified_mtime = stat(File::Spec->catdir(ROOT, 'index.html'))->mtime;

# And use the minified version if possible, or the multi-file version if
# the application has been edited.
my @index = $minified_mtime > $youngest ? ("index.html") : ("maint", "app.html");

# Helper function to locate a file
sub file {
    Plack::App::File->new(file => File::Spec->catdir(ROOT, @_))
}

# Build the app coderef
my $app = builder {
    mount "/favicon.ico"                => file("favicon.ico");
    mount "/puppet/nodes/"              => file(qw/testdata mongodb_nodes.json/);
    mount "/puppet/nagios_host_groups/" => file(qw/testdata mongodb_nagios_host_groups.json/);
    mount "/nagios-api/state"           => file(qw/testdata nagios-api-state.json/);
    mount "/"                           => file(@index);
    mount "/dev"                        => file("maint", "app.html");
    mount "/js"                         => Plack::App::File->new(root => File::Spec->catdir(ROOT, "js"));
    mount "/css"                        => Plack::App::File->new(root => File::Spec->catdir(ROOT, "css"));
    mount "/img"                        => Plack::App::File->new(root => File::Spec->catdir(ROOT, "img"));
    mount "/test"                       => file(qw/test index.html/);
    mount "/test/vendor/qunit.js"       => file(qw/test vendor qunit.js/);
    mount "/test/vendor/qunit.css"      => file(qw/test vendor qunit.css/);
    mount "/test/model.js"              => file(qw/test model.js/);
    mount "/test/view.js"              => file(qw/test view.js/);
    mount "/test/collections.js"        => file(qw/test collections.js/);
};

# Use Plack::Runner here so we can be directly run with perl
# as a perl script. The caller magic also allows us to be used
# as a psgi script, as we don't run anything when require'd
unless (caller()) {
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
}

# And return the app as the final value to be a valid psgi.
return $app;

