#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AnyEvent/Server/PSGI.pm"} = <<'ANYEVENT_SERVER_PSGI';
  package AnyEvent::Server::PSGI;
  use parent 'Twiggy::Server';
  
  1;
ANYEVENT_SERVER_PSGI

$fatpacked{"Fliggy.pm"} = <<'FLIGGY';
  package Fliggy;
  
  use strict;
  use warnings;
  
  use 5.008_001;
  
  our $VERSION = '0.009003';
  
  1;
  __END__
  
  =head1 NAME
  
  Fliggy - Twiggy with inlined Flash Policy Server
  
  =head1 SYNOPSIS
  
    fliggy --listen :8080
  
  See C<fliggy -h> for more details.
  
    use Fliggy::Server;
  
    my $server = Fliggy::Server->new(
        host => $host,
        port => $port,
    );
    $server->register_service($app);
  
    AE::cv->recv;
  
  =head1 DESCRIPTION
  
  Fliggy inherits Twiggy and adds support for inlined Flash Policy server (useful
  for L<Plack::Middleware::SocketIO> or Flash WebSocket fallback).
  
  No need to run Flash Policy server as root on 843 port!
  
  Usage is exactly the same as L<Twiggy>, whenever you run C<twiggy> command, replace it
  with C<fliggy> and you're ready to go.
  
  =head1 SEE ALSO
  
  L<Plack> L<AnyEvent> L<Twiggy>
  
  =cut
  
  =head1 DEVELOPMENT
  
  =head2 Repository
  
      http://github.com/vti/fliggy
  
  =head1 AUTHOR
  
  Viacheslav Tykhanovskyi, C<vti@cpan.org>.
  
  =head1 CREDITS
  
  L<Twiggy> authors.
  
  Johannes Plunien (plu)
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2011, Viacheslav Tykhanovskyi
  
  This program is free software, you can redistribute it and/or modify it under
  the terms of the Artistic License version 2.0.
  
  =cut
FLIGGY

$fatpacked{"Fliggy/Server.pm"} = <<'FLIGGY_SERVER';
  package Fliggy::Server;
  
  use strict;
  use warnings;
  
  BEGIN {
      $ENV{TWIGGY_DEBUG} = $ENV{FLIGGY_DEBUG} || 0;
  }
  
  use base 'Twiggy::Server';
  
  use Errno qw(EAGAIN EINTR);
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  
  use constant DEBUG => $ENV{FLIGGY_DEBUG};
  
  # Copied from Twiggy::Server (can't stand copypasting, but this is the only way)
  sub _try_read_headers {
      my ($self, $sock, undef) = @_;
  
      # FIXME add a timer to manage read timeouts
      local $/ = "\012";
  
    read_more: for my $headers ($_[2]) {
          if ($headers eq '') {
              my $buf = $self->_safe_read($sock, 1);
              return unless defined $buf;
  
              if ($buf eq '<') {
                  $buf = $self->_safe_read($sock, 22);
                  return unless defined $buf;
  
                  if ($buf eq "policy-file-request/>\0") {
                      DEBUG && warn "Flash policy request\n";
                      $self->_write_flash_policy_response($sock);
                      die;
                  }
                  else {
                      $headers .= $buf;
                  }
              }
              else {
                  $headers .= $buf;
              }
          }
  
          if (defined(my $line = <$sock>)) {
              $headers .= $line;
  
              if ($line eq "\015\012" or $line eq "\012") {
  
                  # got an empty line, we're done reading the headers
                  return 1;
              }
              else {
  
                  # try to read more lines using buffered IO
                  redo read_more;
              }
          }
          elsif ($! and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              die $!;
          }
          elsif (!$!) {
              die "client disconnected";
          }
      }
  
      DEBUG
        && warn
        "$sock did not read to end of req, wait for more data to arrive\n";
      return;
  }
  
  sub _write_flash_policy_response {
      my ($self, $sock) = @_;
  
      return unless defined $sock and defined fileno $sock;
  
      # FIXME restrict domain and ports
      my $body = <<"EOF";
  <?xml version="1.0"?>
  <!DOCTYPE cross-domain-policy SYSTEM "/xml/dtds/cross-domain-policy.dtd">
  <cross-domain-policy>
  <site-control permitted-cross-domain-policies="master-only"/>
  <allow-access-from domain="*" to-ports="*" secure="false"/>
  </cross-domain-policy>
  EOF
  
      my $cv = AE::cv;
  
      # From _write_psgi_response
      $self->_write_body($sock, [$body])->cb(
          sub {
              shutdown $sock, 1;
              close $sock;
              $self->{exit_guard}->end;
              local $@;
              eval { $cv->send($_[0]->recv); 1 } or $cv->croak($@);
          }
      );
  
      return;
  }
  
  sub _safe_read {
      my $self = shift;
      my ($sock, $size) = @_;
  
      my $rcount = sysread($sock, my $buf, $size);
  
      # $rcount contains number of bytes read, 0 at end of file
      if (defined $rcount && $rcount == 0) {
          die "client disconnected";
      }
  
      if (!defined $buf || !defined $rcount) {
          if ($! and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              die $!;
          }
          elsif (!$!) {
              die "client disconnected (unknown error)";
          }
  
          return;
      }
  
      return unless $rcount == $size;
  
      return $buf;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Fliggy::Server - Fliggy implementation
  
  =head1 DESCRIPTION
  
  This is an actual L<Fliggy> implementation.
  
  =head1 SEE ALSO
  
  L<Fliggy> L<Twiggy>
  
  =cut
FLIGGY_SERVER

$fatpacked{"HTTP/Config.pm"} = <<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use URI;
  use vars qw($VERSION);
  
  $VERSION = "6.00";
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          return 1 if $request->header($k) eq $v;
          return 1 if $response && $response->header($k) eq $v;
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuation object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 2008, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_CONFIG

$fatpacked{"HTTP/Date.pm"} = <<'HTTP_DATE';
  package HTTP::Date;
  
  $VERSION = "6.00";
  
  require 5.004;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(time2str str2time);
  @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  use strict;
  require Time::Local;
  
  use vars qw(@DoW @MoY %MoY);
  @DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = (1..12);
  
  my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);
  
  
  sub time2str (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
      sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
  	    $DoW[$wday],
  	    $mday, $MoY[$mon], $year+1900,
  	    $hour, $min, $sec);
  }
  
  
  sub str2time ($;$)
  {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
  	return eval {
  	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
  	    $t < 0 ? undef : $t;
  	};
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;        # month
  
      my $tz = pop(@d);
      unless (defined $tz) {
  	unless (defined($tz = shift)) {
  	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  			  my $t = Time::Local::timelocal(reverse @d) + $frac;
  			  $t < 0 ? undef : $t;
  		        };
  	}
      }
  
      my $offset = 0;
      if ($GMT_ZONE{uc $tz}) {
  	# offset already zero
      }
      elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
  	$offset = 3600 * $2;
  	$offset += 60 * $3 if $3;
  	$offset *= -1 if $1 && $1 eq '-';
      }
      else {
  	eval { require Time::Zone } || return undef;
  	$offset = Time::Zone::tz_offset($tz);
  	return undef unless defined $offset;
      }
  
      return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  		  my $t = Time::Local::timegm(reverse @d) + $frac;
  		  $t < 0 ? undef : $t - $offset;
  		};
  }
  
  
  sub parse_date ($)
  {
      local($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;  # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday
  
      my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);
  
      # Then we are able to check for most of the formats with this regexp
      (($day,$mon,$yr,$hr,$min,$sec,$tz) =
          /^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\))?	       # ASCII representation of timezone in parens.
  	    \s*$
  	/x)
  
      ||
  
      # Try the ctime and asctime format
      (($mon, $day, $hr, $min, $sec, $tz, $yr) =
  	/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)
  
      ||
  
      # Then the Unix 'ls -l' date format
      (($mon, $day, $yr, $hr, $min, $sec) =
  	/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)
  
      ||
  
      # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
      (($yr, $mon, $day, $hr, $min, $sec, $tz) =
  	/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)
  
      ||
  
      # Windows 'dir' 11-12-96  03:52PM
      (($mon, $day, $yr, $hr, $min, $ampm) =
          /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)
  
      ||
      return;  # unrecognized format
  
      # Translate month name to number
      $mon = $MoY{$mon} ||
             $MoY{"\u\L$mon"} ||
  	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
             return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless (defined $yr) {
  	my $cur_mon;
  	($cur_mon, $yr) = (localtime)[4, 5];
  	$yr += 1900;
  	$cur_mon++;
  	$yr-- if $mon > $cur_mon;
      }
      elsif (length($yr) < 3) {
  	# Find "obvious" year
  	my $cur_yr = (localtime)[5] + 1900;
  	my $m = $cur_yr % 100;
  	my $tmp = $yr;
  	$yr += $cur_yr - $m;
  	$m -= $tmp;
  	$yr += ($m > 0) ? 100 : -100
  	    if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
  	$ampm = uc $ampm;
  	$hr = 0 if $hr == 12 && $ampm eq 'AM';
  	$hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return($yr, $mon, $day, $hr, $min, $sec, $tz)
  	if wantarray;
  
      if (defined $tz) {
  	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
  	$tz = "";
      }
      return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
  		   $yr, $mon, $day, $hr, $min, $sec, $tz);
  }
  
  
  sub time2iso (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02d",
  	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  
  sub time2isoz (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
              $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Date - date conversion routines
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  returned will B<not> have the number 1900 subtracted from it and the
  $month numbers start with 1.
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned.
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_DATE

$fatpacked{"HTTP/Headers.pm"} = <<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use Carp ();
  
  use vars qw($VERSION $TRANSLATE_UNDERSCORE);
  $VERSION = "6.00";
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless(defined $standard_case{$field}) {
  	    # generate a %standard_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $standard_case{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	next if substr($key, 0, 1) eq '_';
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $key, $vals);
  	}
      }
  }
  
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		my $field = $standard_case{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    my $field = $standard_case{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # intial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  
  if (eval { require Storable; 1 }) {
      *clone = \&Storable::dclone;
  } else {
      *clone = sub {
  	my $self = shift;
  	my $clone = HTTP::Headers->new;
  	$self->scan(sub { $clone->push_header(@_);} );
  	$clone;
      };
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promise that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS

$fatpacked{"HTTP/Headers/Auth.pm"} = <<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  use HTTP::Headers;
  
  package HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
HTTP_HEADERS_AUTH

$fatpacked{"HTTP/Headers/ETag.pm"} = <<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
HTTP_HEADERS_ETAG

$fatpacked{"HTTP/Headers/Util.pm"} = <<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = "6.00";
  
  require Exporter;
  @ISA=qw(Exporter);
  
  @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessary be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS_UTIL

$fatpacked{"HTTP/Message.pm"} = <<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use vars qw($VERSION $AUTOLOAD);
  $VERSION = "6.02";
  
  require HTTP::Headers;
  require Carp;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  $HTTP::URI_CLASS ||= $ENV{PERL_HTTP_URI_CLASS} || "URI";
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
      }, $class;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = $_[1];
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = $_[1];
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32-LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32-BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16-LE" if /^\xFF\xFE/;
  	return "UTF-16-BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32-BE" if /^\x00\x00\x00</;
  	    return "UTF-32-LE" if /^<\x00\x00\x00/;
  	    return "UTF-16-BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16-LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	my $charset;
  	require HTML::Parser;
  	my $p = HTML::Parser->new(
  	    start_h => [sub {
  		my($tag, $attr, $self) = @_;
  		$charset = $attr->{charset};
  		unless ($charset) {
  		    # look at $attr->{content} ...
  		    if (my $c = $attr->{content}) {
  			require HTTP::Headers::Util;
  			my @v = HTTP::Headers::Util::split_header_words($c);
  			return unless @v;
  			my($ct, undef, %ct_param) = @{$v[0]};
  			$charset = $ct_param{charset};
  		    }
  		    return unless $charset;
  		}
  		if ($charset =~ /^utf-?16/i) {
  		    # converted document, assume UTF-8
  		    $charset = "UTF-8";
  		}
  		$self->eof;
  	    }, "tagname, attr, self"],
  	    report_tags => [qw(meta)],
  	    utf8_mode => 1,
  	);
  	$p->parse($$cref);
  	return $charset if $charset;
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require IO::Uncompress::Gunzip;
  		    my $output;
  		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
  			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2") {
  		    require IO::Uncompress::Bunzip2;
  		    my $output;
  		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
  			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    if ($charset eq "none") {
  		# leave it asis
  	    }
  	    elsif ($charset eq "us-ascii" || $charset eq "iso-8859-1") {
  		if ($$content_ref =~ /[^\x00-\x7F]/ && defined &utf8::upgrade) {
  		    unless ($content_ref_iscopy) {
  			my $copy = $$content_ref;
  			$content_ref = \$copy;
  			$content_ref_iscopy++;
  		    }
  		    utf8::upgrade($$content_ref);
  		}
  	    }
  	    else {
  		require Encode;
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset eq "none";
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require IO::Uncompress::Gunzip;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require IO::Uncompress::Bunzip2;
          push(@enc, "x-bzip2");
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = "(no content)";
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = "(no content)";
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = HTTP::Message->new($self->remove_content_headers,
  				   $self->content(""));
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  
  # delegate all other method calls the the headers object.
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->headers->$method(@_) };
      goto &$method;
  }
  
  
  sub DESTROY {}  # avoid AUTOLOADing it
  
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--\r?\n.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map HTTP::Message->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ HTTP::Message->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 SYNOPSIS
  
   use base 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and for textual content
  the raw content encoded to Perl's Unicode strings.  If the C<Content-Encoding>
  or C<charset> of the message is unknown this method will fail by returning
  C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This override the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This override the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2" and "base64".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If an @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_MESSAGE

$fatpacked{"HTTP/Message/PSGI.pm"} = <<'HTTP_MESSAGE_PSGI';
  package HTTP::Message::PSGI;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw( req_to_psgi res_from_psgi );
  
  use Carp ();
  use HTTP::Status qw(status_message);
  use URI::Escape ();
  use Plack::Util;
  use Try::Tiny;
  
  my $TRUE  = (1 == 1);
  my $FALSE = !$TRUE;
  
  sub req_to_psgi {
      my $req = shift;
  
      unless (try { $req->isa('HTTP::Request') }) {
          Carp::croak("Request is not HTTP::Request: $req");
      }
  
      # from HTTP::Request::AsCGI
      my $host = $req->header('Host');
      my $uri  = $req->uri->clone;
      $uri->scheme('http')    unless $uri->scheme;
      $uri->host('localhost') unless $uri->host;
      $uri->port(80)          unless $uri->port;
      $uri->host_port($host)  unless !$host || ( $host eq $uri->host_port );
  
      # STUPID: If the request URI is utf-8 decoded, methods like ->path
      # and ->host returns decoded strings in ascii, which causes double
      # encoded strings in uri_unescape and URI concatenation in
      # Plack::Request :/
      utf8::downgrade $$uri;
  
      my $input;
      my $content = $req->content;
      if (ref $content eq 'CODE') {
          if (defined $req->content_length) {
              $input = HTTP::Message::PSGI::ChunkedInput->new($content);
          } else {
              $req->header("Transfer-Encoding" => "chunked");
              $input = HTTP::Message::PSGI::ChunkedInput->new($content, 1);
          }
      } else {
          open $input, "<", \$content;
          $req->content_length(length $content)
              unless defined $req->content_length;
      }
  
      my $env = {
          PATH_INFO         => URI::Escape::uri_unescape($uri->path || '/'),
          QUERY_STRING      => $uri->query || '',
          SCRIPT_NAME       => '',
          SERVER_NAME       => $uri->host,
          SERVER_PORT       => $uri->port,
          SERVER_PROTOCOL   => $req->protocol || 'HTTP/1.1',
          REMOTE_ADDR       => '127.0.0.1',
          REMOTE_HOST       => 'localhost',
          REMOTE_PORT       => int( rand(64000) + 1000 ),                   # not in RFC 3875
          REQUEST_URI       => $uri->path_query || '/',                     # not in RFC 3875
          REQUEST_METHOD    => $req->method,
          'psgi.version'      => [ 1, 1 ],
          'psgi.url_scheme'   => $uri->scheme eq 'https' ? 'https' : 'http',
          'psgi.input'        => $input,
          'psgi.errors'       => *STDERR,
          'psgi.multithread'  => $FALSE,
          'psgi.multiprocess' => $FALSE,
          'psgi.run_once'     => $TRUE,
          'psgi.streaming'    => $TRUE,
          'psgi.nonblocking'  => $FALSE,
          @_,
      };
  
      for my $field ( $req->headers->header_field_names ) {
          my $key = uc("HTTP_$field");
          $key =~ tr/-/_/;
          $key =~ s/^HTTP_// if $field =~ /^Content-(Length|Type)$/;
  
          unless ( exists $env->{$key} ) {
              $env->{$key} = $req->headers->header($field);
          }
      }
  
      if ($env->{SCRIPT_NAME}) {
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E/\//;
          $env->{PATH_INFO} =~ s/^\/+/\//;
      }
  
      return $env;
  }
  
  sub res_from_psgi {
      my ($psgi_res) = @_;
  
      my $res;
      if (ref $psgi_res eq 'ARRAY') {
          _res_from_psgi($psgi_res, \$res);
      }
      elsif (ref $psgi_res eq 'CODE') {
          $psgi_res->(sub {
              _res_from_psgi($_[0], \$res);
          });
      }
  
      return $res;
  }
  
  sub _res_from_psgi {
      my ($status, $headers, $body) = @{+shift};
      my $res_ref = shift;
  
      my $convert_resp = sub {
          my $res = HTTP::Response->new($status);
          $res->message(status_message($status));
          $res->headers->header(@$headers) if @$headers;
  
          if (ref $body eq 'ARRAY') {
              $res->content(join '', grep defined, @$body);
          } else {
              local $/ = \4096;
              my $content;
              while (defined(my $buf = $body->getline)) {
                  $content .= $buf;
              }
              $body->close;
              $res->content($content);
          }
  
          ${ $res_ref } = $res;
  
          return;
      };
  
      if (!defined $body) {
          my $o = Plack::Util::inline_object
              write => sub { push @{ $body ||= [] }, @_ },
              close => $convert_resp;
  
          return $o;
      }
  
      $convert_resp->();
  }
  
  sub HTTP::Request::to_psgi {
      req_to_psgi(@_);
  }
  
  sub HTTP::Response::from_psgi {
      my $class = shift;
      res_from_psgi(@_);
  }
  
  package
      HTTP::Message::PSGI::ChunkedInput;
  
  sub new {
      my($class, $content, $chunked) = @_;
  
      my $content_cb;
      if ($chunked) {
          my $done;
          $content_cb = sub {
              my $chunk = $content->();
              return if $done;
              unless (defined $chunk) {
                  $done = 1;
                  return "0\015\012\015\012";
              }
              return '' unless length $chunk;
              return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
          };
      } else {
          $content_cb = $content;
      }
  
      bless { content => $content_cb }, $class;
  }
  
  sub read {
      my $self = shift;
  
      my $chunk = $self->{content}->();
      return 0 unless defined $chunk;
  
      $_[0] = '';
      substr($_[0], $_[2] || 0, length $chunk) = $chunk;
  
      return length $chunk;
  }
  
  sub close { }
  
  package HTTP::Message::PSGI;
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Message::PSGI - Converts HTTP::Request and HTTP::Response from/to PSGI env and response
  
  =head1 SYNOPSIS
  
    use HTTP::Message::PSGI;
  
    # $req is HTTP::Request, $res is HTTP::Response
    my $env = req_to_psgi($req);
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
    # Adds methods to HTTP::Request/Response class as well
    my $env = $req->to_psgi;
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  =head1 DESCRIPTION
  
  HTTP::Message::PSGI gives you convenient methods convert HTTP::Request
  object to PSGI env hash and convert PSGI response array ref to
  HTTP::Response object.
  
  If you want the other way round, see L<Plack::Request> and
  L<Plack::Response>.
  
  =head1 METHODS
  
  =over 4
  
  =item req_to_psgi
  
    my $env = req_to_psgi($req [, $key => $val ... ]);
  
  Converts HTTP::Request object into PSGI env hash reference.
  
  =item HTTP::Request::to_psgi
  
    my $env = $req->to_psgi;
  
  Same as C<req_to_psgi> but an instance method in L<HTTP::Request>.
  
  =item res_from_psgi
  
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
  Creates HTTP::Response object from PSGI response array ref.
  
  =item HTTP::Response->from_psgi
  
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  Same as C<res_from_psgi> but a class method in L<HTTP::Response>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Request::AsCGI> L<HTTP::Message> L<Plack::Test>
  
  =cut
  
HTTP_MESSAGE_PSGI

$fatpacked{"HTTP/Request.pm"} = <<'HTTP_REQUEST';
  package HTTP::Request;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.00";
  
  use strict;
  
  
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $request_line;
      if ($str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($method, $uri, $protocol) = split(' ', $request_line);
      $self->method($method) if defined($method);
      $self->uri($uri) if defined($uri);
      $self->protocol($protocol) if $protocol;
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
      return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parseable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_REQUEST

$fatpacked{"HTTP/Request/Common.pm"} = <<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use vars qw(@EXPORT @EXPORT_OK $VERSION $DYNAMIC_FILE_UPLOAD);
  
  $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT =qw(GET HEAD PUT POST);
  @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  
  $VERSION = "6.00";
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub PUT  { _simple_req('PUT' , @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  
  sub POST
  {
      my $url = shift;
      my $req = HTTP::Request->new(POST => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      my($k,$v);
      while (($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename =~ s,.*/,, if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.  
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, 2048, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf 
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);
  
  =head1 DESCRIPTION
  
  This module provide functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.  The
  following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The GET() function returns an C<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the PUT() and POST()
  functions described below.
  
  The get(...) method of C<LWP::UserAgent> exists as a shortcut for
  $ua->request(GET ...).
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The head(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(HEAD ...).
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $content
  
  Like GET() but the method in the request is "PUT".
  
  The content of the request can be specified using the "Content"
  pseudo-header.  This steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like GET() but the method in the request is "DELETE".  This function
  is not exported by default.
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  This works mostly like PUT() with "POST" as the method, but this
  function also takes a second optional array or hash reference
  parameter $form_ref.  As for PUT() the content can also be specified
  directly using the "Content" pseudo-header, and you may also provide
  the $form_ref this way.
  
  The $form_ref argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate a HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create a HTTP::Request object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the $form_ref is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by LWP::MediaTypes::guess_media_type()
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create a HTTP::Request object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the $DYNAMIC_FILE_UPLOAD variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no Content-Length header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the Content-Length is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The post(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(POST ...).
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  
  =head1 COPYRIGHT
  
  Copyright 1997-2004, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
HTTP_REQUEST_COMMON

$fatpacked{"HTTP/Response.pm"} = <<'HTTP_RESPONSE';
  package HTTP::Response;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.01";
  
  use strict;
  use HTTP::Status ();
  
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $status_line;
      if ($str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($protocol, $code, $message);
      if ($status_line =~ /^\d{3} /) {
         # Looks like a response created by HTTP::Response->new
         ($code, $message) = split(' ', $status_line, 2);
      } else {
         ($protocol, $code, $message) = split(' ', $status_line, 3);
      }
      $self->protocol($protocol) if $protocol;
      $self->code($code) if defined($code);
      $self->message($message) if defined($message);
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Content-Location'),    # HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require Encode::Locale;
  			Encode::from_to($encfile, $charset, "locale_fs");
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      require HTTP::Status;
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = $self->status_line;
      $body =~ s/&/&amp;/g;
      $body =~ s/</&lt;/g;
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request)
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meaning these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of a HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" or a "Content-Location:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  When the LWP protocol modules produce the HTTP::Response object, then
  any base URI embedded in the document (step 1) will already have
  initialized the "Content-Base:" header. This means that this method
  only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_RESPONSE

$fatpacked{"HTTP/Server/PSGI.pm"} = <<'HTTP_SERVER_PSGI';
  package HTTP::Server::PSGI;
  use strict;
  use warnings;
  
  use Carp ();
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Plack::TempBuffer;
  use Plack::Middleware::ContentLength;
  use POSIX qw(EINTR);
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use Try::Tiny;
  use Time::HiRes qw(time);
  
  my $alarm_interval;
  BEGIN {
      if ($^O eq 'MSWin32') {
          $alarm_interval = 1;
      } else {
          Time::HiRes->import('alarm');
          $alarm_interval = 0.1;
      }
  }
  
  use constant MAX_REQUEST_SIZE => 131072;
  use constant MSWin32          => $^O eq 'MSWin32';
  
  sub new {
      my($class, %args) = @_;
  
      my $self = bless {
          host               => $args{host} || 0,
          port               => $args{port} || 8080,
          timeout            => $args{timeout} || 300,
          server_software    => $args{server_software} || $class,
          server_ready       => $args{server_ready} || sub {},
          ssl                => $args{ssl},
          ipv6               => $args{ipv6},
          ssl_key_file       => $args{ssl_key_file},
          ssl_cert_file      => $args{ssl_cert_file},
      }, $class;
  
      if ($args{max_workers} && $args{max_workers} > 1) {
          Carp::carp(
              "Preforking in $class is deprecated. Falling back to the non-forking mode. ",
              "If you need preforking, use Starman or Starlet instead and run like `plackup -s Starlet`",
          );
      }
  
      $self;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub prepare_socket_class {
      my($self, $args) = @_;
  
      if ($self->{ssl} && $self->{ipv6}) {
          Carp::croak("SSL and IPv6 are not supported at the same time (yet). Choose one.");
      }
  
      if ($self->{ssl}) {
          eval { require IO::Socket::SSL; 1 }
              or Carp::croak("SSL suport requires IO::Socket::SSL");
          $args->{SSL_key_file}  = $self->{ssl_key_file};
          $args->{SSL_cert_file} = $self->{ssl_cert_file};
          return "IO::Socket::SSL";
      } elsif ($self->{ipv6}) {
          eval { require IO::Socket::IP; 1 }
              or Carp::croak("IPv6 support requires IO::Socket::IP");
          $self->{host}      ||= '::';
          $args->{LocalAddr} ||= '::';
          return "IO::Socket::IP";
      }
  
      return "IO::Socket::INET";
  }
  
  sub setup_listener {
      my $self = shift;
  
      my %args = (
          Listen    => SOMAXCONN,
          LocalPort => $self->{port},
          LocalAddr => $self->{host},
          Proto     => 'tcp',
          ReuseAddr => 1,
      );
  
      my $class = $self->prepare_socket_class(\%args);
      $self->{listen_sock} ||= $class->new(%args)
          or die "failed to listen to port $self->{port}: $!";
  
      $self->{server_ready}->($self);
  }
  
  sub accept_loop {
      my($self, $app) = @_;
  
      $app = Plack::Middleware::ContentLength->wrap($app);
  
      while (1) {
          local $SIG{PIPE} = 'IGNORE';
          if (my $conn = $self->{listen_sock}->accept) {
              $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                  or die "setsockopt(TCP_NODELAY) failed:$!";
              my $env = {
                  SERVER_PORT => $self->{port},
                  SERVER_NAME => $self->{host},
                  SCRIPT_NAME => '',
                  REMOTE_ADDR => $conn->peerhost,
                  'psgi.version' => [ 1, 1 ],
                  'psgi.errors'  => *STDERR,
                  'psgi.url_scheme' => $self->{ssl} ? 'https' : 'http',
                  'psgi.run_once'     => Plack::Util::FALSE,
                  'psgi.multithread'  => Plack::Util::FALSE,
                  'psgi.multiprocess' => Plack::Util::FALSE,
                  'psgi.streaming'    => Plack::Util::TRUE,
                  'psgi.nonblocking'  => Plack::Util::FALSE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'          => $conn,
              };
  
              $self->handle_connection($env, $conn, $app);
              $conn->close;
          }
      }
  }
  
  sub handle_connection {
      my($self, $env, $conn, $app) = @_;
  
      my $buf = '';
      my $res = [ 400, [ 'Content-Type' => 'text/plain' ], [ 'Bad Request' ] ];
  
      while (1) {
          my $rlen = $self->read_timeout(
              $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
              $self->{timeout},
          ) or return;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
              $buf = substr $buf, $reqlen;
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Plack::TempBuffer->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout})
                              or return;
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  open my $input, "<", \$buf;
                  $env->{'psgi.input'} = $input;
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res, $conn);
      } elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0], $conn);
          });
      } else {
          die "Bad response $res";
      }
  
      return;
  }
  
  sub _handle_response {
      my($self, $res, $conn) = @_;
  
      my @lines = (
          "Date: @{[HTTP::Date::time2str()]}\015\012",
          "Server: $self->{server_software}\015\012",
      );
  
      Plack::Util::header_iter($res->[1], sub {
          my ($k, $v) = @_;
          push @lines, "$k: $v\015\012";
      });
  
      unshift @lines, "HTTP/1.0 $res->[0] @{[ HTTP::Status::status_message($res->[0]) ]}\015\012";
      push @lines, "\015\012";
  
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $res->[2]) {
          my $err;
          my $done;
          {
              local $@;
              eval {
                  Plack::Util::foreach(
                      $res->[2],
                      sub {
                          $self->write_all($conn, $_[0], $self->{timeout})
                              or die "failed to send all data\n";
                      },
                  );
                  $done = 1;
              };
              $err = $@;
          };
          unless ($done) {
              if ($err =~ /^failed to send all data\n/) {
                  return;
              } else {
                  die $err;
              }
          }
      } else {
          return Plack::Util::inline_object
              write => sub { $self->write_all($conn, $_[0], $self->{timeout}) },
              close => sub { };
      }
  }
  
  # returns 1 if socket is ready, undef on timeout
  sub do_timeout {
      my ($self, $cb, $timeout) = @_;
      local $SIG{ALRM} = sub {};
      my $wait_until = time + $timeout;
      alarm($timeout);
      my $ret;
      while (1) {
          if ($ret = $cb->()) {
              last;
          } elsif (! (! defined($ret) && $! == EINTR)) {
              undef $ret;
              last;
          }
          # got EINTR
          my $left = $wait_until - time;
          last if $left <= 0;
          alarm($left + $alarm_interval);
      }
      alarm(0);
      $ret;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->sysread($$buf, $len, $off) }, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->syswrite($buf, $len, $off) }, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      return 0 unless defined $buf;
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Server::PSGI - Standalone PSGI compatible HTTP server
  
  =head1 SYNOPSIS
  
    use HTTP::Server::PSGI;
  
    my $server = HTTP::Server::PSGI->new(
        host => "127.0.0.1",
        port => 9091,
        timeout => 120,
    );
  
    $server->run($app);
  
  =head1 DESCRIPTION
  
  HTTP::Server::PSGI is a standalone, single-process and PSGI compatible
  HTTP server implementations.
  
  This server should be great for the development and testing, but might
  not be suitable for a production use.
  
  Some features in HTTP/1.1, notably chunked requests, responses and
  pipeline requests are B<NOT> supported. See L<Starman> if you want
  those features.
  
  =head1 PREFORKING
  
  L<HTTP::Server::PSGI> does B<NOT> support preforking. See L<Starman>
  or L<Starlet> if you want a multi-process prefork web servers.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Standalone> L<Starman> L<Starlet>
  
  =cut
HTTP_SERVER_PSGI

$fatpacked{"HTTP/Status.pm"} = <<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  require 5.002;   # because we use prototypes
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  @EXPORT_OK = qw(is_client_error is_server_error);
  $VERSION = "6.00";
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 2616
  # See also: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ tr/a-z \-/A-Z__/;
      $mnemonicCode .= "sub HTTP_$message () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  
  sub is_info         ($) { $_[0] >= 100 && $_[0] < 200; }
  sub is_success      ($) { $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect     ($) { $_[0] >= 300 && $_[0] < 400; }
  sub is_error        ($) { $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error ($) { $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error ($) { $_[0] >= 500 && $_[0] < 600; }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of a HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
     HTTP_REQUEST_URI_TOO_LARGE           (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_NO_CODE                         (425)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_RETRY_WITH                      (449)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
     HTTP_NOT_EXTENDED                    (510)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above.  If the $code is unknown, then C<undef> is returned.
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  return TRUE for both client error or a server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is an I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is an I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explict imports and
  the C<:constants> tag instead of relying on this.
HTTP_STATUS

$fatpacked{"Method/Generate/Accessor.pm"} = <<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use strictures 1;
  use Moo::_Utils;
  use base qw(Moo::Object);
  use Sub::Quote;
  use B 'perlstring';
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor};
    } elsif ($is eq 'lazy') {
      $spec->{init_arg} = undef unless exists $spec->{init_arg};
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless $spec->{default};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    my %methods;
    if (my $reader = $spec->{reader}) {
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      $methods{$pred} =
        quote_sub "${into}::${pred}" =>
          '    '.$self->_generate_simple_has('$_[0]', $name)."\n"
        ;
    }
    if (my $cl = $spec->{clearer}) {
      $methods{$cl} =
        quote_sub "${into}::${cl}" => 
          "    delete \$_[0]->{${\perlstring $name}}\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], Role::Tiny->methods_provided_by($hspec);
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $spec (@specs) {
        my ($proxy, $target, @args) = @$spec;
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" =>
          'do { '.$self->_generate_get($name, $spec).qq! }||die "Attempted to access '${name}' but it is not set"!,
          delete $self->{captures}
        ;
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and ($spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and ($spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      'do { '.$self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name),
      ).'; '.$simple.' }';
    }
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\perlstring $name}}";
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    $self->_generate_simple_set(
      $me, $name, $spec, $self->_generate_get_default($me, $name, $spec)
    ).' unless '.$test;
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    $spec->{default}
      ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
      : "${me}->${\$spec->{builder}}"
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->_generate_simple_get(@args);
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $simple = $self->_generate_simple_set('$self', $name, $spec, '$value');
      my $code = "do { my (\$self, \$value) = \@_;\n";
      if ($coerce) {
        $code .=
          "        \$value = "
          .$self->_generate_coerce($name, '$self', '$value', $coerce).";\n";
      }
      if ($isa_check) {
        $code .= 
          "        ".$self->_generate_isa_check($name, '$value', $isa_check).";\n";
      }
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', '$value', $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        \$value;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_coerce {
    my ($self, $name, $obj, $value, $coerce) = @_;
    $self->_generate_call_code($name, 'coerce', "${value}", $coerce);
  }
   
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check) = @_;
    $self->_generate_call_code($name, 'isa_check', $value, $check);
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    if (my $quoted = quoted_from_sub($sub)) {
      my $code = $quoted->[1];
      my $at_ = '@_ = ('.$values.');';
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_${name}};
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify(
          $code, $values, Sub::Quote::capture_unroll($cap_name, $captures, 6)
        );
      } else {
        Sub::Quote::inlinify($code, $values);
      }
    } else {
      my $cap_name = qq{\$${type}_for_${name}};
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $_, $spec
                        );
      my $get_value = 
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ( $spec->{coerce} ) {
          $get_value = $self->_generate_coerce(
              $name, $me, $get_value,
              $spec->{coerce}
            )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $me, $source,
              $spec->{coerce}
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub generate_multi_set {
    my ($self, $me, $to_set, $from) = @_;
    "\@{${me}}{qw(${\join ' ', @$to_set})} = $from";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    my $simple = "${me}->{${name_str}} = ${value}";
  
    if ($spec->{weak_ref}) {
      { local $@; require Scalar::Util; }
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      #Internals::SetReadWrite($foo);
      #Scalar::Util::weaken ($foo);
      #Internals::SetReadOnly($foo);
      #
      # but requires XS and is just too damn crazy
      # so simply throw a better exception
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : "Scalar::Util::weaken(${simple})";
  
        eval { Scalar::Util::weaken($simple); 1 } or do {
          if( \$@ =~ /Modification of a read-only value attempted/) {
            { local \$@; require Carp; }
            Carp::croak( sprintf (
              'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
              $name_str,
            ) );
          } else {
            die \$@;
          }
        };
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using perlstring
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot }
    );
    $into->can($name);
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = <<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B 'perlstring';
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @builds;
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = <<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use strictures 1;
  use Sub::Quote;
  use base qw(Moo::Object);
  use Sub::Defer;
  use B 'perlstring';
  
  sub register_attribute_specs {
    my ($self, %spec) = @_;
    @{$self->{attribute_specs}||={}}{keys %spec} = values %spec;
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string} or 'bless({}, $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    my $package = $self->{package};
    defer_sub "${package}::new" => sub {
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      { local $@; require Method::Generate::BuildAll; }
      $body .= Method::Generate::BuildAll->new->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      { local $@; require Method::Generate::DemolishAll; }
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_generator}) {
      '    if ($class ne '.perlstring($into).') {'."\n".
      '      '.$gen.";\n".
      '      return $class->'.$name.'(@_)'.";\n".
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my (@init, @slots, %test);
    my $ag = $self->accessor_generator;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      unless ($ag->is_simple_attribute($name, $attr_spec)) {
        next NAME unless defined($attr_spec->{init_arg})
                           or $ag->has_eager_default($name, $attr_spec);
        $test{$name} = $attr_spec->{init_arg};
        next NAME;
      }
      next NAME unless defined(my $i = $attr_spec->{init_arg});
      push @init, $i;
      push @slots, $name;
    }
    return '' unless @init or %test;
    join '', (
      @init
        ? '    '.$self->_cap_call($ag->generate_multi_set(
            '$new', [ @slots ], '@{$args}{qw('.join(' ',@init).')}'
          )).";\n"
        : ''
    ), map {
      my $arg_key = perlstring($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep $spec->{$_}{required},
          sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, qw('
      .join(' ',@required_init).')) {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  sub _check_isa {
    my ($self, $spec) = @_;
    my $acc = $self->accessor_generator;
    my $captures = $self->{captures};
    my $check = '';
    foreach my $name (sort keys %$spec) {
      my ($init, $isa) = @{$spec->{$name}}{qw(init_arg isa)};
      next unless $init and $isa;
      my $init_str = perlstring($init);
      my ($code, $add_captures) = $acc->generate_isa_check(
        $name, "\$args->{${init_str}}", $isa
      );
      @{$captures}{keys %$add_captures} = values %$add_captures;
      $check .= "    ${code}".(
        (not($spec->{lazy}) and ($spec->{default} or $spec->{builder})
          ? ";\n"
          : "if exists \$args->{${init_str}};\n"
        )
      );
    }
    return $check;
  }
  
  sub _fire_triggers {
    my ($self, $spec) = @_;
    my $acc = $self->accessor_generator;
    my $captures = $self->{captures};
    my $fire = '';
    foreach my $name (sort keys %$spec) {
      my ($init, $trigger) = @{$spec->{$name}}{qw(init_arg trigger)};
      next unless $init && $trigger;
      my ($code, $add_captures) = $acc->generate_trigger(
        $name, '$new', $acc->generate_simple_get('$new', $name), $trigger
      );
      @{$captures}{keys %$add_captures} = values %$add_captures;
      $fire .= "    ${code} if exists \$args->{${\perlstring $init}};\n";
    }
    return $fire;
  }
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = <<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B qw(perlstring);
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL($Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = <<'METHOD_INLINER';
  package Method::Inliner;
  
  use strictures 1;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
  	$fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Moo.pm"} = <<'MOO';
  package Moo;
  
  use strictures 1;
  use Moo::_Utils;
  use B 'perlstring';
  
  our $VERSION = '0.009013'; # 0.9.13
  $VERSION = eval $VERSION;
  
  our %MAKERS;
  
  sub import {
    my $target = caller;
    my $class = shift;
    strictures->import;
    return if $MAKERS{$target}; # already exported into this package
    *{_getglob("${target}::extends")} = sub {
      _load_module($_) for @_;
      # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
      @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    };
    *{_getglob("${target}::with")} = sub {
      { local $@; require Moo::Role; }
      die "Only one role supported at a time by with" if @_ > 1;
      Moo::Role->apply_role_to_package($target, $_[0]);
    };
    $MAKERS{$target} = {};
    *{_getglob("${target}::has")} = sub {
      my ($name, %spec) = @_;
      ($MAKERS{$target}{accessor} ||= do {
        { local $@; require Method::Generate::Accessor; }
        Method::Generate::Accessor->new
      })->generate_method($target, $name, \%spec);
      $class->_constructor_maker_for($target)
            ->register_attribute_specs($name, \%spec);
    };
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        { local $@; require Class::Method::Modifiers; }
        _install_modifier($target, $type, @_);
      };
    }
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        { local $@; require Moo::Object; } ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target, $select_super) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      {
        local $@;
        require Method::Generate::Constructor;
        require Sub::Defer;
      }
      my ($moo_constructor, $con);
  
      if ($select_super && $MAKERS{$select_super}) {
        $moo_constructor = 1;
        $con = $MAKERS{$select_super}{constructor};
      } else {
        my $t_new = $target->can('new');
        if ($t_new) {
          if ($t_new == Moo::Object->can('new')) {
            $moo_constructor = 1;
          } elsif (my $defer_target = (Sub::Defer::defer_info($t_new)||[])->[0]) {
            my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
            if ($MAKERS{$pkg}) {
              $moo_constructor = 1;
              $con = $MAKERS{$pkg}{constructor};
            }
          }
        } else {
          $moo_constructor = 1; # no other constructor, make a Moo one
        }
      };
      Method::Generate::Constructor
        ->new(
          package => $target,
          accessor_generator => do {
            { local $@; require Method::Generate::Accessor; }
            Method::Generate::Accessor->new;
          },
          construction_string => (
            $moo_constructor
              ? ($con ? $con->construction_string : undef)
              : ('$class->'.$target.'::SUPER::new(@_)')
          ),
          subconstructor_generator => (
            $class.'->_constructor_maker_for($class,'.perlstring($target).')'
          ),
        )
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  1;
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatiblity)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
   use Sub::Quote;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
  );
  
   has pounds => (
     is  => 'rw',
     isa => quote_sub q{ die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  and else where
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  This module is an extremely light-weight, high-performance L<Moose> replacement.
  It also avoids depending on any XS modules to allow simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -but not quite- two
  thirds of L<Moose>.
  
  Unlike C<Mouse> this module does not aim at full L<Moose> compatibility.  See
  L</INCOMPATIBILITIES> for more details.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  I've tried several times to use L<Mouse> but it's 3x the size of Moo and
  takes longer to load than most of my Moo based CGI scripts take to run.
  
  If you don't want L<Moose>, you don't want "less metaprotocol" like L<Mouse>,
  you want "as little as possible" - which means "no metaprotocol", which is
  what Moo provides.
  
  By Moo 1.0 I intend to have Moo's equivalent of L<Any::Moose> built in -
  if Moose gets loaded, any Moo class or role will act as a Moose equivalent
  if treated as such.
  
  Hence - Moo exists as its name - Minimal Object Orientation - with a pledge
  to make it smooth to upgrade to L<Moose> when you need more than minimal
  features.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   around BUILDARGS => sub {
     my $orig = shift;
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return $class->$orig(@args);
   };
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares base class. Multiple superclasses can be passed for multiple
  inheritance (but please use roles instead).
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  Composes a L<Role::Tiny> into current class.  Only one role may be composed in
  at a time to allow the code to remain as simple as possible.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * is
  
  B<required>, must be C<ro> or C<rw>.  Unsurprisingly, C<ro> generates an
  accessor that will not respond to arguments; to be clear: a getter only. C<rw>
  will create a perlish getter/setter.
  
  =item * isa
  
  Takes a coderef which is meant to validate the attribute.  Unlike L<Moose> Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   isa => quote_sub q{
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * coerce
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => quote_sub q{
     $_[0] + 1 unless $_[0] % 2
   },
  
  Coerce does not require C<isa> to be defined.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * handles
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a role (L<Moo::Role>) that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * trigger
  
  Takes a coderef which will get called any time the attribute is set. Coderef
  will be invoked against the object with the new value as an argument.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * default
  
  Takes a coderef which will get called with $self as its only argument
  to populate an attribute if no value is supplied to the constructor - or
  if the attribute is lazy, when the attribute is first retrieved if no
  value has yet been provided.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * predicate
  
  Takes a method name which will return true if an attribute has a value.
  
  A common example of this would be to call it C<has_$foo>, implying that the
  object has a C<$foo> set.
  
  =item * builder
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  =item * clearer
  
  Takes a method name which will clear the attribute.
  
  =item * lazy
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * required
  
  B<Boolean>.  Set this if the attribute must be passed on instantiation.
  
  =item * reader
  
  The value of this attribute will be the name of the method to get the value of
  the attribute.  If you like Java style methods, you might set this to
  C<get_foo>
  
  =item * writer
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>
  
  =item * weak_ref
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened; use this when circular references are possible, which will cause
  leaks.
  
  =item * init_arg
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  You can only compose one role at a time.  If your application is large or
  complex enough to warrant complex composition, you wanted L<Moose>.
  
  There is no complex type system.  C<isa> is verified with a coderef, if you
  need complex types, just make a library of coderefs, or better yet, functions
  that return quoted subs.
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea but may be supported by an extension in future.
  
  There is no meta object.  If you need this level of complexity you wanted
  L<Moose> - Moo succeeds at being small because it explicitly does not
  provide a metaprotocol.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - override can
  be handled by around albeit with a little more typing, and the author considers
  augment to be a bad idea.
  
  L</default> only supports coderefs, because doing otherwise is usually a
  mistake anyway.
  
  C<lazy_build> is not supported per se, but of course it will work if you
  manually set all the options it implies.
  
  C<auto_deref> is not supported since the author considers it a bad idea.
  
  C<documentation> is not supported since it's a very poor replacement for POD.
  
  Handling of warnings: when you C<use Moo> we enable FATAL warnings.  The nearest
  similar invocation for L<Moose> would be:
  
    use Moose;
    use warnings FATAL => "all";
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts>.  So if you:
  
      package MyClass;
      use Moo;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2011 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
MOO

$fatpacked{"Moo/Object.pm"} = <<'MOO_OBJECT';
  package Moo::Object;
  
  use strictures 1;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          { local $@; require Method::Generate::DemolishAll; }
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    $NO_BUILD{$class} and
      return bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class)
      : do {
          my $proto = ref($_[0]) eq 'HASH' ? $_[0] : { @_ };
          bless({ %$proto }, $class)->BUILDALL($proto);
        };
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      { local $@; require Method::Generate::BuildAll; }
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      { local $@; require Method::Generate::DemolishAll; }
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    { local $@; require Role::Tiny; }
    { no warnings 'redefine'; *does = \&Role::Tiny::does_role }
    goto &Role::Tiny::does_role;
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = <<'MOO_ROLE';
  package Moo::Role;
  
  use strictures 1;
  use Moo::_Utils;
  use base qw(Role::Tiny);
  
  BEGIN { *INFO = \%Role::Tiny::INFO }
  
  our %INFO;
  
  sub import {
    my $target = caller;
    strictures->import;
    return if $INFO{$target}; # already exported into this package
    # get symbol table reference
    my $stash = do { no strict 'refs'; \%{"${target}::"} };
    *{_getglob "${target}::has"} = sub {
      my ($name, %spec) = @_;
      ($INFO{$target}{accessor_maker} ||= do {
        { local $@; require Method::Generate::Accessor; }
        Method::Generate::Accessor->new
      })->generate_method($target, $name, \%spec);
      $INFO{$target}{attributes}{$name} = \%spec;
    };
    goto &Role::Tiny::import;
  }
  
  sub apply_role_to_package {
    my ($me, $to, $role) = @_;
    $me->SUPER::apply_role_to_package($to, $role);
    $me->_handle_constructor($to, $INFO{$role}{attributes});
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    { local $@; require Sub::Quote; }
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Role::Tiny" unless my $info = $INFO{$role};
    }
  
    $Moo::MAKERS{$new_name} = {};
  
    $me->_handle_constructor(
      $new_name, { map %{$INFO{$_}{attributes}||{}}, @roles }, $superclass
    );
  
    return $new_name;
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _handle_constructor {
    my ($me, $to, $attr_info, $superclass) = @_;
    return unless $attr_info && keys %$attr_info;
    if ($INFO{$to}) {
      @{$INFO{$to}{attributes}||={}}{keys %$attr_info} = values %$attr_info;
    } else {
      # only fiddle with the constructor if the target is a Moo class
      if ($INC{"Moo.pm"}
          and my $con = Moo->_constructor_maker_for($to, $superclass)) {
        $con->register_attribute_specs(%$attr_info);
      }
    }
  }
  
  1;
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  else where
  
   package Some::Class;
  
   use Moo;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = <<'MOO__UTILS';
  package Moo::_Utils;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  BEGIN {
    *lt_5_8_3 = $] < 5.008003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  use strictures 1;
  use base qw(Exporter);
  use Moo::_mro;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa
  );
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      { local $@; require Sub::Defer; }
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  # _load_module is inlined in Role::Tiny - make sure to copy if you update it.
  
  sub _load_module {
    (my $proto = $_[0]) =~ s/::/\//g;
    return 1 if $INC{"${proto}.pm"};
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1 if grep !/::$/, keys %{_getstash($_[0])||{}};
    { local $@; require "${proto}.pm"; }
    return 1;
  }
  
  sub _maybe_load_module {
    return $MAYBE_LOADED{$_[0]} if exists $MAYBE_LOADED{$_[0]};
    (my $proto = $_[0]) =~ s/::/\//g;
    local $@;
    if (eval { require "${proto}.pm"; 1 }) {
      $MAYBE_LOADED{$_[0]} = 1;
    } else {
      if (exists $INC{"${proto}.pm"}) {
        warn "$_[0] exists but failed to load with error: $@";
      }
      $MAYBE_LOADED{$_[0]} = 0;
    }
    return $MAYBE_LOADED{$_[0]};
  }
  
  sub _get_linear_isa {
      return mro::get_linear_isa($_[0]);
  }
  
  our $_in_global_destruction = 0;
  END { $_in_global_destruction = 1 }
  
  sub STANDARD_DESTROY {
    my $self = shift;
  
    my $e = do {
      local $?;
      local $@;
      eval {
        $self->DEMOLISHALL($_in_global_destruction);
      };
      $@;
    };
  
    no warnings 'misc';
    die $e if $e; # rethrow
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = <<'MOO__MRO';
  package Moo::_mro;
  
  local $@;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Plack.pm"} = <<'PLACK';
  package Plack;
  
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack - Perl Superglue for Web frameworks and Web Servers (PSGI toolkit)
  
  =head1 DESCRIPTION
  
  Plack is a set of tools for using the PSGI stack. It contains
  middleware components, a reference server and utilities for Web
  application frameworks. Plack is like Ruby's Rack or Python's Paste
  for WSGI.
  
  See L<PSGI> for the PSGI specification and L<PSGI::FAQ> to know what
  PSGI and Plack are and why we need them.
  
  =head1 MODULES AND UTILITIES
  
  =head2 Plack::Handler
  
  L<Plack::Handler> and its subclasses contains adapters for web
  servers. We have adapters for the built-in standalone web server
  L<HTTP::Server::PSGI>, L<CGI|Plack::Handler::CGI>,
  L<FCGI|Plack::Handler::FCGI>, L<Apache1|Plack::Handler::Apache1>,
  L<Apache2|Plack::Handler::Apache2> and
  L<HTTP::Server::Simple|Plack::Handler::HTTP::Server::Simple> included
  in the core Plack distribution.
  
  There are also many HTTP server implementations on CPAN that have Plack
  handlers.
  
  See L<Plack::Handler> when writing your own adapters.
  
  =head2 Plack::Loader
  
  L<Plack::Loader> is a loader to load one L<Plack::Handler> adapter
  and run a PSGI application code reference with it.
  
  =head2 Plack::Util
  
  L<Plack::Util> contains a lot of utility functions for server
  implementors as well as middleware authors.
  
  =head2 .psgi files
  
  A PSGI application is a code reference but it's not easy to pass code
  reference via the command line or configuration files, so Plack uses a
  convention that you need a file named C<app.psgi> or similar, which
  would be loaded (via perl's core function C<do>) to return the PSGI
  application code reference.
  
    # Hello.psgi
    my $app = sub {
        my $env = shift;
        # ...
        return [ $status, $headers, $body ];
    };
  
  If you use a web framework, chances are that they provide a helper
  utility to automatically generate these C<.psgi> files for you, such
  as:
  
    # MyApp.psgi
    use MyApp;
    my $app = sub { MyApp->run_psgi(@_) };
  
  It's important that the return value of C<.psgi> file is the code
  reference. See C<eg/dot-psgi> directory for more examples of C<.psgi>
  files.
  
  =head2 plackup, Plack::Runner
  
  L<plackup> is a command line launcher to run PSGI applications from
  command line using L<Plack::Loader> to load PSGI backends. It can be
  used to run standalone servers and FastCGI daemon processes. Other
  server backends like Apache2 needs a separate configuration but
  C<.psgi> application file can still be the same.
  
  If you want to write your own frontend that replaces, or adds
  functionalities to L<plackup>, take a look at the L<Plack::Runner> module.
  
  =head2 Plack::Middleware
  
  PSGI middleware is a PSGI application that wraps an existing PSGI
  application and plays both side of application and servers. From the
  servers the wrapped code reference still looks like and behaves
  exactly the same as PSGI applications.
  
  L<Plack::Middleware> gives you an easy way to wrap PSGI applications
  with a clean API, and compatibility with L<Plack::Builder> DSL.
  
  =head2 Plack::Builder
  
  L<Plack::Builder> gives you a DSL that you can enable Middleware in
  C<.psgi> files to wrap existent PSGI applications.
  
  =head2 Plack::Request, Plack::Response
  
  L<Plack::Request> gives you a nice wrapper API around PSGI C<$env>
  hash to get headers, cookies and query parameters much like
  L<Apache::Request> in mod_perl.
  
  L<Plack::Response> does the same to construct the response array
  reference.
  
  =head2 Plack::Test
  
  L<Plack::Test> is a unified interface to test your PSGI application
  using standard L<HTTP::Request> and L<HTTP::Response> pair with simple
  callbacks.
  
  =head2 Plack::Test::Suite
  
  L<Plack::Test::Suite> is a test suite to test a new PSGI server backend.
  
  =head1 CONTRIBUTING
  
  =head2 Patches and Bug Fixes
  
  Small patches and bug fixes can be either submitted via nopaste on IRC
  L<irc://irc.perl.org/#plack> or L<the github issue
  tracker|http://github.com/miyagawa/Plack/issues>.  Forking on
  L<github|http://github.com/miyagawa/Plack> is another good way if you
  intend to make larger fixes.
  
  See also L<http://contributing.appspot.com/plack> when you think this
  document is terribly outdated.
  
  =head2 Module Namespaces
  
  Modules added to the Plack:: sub-namespaces should be reasonably generic
  components which are useful as building blocks and not just simply using
  Plack.
  
  Middleware authors are free to use the Plack::Middleware:: namespace for
  their middleware components. Middleware must be written in the pipeline
  style such that they can chained together with other middleware components.
  The Plack::Middleware:: modules in the core distribution are good examples
  of such modules. It is recommended that you inherit from L<Plack::Middleware>
  for these types of modules.
  
  Not all middleware components are wrappers, but instead are more like
  endpoints in a middleware chain. These types of components should use the
  Plack::App:: namespace. Again, look in the core modules to see excellent
  examples of these (L<Plack::App::File>, L<Plack::App::Directory>, etc.).
  It is recommended that you inherit from L<Plack::Component> for these
  types of modules.
  
  B<DO NOT USE> Plack:: namespace to build a new web application or a
  framework. It's like naming your application under CGI:: namespace if
  it's supposed to run on CGI and that is a really bad choice and
  would confuse people badly.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 COPYRIGHT
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  Copyright 2009-2011 Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Yuval Kogman (nothingmuch)
  
  Tokuhiro Matsuno (tokuhirom)
  
  Kazuhiro Osawa (Yappo)
  
  Kazuho Oku
  
  Florian Ragwitz (rafl)
  
  Chia-liang Kao (clkao)
  
  Masahiro Honma (hiratara)
  
  Daisuke Murase (typester)
  
  John Beppu
  
  Matt S Trout (mst)
  
  Shawn M Moore (Sartak)
  
  Stevan Little
  
  Hans Dieter Pearcey (confound)
  
  Tomas Doran (t0m)
  
  mala
  
  Mark Stosberg
  
  Aaron Trevena
  
  =head1 SEE ALSO
  
  The L<PSGI> specification upon which Plack is based.
  
  L<http://plackperl.org/>
  
  The Plack wiki: L<https://github.com/miyagawa/Plack/wiki>
  
  The Plack FAQ: L<https://github.com/miyagawa/Plack/wiki/Faq>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK

$fatpacked{"Plack/App/CGIBin.pm"} = <<'PLACK_APP_CGIBIN';
  package Plack::App::CGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util::Accessor qw( exec_cb );
  use Plack::App::WrapCGI;
  
  sub allow_path_info { 1 }
  
  my %exec_cache;
  
  sub would_exec {
      my($self, $file) = @_;
  
      return $exec_cache{$file} if exists $exec_cache{$file};
  
      my $exec_cb = $self->exec_cb || sub { $self->exec_cb_default(@_) };
  
      return $exec_cache{$file} = $exec_cb->($file);
  }
  
  sub exec_cb_default {
      my($self, $file) = @_;
  
      if ($file =~ /\.pl$/i) {
          return 0;
      } elsif ($self->shebang_for($file) =~ /^\#\!.*perl/) {
          return 0;
      } else {
          return 1;
      }
  }
  
  sub shebang_for {
      my($self, $file) = @_;
  
      open my $fh, "<", $file or return '';
      my $line = <$fh>;
      return $line;
  }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::App::WrapCGI->new(
          script => $file, execute => $self->would_exec($file),
      );
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::CGIBin - cgi-bin replacement for Plack servers
  
  =head1 SYNOPSIS
  
    use Plack::App::CGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app;
    builder {
        mount "/cgi-bin" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::CGIBin -e 'Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app'
  
  =head1 DESCRIPTION
  
  Plack::App::CGIBin allows you to load CGI scripts from a directory and
  convert them into a PSGI application.
  
  This would give you the extreme easiness when you have bunch of old
  CGI scripts that is loaded using I<cgi-bin> of Apache web server.
  
  =head1 HOW IT WORKS
  
  This application checks if a given file path is a perl script and if
  so, uses L<CGI::Compile> to compile a CGI script into a sub (like
  L<ModPerl::Registry>) and then run it as a persistent application
  using L<CGI::Emulate::PSGI>.
  
  If the give file is not a perl script, it executes the script just
  like a normal CGI script with fork & exec. This is like a normal web
  server mode and no performance benefit is achieved.
  
  The default mechanism to determine if a given file is a Perl script is
  as follows:
  
  =over 4
  
  =item *
  
  Check if the filename ends with C<.pl>
  
  =item *
  
  Open the file and see if the shebang (first line of the file) contains the word C<perl>
  
  =back
  
  You can customize this behavior by passing C<exec_cb> callback, which
  takes a file path to its first argument.
  
  For example, if your perl-based CGI script uses lots of global
  variables and such and are not ready to run on a persistent
  environment, you can do:
  
    my $app = Plack::App::CGIBin->new(
        root => "/path/to/cgi-bin",
        exec_cb => sub { 1 },
    )->to_app;
  
  to always force the execute option for any files.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File> L<CGI::Emulate::PSGI> L<CGI::Compile> L<Plack::App::WrapCGI>
  
  See also L<Plack::App::WrapCGI> if you compile one CGI script into a
  PSGI application without serving CGI scripts from a directory, to
  remove overhead of filesystem lookups, etc.
  
  =cut
PLACK_APP_CGIBIN

$fatpacked{"Plack/App/Cascade.pm"} = <<'PLACK_APP_CASCADE';
  package Plack::App::Cascade;
  use strict;
  use base qw(Plack::Component);
  
  use Plack::Util;
  use Plack::Util::Accessor qw(apps catch codes);
  
  sub add {
      my $self = shift;
      $self->apps([]) unless $self->apps;
      push @{$self->apps}, @_;
  }
  
  sub prepare_app {
      my $self = shift;
      my %codes = map { $_ => 1 } @{ $self->catch || [ 404 ] };
      $self->codes(\%codes);
  }
  
  sub call {
      my($self, $env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $res = [ 404, [ 'Content-Type' => 'text/html' ], [ '404 Not Found' ] ];
  
          my $done;
          my $respond_wrapper = sub {
              my $res = shift;
              if ($self->codes->{$res->[0]}) {
                  return Plack::Util::inline_object
                      write => sub { }, close => sub { };
              } else {
                  $done = 1;
                  return $respond->($res);
              }
          };
  
          for my $app (@{$self->apps || []}) {
              my $res = $app->($env);
              if (ref $res eq 'CODE') {
                  $res->($respond_wrapper);
              } else {
                  $respond_wrapper->($res);
              }
              return if $done;
          }
  
          $respond->($res);
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Cascade - Cascadable compound application
  
  =head1 SYNOPSIS
  
    use Plack::App::Cascade;
    use Plack::App::URLMap;
    use Plack::App::File;
  
    # Serve static files from multiple search paths
    my $cascade = Plack::App::Cascade->new;
    $cascade->add( Plack::App::File->new(root => "/www/example.com/foo")->to_app );
    $cascade->add( Plack::App::File->new(root => "/www/example.com/bar")->to_app );
  
    my $app = Plack::App::URLMap->new;
    $app->map("/static", $cascade);
    $app->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::Cascade is a Plack middleware component that compounds
  several apps and tries them to return the first response that is not
  404.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $app = Plack::App::Cascade->new(apps => [ $app1, $app2 ]);
  
  Creates a new Cascade application.
  
  =item add
  
    $app->add($app1);
    $app->add($app2, $app3);
  
  Appends a new application to the list of apps to try. You can pass the
  multiple apps to the one C<add> call.
  
  =item catch
  
    $app->catch([ 403, 404 ]);
  
  Sets which error codes to catch and process onwards. Defaults to C<404>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::URLMap> Rack::Cascade
  
  =cut
PLACK_APP_CASCADE

$fatpacked{"Plack/App/Directory.pm"} = <<'PLACK_APP_DIRECTORY';
  package Plack::App::Directory;
  use parent qw(Plack::App::File);
  use strict;
  use warnings;
  use Plack::Util;
  use HTTP::Date;
  use Plack::MIME;
  use DirHandle;
  use URI::Escape;
  use Plack::Request;
  
  # Stolen from rack/directory.rb
  my $dir_file = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>";
  my $dir_page = <<PAGE;
  <html><head>
    <title>%s</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style type='text/css'>
  table { width:100%%; }
  .name { text-align:left; }
  .size, .mtime { text-align:right; }
  .type { width:11em; }
  .mtime { width:15em; }
    </style>
  </head><body>
  <h1>%s</h1>
  <hr />
  <table>
    <tr>
      <th class='name'>Name</th>
      <th class='size'>Size</th>
      <th class='type'>Type</th>
      <th class='mtime'>Last Modified</th>
    </tr>
  %s
  </table>
  <hr />
  </body></html>
  PAGE
  
  sub should_handle {
      my($self, $file) = @_;
      return -d $file || -f $file;
  }
  
  sub return_dir_redirect {
      my ($self, $env) = @_;
      my $uri = Plack::Request->new($env)->uri;
      return [ 301,
          [
              'Location' => $uri . '/',
              'Content-Type' => 'text/plain',
              'Content-Length' => 8,
          ],
          [ 'Redirect' ],
      ];
  }
  
  sub serve_path {
      my($self, $env, $dir, $fullpath) = @_;
  
      if (-f $dir) {
          return $self->SUPER::serve_path($env, $dir, $fullpath);
      }
  
      my $dir_url = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
  
      if ($dir_url !~ m{/$}) {
          return $self->return_dir_redirect($env);
      }
  
      my @files = ([ "../", "Parent Directory", '', '', '' ]);
  
      my $dh = DirHandle->new($dir);
      my @children;
      while (defined(my $ent = $dh->read)) {
          next if $ent eq '.';
          push @children, $ent;
      }
  
      for my $basename (sort { $a cmp $b } @children) {
          my $file = "$dir/$basename";
          my $url = $dir_url . $basename;
  
          my $is_dir = -d $file;
          my @stat = stat _;
  
          $url = join '/', map {uri_escape($_)} split m{/}, $url;
  
          if ($is_dir) {
              $basename .= "/";
              $url      .= "/";
          }
  
          my $mime_type = $is_dir ? 'directory' : ( Plack::MIME->mime_type($file) || 'text/plain' );
          push @files, [ $url, $basename, $stat[7], $mime_type, HTTP::Date::time2str($stat[9]) ];
      }
  
      my $path  = Plack::Util::encode_html("Index of $env->{PATH_INFO}");
      my $files = join "\n", map {
          my $f = $_;
          sprintf $dir_file, map Plack::Util::encode_html($_), @$f;
      } @files;
      my $page  = sprintf $dir_page, $path, $path, $files;
  
      return [ 200, ['Content-Type' => 'text/html; charset=utf-8'], [ $page ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Directory - Serve static files from document root with directory index
  
  =head1 SYNOPSIS
  
    # app.psgi
    use Plack::App::Directory;
    my $app = Plack::App::Directory->new({ root => "/path/to/htdocs" })->to_app;
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application with directory index a la Apache's mod_autoindex.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to the current directory.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File>
  
  =cut
PLACK_APP_DIRECTORY

$fatpacked{"Plack/App/File.pm"} = <<'PLACK_APP_FILE';
  package Plack::App::File;
  use strict;
  use warnings;
  use parent qw/Plack::Component/;
  use File::Spec::Unix;
  use Cwd ();
  use Plack::Util;
  use Plack::MIME;
  use HTTP::Date;
  
  use Plack::Util::Accessor qw( root file content_type encoding );
  
  sub should_handle {
      my($self, $file) = @_;
      return -f $file;
  }
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my($file, $path_info) = $self->file || $self->locate_file($env);
      return $file if ref $file eq 'ARRAY';
  
      if ($path_info) {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.SCRIPT_NAME'} =~ s/\Q$path_info\E$//;
          $env->{'plack.file.PATH_INFO'}   = $path_info;
      } else {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.PATH_INFO'}   = '';
      }
  
      return $self->serve_path($env, $file);
  }
  
  sub locate_file {
      my($self, $env) = @_;
  
      my $path = $env->{PATH_INFO} || '';
  
      if ($path =~ /\0/) {
          return $self->return_400;
      }
  
      my $docroot = $self->root || ".";
      my @path = split '/', $path;
      if (@path) {
          shift @path if $path[0] eq '';
      } else {
          @path = ('.');
      }
  
      if (grep $_ eq '..', @path) {
          return $self->return_403;
      }
  
      my($file, @path_info);
      while (@path) {
          my $try = File::Spec::Unix->catfile($docroot, @path);
          if ($self->should_handle($try)) {
              $file = $try;
              last;
          } elsif (!$self->allow_path_info) {
              last;
          }
          unshift @path_info, pop @path;
      }
  
      if (!$file) {
          return $self->return_404;
      }
  
      if (!-r $file) {
          return $self->return_403;
      }
  
      return $file, join("/", "", @path_info);
  }
  
  sub allow_path_info { 0 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $content_type = $self->content_type || Plack::MIME->mime_type($file)
                         || 'text/plain';
  
      if ($content_type =~ m!^text/!) {
          $content_type .= "; charset=" . ($self->encoding || "utf-8");
      }
  
      open my $fh, "<:raw", $file
          or return $self->return_403;
  
      my @stat = stat $file;
  
      Plack::Util::set_io_path($fh, Cwd::realpath($file));
  
      return [
          200,
          [
              'Content-Type'   => $content_type,
              'Content-Length' => $stat[7],
              'Last-Modified'  => HTTP::Date::time2str( $stat[9] )
          ],
          $fh,
      ];
  }
  
  sub return_403 {
      my $self = shift;
      return [403, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['forbidden']];
  }
  
  sub return_400 {
      my $self = shift;
      return [400, ['Content-Type' => 'text/plain', 'Content-Length' => 11], ['Bad Request']];
  }
  
  # Hint: subclasses can override this to return undef to pass through 404
  sub return_404 {
      my $self = shift;
      return [404, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['not found']];
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::App::File - Serve static files from root directory
  
  =head1 SYNOPSIS
  
    use Plack::App::File;
    my $app = Plack::App::File->new(root => "/path/to/htdocs")->to_app;
  
    # Or map the path to a specific file
    use Plack::Builder;
    builder {
        mount "/favicon.ico" => Plack::App::File->new(file => '/path/to/favicon.ico');
    };
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application, and internally used by
  L<Plack::Middleware::Static>. This application serves file from
  document root if the path matches with the local file. Use
  L<Plack::App::Directory> if you want to list files in the directory
  as well.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to C<.> (current directory)
  
  =item file
  
  The file path to create responses from. Optional.
  
  If it's set the application would B<ALWAYS> create a response out of
  the file and there will be no security check etc. (hence fast). If
  it's not set, the application uses C<root> to find the matching file.
  
  =item encoding
  
  Set the file encoding for text files. Defaults to C<utf-8>.
  
  =item content_type
  
  Set the file content type. If not set L<Plack::MIME> will try to detect it
  based on the file extension or fall back to C<text/plain>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::Static> L<Plack::App::Directory>
  
  =cut
  
  
PLACK_APP_FILE

$fatpacked{"Plack/App/PSGIBin.pm"} = <<'PLACK_APP_PSGIBIN';
  package Plack::App::PSGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util;
  
  sub allow_path_info { 1 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::Util::load_psgi($file);
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::PSGIBin - Run .psgi files from a directory
  
  =head1 SYNOPSIS
  
    use Plack::App::PSGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::PSGIBin->new(root => "/path/to/psgi/scripts")->to_app;
    builder {
        mount "/psgi" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::PSGIBin -e 'Plack::App::PSGIBin->new(root => "/path/psgi/scripts")->to_app'
  
  =head1 DESCRIPTION
  
  This application loads I<.psgi> files (or actually whichever filename
  extensions) from the root directory and run it as a PSGI
  application. Suppose you have a directory containing C<foo.psgi> and
  C<bar.psgi>, map this application to C</app> with
  L<Plack::App::URLMap> and you can access them via the URL:
  
    http://example.com/app/foo.psgi
    http://example.com/app/bar.psgi
  
  to load them. You can rename the file to the one without C<.psgi>
  extension to make the URL look nicer, or use the URL rewriting tools
  like L<Plack::Middleware::Rewrite> to do the same thing.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
PLACK_APP_PSGIBIN

$fatpacked{"Plack/App/URLMap.pm"} = <<'PLACK_APP_URLMAP';
  package Plack::App::URLMap;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use constant DEBUG => $ENV{PLACK_URLMAP_DEBUG};
  
  use Carp ();
  
  sub mount { shift->map(@_) }
  
  sub map {
      my $self = shift;
      my($location, $app) = @_;
  
      my $host;
      if ($location =~ m!^https?://(.*?)(/.*)!) {
          $host     = $1;
          $location = $2;
      }
  
      if ($location !~ m!^/!) {
          Carp::croak("Paths need to start with /");
      }
      $location =~ s!/$!!;
  
      push @{$self->{_mapping}}, [ $host, $location, $app ];
  }
  
  sub prepare_app {
      my $self = shift;
      # sort by path length
      $self->{_sorted_mapping} = [
          map  { [ @{$_}[2..4] ] }
          sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] }
          map  { [ ($_->[0] ? length $_->[0] : 0), length($_->[1]), @$_ ] } @{$self->{_mapping}},
      ];
  }
  
  sub call {
      my ($self, $env) = @_;
  
      my $path_info   = $env->{PATH_INFO};
      my $script_name = $env->{SCRIPT_NAME};
  
      my($http_host, $server_name) = @{$env}{qw( HTTP_HOST SERVER_NAME )};
  
      if ($http_host and my $port = $env->{SERVER_PORT}) {
          $http_host =~ s/:$port$//;
      }
  
      for my $map (@{ $self->{_sorted_mapping} }) {
          my($host, $location, $app) = @$map;
          my $path = $path_info; # copy
          no warnings 'uninitialized';
          DEBUG && warn "Matching request (Host=$http_host Path=$path) and the map (Host=$host Path=$location)\n";
          next unless not defined $host     or
                      $http_host   eq $host or
                      $server_name eq $host;
          next unless $location eq '' or $path =~ s!^\Q$location\E!!;
          next unless $path eq '' or $path =~ m!^/!;
          DEBUG && warn "-> Matched!\n";
  
          my $orig_path_info   = $env->{PATH_INFO};
          my $orig_script_name = $env->{SCRIPT_NAME};
  
          $env->{PATH_INFO}  = $path;
          $env->{SCRIPT_NAME} = $script_name . $location;
          return $self->response_cb($app->($env), sub {
              $env->{PATH_INFO} = $orig_path_info;
              $env->{SCRIPT_NAME} = $orig_script_name;
          });
      }
  
      DEBUG && warn "All matching failed.\n";
  
      return [404, [ 'Content-Type' => 'text/plain' ], [ "Not Found" ]];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::URLMap - Map multiple apps in different paths
  
  =head1 SYNOPSIS
  
    use Plack::App::URLMap;
  
    my $app1 = sub { ... };
    my $app2 = sub { ... };
    my $app3 = sub { ... };
  
    my $urlmap = Plack::App::URLMap->new;
    $urlmap->map("/" => $app1);
    $urlmap->map("/foo" => $app2);
    $urlmap->map("http://bar.example.com/" => $app3);
  
    my $app = $urlmap->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::URLMap is a PSGI application that can dispatch multiple
  applications based on URL path and hostnames (a.k.a "virtual hosting")
  and takes care of rewriting C<SCRIPT_NAME> and C<PATH_INFO> (See
  L</"HOW THIS WORKS"> for details). This module is inspired by
  Rack::URLMap.
  
  =head1 METHODS
  
  =over 4
  
  =item map
  
    $urlmap->map("/foo" => $app);
    $urlmap->map("http://bar.example.com/" => $another_app);
  
  Maps URL path or an absolute URL to a PSGI application. The match
  order is sorted by host name length and then path length.
  
  URL paths need to match from the beginning and should match completely
  till the path separator (or the end of the path). For example, if you
  register the path C</foo>, it B<will> match with the request C</foo>,
  C</foo/> or C</foo/bar> but it B<won't> match with C</foox>.
  
  Mapping URL with host names is also possible, and in that case the URL
  mapping works like a virtual host.
  
  Mappings will nest.  If $app is already mapped to C</baz> it will
  match a request for C</foo/baz> but not C</foo>. See L</"HOW THIS
  WORKS"> for more details.
  
  =item mount
  
  Alias for C<map>.
  
  =item to_app
  
    my $handler = $urlmap->to_app;
  
  Returns the PSGI application code reference. Note that the
  Plack::App::URLMap object is callable (by overloading the code
  dereference), so returning the object itself as a PSGI application
  should also work.
  
  =back
  
  =head1 DEBUGGING
  
  You can set the environment variable C<PLACK_URLMAP_DEBUG> to see how
  this application matches with the incoming request host names and
  paths.
  
  =head1 HOW THIS WORKS
  
  This application works by I<fixing> C<SCRIPT_NAME> and C<PATH_INFO>
  before dispatching the incoming request to the relocated
  applications.
  
  Say you have a Wiki application that takes C</index> and C</page/*>
  and makes a PSGI application C<$wiki_app> out of it, using one of
  supported web frameworks, you can put the whole application under
  C</wiki> by:
  
    # MyWikiApp looks at PATH_INFO and handles /index and /page/*
    my $wiki_app = sub { MyWikiApp->run(@_) };
    
    use Plack::App::URLMap;
    my $app = Plack::App::URLMap->new;
    $app->mount("/wiki" => $wiki_app);
  
  When a request comes in with C<PATH_INFO> set to C</wiki/page/foo>,
  the URLMap application C<$app> strips the C</wiki> part from
  C<PATH_INFO> and B<appends> that to C<SCRIPT_NAME>.
  
  That way, if the C<$app> is mounted under the root
  (i.e. C<SCRIPT_NAME> is C<"">) with standalone web servers like
  L<Starman>, C<SCRIPT_NAME> is now locally set to C</wiki> and
  C<PATH_INFO> is changed to C</page/foo> when C<$wiki_app> gets called.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_APP_URLMAP

$fatpacked{"Plack/App/WrapCGI.pm"} = <<'PLACK_APP_WRAPCGI';
  package Plack::App::WrapCGI;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use Plack::Util::Accessor qw(script execute _app);
  use CGI::Emulate::PSGI;
  use CGI::Compile;
  use Carp;
  use POSIX ":sys_wait_h";
  
  sub prepare_app {
      my $self = shift;
      my $script = $self->script
          or croak "'script' is not set";
  
      if ($self->execute) {
          my $app = sub {
              my $env = shift;
  
              pipe( my $stdoutr, my $stdoutw );
              pipe( my $stdinr,  my $stdinw );
  
  
              my $pid = fork();
              Carp::croak("fork failed: $!") unless defined $pid;
  
  
              if ($pid == 0) { # child
                  local $SIG{__DIE__} = sub {
                      print STDERR @_;
                      exit(1);
                  };
  
                  close $stdoutr;
                  close $stdinw;
  
                  local %ENV = (%ENV, CGI::Emulate::PSGI->emulate_environment($env));
  
                  open( STDOUT, ">&=" . fileno($stdoutw) )
                    or Carp::croak "Cannot dup STDOUT: $!";
                  open( STDIN, "<&=" . fileno($stdinr) )
                    or Carp::croak "Cannot dup STDIN: $!";
  
                  exec($script) or Carp::croak("cannot exec: $!");
  
                  exit(2);
              }
  
              close $stdoutw;
              close $stdinr;
  
              syswrite($stdinw, do {
                  local $/;
                  my $fh = $env->{'psgi.input'};
                  <$fh>;
              });
              # close STDIN so child will stop waiting
              close $stdinw;
  
              my $res = '';
              while (waitpid($pid, WNOHANG) <= 0) {
                  $res .= do { local $/; <$stdoutr> };
              }
              $res .= do { local $/; <$stdoutr> };
  
              if (POSIX::WIFEXITED($?)) {
                  return CGI::Parse::PSGI::parse_cgi_output(\$res);
              } else {
                  Carp::croak("Error at run_on_shell CGI: $!");
              }
          };
          $self->_app($app);
      } else {
          my $sub = CGI::Compile->compile($script);
          my $app = CGI::Emulate::PSGI->handler($sub);
  
          $self->_app($app);
      }
  }
  
  sub call {
      my($self, $env) = @_;
      $self->_app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::WrapCGI - Compiles a CGI script as PSGI application
  
  =head1 SYNOPSIS
  
    use Plack::App::WrapCGI;
  
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.pl")->to_app;
  
    # if you want to execute as a real CGI script
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.rb", execute => 1)->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::WrapCGI compiles a CGI script into a PSGI application
  using L<CGI::Compile> and L<CGI::Emulate::PSGI>, and runs it with any
  PSGI server as a PSGI application.
  
  See also L<Plack::App::CGIBin> if you have a directory that contains a
  lot of CGI scripts and serve them like Apache's mod_cgi.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    my $app = Plack::App::WrapCGI->new(%args);
  
  Creates a new PSGI application using the given script. I<%args> has two
  parameters:
  
  =over 8
  
  =item script
  
  The path to a CGI-style program. This is a required parameter.
  
  =item execute
  
  An optional parameter. When set to a true value, this app will run the script
  with a CGI-style C<fork>/C<exec> model. Note that you may run programs written
  in other languages with this approach.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
  
  =cut
PLACK_APP_WRAPCGI

$fatpacked{"Plack/Builder.pm"} = <<'PLACK_BUILDER';
  package Plack::Builder;
  use strict;
  use parent qw( Exporter );
  our @EXPORT = qw( builder add enable enable_if mount );
  
  use Carp ();
  use Plack::App::URLMap;
  use Plack::Middleware::Conditional; # TODO delayed load?
  
  sub new {
      my $class = shift;
      bless { middlewares => [ ] }, $class;
  }
  
  sub add_middleware {
      my($self, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, $mw;
  }
  
  sub add_middleware_if {
      my($self, $cond, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, sub {
          Plack::Middleware::Conditional->wrap($_[0], condition => $cond, builder => $mw);
      };
  }
  
  # do you want remove_middleware() etc.?
  
  sub _mount {
      my ($self, $location, $app) = @_;
  
      if (!$self->{_urlmap}) {
          $self->{_urlmap} = Plack::App::URLMap->new;
      }
  
      $self->{_urlmap}->map($location => $app);
      $self->{_urlmap};
  }
  
  sub to_app {
      my($self, $app) = @_;
  
      for my $mw (reverse @{$self->{middlewares}}) {
          $app = $mw->($app);
      }
  
      $app;
  }
  
  # DSL goes here
  our $_add = our $_add_if = our $_mount = sub {
      Carp::croak("enable/mount should be called inside builder {} block");
  };
  
  sub add      { Carp::carp("add is deprecated. Use 'enable'"); $_add->(@_) }
  sub enable         { $_add->(@_) }
  sub enable_if(&$@) { $_add_if->(@_) }
  
  sub mount {
      my $self = shift;
      if (Scalar::Util::blessed($self)) {
          $self->_mount(@_);
      }else{
          $_mount->($self, @_);
      }
  }
  
  sub builder(&) {
      my $block = shift;
  
      my $self = __PACKAGE__->new;
  
      my $mount_is_called;
      my $urlmap = Plack::App::URLMap->new;
      local $_mount = sub {
          $mount_is_called++;
          $urlmap->map(@_);
          $urlmap;
      };
      local $_add = sub {
          $self->add_middleware(@_);
      };
      local $_add_if = sub {
          $self->add_middleware_if(@_);
      };
  
      my $app = $block->();
  
      if ($mount_is_called) {
          if ($app ne $urlmap) {
              Carp::carp("You used mount() in a builder block, but the last line (app) isn't using mount().\n" .
                         "This causes all mount() mappings to be ignored. See perldoc Plack::Builder for details.");
          } else {
              $app = $app->to_app;
          }
      }
  
      $self->to_app($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Builder - OO and DSL to enable Plack Middlewares
  
  =head1 SYNOPSIS
  
    # in .psgi
    use Plack::Builder;
  
    my $app = sub { ... };
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", opt => "val";
        enable "Plack::Middleware::Baz";
        $app;
    };
  
    # use URLMap
  
    builder {
        mount "/foo" => builder {
            enable "Plack::Middleware::Foo";
            $app;
        };
  
        mount "/bar" => $app2;
        mount "http://example.com/" => builder { $app3 };
    };
  
    # using OO interface
  
    my $builder = Plack::Builder->new();
    $builder->add_middleware('Foo', opt => 1);
    $app = $builder->mount('/app' => $app);
    $app = $builder->to_app($app);
  
  =head1 DESCRIPTION
  
  Plack::Builder gives you a quick domain specific language (DSL) to
  wrap your application with Plack::Middleware subclasses. The
  middleware you're trying to use should use L<Plack::Middleware> as a
  base class to use this DSL, inspired by Rack::Builder.
  
  Whenever you call C<enable> on any middleware, the middleware app is
  pushed to the stack inside the builder, and then reversed when it
  actually creates a wrapped application handler, so:
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", opt => "val";
        $app;
    };
  
  is syntactically equal to:
  
    $app = Plack::Middleware::Bar->wrap($app, opt => "val");
    $app = Plack::Middleware::Foo->wrap($app);
  
  In other words, you're supposed to C<enable> middleware from outer to inner.
  
  =head1 INLINE MIDDLEWARE
  
  Plack::Builder allows you to code middleware inline using a nested
  code reference.
  
  If the first argument to C<enable> is a code reference, it will be
  passed an C<$app> and is supposed to return another code reference
  which is PSGI application that consumes C<$env> in runtime. So:
  
    builder {
        enable sub {
            my $app = shift;
            sub {
                my $env = shift;
                # do preprocessing
                my $res = $app->($env);
                # do postprocessing
                return $res;
            };
        };
        $app;
    };
  
  is equal to:
  
    my $mw = sub {
        my $app = shift;
        sub { my $env = shift; $app->($env) };
    };
  
    $app = $mw->($app);
  
  =head1 URLMap support
  
  Plack::Builder has a native support for L<Plack::App::URLMap> with C<mount> method.
  
    use Plack::Builder;
    my $app = builder {
        mount "/foo" => $app1;
        mount "/bar" => builder {
            enable "Plack::Middleware::Foo";
            $app2;
        };
    };
  
  See L<Plack::App::URLMap>'s C<map> method to see what they mean. With
  builder you can't use C<map> as a DSL, for the obvious reason :)
  
  B<NOTE>: Once you use C<mount> in your builder code, you have to use
  C<mount> for all the paths, including the root path (C</>). You can't
  have the default app in the last line of C<builder> like:
  
    my $app = sub {
        my $env = shift;
        ...
    };
  
    builder {
        mount "/foo" => sub { ... };
        $app; # THIS DOESN'T WORK
    };
  
  You'll get warnings saying that your mount configuration will be
  ignored. Instead you should use C<< mount "/" => ... >> in the last
  line to set the default fallback app.
  
    builder {
        mount "/foo" => sub { ... };
        mount "/" => $app;
    }
  
  Note that the C<builder> DSL returns a whole new PSGI application, which means
  
  =over 4
  
  =item *
  
  C<builder { ... }> should normally the last statement of a C<.psgi>
  file, because the return value of C<builder> is the application that
  actually is executed.
  
  =item *
  
  You can nest your C<builder> block, mixed with C<mount> (see URLMap
  support above):
  
    builder {
        mount "/foo" => builder {
            mount "/bar" => $app;
        }
    }
  
  will locate the C<$app> under C</foo/bar> since the inner C<builder>
  block puts it under C</bar> and it results a new PSGI application
  which is located under C</foo> because of the outer C<builder> block.
  
  =back
  
  =head1 CONDITIONAL MIDDLEWARE SUPPORT
  
  You can use C<enable_if> to conditionally enable middleware based on
  the runtime environment. See L<Plack::Middleware::Conditional> for
  details.
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::App::URLMap> L<Plack::Middleware::Conditional>
  
  =cut
  
  
  
PLACK_BUILDER

$fatpacked{"Plack/Component.pm"} = <<'PLACK_COMPONENT';
  package Plack::Component;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use overload '&{}' => sub { shift->to_app(@_) }, fallback => 1;
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self;
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          $self = bless {%{$_[0]}}, $class;
      } else {
          $self = bless {@_}, $class;
      }
  
      $self;
  }
  
  # NOTE:
  # this is for back-compat only,
  # future modules should use
  # Plack::Util::Accessor directly
  # or their own favorite accessor
  # generator.
  # - SL
  sub mk_accessors {
      my $self = shift;
      Plack::Util::Accessor::mk_accessors( ref( $self ) || $self, @_ )
  }
  
  sub prepare_app { return }
  
  sub to_app {
      my $self = shift;
      $self->prepare_app;
      return sub { $self->call(@_) };
  }
  
  
  sub response_cb {
      my($self, $res, $cb) = @_;
      Plack::Util::response_cb($res, $cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Component - Base class for PSGI endpoints
  
  =head1 SYNOPSIS
  
    package Plack::App::Foo;
    use parent qw( Plack::Component );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        my $res = ...; # create a response ...
  
        # return the response
        return $res;
    }
  
  =head1 DESCRIPTION
  
  Plack::Component is the base class shared between Plack::Middleware
  and Plack::App::* modules. If you are writing middleware, you should
  inherit from L<Plack::Middleware>, but if you are writing a
  Plack::App::* you should inherit from this directly.
  
  =head1 REQUIRED METHOD
  
  =over 4
  
  =item call ($env)
  
  You are expected to implement a C<call> method in your component. This
  is where all the work gets done. It receives the PSGI C<$env> hash-ref
  as an argument and is expected to return a proper PSGI response value.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new (%opts | \%opts)
  
  The constructor accepts either a hash or a hash-ref and uses that to
  create the instance with. It will call no other methods and simply return
  the instance that is created.
  
  =item prepare_app
  
  This method is called by C<to_app> and is meant as a hook to be used to
  prepare your component before it is packaged as a PSGI C<$app>.
  
  =item to_app
  
  This is the method used in several parts of the Plack infrastructure to
  convert your component into a PSGI C<$app>. You should not ever need to
  override this method, it is recommended to use C<prepare_app> and C<call>
  instead.
  
  =item response_cb
  
  This is a wrapper for C<response_cb> in L<Plack::Util>. See
  L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =head1 OBJECT LIFECYCLE
  
  Objects for the derived classes (Plack::App::* or
  Plack::Middleware::*) are created at the PSGI application compile
  phase using C<new>, C<prepare_app> and C<to_app>, and the created
  object persists during the web server lifecycle, unless it is running
  on the non-persistent environment like CGI. C<call> is invoked against
  the same object whenever a new request comes in.
  
  You can check if it is running in a persistent environment by checking
  C<psgi.run_once> key in the C<$env> being true (non-persistent) or
  false (persistent), but it is best for you to write your middleware
  safely for a persistent environment. To accomplish that, you should
  avoid saving per-request data like C<$env> in your object.
  
  =head1 BACKWARDS COMPATIBILITY
  
  The L<Plack::Middleware> module used to inherit from L<Class::Accessor::Fast>,
  which has been removed in favor of the L<Plack::Util::Accessor> module. When
  developing new components it is recommended to use L<Plack::Util::Accessor>
  like so:
  
    use Plack::Util::Accessor qw( foo bar baz );
  
  However, in order to keep backwards compatibility this module provides a
  C<mk_accessors> method similar to L<Class::Accessor::Fast>. New code should
  not use this and use L<Plack::Util::Accessor> instead.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Middleware>
  
  =cut
PLACK_COMPONENT

$fatpacked{"Plack/HTTPParser.pm"} = <<'PLACK_HTTPPARSER';
  package Plack::HTTPParser;
  use strict;
  use parent qw(Exporter);
  
  our @EXPORT = qw( parse_http_request );
  
  use Try::Tiny;
  
  {
      if (!$ENV{PLACK_HTTP_PARSER_PP} && try { require HTTP::Parser::XS; 1 }) {
          *parse_http_request = \&HTTP::Parser::XS::parse_http_request;
      } else {
          require Plack::HTTPParser::PP;
          *parse_http_request = \&Plack::HTTPParser::PP::parse_http_request;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser - Parse HTTP headers
  
  =head1 SYNOPSIS
  
    use Plack::HTTPParser qw(parse_http_request);
  
    my $ret = parse_http_request($header_str, \%env);
    # see HTTP::Parser::XS docs
  
  =head1 DESCRIPTION
  
  Plack::HTTPParser is a wrapper class to dispatch C<parse_http_request>
  to Kazuho Oku's XS based HTTP::Parser::XS or pure perl fallback based
  on David Robins HTTP::Parser.
  
  If you want to force the use of the slower pure perl version even if the
  fast XS version is available, set the environment variable
  C<PLACK_HTTP_PARSER_PP> to 1.
  
  =head1 SEE ALSO
  
  L<HTTP::Parser::XS> L<HTTP::Parser>
  
  =cut
PLACK_HTTPPARSER

$fatpacked{"Plack/HTTPParser/PP.pm"} = <<'PLACK_HTTPPARSER_PP';
  package Plack::HTTPParser::PP;
  use strict;
  use warnings;
  use URI::Escape;
  
  sub parse_http_request {
      my($chunk, $env) = @_;
      $env ||= {};
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my ($major, $minor);
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/(\d+)\.(\d+)$/i;
      ($major, $minor) = ($1, $2);
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{SERVER_PROTOCOL} = "HTTP/$major.$minor";
      $env->{REQUEST_URI}     = $uri;
  
      my($path, $query) = ( $uri =~ /^([^?]*)(?:\?(.*))?$/s );
      for ($path, $query) { s/\#.*$// if defined && length } # dumb clients sending URI fragments
  
      $env->{PATH_INFO}    = URI::Escape::uri_unescape($path);
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser::PP - Pure perl fallback of HTTP::Parser::XS
  
  =head1 DESCRIPTION
  
  Do not use this module directly. Use L<Plack::HTTPParser> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
  
PLACK_HTTPPARSER_PP

$fatpacked{"Plack/Handler.pm"} = <<'PLACK_HANDLER';
  package Plack::Handler;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler - Connects PSGI applications and Web servers
  
  =head1 SYNOPSIS
  
    package Plack::Handler::AwesomeWebServer;
    sub new {
        my($class, %opt) = @_;
        ...
        return $self;
    }
  
    sub run {
        my($self, $app) = @_;
        # launch the AwesomeWebServer and run $app in the loop
    }
  
    # then from command line
    plackup -s AwesomeWebServer -a app.psgi
  
  =head1 DESCRIPTION
  
  Plack::Handler defines an adapter (connector) interface to adapt
  L<plackup> and L<Plack::Runner> to various PSGI web servers, such as
  Apache2 for mod_perl and Standalone for L<HTTP::Server::PSGI>.
  
  It is an empty class, and as long as they implement the methods
  defined as an Server adapter interface, they do not need to inherit
  Plack::Handler.
  
  If you write a new handler for existing web servers, I recommend you
  to include the full name of the server module after I<Plack::Handler>
  prefix, like L<Plack::Handler::Net::Server::Coro> if you write a
  handler for L<Net::Server::Coro>. That way you'll be using plackup
  command line option like:
  
    plackup -s Net::Server::Coro
  
  that makes it easy to figure out which web server you're going to use.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $server = FooBarServer->new(%args);
  
  Creates a new adapter object. I<%args> can take arbitrary parameters
  to configure server environments but common parameters are:
  
  =over 8
  
  =item port
  
  Port number the server listens to.
  
  =item host
  
  Address the server listens to. Set to undef to listen any interface.
  
  =back
  
  =item run
  
    $server->run($app);
  
  Starts the server process and when a request comes in, run the PSGI
  application passed in C<$app> in the loop.
  
  =item register_service
  
    $server->register_service($app);
  
  Optional interface if your server should run in parallel with other
  event loop, particularly L<AnyEvent>. This is the same as C<run> but
  doesn't run the main loop.
  
  =back
  
  =head1 SEE ALSO
  
  rackup
  
  =cut
  
PLACK_HANDLER

$fatpacked{"Plack/Handler/Apache1.pm"} = <<'PLACK_HANDLER_APACHE1';
  package Plack::Handler::Apache1;
  use strict;
  use Apache::Request;
  use Apache::Constants qw(:common :response);
  
  use Plack::Util;
  use Scalar::Util;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          local $ENV{MOD_PERL}; # trick Catalyst/CGI.pm etc.
          Plack::Util::load_psgi $app;
      };
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      my $vpath    = $env->{SCRIPT_NAME} . ($env->{PATH_INFO} || '');
  
      my $location = $r->location || "/";
         $location =~ s{/$}{};
      (my $path_info = $vpath) =~ s/^\Q$location\E//;
  
      $env->{SCRIPT_NAME} = $location;
      $env->{PATH_INFO}   = $path_info;
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return OK;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
      $r->send_http_header;
  
      if (defined $body) {
          if (Plack::Util::is_real_fh($body)) {
              $r->send_fd($body);
          } else {
              Plack::Util::foreach($body, sub { $r->print(@_) });
          }
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_) },
              close => sub { };
      }
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Plack::Handler::Apache1 - Apache 1.3.x handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlHandler Plack::Handler::Apache1
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    <Perl>
    use Plack::Handler::Apache1;
    Plack::Handler::Apache1->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application with mod_perl on Apache 1.3.x.
  
  =head1 AUTHOR
  
  Aaron Trevena
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_APACHE1

$fatpacked{"Plack/Handler/Apache2.pm"} = <<'PLACK_HANDLER_APACHE2';
  package Plack::Handler::Apache2;
  use strict;
  use warnings;
  use Apache2::RequestRec;
  use Apache2::RequestIO;
  use Apache2::RequestUtil;
  use Apache2::Response;
  use Apache2::Const -compile => qw(OK);
  use Apache2::Log;
  use APR::Table;
  use IO::Handle;
  use Plack::Util;
  use Scalar::Util;
  use URI;
  use URI::Escape;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          local $ENV{MOD_PERL}; # trick Catalyst/CGI.pm etc.
          Plack::Util::load_psgi $app;
      };
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      # Actually, we can not trust PATH_INFO from mod_perl because mod_perl squeezes multiple slashes into one slash.
      my $uri = URI->new("http://".$r->hostname.$r->unparsed_uri);
  
      $env->{PATH_INFO} = uri_unescape($uri->path);
  
      $class->fixup_path($r, $env);
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return Apache2::Const::OK;
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  # The method for PH::Apache2::Registry to override.
  sub fixup_path {
      my ($class, $r, $env) = @_;
  
      # $env->{PATH_INFO} is created from unparsed_uri so it is raw.
      my $path_info = $env->{PATH_INFO} || '';
  
      # Get argument of <Location> or <LocationMatch> directive
      # This may be string or regexp and we can't know either.
      my $location = $r->location;
  
      # Let's *guess* if we're in a LocationMatch directive
      if ($location eq '/') {
          # <Location /> could be handled as a 'root' case where we make
          # everything PATH_INFO and empty SCRIPT_NAME as in the PSGI spec
          $env->{SCRIPT_NAME} = '';
      } elsif ($path_info =~ s{^($location)/?}{/}) {
          $env->{SCRIPT_NAME} = $1 || '';
      } else {
          # Apache's <Location> is matched but here is not.
          # This is something wrong. We can only respect original.
          $r->server->log_error(
              "Your request path is '$path_info' and it doesn't match your Location(Match) '$location'. " .
              "This should be due to the configuration error. See perldoc Plack::Handler::Apache2 for details."
          );
      }
  
      $env->{PATH_INFO}   = $path_info;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
  
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } elsif (lc $h eq 'content-length') {
              $r->set_content_length($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
  
      if (Scalar::Util::blessed($body) and $body->can('path') and my $path = $body->path) {
          $r->sendfile($path);
      } elsif (defined $body) {
          Plack::Util::foreach($body, sub { $r->print(@_) });
          $r->rflush;
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_); $r->rflush },
              close => sub { $r->rflush };
      }
  
      return Apache2::Const::OK;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2 - Apache 2.0 handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlResponseHandler Plack::Handler::Apache2
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    # Optional, preload the application in the parent like startup.pl
    <Perl>
    use Plack::Handler::Apache2;
    Plack::Handler::Apache2->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application with mod_perl on Apache 2.x.
  
  =head1 CREATING CUSTOM HANDLER
  
  If you want to create a custom handler that loads or creates PSGI
  applications using other means than loading from C<.psgi> files, you
  can create your own handler class and use C<call_app> class method to
  run your application.
  
    package My::ModPerl::Handler;
    use Plack::Handler::Apache2;
  
    sub get_app {
      # magic!
    }
  
    sub handler {
      my $r = shift;
      my $app = get_app();
      Plack::Handler::Apache2->call_app($r, $app);
    }
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Paul Driver
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_HANDLER_APACHE2

$fatpacked{"Plack/Handler/Apache2/Registry.pm"} = <<'PLACK_HANDLER_APACHE2_REGISTRY';
  package Plack::Handler::Apache2::Registry;
  use strict;
  use warnings;
  use Try::Tiny;
  use Apache2::Const;
  use Apache2::Log;
  use parent qw/Plack::Handler::Apache2/;
  
  sub handler {
      my $class = __PACKAGE__;
      my ($r) = @_;
  
      return try {
          my $app = $class->load_app( $r->filename );
          $class->call_app( $r, $app );
      }catch{
          if(/no such file/i){
              $r->log_error( $_ );
              return Apache2::Const::NOT_FOUND;
          }else{
              $r->log_error( $_ );
              return Apache2::Const::SERVER_ERROR;
          }
      };
  }
  
  # Overriding
  sub fixup_path {
      my ($class, $r, $env) = @_;
      $env->{PATH_INFO} =~ s{^$env->{SCRIPT_NAME}}{};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2::Registry - Runs .psgi files.
  
  =head1 SYNOPSIS
  
    PerlModule Plack::Handler::Apache2::Registry;
    <Location /psgi-bin>
    SetHandler modperl
    PerlHandler Plack::Handler::Apache2::Registry
    </Location>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any *.psgi files with mod_perl2,
  just like ModPerl::Registry.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Apache2>
  
  =cut
  
PLACK_HANDLER_APACHE2_REGISTRY

$fatpacked{"Plack/Handler/CGI.pm"} = <<'PLACK_HANDLER_CGI';
  package Plack::Handler::CGI;
  use strict;
  use warnings;
  use IO::Handle;
  
  # copied from HTTP::Status
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  sub new { bless {}, shift }
  
  sub run {
      my ($self, $app) = @_;
  
      my $env = $self->setup_env();
  
      my $res = $app->($env);
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  }
  
  sub setup_env {
      my ( $self, $override_env ) = @_;
  
      $override_env ||= {};
  
      binmode STDIN;
      binmode STDERR;
  
      my $env = {
          %ENV,
          'psgi.version'    => [ 1, 1 ],
          'psgi.url_scheme' => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'      => *STDIN,
          'psgi.errors'     => *STDERR,
          'psgi.multithread'  => 0,
          'psgi.multiprocess' => 1,
          'psgi.run_once'     => 1,
          'psgi.streaming'    => 1,
          'psgi.nonblocking'  => 1,
          %{ $override_env },
      };
  
      delete $env->{HTTP_CONTENT_TYPE};
      delete $env->{HTTP_CONTENT_LENGTH};
      $env->{'HTTP_COOKIE'} ||= $ENV{COOKIE}; # O'Reilly server bug
  
      if (!exists $env->{PATH_INFO}) {
          $env->{PATH_INFO} = '';
      }
  
      if ($env->{SCRIPT_NAME} eq '/') {
          $env->{SCRIPT_NAME} = '';
          $env->{PATH_INFO}   = '/' . $env->{PATH_INFO};
      }
  
      return $env;
  }
  
  
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = $StatusCode{$res->[0]};
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice(@$headers, 0, 2)) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $body = $res->[2];
      my $cb = sub { print STDOUT $_[0] };
  
      # inline Plack::Util::foreach here
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      }
      elsif (defined $body) {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
      else {
          return Plack::Handler::CGI::Writer->new;
      }
  }
  
  package Plack::Handler::CGI::Writer;
  sub new   { bless \do { my $x }, $_[0] }
  sub write { print STDOUT $_[1] }
  sub close { }
  
  package Plack::Handler::CGI;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::CGI - CGI handler for Plack
  
  =head1 SYNOPSIS
  
  Want to run PSGI application as a CGI script? Rename .psgi to .cgi and
  change the shebang line like:
  
    #!/usr/bin/env plackup
    # rest of the file can be the same as other .psgi file
  
  You can alternatively create a .cgi file that contains something like:
  
    #!/usr/bin/perl
    use Plack::Loader;
    my $app = Plack::Util::load_psgi("/path/to/app.psgi");
    Plack::Loader->auto->run($app);
  
  This will auto-recognize the CGI environment variable to load this class.
  
  If you really want to explicitly load the CGI handler, you can. For instance
  you might do this when you want to embed a PSGI application server built into
  CGI-compatible perl-based web server:
  
    use Plack::Handler::CGI;
    Plack::Handler::CGI->new->run($app);
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a CGI script.
  
  =head1 UTILITY METHODS
  
  =head2 setup_env()
  
    my $env = Plack::Handler::CGI->setup_env();
    my $env = Plack::Handler::CGI->setup_env(\%override_env);
  
  Sets up the PSGI environment hash for a CGI request from C<< %ENV >>> and returns it.
  You can can provide a hashref of key/value pairs to override the defaults if you would like.
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
  
PLACK_HANDLER_CGI

$fatpacked{"Plack/Handler/FCGI.pm"} = <<'PLACK_HANDLER_FCGI';
  package Plack::Handler::FCGI;
  use strict;
  use warnings;
  use constant RUNNING_IN_HELL => $^O eq 'MSWin32';
  
  use Scalar::Util qw(blessed);
  use Plack::Util;
  use FCGI;
  use HTTP::Status qw(status_message);
  use URI;
  use URI::Escape;
  
  sub new {
      my $class = shift;
      my $self  = bless {@_}, $class;
  
      $self->{leave_umask} ||= 0;
      $self->{keep_stderr} ||= 0;
      $self->{nointr}      ||= 0;
      $self->{daemonize}   ||= $self->{detach}; # compatibility
      $self->{nproc}       ||= 1 unless blessed $self->{manager};
      $self->{pid}         ||= $self->{pidfile}; # compatibility
      $self->{listen}      ||= [ ":$self->{port}" ] if $self->{port}; # compatibility
      $self->{manager}     = 'FCGI::ProcManager' unless exists $self->{manager};
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $sock = 0;
      if (-S STDIN) {
          # running from web server. Do nothing
          # Note it should come before listen check because of plackup's default
      } elsif ($self->{listen}) {
          my $old_umask = umask;
          unless ($self->{leave_umask}) {
              umask(0);
          }
          $sock = FCGI::OpenSocket( $self->{listen}->[0], 100 )
              or die "failed to open FastCGI socket: $!";
          unless ($self->{leave_umask}) {
              umask($old_umask);
          }
      } elsif (!RUNNING_IN_HELL) {
          die "STDIN is not a socket: specify a listen location";
      }
  
      my %env;
      my $request = FCGI::Request(
          \*STDIN, \*STDOUT,
          ($self->{keep_stderr} ? \*STDOUT : \*STDERR), \%env, $sock,
          ($self->{nointr} ? 0 : &FCGI::FAIL_ACCEPT_ON_INTR),
      );
  
      my $proc_manager;
  
      if ($self->{listen}) {
          $self->daemon_fork if $self->{daemonize};
  
          if ($self->{manager}) {
              if (blessed $self->{manager}) {
                  for (qw(nproc pid)) {
                      die "Don't use '$_' when passing in a 'manager' object"
                          if $self->{$_};
                  }
                  $proc_manager = $self->{manager};
              } else {
                  Plack::Util::load_class($self->{manager});
                  $proc_manager = $self->{manager}->new({
                      n_processes => $self->{nproc},
                      pid_fname   => $self->{pid},
                      (exists $self->{proc_title}
                           ? (pm_title => $self->{proc_title}) : ()),
                  });
              }
  
              # detach *before* the ProcManager inits
              $self->daemon_detach if $self->{daemonize};
  
              $proc_manager->pm_manage;
          }
          elsif ($self->{daemonize}) {
              $self->daemon_detach;
          }
      }
  
      while ($request->Accept >= 0) {
          $proc_manager && $proc_manager->pm_pre_dispatch;
  
          my $env = {
              %env,
              'psgi.version'      => [1,1],
              'psgi.url_scheme'   => ($env{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
              'psgi.input'        => *STDIN,
              'psgi.errors'       => *STDERR, # FCGI.pm redirects STDERR in Accept() loop, so just print STDERR
                                              # print to the correct error handle based on keep_stderr
              'psgi.multithread'  => Plack::Util::FALSE,
              'psgi.multiprocess' => Plack::Util::TRUE,
              'psgi.run_once'     => Plack::Util::FALSE,
              'psgi.streaming'    => Plack::Util::TRUE,
              'psgi.nonblocking'  => Plack::Util::FALSE,
              'psgix.harakiri'    => defined $proc_manager,
          };
  
          delete $env->{HTTP_CONTENT_TYPE};
          delete $env->{HTTP_CONTENT_LENGTH};
  
          # lighttpd munges multiple slashes in PATH_INFO into one. Try recovering it
          my $uri = URI->new("http://localhost" .  $env->{REQUEST_URI});
          $env->{PATH_INFO} = uri_unescape($uri->path);
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E//;
  
          if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ m!lighttpd[-/]1\.(\d+\.\d+)!) {
              no warnings;
              if ($ENV{PLACK_ENV} eq 'development' && $1 < 4.23 && $env->{PATH_INFO} eq '') {
                  warn "You're using lighttpd 1.$1 and appear to mount your FastCGI handler under the root ('/'). ",
                       "It's known to be causing issues because of the lighttpd bug. You're recommended to enable ",
                       "LighttpdScriptNameFix middleware, or upgrade lighttpd to 1.4.23 or later and include ",
                       "'fix-root-scriptname' flag in 'fastcgi.server'. See perldoc Plack::Handler::FCGI for details. ",
                       "This friendly warning will go away in the next major release of Plack.";
              }
              $env->{SERVER_NAME} =~ s/:\d+$//; # cut off port number
          }
  
          # root access for mod_fastcgi
          if (!exists $env->{PATH_INFO}) {
              $env->{PATH_INFO} = '';
          }
  
          my $res = Plack::Util::run_app $app, $env;
  
          if (ref $res eq 'ARRAY') {
              $self->_handle_response($res);
          }
          elsif (ref $res eq 'CODE') {
              $res->(sub {
                  $self->_handle_response($_[0]);
              });
          }
          else {
              die "Bad response $res";
          }
  
          # give pm_post_dispatch the chance to do things after the client thinks
          # the request is done
          $request->Finish;
  
          $proc_manager && $proc_manager->pm_post_dispatch();
  
          if ($proc_manager && $env->{'psgix.harakiri.commit'}) {
              $proc_manager->pm_exit("safe exit with harakiri");
          }
      }
  }
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = status_message($res->[0]);
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice @$headers, 0, 2) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $cb = sub { print STDOUT $_[0] };
      my $body = $res->[2];
      if (defined $body) {
          Plack::Util::foreach($body, $cb);
      }
      else {
          return Plack::Util::inline_object
              write => $cb,
              close => sub { };
      }
  }
  
  sub daemon_fork {
      require POSIX;
      fork && exit;
  }
  
  sub daemon_detach {
      my $self = shift;
      print "FastCGI daemon started (pid $$)\n";
      open STDIN,  "+</dev/null" or die $!; ## no critic
      open STDOUT, ">&STDIN"     or die $!;
      open STDERR, ">&STDIN"     or die $!;
      POSIX::setsid();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::FCGI - FastCGI handler for Plack
  
  =head1 SYNOPSIS
  
    # Run as a standalone daemon
    plackup -s FCGI --listen /tmp/fcgi.sock --daemonize --nproc 10
  
    # Run from your web server like mod_fastcgi
    #!/usr/bin/env plackup -s FCGI
    my $app = sub { ... };
  
    # Roll your own
    my $server = Plack::Handler::FCGI->new(
        nproc  => $num_proc,
        listen => [ $port_or_socket ],
        detach => 1,
    );
    $server->run($app);
  
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a standalone
  FastCGI daemon or a .fcgi script.
  
  =head2 OPTIONS
  
  =over 4
  
  =item listen
  
      listen => [ '/path/to/socket' ]
      listen => [ ':8080' ]
  
  Listen on a socket path, hostname:port, or :port.
  
  =item port
  
  listen via TCP on port on all interfaces (Same as C<< listen => ":$port" >>)
  
  =item leave-umask
  
  Set to 1 to disable setting umask to 0 for socket open
  
  =item nointr
  
  Do not allow the listener to be interrupted by Ctrl+C
  
  =item nproc
  
  Specify a number of processes for FCGI::ProcManager
  
  =item pid
  
  Specify a filename for the pid file
  
  =item manager
  
  Specify a FCGI::ProcManager sub-class
  
  =item daemonize
  
  Daemonize the process.
  
  =item keep-stderr
  
  Send STDERR to STDOUT instead of the webserver
  
  =back
  
  =head2 WEB SERVER CONFIGURATIONS
  
  =head3 nginx
  
  This is an example nginx configuration to run your FCGI daemon on a
  Unix domain socket and run it at the server's root URL (/).
  
    http {
      server {
        listen 3001;
        location / {
          set $script "";
          set $path_info $uri;
          fastcgi_pass unix:/tmp/fastcgi.sock;
          fastcgi_param  SCRIPT_NAME      $script;
          fastcgi_param  PATH_INFO        $path_info;
          fastcgi_param  QUERY_STRING     $query_string;
          fastcgi_param  REQUEST_METHOD   $request_method;
          fastcgi_param  CONTENT_TYPE     $content_type;
          fastcgi_param  CONTENT_LENGTH   $content_length;
          fastcgi_param  REQUEST_URI      $request_uri;
          fastcgi_param  SERVER_PROTOCOL  $server_protocol;
          fastcgi_param  REMOTE_ADDR      $remote_addr;
          fastcgi_param  REMOTE_PORT      $remote_port;
          fastcgi_param  SERVER_ADDR      $server_addr;
          fastcgi_param  SERVER_PORT      $server_port;
          fastcgi_param  SERVER_NAME      $server_name;
        }
      }
    }
  
  If you want to host your application in a non-root path, then you
  should mangle this configuration to set the path to C<SCRIPT_NAME> and
  the rest of the path in C<PATH_INFO>.
  
  See L<http://wiki.nginx.org/NginxFcgiExample> for more details.
  
  =head3 Apache mod_fastcgi
  
  You can use C<FastCgiExternalServer> as normal.
  
    FastCgiExternalServer /tmp/myapp.fcgi -socket /tmp/fcgi.sock
  
  See L<http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html#FastCgiExternalServer> for more details.
  
  =head3 lighttpd
  
  To host the app in the root path, you're recommended to use lighttpd
  1.4.23 or newer with C<fix-root-scriptname> flag like below.
  
    fastcgi.server = ( "/" =>
       ((
         "socket" => "/tmp/fcgi.sock",
         "check-local" => "disable"
         "fix-root-scriptname" => "enable",
       ))
  
  If you use lighttpd older than 1.4.22 where you don't have
  C<fix-root-scriptname>, mouting apps under the root causes wrong
  C<SCRIPT_NAME> and C<PATH_INFO> set. Also, mouting under the empty
  root (C<"">) or a path that has a trailing slash would still cause
  weird values set even with C<fix-root-scriptname>. In such cases you
  can use L<Plack::Middleware::LighttpdScriptNameFix> to fix it.
  
  To mount in the non-root path over TCP:
  
    fastcgi.server = ( "/foo" =>
       ((
         "host" = "127.0.0.1"
         "port" = "5000"
         "check-local" => "disable"
       ))
  
  It's recommended that your mount path does B<NOT> have the trailing
  slash. If you I<really> need to have one, you should consider using
  L<Plack::Middleware::LighttpdScriptNameFix> to fix the wrong
  B<PATH_INFO> values set by lighttpd.
  
  =cut
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_FCGI

$fatpacked{"Plack/Handler/Fliggy.pm"} = <<'PLACK_HANDLER_FLIGGY';
  package Plack::Handler::Fliggy;
  
  use strict;
  use warnings;
  
  sub new {
      my $class = shift;
      bless {@_}, $class;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $class = 'Fliggy::Server';
      eval "require $class";
      die if $@;
  
      $class->new(%{$self})->run($app);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::Fliggy - Adapter for Fliggy
  
  =head1 SYNOPSIS
  
    plackup -s Fliggy --port 9090
  
  =head1 DESCRIPTION
  
  This is an adapter to run L<PSGI> apps on L<Fliggy> via L<plackup>.
  
  =head1 METHODS
  
  =head2 C<new>
  
      my $handler = Plack::Handler::Fliggy->new;
  
  Create new instance.
  
  =head2 C<run>
  
      $handler->run;
  
  Run the server.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_HANDLER_FLIGGY

$fatpacked{"Plack/Handler/HTTP/Server/PSGI.pm"} = <<'PLACK_HANDLER_HTTP_SERVER_PSGI';
  package Plack::Handler::HTTP::Server::PSGI;
  use strict;
  
  # for temporary backward compat
  use parent qw( HTTP::Server::PSGI );
  
  sub new {
      my($class, %args) = @_;
      bless { %args }, $class;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->_server->run($app);
  }
  
  sub _server {
      my $self = shift;
      HTTP::Server::PSGI->new(%$self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::PSGI - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s HTTP::Server::PSGI \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 BACKWARD COMPATIBLITY
  
  Since Plack 0.99_22 this handler doesn't support preforking
  configuration i.e. C<--max-workers>. Use L<Starman> or L<Starlet> if
  you need preforking PSGI web server.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item host
  
  Host the server binds to. Defaults to all interfaces.
  
  =item port
  
  Port number the server listens on. Defaults to 8080.
  
  =item timeout
  
  Number of seconds a request times out. Defaults to 300.
  
  =item max-reqs-per-child
  
  Number of requests per worker to process. Defaults to 100.
  
  =back
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack> L<HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_HTTP_SERVER_PSGI

$fatpacked{"Plack/Handler/HTTP/Server/Simple.pm"} = <<'PLACK_HANDLER_HTTP_SERVER_SIMPLE';
  package Plack::Handler::HTTP::Server::Simple;
  use strict;
  
  sub new {
      my($class, %args) = @_;
      bless {%args}, $class;
  }
  
  sub run {
      my($self, $app) = @_;
  
      my $server = Plack::Handler::HTTP::Server::Simple::PSGIServer->new($self->{port});
      $server->host($self->{host}) if $self->{host};
      $server->app($app);
      $server->{_server_ready} = delete $self->{server_ready} || sub {};
  
      $server->run;
  }
  
  package Plack::Handler::HTTP::Server::Simple::PSGIServer;
  use parent qw(HTTP::Server::Simple::PSGI);
  
  sub print_banner {
      my $self = shift;
  
      $self->{_server_ready}->({
          host => $self->host,
          port => $self->port,
          server_software => 'HTTP::Server::Simple::PSGI',
      });
  }
  
  package Plack::Handler::HTTP::Server::Simple;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::Simple - Adapter for HTTP::Server::Simple
  
  =head1 SYNOPSIS
  
    plackup -s HTTP::Server::Simple --port 9090
  
  =head1 DESCRIPTION
  
  Plack::Handler::HTTP::Server::Simple is an adapter to run PSGI
  applications on L<HTTP::Server::Simple>.
  
  =head1 SEE ALSO
  
  L<Plack>, L<HTTP::Server::Simple::PSGI>
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  
  =cut
PLACK_HANDLER_HTTP_SERVER_SIMPLE

$fatpacked{"Plack/Handler/Standalone.pm"} = <<'PLACK_HANDLER_STANDALONE';
  package Plack::Handler::Standalone;
  use strict;
  use warnings;
  use parent qw( Plack::Handler::HTTP::Server::PSGI );
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Standalone - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s Standalone \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 DESCRIPTION
  
  Plack::Handler::Standalone is an adapter for default Plack server
  implementation L<HTTP::Server::PSGI>. This is just an alias for
  L<Plack::Handler::HTTP::Server::PSGI>.
  
  =head1 SEE ALSO
  
  L<Plack::Handler::HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_STANDALONE

$fatpacked{"Plack/Handler/Twiggy.pm"} = <<'PLACK_HANDLER_TWIGGY';
  package Plack::Handler::Twiggy;
  use strict;
  
  sub new {
      my $class = shift;
      bless {@_}, $class;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $class = $ENV{SERVER_STARTER_PORT} ?
          'Twiggy::Server::SS' : 'Twiggy::Server';
      eval "require $class";
      die if $@;
  
      $class->new(%{$self})->run($app);
  }
      
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Twiggy - Adapter for Twiggy
  
  =head1 SYNOPSIS
  
    plackup -s Twiggy --port 9090
  
    # with start_server
    start_server --port=9090 plackup -s Twiggy 
  
  =head1 DESCRIPTION
  
  This is an adapter to run PSGI apps on Twiggy via L<plackup>.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_HANDLER_TWIGGY

$fatpacked{"Plack/Loader.pm"} = <<'PLACK_LOADER';
  package Plack::Loader;
  use strict;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {}, $class;
  }
  
  sub watch {
      # do nothing. Override in subclass
  }
  
  sub auto {
      my($class, @args) = @_;
  
      my $backend = $class->guess
          or Carp::croak("Couldn't auto-guess server server implementation. Set it with PLACK_SERVER");
  
      my $server = try {
          $class->load($backend, @args);
      } catch {
          if (($ENV{PLACK_ENV}||'') eq 'development' or !/^Can't locate /) {
              warn "Autoloading '$backend' backend failed. Falling back to the Standalone. ",
                  "(You might need to install Plack::Handler::$backend from CPAN.  Caught error was: $_)\n"
                      if $ENV{PLACK_ENV} && $ENV{PLACK_ENV} eq 'development';
          }
          $class->load('Standalone' => @args);
      };
  
      return $server;
  }
  
  sub load {
      my($class, $server, @args) = @_;
  
      my($server_class, $error);
      for my $prefix (qw( Plack::Handler Plack::Server )) {
          try {
              $server_class = Plack::Util::load_class($server, $prefix);
          } catch {
              $error ||= $_;
          };
          last if $server_class;
          last if $error && $error !~ /^Can't locate Plack\/Handler\//;
      }
  
      if ($server_class) {
          $server_class->new(@args);
      } else {
          die $error;
      }
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{app} = $builder->();
  }
  
  sub guess {
      my $class = shift;
  
      my $env = $class->env;
  
      return $env->{PLACK_SERVER} if $env->{PLACK_SERVER};
  
      if ($env->{PHP_FCGI_CHILDREN} || $env->{FCGI_ROLE} || $env->{FCGI_SOCKET_PATH}) {
          return "FCGI";
      } elsif ($env->{GATEWAY_INTERFACE}) {
          return "CGI";
      } elsif (exists $INC{"Coro.pm"}) {
          return "Corona";
      } elsif (exists $INC{"AnyEvent.pm"}) {
          return "Twiggy";
      } elsif (exists $INC{"POE.pm"}) {
          return "POE";
      } else {
          return "Standalone";
      }
  }
  
  sub env { \%ENV }
  
  sub run {
      my($self, $server, $builder) = @_;
      $server->run($self->{app});
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader - (auto)load Plack Servers
  
  =head1 SYNOPSIS
  
    # auto-select server backends based on env vars
    use Plack::Loader;
    Plack::Loader->auto(%args)->run($app);
  
    # specify the implementation with a name
    Plack::Loader->load('FCGI', %args)->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Loader is a factory class to load one of Plack::Handler subclasses based on the environment.
  
  =head1 AUTOLOADING
  
  C<< Plack::Loader->auto(%args) >> will autoload the most correct
  server implementation by guessing from environment variables and Perl INC
  hashes.
  
  =over 4
  
  =item PLACK_SERVER
  
    env PLACK_SERVER=AnyEvent ...
  
  Plack users can specify the specific implementation they want to load
  using the C<PLACK_SERVER> environment variable.
  
  =item PHP_FCGI_CHILDREN, GATEWAY_INTERFACE
  
  If there's one of FastCGI or CGI specific environment variables set,
  use the corresponding server implementation.
  
  =item %INC
  
  If one of L<AnyEvent>, L<Coro> or L<POE> is loaded, the relevant
  server implementation such as L<Twiggy>, L<Corona> or
  L<POE::Component::Server::PSGI> will be loaded, if they're available.
  
  =back
  
  =cut
  
  
PLACK_LOADER

$fatpacked{"Plack/Loader/Delayed.pm"} = <<'PLACK_LOADER_DELAYED';
  package Plack::Loader::Delayed;
  use strict;
  use parent qw(Plack::Loader);
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $compiled;
      my $app = sub {
          $compiled ||= $self->{builder}->();
          $compiled->(@_);
      };
  
      $server->{psgi_app_builder} = $self->{builder};
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Delayed - Delay the loading of .psgi until the first run
  
  =head1 SYNOPSIS
  
    plackup -s Starlet -L Delayed myapp.psgi
  
  =head1 DESCRIPTION
  
  This loader delays the compilation of specified PSGI application until
  the first request time. This prevents bad things from happening with
  preforking web servers like L<Starlet>, when your application
  manipulates resources such as sockets or database connections in the
  master startup process and then shared by children.
  
  You can combine this loader with C<-M> command line option, like:
  
    plackup -s Starlet -MCatalyst -L Delayed myapp.psgi
  
  loads the module Catalyst in the master process for the better process
  management with copy-on-write, however the application C<myapp.psgi>
  is loaded per children.
  
  L<Starman> since version 0.2000 loads this loader by default unless
  you specify the command line option C<--preload-app> for the
  L<starman> executable.
  
  =head1 DEVELOPERS
  
  Web server developers can make use of C<psgi_app_builder> attribute
  callback set in Plack::Handler, to load the application earlier than
  the first request time.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_LOADER_DELAYED

$fatpacked{"Plack/Loader/Restarter.pm"} = <<'PLACK_LOADER_RESTARTER';
  package Plack::Loader::Restarter;
  use strict;
  use warnings;
  use parent qw(Plack::Loader);
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my($class, $runner) = @_;
      bless { watch => [] }, $class;
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub watch {
      my($self, @dir) = @_;
      push @{$self->{watch}}, @dir;
  }
  
  sub _fork_and_start {
      my($self, $server) = @_;
  
      delete $self->{pid}; # re-init in case it's a restart
  
      my $pid = fork;
      die "Can't fork: $!" unless defined $pid;
  
      if ($pid == 0) { # child
          return $server->run($self->{builder}->());
      } else {
          $self->{pid} = $pid;
      }
  }
  
  sub _kill_child {
      my $self = shift;
  
      my $pid = $self->{pid} or return;
      warn "Killing the existing server (pid:$pid)\n";
      kill 'TERM' => $pid;
      waitpid($pid, 0);
  }
  
  sub valid_file {
      my($self, $file) = @_;
      $file->{path} !~ m![/\\][\._]|\.bak$|~$|_flymake\.p[lm]!;
  }
  
  sub run {
      my($self, $server, $builder) = @_;
  
      $self->_fork_and_start($server, $builder);
      return unless $self->{pid};
  
      require Filesys::Notify::Simple;
      my $watcher = Filesys::Notify::Simple->new($self->{watch});
      warn "Watching @{$self->{watch}} for file updates.\n";
      local $SIG{TERM} = sub { $self->_kill_child; exit(0); };
  
      while (1) {
          my @restart;
  
          # this is blocking
          $watcher->wait(sub {
              my @events = @_;
              @events = grep $self->valid_file($_), @events;
              return unless @events;
  
              @restart = @events;
          });
  
          next unless @restart;
  
          for my $ev (@restart) {
              warn "-- $ev->{path} updated.\n";
          }
  
          $self->_kill_child;
          warn "Successfully killed! Restarting the new server process.\n";
          $self->_fork_and_start($server, $builder);
          return unless $self->{pid};
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Restarter - Restarting loader
  
  =head1 SYNOPSIS
  
    plackup -r -R paths
  
  =head1 DESCRIPTION
  
  Plack::Loader::Restarter is a loader backend that implements C<-r> and
  C<-R> option for the L<plackup> script. It forks the server as a child
  process and the parent watches the directories for file updates, and
  whenever it receives the notification, kills the child server and
  restart.
  
  =head1 SEE ALSO
  
  L<Plack::Runner>, L<Catalyst::Restarter>
  
  =cut
PLACK_LOADER_RESTARTER

$fatpacked{"Plack/Loader/Shotgun.pm"} = <<'PLACK_LOADER_SHOTGUN';
  package Plack::Loader::Shotgun;
  use strict;
  use parent qw(Plack::Loader);
  use Storable;
  use Try::Tiny;
  use Plack::Middleware::BufferedStreaming;
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = sub { Plack::Middleware::BufferedStreaming->wrap($builder->()) };
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $app = sub {
          my $env = shift;
  
          pipe my $read, my $write;
  
          my $pid = fork;
          if ($pid) {
              # parent
              close $write;
              my $res = Storable::thaw(join '', <$read>);
              close $read;
              waitpid($pid, 0);
  
              return $res;
          } else {
              # child
              close $read;
  
              my $res;
              try {
                  $env->{'psgi.streaming'} = 0;
                  $res = $self->{builder}->()->($env);
                  my @body;
                  Plack::Util::foreach($res->[2], sub { push @body, $_[0] });
                  $res->[2] = \@body;
              } catch {
                  $env->{'psgi.errors'}->print($_);
                  $res = [ 500, [ "Content-Type", "text/plain" ], [ "Internal Server Error" ] ];
              };
  
              print {$write} Storable::freeze($res);
              close $write;
              exit;
          }
      };
  
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Shotgun - forking implementation of plackup
  
  =head1 SYNOPSIS
  
    plackup -L Shotgun
  
  =head1 DESCRIPTION
  
  Shotgun loader delays the compilation and execution of your
  application until the runtime. When a new request comes in, this forks
  a new child, compiles your code and runs the application.
  
  This should be an ultimate alternative solution when reloading with
  L<Plack::Middleware::Refresh> doesn't work, or plackup's default C<-r>
  filesystem watcher causes problems. I can imagine this is useful for
  applications which expects their application is only evaluated once
  (like in-file templates) or on operating systems with broken fork
  implementation, etc.
  
  This is much like good old CGI's fork and run but you don't need a web
  server, and there's a benefit of preloading modules that are not
  likely to change. For instance if you develop a web application using
  Moose and DBIx::Class,
  
    plackup -MMoose -MDBIx::Class -L Shotgun yourapp.psgi
  
  would preload those modules and only re-evaluates your code in every
  request.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa with an inspiration from L<http://github.com/rtomayko/shotgun>
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_LOADER_SHOTGUN

$fatpacked{"Plack/MIME.pm"} = <<'PLACK_MIME';
  package Plack::MIME;
  use strict;
  
  # stolen from rack.mime.rb
  our $MIME_TYPES = {
      ".3gp"     => "video/3gpp",
      ".a"       => "application/octet-stream",
      ".ai"      => "application/postscript",
      ".aif"     => "audio/x-aiff",
      ".aiff"    => "audio/x-aiff",
      ".asc"     => "application/pgp-signature",
      ".asf"     => "video/x-ms-asf",
      ".asm"     => "text/x-asm",
      ".asx"     => "video/x-ms-asf",
      ".atom"    => "application/atom+xml",
      ".au"      => "audio/basic",
      ".avi"     => "video/x-msvideo",
      ".bat"     => "application/x-msdownload",
      ".bin"     => "application/octet-stream",
      ".bmp"     => "image/bmp",
      ".bz2"     => "application/x-bzip2",
      ".c"       => "text/x-c",
      ".cab"     => "application/vnd.ms-cab-compressed",
      ".cc"      => "text/x-c",
      ".chm"     => "application/vnd.ms-htmlhelp",
      ".class"   => "application/octet-stream",
      ".com"     => "application/x-msdownload",
      ".conf"    => "text/plain",
      ".cpp"     => "text/x-c",
      ".crt"     => "application/x-x509-ca-cert",
      ".css"     => "text/css",
      ".csv"     => "text/csv",
      ".cxx"     => "text/x-c",
      ".deb"     => "application/x-debian-package",
      ".der"     => "application/x-x509-ca-cert",
      ".diff"    => "text/x-diff",
      ".djv"     => "image/vnd.djvu",
      ".djvu"    => "image/vnd.djvu",
      ".dll"     => "application/x-msdownload",
      ".dmg"     => "application/octet-stream",
      ".doc"     => "application/msword",
      ".dot"     => "application/msword",
      ".dtd"     => "application/xml-dtd",
      ".dvi"     => "application/x-dvi",
      ".ear"     => "application/java-archive",
      ".eml"     => "message/rfc822",
      ".eps"     => "application/postscript",
      ".exe"     => "application/x-msdownload",
      ".f"       => "text/x-fortran",
      ".f77"     => "text/x-fortran",
      ".f90"     => "text/x-fortran",
      ".flv"     => "video/x-flv",
      ".for"     => "text/x-fortran",
      ".gem"     => "application/octet-stream",
      ".gemspec" => "text/x-script.ruby",
      ".gif"     => "image/gif",
      ".gz"      => "application/x-gzip",
      ".h"       => "text/x-c",
      ".hh"      => "text/x-c",
      ".htm"     => "text/html",
      ".html"    => "text/html",
      ".ico"     => "image/vnd.microsoft.icon",
      ".ics"     => "text/calendar",
      ".ifb"     => "text/calendar",
      ".iso"     => "application/octet-stream",
      ".jar"     => "application/java-archive",
      ".java"    => "text/x-java-source",
      ".jnlp"    => "application/x-java-jnlp-file",
      ".jpeg"    => "image/jpeg",
      ".jpg"     => "image/jpeg",
      ".js"      => "application/javascript",
      ".json"    => "application/json",
      ".log"     => "text/plain",
      ".m3u"     => "audio/x-mpegurl",
      ".m4v"     => "video/mp4",
      ".man"     => "text/troff",
      ".manifest"=> "text/cache-manifest",
      ".mathml"  => "application/mathml+xml",
      ".mbox"    => "application/mbox",
      ".mdoc"    => "text/troff",
      ".me"      => "text/troff",
      ".mid"     => "audio/midi",
      ".midi"    => "audio/midi",
      ".mime"    => "message/rfc822",
      ".mml"     => "application/mathml+xml",
      ".mng"     => "video/x-mng",
      ".mov"     => "video/quicktime",
      ".mp3"     => "audio/mpeg",
      ".mp4"     => "video/mp4",
      ".mp4v"    => "video/mp4",
      ".mpeg"    => "video/mpeg",
      ".mpg"     => "video/mpeg",
      ".ms"      => "text/troff",
      ".msi"     => "application/x-msdownload",
      ".odp"     => "application/vnd.oasis.opendocument.presentation",
      ".ods"     => "application/vnd.oasis.opendocument.spreadsheet",
      ".odt"     => "application/vnd.oasis.opendocument.text",
      ".ogg"     => "application/ogg",
      ".ogv"     => "video/ogg",
      ".p"       => "text/x-pascal",
      ".pas"     => "text/x-pascal",
      ".pbm"     => "image/x-portable-bitmap",
      ".pdf"     => "application/pdf",
      ".pem"     => "application/x-x509-ca-cert",
      ".pgm"     => "image/x-portable-graymap",
      ".pgp"     => "application/pgp-encrypted",
      ".pkg"     => "application/octet-stream",
      ".pl"      => "text/x-script.perl",
      ".pm"      => "text/x-script.perl-module",
      ".png"     => "image/png",
      ".pnm"     => "image/x-portable-anymap",
      ".ppm"     => "image/x-portable-pixmap",
      ".pps"     => "application/vnd.ms-powerpoint",
      ".ppt"     => "application/vnd.ms-powerpoint",
      ".ps"      => "application/postscript",
      ".psd"     => "image/vnd.adobe.photoshop",
      ".py"      => "text/x-script.python",
      ".qt"      => "video/quicktime",
      ".ra"      => "audio/x-pn-realaudio",
      ".rake"    => "text/x-script.ruby",
      ".ram"     => "audio/x-pn-realaudio",
      ".rar"     => "application/x-rar-compressed",
      ".rb"      => "text/x-script.ruby",
      ".rdf"     => "application/rdf+xml",
      ".roff"    => "text/troff",
      ".rpm"     => "application/x-redhat-package-manager",
      ".rss"     => "application/rss+xml",
      ".rtf"     => "application/rtf",
      ".ru"      => "text/x-script.ruby",
      ".s"       => "text/x-asm",
      ".sgm"     => "text/sgml",
      ".sgml"    => "text/sgml",
      ".sh"      => "application/x-sh",
      ".sig"     => "application/pgp-signature",
      ".snd"     => "audio/basic",
      ".so"      => "application/octet-stream",
      ".svg"     => "image/svg+xml",
      ".svgz"    => "image/svg+xml",
      ".swf"     => "application/x-shockwave-flash",
      ".t"       => "text/troff",
      ".tar"     => "application/x-tar",
      ".tbz"     => "application/x-bzip-compressed-tar",
      ".tcl"     => "application/x-tcl",
      ".tex"     => "application/x-tex",
      ".texi"    => "application/x-texinfo",
      ".texinfo" => "application/x-texinfo",
      ".text"    => "text/plain",
      ".tif"     => "image/tiff",
      ".tiff"    => "image/tiff",
      ".torrent" => "application/x-bittorrent",
      ".tr"      => "text/troff",
      ".txt"     => "text/plain",
      ".vcf"     => "text/x-vcard",
      ".vcs"     => "text/x-vcalendar",
      ".vrml"    => "model/vrml",
      ".war"     => "application/java-archive",
      ".wav"     => "audio/x-wav",
      ".wma"     => "audio/x-ms-wma",
      ".wmv"     => "video/x-ms-wmv",
      ".wmx"     => "video/x-ms-wmx",
      ".wrl"     => "model/vrml",
      ".wsdl"    => "application/wsdl+xml",
      ".xbm"     => "image/x-xbitmap",
      ".xhtml"   => "application/xhtml+xml",
      ".xls"     => "application/vnd.ms-excel",
      ".xml"     => "application/xml",
      ".xpm"     => "image/x-xpixmap",
      ".xsl"     => "application/xml",
      ".xslt"    => "application/xslt+xml",
      ".yaml"    => "text/yaml",
      ".yml"     => "text/yaml",
      ".zip"     => "application/zip",
  };
  
  my $fallback = sub { };
  
  sub mime_type {
      my($class, $file) = @_;
      $file =~ /(\.[a-zA-Z0-9]+)$/ or return;
      $MIME_TYPES->{lc $1} || $fallback->(lc $1);
  }
  
  sub add_type {
      my $class = shift;
      while (my($ext, $type) = splice @_, 0, 2) {
          $MIME_TYPES->{lc $ext} = $type;
      }
  }
  
  sub set_fallback {
      my($class, $cb) = @_;
      $fallback = $cb;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::MIME - MIME type registry
  
  =head1 SYNOPSIS
  
    use Plack::MIME;
  
    my $mime = Plack::MIME->mime_type(".png"); # image/png
  
    # register new type(s)
    Plack::MIME->add_type(".foo" => "application/x-foo");
  
    # Use MIME::Types as a fallback
    use MIME::Types 'by_suffix';
    Plack::MIME->set_fallback(sub { (by_suffix $_[0])[0] });
  
  =head1 DESCRIPTION
  
  Plack::MIME is a simple MIME type registry for Plack applications. The
  selection of MIME types is based on Rack's Rack::Mime module.
  
  =head1 SEE ALSO
  
  Rack::Mime L<MIME::Types>
  
  =cut
  
  
PLACK_MIME

$fatpacked{"Plack/Middleware.pm"} = <<'PLACK_MIDDLEWARE';
  package Plack::Middleware;
  use strict;
  use warnings;
  use Carp ();
  use parent qw(Plack::Component);
  use Plack::Util;
  use Plack::Util::Accessor qw( app );
  
  sub import {
      my $class = shift;
      if (@_) {
          Carp::carp("use Plack::Middleware qw(Foo) is deprecated. See perldoc Plack::Builder");
      }
  }
  
  sub wrap {
      my($self, $app, @args) = @_;
      if (ref $self) {
          $self->{app} = $app;
      } else {
          $self = $self->new({ app => $app, @args });
      }
      return $self->to_app;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware - Base class for easy-to-use PSGI middleware
  
  =head1 SYNOPSIS
  
    package Plack::Middleware::Foo;
    use parent qw( Plack::Middleware );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        # $self->app is the original app
        my $res = $self->app->($env);
  
        # Do something with $res
        return $res;
    }
  
    # then in app.psgi
    use Plack::Builder;
  
    my $app = sub { ... } # as usual
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", %options;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware is a utility base class to write PSGI
  middleware. All you have to do is to inherit from Plack::Middleware
  and then implement the callback C<call> method (or C<to_app> method
  that would return the PSGI code reference) to do the actual work. You
  can use C<< $self->app >> to call the original (wrapped) application.
  
  Your middleware object is created at a PSGI application compile time
  and is persistent during the web server life cycle (unless it is a
  non-persistent environment such as CGI), so you should never set or
  cache per-request data like C<$env> in your middleware object. See
  also L<Plack::Component/"OBJECT LIFECYCLE">.
  
  See L<Plack::Builder> how to actually enable middleware in your
  I<.psgi> application file using the DSL. If you do not like our
  builder DSL, you can also use C<wrap> method to wrap your application
  with a middleware:
  
    use Plack::Middleware::Foo;
  
    my $app = sub { ... };
    $app = Plack::Middleware::Foo->wrap($app, %options);
    $app = Plack::Middleware::Bar->wrap($app, %options);
  
  =head1 RESPONSE CALLBACK
  
  The typical middleware is written like this:
  
    package Plack::Middleware::Something;
    use parent qw(Plack::Middleware);
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $self->app->($env);
        # post-processing $res
        return $res;
    }
  
  The tricky thing about post processing the response is that it could
  either be an immediate 3 element array ref, or a code reference that
  implements the delayed (streaming) interface.
  
  Dealing with these two types of response in each piece of middleware
  is pointless, so you're recommended to use the C<response_cb> wrapper
  function in L<Plack::Util> when implementing a post processing
  middleware.
  
    my $res = $app->($env);
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        # do something with $res;
    });
  
  The callback function gets a PSGI response as a 3 element array
  reference, and you can update the reference to implement the post
  processing.
  
    package Plack::Middleware::Always500;
    use parent qw(Plack::Middleware);
    use Plack::Util;
  
    sub call {
        my($self, $env) = @_;
        my $res  = $self->app->($env);
        Plack::Util::response_cb($res, sub {
            my $res = shift;
            $res->[0] = 500;
            return;
        });
    }
  
  In this example, the callback gets the C<$res> and updates its first
  element (status code) to 500. Using C<response_cb> makes sure that
  this works with the delayed response too.
  
  You're not required (and not recommended either) to return a new array
  reference - they will be simply ignored. You're suggested to
  explicitly return, unless you fiddle with the content filter callback
  (see below).
  
  Similarly, note that you have to keep the C<$res> reference when you
  swap the entire response.
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        $res = [ $new_status, $new_headers, $new_body ]; # THIS DOES NOT WORK
        return;
    });
  
  This does not work, since assigning a new anonymous array to C<$res>
  doesn't update the original PSGI response value. You should instead
  do:
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        @$res = ($new_status, $new_headers, $new_body); # THIS WORKS
        return;
    });
  
  The third element of PSGI response array ref is a body, and it could
  be either array ref or IO::Handle-ish object. The application could
  also make use of C<$writer> object if C<psgi.streaming> is in
  effect. Dealing with these variants is again really painful, and
  C<response_cb> can take care of that too, by allowing you to return a
  content filter as a code reference.
  
    # replace all "Foo" in content body with "Bar"
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        return sub {
            my $chunk = shift;
            return unless defined $chunk;
            $chunk =~ s/Foo/Bar/g;
            return $chunk;
        }
    });
  
  The callback takes one argument C<$chunk> and your callback is
  expected to return the updated chunk. If the given C<$chunk> is undef,
  it means the stream has reached the end, so your callback should also
  return undef, or return the final chunk and return undef when called
  next time.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Component>
  
  =cut
PLACK_MIDDLEWARE

$fatpacked{"Plack/Middleware/AccessLog.pm"} = <<'PLACK_MIDDLEWARE_ACCESSLOG';
  package Plack::Middleware::AccessLog;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  use Plack::Util::Accessor qw( logger format );
  
  use Carp ();
  use Plack::Util;
  
  my %formats = (
      common => "%h %l %u %t \"%r\" %>s %b",
      combined => "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"",
  );
  
  use POSIX ();
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
          my $content_length = Plack::Util::content_length($res->[2]);
          $logger->( $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length }) );
      });
  }
  
  sub log_line {
      my($self, $status, $headers, $env, $opts) = @_;
  
      my $h = Plack::Util::headers($headers);
  
      my $strftime = sub {
          my $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
          POSIX::setlocale(&POSIX::LC_ALL, 'en');
          my $out = POSIX::strftime(@_);
          POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
          return $out;
      };
  
      my $block_handler = sub {
          my($block, $type) = @_;
          if ($type eq 'i') {
              $block =~ s/-/_/g;
              my $val = _safe($env->{"HTTP_" . uc($block)});
              return defined $val ? $val : "-";
          } elsif ($type eq 'o') {
              return scalar $h->get($block) || "-";
          } elsif ($type eq 't') {
              return "[" . $strftime->($block, localtime) . "]";
          } else {
              Carp::carp("{$block}$type not supported");
              return "-";
          }
      };
  
  
      my %char_handler = (
          '%' => sub { '%' },
          h => sub { $env->{REMOTE_ADDR} || '-' },
          l => sub { '-' },
          u => sub { $env->{REMOTE_USER} || '-' },
          t => sub { "[" . $strftime->("%d/%b/%Y:%H:%M:%S %z", localtime) . "]" },
          r => sub { _safe($env->{REQUEST_METHOD}) . " " . _safe($env->{REQUEST_URI}) .
                     " " . $env->{SERVER_PROTOCOL} },
          s => sub { $status },
          b => sub { $opts->{content_length} || $h->get('Content-Length') || "-" },
          T => sub { $opts->{time} ? int($opts->{time}) : "-" },
          D => sub { $opts->{time} ? $opts->{time} * 1000000 : "-" },
          v => sub { $env->{SERVER_NAME} || '-' },
          V => sub { $env->{HTTP_HOST} || $env->{SERVER_NAME} || '-' },
      );
  
      my $char_handler = sub {
          my $char = shift;
  
          my $cb = $char_handler{$char};
          unless ($cb) {
              Carp::carp "\%$char not supported.";
              return "-";
          }
          $cb->($char);
      };
  
      my $fmt = $self->format || "combined";
      $fmt = $formats{$fmt} if exists $formats{$fmt};
  
      $fmt =~ s{
          (?:
           \%\{(.+?)\}([a-z]) |
           \%(?:[<>])?([a-zA-Z\%])
          )
      }{ $1 ? $block_handler->($1, $2) : $char_handler->($3) }egx;
  
      return $fmt . "\n";
  }
  
  sub _safe {
      my $string = shift;
      $string =~ s/([^[:print:]])/"\\x" . unpack("H*", $1)/eg
          if defined $string;
      $string;
  }
  
  
  __END__
  
  =for stopwords
  LogFormat
  
  =head1 NAME
  
  Plack::Middleware::AccessLog - Logs requests like Apache's log format
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog", format => "combined";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog forwards the request to the given app and
  logs request and response details to the logger callback. The format
  can be specified using Apache-like format strings (or C<combined> or
  C<common> for the default formats). If none is specified C<combined> is
  used.
  
  This middleware uses calculable content-length by checking body type,
  and can not log the time taken to serve requests. It also logs the
  request B<before> the response is actually sent to the client. Use
  L<Plack::Middleware::AccessLog::Timed> if you want to log details
  B<after> the response is transmitted (more like a real web server) to
  the client.
  
  This middleware is enabled by default when you run L<plackup> as a
  default C<development> environment.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item format
  
    enable "Plack::Middleware::AccessLog",
        format => "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"";
  
  Takes a format string (or a preset template C<combined> or C<custom>)
  to specify the log format. This middleware implements subset of
  Apache's LogFormat templates.
  
  =item logger
  
    my $logger = Log::Dispatch->new(...);
    enable "Plack::Middleware::AccessLog",
        logger => sub { $logger->log(debug => @_) };
  
  Sets a callback to print log message to. It prints to C<psgi.errors>
  output stream by default.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://httpd.apache.org/docs/2.2/mod/mod_log_config.html> Rack::CustomLogger
  
  =cut
  
PLACK_MIDDLEWARE_ACCESSLOG

$fatpacked{"Plack/Middleware/AccessLog/Timed.pm"} = <<'PLACK_MIDDLEWARE_ACCESSLOG_TIMED';
  package Plack::Middleware::AccessLog::Timed;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware::AccessLog );
  
  use Time::HiRes;
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $time = Time::HiRes::gettimeofday;
      my $length = 0;
      my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my($status, $header, $body) = @$res;
  
          if (!defined $body) {
              $logger->( $self->log_line($status, $header, $env) );
              return;
          }
  
          my $getline = ref $body eq 'ARRAY' ? sub { shift @$body } : sub { $body->getline };
  
          my $timer_body = Plack::Util::inline_object(
              getline => sub {
                  my $line = $getline->();
                  $length += length $line if defined $line;
                  return $line;
              },
              close => sub {
                  $body->close if ref $body ne 'ARRAY';
  
                  my $now = Time::HiRes::gettimeofday;
                  $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
              },
          );
  
          @$res = ($status, $header, $timer_body);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::AccessLog::Timed - Logs requests with time and accurate body size
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog::Timed",
            format => "%v %h %l %u %t \"%r\" %>s %b %D";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog::Timed is a subclass of
  Plack::Middleware::AccessLog but uses a wrapped body handle to get the
  actual response body size C<%b> (even if it's not a chunk of array or
  a real filehandle) and the time taken to serve the request: C<%T> or
  C<%D>.
  
  This wraps the response body output stream so some server
  optimizations like sendfile(2) will be disabled if you use this
  middleware.
  
  =head1 CONFIGURATION
  
  Same as L<Plack::Middleware::AccessLog>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::AccessLog>
  
  =cut
PLACK_MIDDLEWARE_ACCESSLOG_TIMED

$fatpacked{"Plack/Middleware/Auth/Basic.pm"} = <<'PLACK_MIDDLEWARE_AUTH_BASIC';
  package Plack::Middleware::Auth::Basic;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw( realm authenticator );
  use Scalar::Util;
  use MIME::Base64;
  
  sub prepare_app {
      my $self = shift;
  
      my $auth = $self->authenticator or die 'authenticator is not set';
      if (Scalar::Util::blessed($auth) && $auth->can('authenticate')) {
          $self->authenticator(sub { $auth->authenticate(@_[0,1]) }); # because Authen::Simple barfs on 3 params
      } elsif (ref $auth ne 'CODE') {
          die 'authenticator should be a code reference or an object that responds to authenticate()';
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $auth = $env->{HTTP_AUTHORIZATION}
          or return $self->unauthorized;
  
      if ($auth =~ /^Basic (.*)$/) {
          my($user, $pass) = split /:/, (MIME::Base64::decode($1) || ":");
          $pass = '' unless defined $pass;
          if ($self->authenticator->($user, $pass, $env)) {
              $env->{REMOTE_USER} = $user;
              return $self->app->($env);
          }
      }
  
      return $self->unauthorized;
  }
  
  sub unauthorized {
      my $self = shift;
      my $body = 'Authorization required';
      return [
          401,
          [ 'Content-Type' => 'text/plain',
            'Content-Length' => length $body,
            'WWW-Authenticate' => 'Basic realm="' . ($self->realm || "restricted area") . '"' ],
          [ $body ],
      ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Auth::Basic - Simple basic authentication middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    my $app = sub { ... };
  
    builder {
        enable "Auth::Basic", authenticator => \&authen_cb;
        $app;
    };
  
    sub authen_cb {
        my($username, $password) = @_;
        return $username eq 'admin' && $password eq 's3cr3t';
    }
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Auth::Basic is a basic authentication handler for Plack.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item authenticator
  
  A callback function that takes username and password supplied and
  returns whether the authentication succeeds. Required.
  
  Authenticator can also be an object that responds to C<authenticate>
  method that takes username and password and returns boolean, so
  backends for L<Authen::Simple> is perfect to use:
  
    use Authen::Simple::LDAP;
    enable "Auth::Basic", authenticator => Authen::Simple::LDAP->new(...);
  
  =item realm
  
  Realm name to display in the basic authentication dialog. Defaults to I<restricted area>.
  
  =back
  
  =head1 LIMITATIONS
  
  This middleware expects that the application has a full access to the
  headers sent by clients in PSGI environment. That is normally the case
  with standalone Perl PSGI web servers such as L<Starman> or
  L<HTTP::Server::Simple::PSGI>.
  
  However, in a web server configuration where you can't achieve this
  (i.e. using your application via Apache's mod_cgi), this middleware
  does not work since your application can't know the value of
  C<Authorization:> header.
  
  If you use Apache as a web server and CGI to run your PSGI
  application, you can either a) compile Apache with
  C<-DSECURITY_HOLE_PASS_AUTHORIZATION> option, or b) use mod_rewrite to
  pass the Authorization header to the application with the rewrite rule
  like following.
  
    RewriteEngine on
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_MIDDLEWARE_AUTH_BASIC

$fatpacked{"Plack/Middleware/BufferedStreaming.pm"} = <<'PLACK_MIDDLEWARE_BUFFEREDSTREAMING';
  package Plack::Middleware::BufferedStreaming;
  use strict;
  no warnings;
  use Carp;
  use Plack::Util;
  use Scalar::Util qw(weaken);
  use parent qw(Plack::Middleware);
  
  sub call {
      my ( $self, $env ) = @_;
  
      my $caller_supports_streaming = $env->{'psgi.streaming'};
      $env->{'psgi.streaming'} = Plack::Util::TRUE;
  
      my $res = $self->app->($env);
      return $res if $caller_supports_streaming;
  
      if ( ref($res) eq 'CODE' ) {
          my $ret;
  
          $res->(sub {
              my $write = shift;
  
              if ( @$write == 2 ) {
                  my @body;
  
                  $ret = [ @$write, \@body ];
  
                  return Plack::Util::inline_object(
                      write => sub { push @body, $_[0] },
                      close => sub { },
                  );
              } else {
                  $ret = $write;
                  return;
              }
          });
  
          return $ret;
      } else {
          return $res;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::BufferedStreaming - Enable buffering for non-streaming aware servers
  
  =head1 SYNOPSIS
  
    enable "BufferedStreaming";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::BufferedStreaming is a PSGI middleware component
  that wraps the application that uses C<psgi.streaming> interface to
  run on the servers that do not support the interface, by buffering the
  writer output to a temporary buffer.
  
  This middleware doesn't do anything and bypass the application if the
  server supports C<psgi.streaming> interface.
  
  =head1 AUTHOR
  
  Yuval Kogman
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_BUFFEREDSTREAMING

$fatpacked{"Plack/Middleware/Chunked.pm"} = <<'PLACK_MIDDLEWARE_CHUNKED';
  package Plack::Middleware::Chunked;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($env->{'SERVER_PROTOCOL'} ne 'HTTP/1.0' and
              ! Plack::Util::status_with_no_entity_body($res->[0]) and
              ! $h->exists('Content-Length') and
              ! $h->exists('Transfer-Encoding')
          ) {
              $h->set('Transfer-Encoding' => 'chunked');
              my $done;
              return sub {
                  my $chunk = shift;
                  return if $done;
                  unless (defined $chunk) {
                      $done = 1;
                      return "0\015\012\015\012";
                  }
                  return '' unless length $chunk;
                  return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Chunked - Applies chunked encoding to the response body
  
  =head1 SYNOPSIS
  
    # Mostly from server implemenations
    $app = Plack::Middeware::Chunked->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middeware::Chunked is a middleware, or rather a library for
  PSGI server to automatically add chunked encoding to the response body
  when Content-Length is not set in the response header.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Chunked
  
  =cut
PLACK_MIDDLEWARE_CHUNKED

$fatpacked{"Plack/Middleware/Conditional.pm"} = <<'PLACK_MIDDLEWARE_CONDITIONAL';
  package Plack::Middleware::Conditional;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util::Accessor qw( condition middleware builder );
  
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
  
      $self->middleware( $self->builder->($self->app) );
      $self;
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $app = $self->condition->($env) ? $self->middleware : $self->app;
      return $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Conditional - Conditional wrapper for Plack middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace';
        $app;
    };
  
    # Or more raw version of it
    $app = Plack::Middleware::Conditional->wrap(
        $app,
        condition  => sub { my $env = shift; $env->{HTTP_USER_AGENT} =~ /WebKit/ },
        builder => sub { Plack::Middleware::SuperAdminConsole->wrap($_[0], @args) },
    );
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Conditional is a piece of meta-middleware, to run a
  specific middleware component under the runtime condition. The goal of
  this middleware is to avoid baking runtime configuration options in
  individual middleware components, and rather share them as another
  middleware component.
  
  =head1 EXAMPLES
  
  Note that some of the middleware component names are just made up for
  the explanation and might not exist.
  
    # Minify JavaScript if the browser is Firefox
    enable_if { $_[0]->{HTTP_USER_AGENT} =~ /Firefox/ } 'JavaScriptMinifier';
  
    # Enable Stacktrace when being accessed from the local network
    enable_if { $_[0]->{REMOTE_ADDR} =~ /^10\.0\.1\.*/ } 'StackTrace';
  
    # Work with other conditional setter middleware:
    # Transcode Jpeg on the fly for mobile clients
    builder {
        enable 'MobileDetector';
        enable_if { $_[0]->{'plack.mobile_detected'} }
          'TranscodeJpeg', max_size => 30_000;
        $app;
    };
  
  Note that in the last example I<MobileDetector> should come first
  because the conditional check runs in I<pre-run> condition, which is
  from outer to inner and that is from the top to the bottom in the
  Builder DSL code.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Steve Cook
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_MIDDLEWARE_CONDITIONAL

$fatpacked{"Plack/Middleware/ConditionalGET.pm"} = <<'PLACK_MIDDLEWARE_CONDITIONALGET';
  package Plack::Middleware::ConditionalGET;
  use strict;
  use parent qw( Plack::Middleware );
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      return $res unless $env->{REQUEST_METHOD} =~ /^(GET|HEAD)$/;
  
      $self->response_cb($res, sub {
          my $res = shift;
          return unless $res->[2]; # do not support streaming interface
  
          my $h = Plack::Util::headers($res->[1]);
          if ( $self->etag_matches($h, $env) || $self->not_modified_since($h, $env) ) {
              $res->[0] = 304;
              $h->remove($_) for qw( Content-Type Content-Length Content-Disposition );
              $res->[2] = [];
          }
      });
  }
  
  no warnings 'uninitialized';
  
  # RFC 2616 14.25 says it's OK and expected to use 'eq' :)
  # > Note: When handling an If-Modified-Since header field, some
  # > servers will use an exact date comparison function, rather than a
  # > less-than function, for deciding whether to send a 304 ...
  
  sub etag_matches {
      my($self, $h, $env) = @_;
      $h->exists('ETag') && $h->get('ETag') eq _value($env->{HTTP_IF_NONE_MATCH});
  }
  
  sub not_modified_since {
      my($self, $h, $env) = @_;
      $h->exists('Last-Modified') && $h->get('Last-Modified') eq _value($env->{HTTP_IF_MODIFIED_SINCE});
  }
  
  sub _value {
      my $str = shift;
      # IE sends wrong formatted value(i.e. "Thu, 03 Dec 2009 01:46:32 GMT; length=17936")
      $str =~ s/;.*$//;
      return $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ConditionalGET - Middleware to enable conditional GET
  
  =head1 SYNOPSIS
  
    builder {
        enable "ConditionalGET";
        ....
    };
  
  =head1 DESCRIPTION
  
  This middleware enables conditional GET and HEAD using
  C<If-None-Match> and C<If-Modified-Since> header. The application
  should set either or both of C<Last-Modified> or C<ETag> response
  headers per RFC 2616. When either of the conditions is met, the
  response body is set to be zero length and the status is set to 304
  Not Modified.
  
  =head1 SEE ALSO
  
  Rack::ConditionalGet
  
  =cut
PLACK_MIDDLEWARE_CONDITIONALGET

$fatpacked{"Plack/Middleware/ContentLength.pm"} = <<'PLACK_MIDDLEWARE_CONTENTLENGTH';
  package Plack::Middleware::ContentLength;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if (!Plack::Util::status_with_no_entity_body($res->[0]) &&
              !$h->exists('Content-Length') &&
              !$h->exists('Transfer-Encoding') &&
              defined(my $content_length = Plack::Util::content_length($res->[2]))) {
              $h->push('Content-Length' => $content_length);
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentLength - Adds Content-Length header automatically
  
  =head1 SYNOPSIS
  
    # in app.psgi
  
    builder {
        enable "Plack::Middleware::ContentLength";
        $app;
    }
  
    # Or in Plack::Handler::*
    $app = Plack::Middleware::ContentLength->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ContentLength is a middleware that automatically
  adds C<Content-Length> header when it's appropriate i.e. the response
  has a content body with calculable size (array of chunks or a real
  filehandle).
  
  This middleware can also be used as a library from PSGI server
  implementations to automatically set C<Content-Length> rather than in
  the end user level.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::ContentLength
  
  =cut
  
PLACK_MIDDLEWARE_CONTENTLENGTH

$fatpacked{"Plack/Middleware/ContentMD5.pm"} = <<'PLACK_MIDDLEWARE_CONTENTMD5';
  package Plack::Middleware::ContentMD5;
  
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Digest::MD5 qw/md5_hex/;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
      
      $self->response_cb($res, sub {
          my $res = shift;
  
          return unless defined $res->[2];
          return if (Plack::Util::status_with_no_entity_body($res->[0]));
          
          my $h = Plack::Util::headers($res->[1]);
          return if ( $h->exists('Content-MD5') );
          
          my $body = $res->[2];
          if (ref $body eq 'ARRAY') {
              $h->set('Content-MD5', md5_hex(@$body));
          }
          # Do we need support $fh?
  
          return;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentMD5 - Automatically sets the Content-MD5 header on all String bodies
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::ContentMD5";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Automatically sets the Content-MD5 header on all String bodies
  
  =head1 AUTHOR
  
  Fayland Lam
  
  =cut
PLACK_MIDDLEWARE_CONTENTMD5

$fatpacked{"Plack/Middleware/ErrorDocument.pm"} = <<'PLACK_MIDDLEWARE_ERRORDOCUMENT';
  package Plack::Middleware::ErrorDocument;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  use Plack::MIME;
  use Plack::Util;
  use Plack::Util::Accessor qw( subrequest );
  
  use HTTP::Status qw(is_error);
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $r = $self->app->($env);
  
      $self->response_cb($r, sub {
          my $r = shift;
          unless (is_error($r->[0]) && exists $self->{$r->[0]}) {
              return;
          }
  
          my $path = $self->{$r->[0]};
          if ($self->subrequest) {
              for my $key (keys %$env) {
                  unless ($key =~ /^psgi/) {
                      $env->{'psgix.errordocument.' . $key} = $env->{$key};
                  }
              }
  
              # TODO: What if SCRIPT_NAME is not empty?
              $env->{REQUEST_METHOD} = 'GET';
              $env->{REQUEST_URI}    = $path;
              $env->{PATH_INFO}      = $path;
              $env->{QUERY_STRING}   = '';
              delete $env->{CONTENT_LENGTH};
  
              my $sub_r = $self->app->($env);
              if ($sub_r->[0] == 200) {
                  $r->[1] = $sub_r->[1];
                  $r->[2] = $sub_r->[2];
              }
              # TODO: allow 302 here?
          } else {
              open my $fh, "<", $path or die "$path: $!";
              $r->[2] = $fh;
              my $h = Plack::Util::headers($r->[1]);
              $h->remove('Content-Length');
              $h->set('Content-Type', Plack::MIME->mime_type($path));
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ErrorDocument - Set Error Document based on HTTP status code
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            500 => '/uri/errors/500.html', 404 => '/uri/errors/404.html',
            subrequest => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ErrorDocument allows you to customize error screen
  by setting paths (file system path or URI path) of error pages per
  status code.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item subrequest
  
  A boolean flag to serve error pages using a new GET sub request.
  Defaults to false, which means it serves error pages using file
  system path.
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            502 => '/home/www/htdocs/errors/maint.html';
        enable "Plack::Middleware::ErrorDocument",
            404 => '/static/404.html', 403 => '/static/403.html', subrequest => 1;
        $app;
    };
  
  This configuration serves 502 error pages from file system directly
  assuming that's when you probably maintain database etc. but serves
  404 and 403 pages using a sub request so your application can do some
  logic there like logging or doing suggestions.
  
  When using a subrequest, the subrequest should return a regular '200' response.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  =cut
PLACK_MIDDLEWARE_ERRORDOCUMENT

$fatpacked{"Plack/Middleware/HTTPExceptions.pm"} = <<'PLACK_MIDDLEWARE_HTTPEXCEPTIONS';
  package Plack::Middleware::HTTPExceptions;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(rethrow);
  
  use Carp ();
  use Try::Tiny;
  use Scalar::Util 'blessed';
  use HTTP::Status ();
  
  sub prepare_app {
      my $self = shift;
      $self->rethrow(1) if ($ENV{PLACK_ENV} || '') eq 'development';
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $res = try {
          $self->app->($env);
      } catch {
          $self->transform_error($_, $env);
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if ($writer) {
                  Carp::cluck $_;
                  $writer->close;
              } else {
                  my $res = $self->transform_error($_, $env);
                  $respond->($res);
              }
          };
      };
  }
  
  sub transform_error {
      my($self, $e, $env) = @_;
  
      my($code, $message);
      if (blessed $e && $e->can('as_psgi')) {
          return $e->as_psgi;
      }
      if (blessed $e && $e->can('code')) {
          $code = $e->code;
          $message =
              $e->can('as_string')       ? $e->as_string :
              overload::Method($e, '""') ? "$e"          : undef;
      } else {
          if ($self->rethrow) {
              die $e;
          }
          else {
              $code = 500;
              $env->{'psgi.errors'}->print($e);
          }
      }
  
      if ($code !~ /^[3-5]\d\d$/) {
          die $e; # rethrow
      }
  
      $message ||= HTTP::Status::status_message($code);
  
      my @headers = (
           'Content-Type'   => 'text/plain',
           'Content-Length' => length($message),
      );
  
      if ($code =~ /^3/ && (my $loc = eval { $e->location })) {
          push(@headers, Location => $loc);
      }
  
      return [ $code, \@headers, [ $message ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::HTTPExceptions - Catch HTTP exceptions
  
  =head1 SYNOPSIS
  
    use HTTP::Exception;
  
    my $app = sub {
        # ...
        HTTP::Exception::500->throw;
    };
  
    builder {
        enable "HTTPExceptions", rethrow => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::HTTPExceptions is a PSGI middleware component to
  catch exceptions from applications that can be translated into HTTP
  status codes.
  
  Your application is supposed to throw an object that implements a
  C<code> method which returns the HTTP status code, such as 501 or
  404. This middleware catches them and creates a valid response out of
  the code. If the C<code> method returns a code that is not an HTTP
  redirect or error code (3xx, 4xx, or 5xx), the exception will be
  rethrown.
  
  The exception object may also implement C<as_string> or overload
  stringification to represent the text of the error. The text defaults to
  the status message of the error code, such as I<Service Unavailable> for
  C<503>.
  
  Finally, the exception object may implement C<as_psgi>, and the result
  of this will be returned directly as the PSGI response.
  
  If the code is in the 3xx range and the exception implements the 'location'
  method (HTTP::Exception::3xx does), the Location header will be set in the
  response, so you can do redirects this way.
  
  There are CPAN modules L<HTTP::Exception> and L<HTTP::Throwable>, and
  they are perfect to throw from your application to let this middleware
  catch and display, but you can also implement your own exception class
  to throw.
  
  If the thrown exception is not an object that implements either a
  C<code> or an C<as_psgi> method, a 500 error will be returned.
  Alternatively, you can pass a true value for the C<rethrow> parameter
  for this middleware, and the exception will instead be rethrown. This is
  enabled by default when C<PLACK_ENV> is set to C<development>, so that
  the L<StackTrace|Plack::Middleware::StackTrace> middleware can catch it
  instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  paste.httpexceptions L<HTTP::Exception> L<HTTP::Throwable>
  
  =cut
PLACK_MIDDLEWARE_HTTPEXCEPTIONS

$fatpacked{"Plack/Middleware/Head.pm"} = <<'PLACK_MIDDLEWARE_HEAD';
  package Plack::Middleware::Head;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  sub call {
      my($self, $env) = @_;
  
      return $self->app->($env)
          unless $env->{REQUEST_METHOD} eq 'HEAD';
  
      $self->response_cb($self->app->($env), sub {
          my $res = shift;
          $res->[2] = [];
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Head - auto delete response body in HEAD requests
  
  =head1 SYNOPSIS
  
    enable "Head";
  
  =head1 DESCRIPTION
  
  This middleware deletes response body in HEAD requests.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Head
  
  =cut
  
PLACK_MIDDLEWARE_HEAD

$fatpacked{"Plack/Middleware/IIS6ScriptNameFix.pm"} = <<'PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX';
  package Plack::Middleware::IIS6ScriptNameFix;
  
  use strict;
  use parent 'Plack::Middleware';
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /IIS\/[6-9]\.[0-9]/) {
          my @script_name = split(m!/!, $env->{PATH_INFO});
          my @path_translated = split(m!/|\\\\?!, $env->{PATH_TRANSLATED});
          my @path_info;
  
          while ($script_name[$#script_name] eq $path_translated[$#path_translated]) {
              pop(@path_translated);
              unshift(@path_info, pop(@script_name));
          }
  
          unshift(@path_info, '', '');
  
          $env->{PATH_INFO} = join('/', @path_info);
          $env->{SCRIPT_NAME} = join('/', @script_name);
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS6ScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that IIS6 sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS6ScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS6ScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by IIS6.
  
  =head1 AUTHORS
  
  Florian Ragwitz
  
  =cut
PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/JSONP.pm"} = <<'PLACK_MIDDLEWARE_JSONP';
  package Plack::Middleware::JSONP;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use URI::Escape ();
  
  use Plack::Util::Accessor qw/callback_key/;
  
  sub prepare_app {
      my $self = shift;
      unless (defined $self->callback_key) {
          $self->callback_key('callback');
      }
  }
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          if (defined $res->[2]) {
              my $h = Plack::Util::headers($res->[1]);
              my $callback_key = $self->callback_key;
              if ($h->get('Content-Type') =~ m!/(?:json|javascript)! &&
                  $env->{QUERY_STRING} =~ /(?:^|&)$callback_key=([^&]+)/) {
                  my $cb = URI::Escape::uri_unescape($1);
                  if ($cb =~ /^[\w\.\[\]]+$/) {
                      my $body;
                      Plack::Util::foreach($res->[2], sub { $body .= $_[0] });
                      my $jsonp = "$cb($body)";
                      $res->[2] = [ $jsonp ];
                      $h->set('Content-Length', length $jsonp);
                      $h->set('Content-Type', 'text/javascript');
                  }
              }
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::JSONP - Wraps JSON response in JSONP if callback parameter is specified
  
  =head1 SYNOPSIS
  
      enable "JSONP", callback_key => 'jsonp';
  
  =head1 DESCRIPTION
  
  Plack::Middleware::JSONP wraps JSON response, which has Content-Type
  value either C<text/javascript> or C<application/json> as a JSONP
  response which is specified with the C<callback> query parameter. The
  name of the parameter can be set while enabling the middleware.
  
  This middleware only works with a non-streaming response, and doesn't
  touch the response otherwise.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_JSONP

$fatpacked{"Plack/Middleware/LighttpdScriptNameFix.pm"} = <<'PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX';
  package Plack::Middleware::LighttpdScriptNameFix;
  use strict;
  use parent qw/Plack::Middleware/;
  use Plack::Util::Accessor qw(script_name);
  
  sub prepare_app {
      my $self = shift;
  
      my $script_name = $self->script_name;
      $script_name = '' unless defined($script_name);
      $script_name =~ s!/$!!;
      $self->script_name($script_name);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /lighttpd/) {
          $env->{PATH_INFO}   = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{SCRIPT_NAME} = $self->script_name;
          $env->{PATH_INFO}  =~ s/^\Q$env->{SCRIPT_NAME}\E//;
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LighttpdScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that lighttpd sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "LighttpdScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "LighttpdScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by
  lighttpd when you mount your app under the root path ("/"). If you use
  lighttpd 1.4.23 or later you can instead enable C<fix-root-scriptname>
  flag inside C<fastcgi.server> instead of using this middleware.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item script_name
  
  Even with C<fix-root-scriptname>, lighttpd I<still> sets weird
  C<SCRIPT_NAME> and C<PATH_INFO> if you mount your application at C<"">
  or something that ends with C</>. Setting C<script_name> option tells
  the middleware how to reconstruct the new correct C<SCRIPT_NAME> and
  C<PATH_INFO>.
  
  If you mount the app under C</something/>, you should set:
  
    enable "LighttpdScriptNameFix", script_name => "/something";
  
  and when a request for C</something/a/b?param=1> comes, C<SCRIPT_NAME>
  becomes C</something> and C<PATH_INFO> becomes C</a/b>.
  
  C<script_name> option is set to empty by default, which means all the
  request path is set to C<PATH_INFO> and it behaves like your fastcgi
  application is mounted in the root path.
  
  =back
  
  =head1 AUTHORS
  
  Yury Zavarin
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::FCGI>
  L<http://github.com/miyagawa/Plack/issues#issue/68>
  L<https://redmine.lighttpd.net/issues/729>
  
  =cut
  
PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/Lint.pm"} = <<'PLACK_MIDDLEWARE_LINT';
  package Plack::Middleware::Lint;
  use strict;
  no warnings;
  use Carp ();
  use parent qw(Plack::Middleware);
  use Scalar::Util qw(blessed);
  use Plack::Util;
  
  sub wrap {
      my($self, $app) = @_;
  
      unless (ref $app eq 'CODE' or overload::Method($app, '&{}')) {
          die("PSGI app should be a code reference: ", (defined $app ? $app : "undef"));
      }
  
      $self->SUPER::wrap($app);
  }
  
  sub call {
      my $self = shift;
      my $env = shift;
  
      $self->validate_env($env);
      my $res = $self->app->($env);
      return $self->validate_res($res);
  }
  
  sub validate_env {
      my ($self, $env) = @_;
      unless ($env->{REQUEST_METHOD}) {
          die('Missing env param: REQUEST_METHOD');
      }
      unless ($env->{REQUEST_METHOD} =~ /^[A-Z]+$/) {
          die("Invalid env param: REQUEST_METHOD($env->{REQUEST_METHOD})");
      }
      unless (defined($env->{SCRIPT_NAME})) { # allows empty string
          die('Missing mandatory env param: SCRIPT_NAME');
      }
      if ($env->{SCRIPT_NAME} eq '/') {
          die('SCRIPT_NAME must not be /');
      }
      unless (defined($env->{PATH_INFO})) { # allows empty string
          die('Missing mandatory env param: PATH_INFO');
      }
      unless (defined($env->{SERVER_NAME})) {
          die('Missing mandatory env param: SERVER_NAME');
      }
      if ($env->{SERVER_NAME} eq '') {
          die('SERVER_NAME must not be empty string');
      }
      unless (defined($env->{SERVER_PORT})) {
          die('Missing mandatory env param: SERVER_PORT');
      }
      if ($env->{SERVER_PORT} eq '') {
          die('SERVER_PORT must not be empty string');
      }
      if (defined($env->{SERVER_PROTOCOL}) and $env->{SERVER_PROTOCOL} !~ m{^HTTP/1.\d$}) {
          die("Invalid SERVER_PROTOCOL: $env->{SEREVR_PROTOCOL}");
      }
      for my $param (qw/version url_scheme input errors multithread multiprocess/) {
          unless (exists $env->{"psgi.$param"}) {
              die("Missing psgi.$param");
          }
      }
      unless (ref($env->{'psgi.version'}) eq 'ARRAY') {
          die("psgi.version should be ArrayRef: $env->{'psgi.version'}");
      }
      unless (scalar(@{$env->{'psgi.version'}}) == 2) {
          die('psgi.version should contain 2 elements, not ', scalar(@{$env->{'psgi.version'}}));
      }
      unless ($env->{'psgi.url_scheme'} =~ /^https?$/) {
          die("psgi.url_scheme should be 'http' or 'https': ", $env->{'psgi.url_scheme'});
      }
      if ($env->{"psgi.version"}->[1] == 1) { # 1.1
          for my $param (qw(streaming nonblocking run_once)) {
              unless (exists $env->{"psgi.$param"}) {
                  die("Missing psgi.$param");
              }
          }
      }
      if ($env->{HTTP_CONTENT_TYPE}) {
          die('HTTP_CONTENT_TYPE should not exist');
      }
      if ($env->{HTTP_CONTENT_LENGTH}) {
          die('HTTP_CONTENT_LENGTH should not exist');
      }
  }
  
  sub is_possibly_fh {
      my $fh = shift;
  
      ref $fh eq 'GLOB' &&
      *{$fh}{IO} &&
      *{$fh}{IO}->can('getline');
  }
  
  sub validate_res {
      my ($self, $res, $streaming) = @_;
  
      unless (ref($res) eq 'ARRAY' or ref($res) eq 'CODE') {
          die("Response should be array ref or code ref: $res");
      }
  
      if (ref $res eq 'CODE') {
          return $self->response_cb($res, sub { $self->validate_res(@_, 1) });
      }
  
      unless (@$res == 3 || ($streaming && @$res == 2)) {
          die('Response needs to be 3 element array, or 2 element in streaming');
      }
  
      unless ($res->[0] =~ /^\d+$/ && $res->[0] >= 100) {
          die("Status code needs to be an integer greater than or equal to 100: $res->[0]");
      }
  
      unless (ref $res->[1] eq 'ARRAY') {
          die("Headers needs to be an array ref: $res->[1]");
      }
  
      my @copy = @{$res->[1]};
      unless (@copy % 2 == 0) {
          die('The number of response headers needs to be even, not odd(', scalar(@copy), ')');
      }
  
      while(my($key, $val) = splice(@copy, 0, 2)) {
          if (lc $key eq 'status') {
              die('Response headers MUST NOT contain a key named Status');
          }
          if ($key =~ /[:\r\n]|[-_]$/) {
              die("Response headers MUST NOT contain a key with : or newlines, or that end in - or _: $key");
          }
          unless ($key =~ /^[a-zA-Z][0-9a-zA-Z\-_]*$/) {
              die("Response headers MUST consist only of letters, digits, _ or - and MUST start with a letter: $key");
          }
          if ($val =~ /[\000-\037]/) {
              die("Response headers MUST NOT contain characters below octal \037: $val");
          }
          if (!defined $val) {
              die("Response headers MUST be a defined string");
          }
      }
  
      # @$res == 2 is only right in psgi.streaming, and it's already checked.
      unless (@$res == 2 ||
              ref $res->[2] eq 'ARRAY' ||
              Plack::Util::is_real_fh($res->[2]) ||
              is_possibly_fh($res->[2]) ||
              (blessed($res->[2]) && $res->[2]->can('getline'))) {
          die("Body should be an array ref or filehandle: $res->[2]");
      }
  
      if (ref $res->[2] eq 'ARRAY' && grep _is_really_utf8($_), @{$res->[2]}) {
          die("Body must be bytes and should not contain wide characters (UTF-8 strings)");
      }
  
      return $res;
  }
  
  # NOTE: Some modules like HTML:: or XML:: could possibly generate
  # ASCII only strings with utf8 flags on. They're actually safe to
  # print, so there's no need to give warnings about it.
  sub _is_really_utf8 {
      my $str = shift;
      utf8::is_utf8($str) && $str =~ /[^\x00-\x7f]/;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Lint - Validate request and response
  
  =head1 SYNOPSIS
  
    use Plack::Middleware::Lint;
  
    my $app = sub { ... }; # your app or middleware
    $app = Plack::Middleware::Lint->wrap($app);
  
    # Or from plackup
    plackup -e 'enable "Lint"' myapp.psgi
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Lint is a middleware component to validate request
  and response environment formats. You are strongly suggested to use
  this middleware when you develop a new framework adapter or a new PSGI
  web server that implements the PSGI interface.
  
  This middleware is enabled by default when you run plackup or other
  launcher tools with the default environment I<development> value.
  
  =head1 DEBUGGING
  
  Because of how this middleware works, it may not be easy to debug Lint
  errors when you encounter one, unless you're writing a PSGI web server
  or a framework.
  
  For example, when you're an application developer (user of some
  framework) and see errors like:
  
    Body should be an array ref or filehandle at lib/Plack/Middleware/Lint.pm line XXXX
  
  there's no clue about which line of I<your application> produces that
  error.
  
  We're aware of the issue, and have a plan to spit out more helpful
  errors to diagnose the issue. But until then, currently there are some
  workarounds to make this easier. For now, the easiest one would be to
  enable L<Plack::Middleware::REPL> outside of the Lint middleware,
  like:
  
    plackup -e 'enable "REPL"; enable "Lint"' app.psgi
  
  so that the Lint errors are caught by the REPL shell, where you can
  inspect all the variables in the response.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_LINT

$fatpacked{"Plack/Middleware/Log4perl.pm"} = <<'PLACK_MIDDLEWARE_LOG4PERL';
  package Plack::Middleware::Log4perl;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(category logger conf);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
  
      if ($self->conf) {
          require Log::Log4perl;
          Log::Log4perl::init($self->conf);
      }
  
      $self->logger( Log::Log4perl->get_logger($self->category || '') );
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          my $level = $args->{level};
          local $Log::Log4perl::caller_depth
              = $Log::Log4perl::caller_depth + 1;
          $self->logger->$level($args->{message});
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Log4perl - Uses Log::Log4perl to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
    Log::Log4perl::init('/path/to/log4perl.conf');
  
    builder {
        enable "Log4perl", category => "plack";
        $app;
    }
  
    # in log4perl.conf
    log4perl.logger.plack = INFO, Logfile
    log4perl.appender.Logfile = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = /path/to/logfile.log
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::SimpleLayout
  
    # Or let middleware to configure log4perl
    enable "Log4perl", category => "plack", conf => '/path/to/log.conf';
  
  =head1 DESCRIPTION
  
  Log4perl is a Plack::Middleware component that allows you to use
  L<Log::Log4perl> to configure logging object.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item category
  
  The log4perl category to send logs to. Defaults to C<''> which means
  it send to the root logger.
  
  =item conf
  
  The configuration file path (or a scalar ref containing the config
  string) for Log::Log4perl to automatically configure.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOG4PERL

$fatpacked{"Plack/Middleware/LogDispatch.pm"} = <<'PLACK_MIDDLEWARE_LOGDISPATCH';
  package Plack::Middleware::LogDispatch;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(logger);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
      unless ($self->logger) {
          Carp::croak "logger is not defined";
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          $args->{level} = 'critical' if $args->{level} eq 'fatal';
          $self->logger->log(%$args);
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LogDispatch - Uses Log::Dispatch to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Dispatch;
  
    my $logger = Log::Dispatch->new;
    $logger->add( Log::Dispatch::File->new(...) );
    $logger->add( Log::Dispatch::DesktopNotification->new(...) );
  
    builder {
        enable "LogDispatch", logger => $logger;
        $app;
    }
  
    # use with Log::Dispatch::Config
    use Log::Dispatch::Config;
    Log::Dispatch::Config->configure('/path/to/log.conf');
  
    builder {
        enable "LogDispatch", logger => Log::Dispatch::Config->instance;
        ...
    }
  
  =head1 DESCRIPTION
  
  LogDispatch is a Plack::Middleware component that allows you to use
  L<Log::Dispatch> to configure logging object.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item logger
  
  Log::Dispatch object to send logs to. Required.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOGDISPATCH

$fatpacked{"Plack/Middleware/NullLogger.pm"} = <<'PLACK_MIDDLEWARE_NULLLOGGER';
  package Plack::Middleware::NullLogger;
  use strict;
  use parent qw/Plack::Middleware/;
  
  sub call {
      my($self, $env) = @_;
      $env->{'psgix.logger'} = sub { };
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::NullLogger - Send logs to /dev/null
  
  =head1 SYNOPSIS
  
    enable "NullLogger";
  
  =head1 DESCRIPTION
  
  NullLogger is a middleware component that receives logs and does
  nothing but discarding them. Might be useful to shut up all the logs
  from frameworks in one shot.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_NULLLOGGER

$fatpacked{"Plack/Middleware/RearrangeHeaders.pm"} = <<'PLACK_MIDDLEWARE_REARRANGEHEADERS';
  package Plack::Middleware::RearrangeHeaders;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use HTTP::Headers;
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = HTTP::Headers->new(@{$res->[1]});
          my @new_headers;
          $h->scan(sub { push @new_headers, @_ });
  
          $res->[1] = \@new_headers;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::RearrangeHeaders - Reorder HTTP headers for buggy clients
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [
            'Last-Modified' => 'Wed, 23 Sep 2009 13:36:33 GMT',
            'Content-Type' => 'text/plain',
            'ETag' => 'foo bar',
        ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::RearrangeHeaders";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::RearrangeHeaders sorts HTTP headers based on "Good Practice" i.e.:
  
    # "Good Practice" order of HTTP message headers:
    #    - Response-Headers
    #    - Entity-Headers
  
  to work around buggy clients like very old MSIE or broken HTTP proxy
  servers. Most clients today don't (and shouldn't) care about HTTP
  header order but if you're too pedantic or have some environments
  where you need to deal with buggy clients like above, this might be
  useful.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =cut
PLACK_MIDDLEWARE_REARRANGEHEADERS

$fatpacked{"Plack/Middleware/Recursive.pm"} = <<'PLACK_MIDDLEWARE_RECURSIVE';
  package Plack::Middleware::Recursive;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Try::Tiny;
  use Scalar::Util qw(blessed);
  
  open my $null_io, "<", \"";
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'plack.recursive.include'} = $self->recurse_callback($env, 1);
  
      my $res = try {
          $self->app->($env);
      } catch {
          if (blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
              return $self->recurse_callback($env)->($_->path);
          } else {
              die $_; # rethrow
          }
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if (!$writer && blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
                  $res = $self->recurse_callback($env)->($_->path);
                  return ref $res eq 'CODE' ? $res->($respond) : $respond->($res);
              } else {
                  die $_;
              }
          };
      };
  }
  
  sub recurse_callback {
      my($self, $env, $include) = @_;
  
      my $old_path_info = $env->{PATH_INFO};
  
      return sub {
          my $new_path_info = shift;
          my($path, $query) = split /\?/, $new_path_info, 2;
  
          Scalar::Util::weaken($env);
  
          $env->{PATH_INFO}      = $path;
          $env->{QUERY_STRING}   = $query;
          $env->{REQUEST_METHOD} = 'GET';
          $env->{CONTENT_LENGTH} = 0;
          $env->{CONTENT_TYPE}   = '';
          $env->{'psgi.input'}   = $null_io;
          push @{$env->{'plack.recursive.old_path_info'}}, $old_path_info;
  
          $include ? $self->app->($env) : $self->call($env);
      };
  }
  
  package Plack::Recursive::ForwardRequest;
  use overload q("") => \&as_string, fallback => 1;
  
  sub new {
      my($class, $path) = @_;
      bless { path => $path }, $class;
  }
  
  sub path { $_[0]->{path} }
  
  sub throw {
      my($class, @args) = @_;
      die $class->new(@args);
  }
  
  sub as_string {
      my $self = shift;
      return "Forwarding to $self->{path}: Your application should be wrapped with Plack::Middleware::Recursive.";
  }
  
  package Plack::Middleware::Recursive;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Recursive - Allows PSGI apps to include or forward requests recursively
  
  =head1 SYNOPSIS
  
    # with Builder
    enable "Recursive";
  
    # in apps
    my $res = $env->{'plack.recursive.include'}->("/new_path");
  
    # Or, use exceptions
    my $app = sub {
        # ...
        Plack::Recursive::ForwardRequest->throw("/new_path");
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Recursive allows PSGI applications to recursively
  include or forward requests to other paths. Applications can make use
  of callbacks stored in C<< $env->{'plack.recursive.include'} >> to
  I<include> another path to get the response (whether it's an array ref
  or a code ref depending on your application), or throw an exception
  Plack::Recursive::ForwardRequest anywhere in the code to I<forward>
  the current request (i.e. abort the current and redo the request).
  
  =head1 EXCEPTIONS
  
  This middleware passes through unknown exceptions to the outside
  middleware stack, so if you use this middleware with other exception
  handlers such as L<Plack::Middleware::StackTrace> or
  L<Plack::Middleware::HTTPExceptions>, be sure to wrap this so
  L<Plack::Middleware::Recursive> gets as inner as possible.
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Honma
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Middleware::HTTPExceptions>
  
  The idea, code and interface are stolen from Rack::Recursive and paste.recursive.
  
  =cut
  
  
PLACK_MIDDLEWARE_RECURSIVE

$fatpacked{"Plack/Middleware/Refresh.pm"} = <<'PLACK_MIDDLEWARE_REFRESH';
  package Plack::Middleware::Refresh;
  use strict;
  use parent qw(Plack::Middleware);
  use Module::Refresh;
  use Plack::Util::Accessor qw(last cooldown);
  
  sub prepare_app {
      my $self = shift;
      $self->cooldown(10) unless defined $self->cooldown;
  
      Module::Refresh->new;
      $self->last(time - $self->cooldown);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if (time > $self->last + $self->cooldown) {
          Module::Refresh->refresh;
          $self->last(time);
      }
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Refresh - Refresh all modules in %INC
  
  =head1 SYNOPSIS
  
    enable "Refresh", cooldown => 3;
    $app;
  
  =head1 DESCRIPTION
  
  This is I<yet another> approach to refresh modules in C<%INC> during
  the development cycle, without the need to have a forking process to
  watch for filesystem updates. This middleware, in a request time,
  compares the last refresh time and the current time and if the
  difference is bigger than I<cooldown> seconds which defaults to 10,
  call L<Module::Refresh> to reload all Perl modules in C<%INC> if the
  files have been modified.
  
  Note that this only reloads modules and not other files such as
  templates.
  
  This middleware is quite similar to what Rack::Reoader does. If you
  have issues with this reloading technique, for instance when you have
  in-file templates that needs to be recompiled, or Moose classes that
  has C<make_immutable>, take a look at L<plackup>'s default -r option
  or L<Plack::Loader::Shotgun> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Module::Refresh> Rack::Reloader
  
  =cut
  
PLACK_MIDDLEWARE_REFRESH

$fatpacked{"Plack/Middleware/Runtime.pm"} = <<'PLACK_MIDDLEWARE_RUNTIME';
  package Plack::Middleware::Runtime;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use Plack::Util::Accessor qw(header_name);
  use Time::HiRes;
  
  sub call {
      my($self, $env) = @_;
  
      my $start = [ Time::HiRes::gettimeofday ];
      my $res = $self->app->($env);
  
      $self->response_cb($res, sub {
          my $res = shift;
          my $req_time = sprintf '%.6f', Time::HiRes::tv_interval($start);
          Plack::Util::header_set($res->[1], 'X-Runtime', $req_time);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Runtime - Sets an X-Runtime response header
  
  =head1 SYNOPSIS
  
    enable "Runtime";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Runtime is a Plack middleware component that sets
  application's response time, in seconds to I<X-Runtime> HTTP response
  header.
  
  =head1 OPTIONS
  
  =over 4
  
  =item header_name
  
  Name of the header. Defaults to I<X-Runtime>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Time::HiRes> Rack::Runtime
  
  =cut
PLACK_MIDDLEWARE_RUNTIME

$fatpacked{"Plack/Middleware/SimpleContentFilter.pm"} = <<'PLACK_MIDDLEWARE_SIMPLECONTENTFILTER';
  package Plack::Middleware::SimpleContentFilter;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Plack::Util::Accessor qw( filter );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($h->get('Content-Type') =~ m!^text/!) {
              return sub {
                  my $chunk = shift;
                  return unless defined $chunk;
                  local $_ = $chunk;
                  $self->filter->();
                  return $_;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleContentFilter - Filters response content
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::SimpleContentFilter",
            filter => sub { s/Foo/Bar/g; };
        $app;
    };
  
  =head1 DESCRIPTION
  
  B<This middleware should be considered as a demo. Running this against
  your application might break your HTML unless you code the filter
  callback carefully>.
  
  Plack::Middleware::SimpleContentFilter is a simple content text filter
  to run against response body. This middleware is only enabled against
  responses with C<text/*> Content-Type.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLECONTENTFILTER

$fatpacked{"Plack/Middleware/SimpleLogger.pm"} = <<'PLACK_MIDDLEWARE_SIMPLELOGGER';
  package Plack::Middleware::SimpleLogger;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(level);
  use POSIX ();
  use Scalar::Util ();
  
  # Should this be in Plack::Util?
  my $i = 0;
  my %level_numbers = map { $_ => $i++ } qw(debug info warn error fatal);
  
  sub call {
      my($self, $env) = @_;
  
      my $min = $level_numbers{ $self->level || "debug" };
  
      my $env_ref = $env;
      Scalar::Util::weaken($env_ref);
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
  
          if ($level_numbers{$args->{level}} >= $min) {
              $env_ref->{'psgi.errors'}->print($self->format_message($args->{level}, $args->{message}));
          }
      };
  
      $self->app->($env);
  }
  
  sub format_time {
      my $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
      POSIX::setlocale(&POSIX::LC_ALL, 'en');
      my $out = POSIX::strftime(@_);
      POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
      return $out;
  }
  
  sub format_message {
      my($self, $level, $message) = @_;
  
      my $time = format_time("%Y-%m-%dT%H:%M:%S", localtime);
      sprintf "%s [%s #%d] %s: %s\n", uc substr($level, 0, 1), $time, $$, uc $level, $message;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleLogger - Simple logger that prints to psgi.errors
  
  =head1 SYNOPSIS
  
    enable "SimpleLogger", level => "warn";
  
  =head1 DESCRIPTION
  
  SimpleLogger is a middleware component that formats the log message
  with information such as the time and PID and prints them to
  I<psgi.errors> stream, which is mostly STDERR or server log output.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLELOGGER

$fatpacked{"Plack/Middleware/StackTrace.pm"} = <<'PLACK_MIDDLEWARE_STACKTRACE';
  package Plack::Middleware::StackTrace;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Devel::StackTrace;
  use Devel::StackTrace::AsHTML;
  use Try::Tiny;
  use Plack::Util::Accessor qw( force no_print_errors );
  
  our $StackTraceClass = "Devel::StackTrace";
  
  # Optional since it needs PadWalker
  if (try { require Devel::StackTrace::WithLexicals; Devel::StackTrace::WithLexicals->VERSION(0.08); 1 }) {
      $StackTraceClass = "Devel::StackTrace::WithLexicals";
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $trace;
      local $SIG{__DIE__} = sub {
          $trace = $StackTraceClass->new(
              indent => 1, message => munge_error($_[0], [ caller ]),
              ignore_package => __PACKAGE__,
          );
          die @_;
      };
  
      my $caught;
      my $res = try {
          $self->app->($env);
      } catch {
          $caught = $_;
          [ 500, [ "Content-Type", "text/plain; charset=utf-8" ], [ no_trace_error(utf8_safe($caught)) ] ];
      };
  
      if ($trace && ($caught || ($self->force && ref $res eq 'ARRAY' && $res->[0] == 500)) ) {
          my $text = $trace->as_string;
          my $html = $trace->as_html;
          $env->{'plack.stacktrace.text'} = $text;
          $env->{'plack.stacktrace.html'} = $html;
          $env->{'psgi.errors'}->print($text) unless $self->no_print_errors;
          if (($env->{HTTP_ACCEPT} || '*/*') =~ /html/) {
              $res = [500, ['Content-Type' => 'text/html; charset=utf-8'], [ utf8_safe($html) ]];
          } else {
              $res = [500, ['Content-Type' => 'text/plain; charset=utf-8'], [ utf8_safe($text) ]];
          }
      }
  
      # break $trace here since $SIG{__DIE__} holds the ref to it, and
      # $trace has refs to Standalone.pm's args ($conn etc.) and
      # prevents garbage collection to be happening.
      undef $trace;
  
      return $res;
  }
  
  sub no_trace_error {
      my $msg = shift;
      chomp($msg);
  
      return <<EOF;
  The application raised the following error:
  
    $msg
  
  and the StackTrace middleware couldn't catch its stack trace, possibly because your application overrides \$SIG{__DIE__} by itself, preventing the middleware from working correctly. Remove the offending code or module that does it: known examples are CGI::Carp and Carp::Always.
  EOF
  }
  
  sub munge_error {
      my($err, $caller) = @_;
      return $err if ref $err;
  
      # Ugly hack to remove " at ... line ..." automatically appended by perl
      # If there's a proper way to do this, please let me know.
      $err =~ s/ at \Q$caller->[1]\E line $caller->[2]\.\n$//;
  
      return $err;
  }
  
  sub utf8_safe {
      my $str = shift;
  
      # NOTE: I know messing with utf8:: in the code is WRONG, but
      # because we're running someone else's code that we can't
      # guarnatee which encoding an exception is encoded, there's no
      # better way than doing this. The latest Devel::StackTrace::AsHTML
      # (0.08 or later) encodes high-bit chars as HTML entities, so this
      # path won't be executed.
      if (utf8::is_utf8($str)) {
          utf8::encode($str);
      }
  
      $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::StackTrace - Displays stack trace when your app dies
  
  =head1 SYNOPSIS
  
    enable "StackTrace";
  
  =head1 DESCRIPTION
  
  This middleware catches exceptions (run-time errors) happening in your
  application and displays nice stack trace screen. The stack trace is
  also stored in the environment as a plaintext and HTML under the key
  C<plack.stacktrace.text> and C<plack.stacktrace.html> respectively, so
  that middleware futher up the stack can reference it.
  
  This middleware is enabled by default when you run L<plackup> in the
  default I<development> mode.
  
  You're recommended to use this middleware during the development and
  use L<Plack::Middleware::HTTPExceptions> in the deployment mode as a
  replacement, so that all the exceptions thrown from your application
  still get caught and rendered as a 500 error response, rather than
  crashing the web server.
  
  Catching errors in streaming response is not supported.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item force
  
    enable "StackTrace", force => 1;
  
  Force display the stack trace when an error occurs within your
  application and the response code from your application is
  500. Defaults to off.
  
  The use case of this option is that when your framework catches all
  the exceptions in the main handler and returns all failures in your
  code as a normal 500 PSGI error response. In such cases, this
  middleware would never have a chance to display errors because it
  can't tell if it's an application error or just random C<eval> in your
  code. This option enforces the middleware to display stack trace even
  if it's not the direct error thrown by the application.
  
  =item no_print_errors
  
    enable "StackTrace", no_print_errors => 1;
  
  Skips printing the text stacktrace to console
  (C<psgi.errors>). Defaults to 0, which means the text version of the
  stack trace error is printed to the errors handle, which usually is a
  standard error.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace::AsHTML> L<Plack::Middleware> L<Plack::Middleware::HTTPExceptions>
  
  =cut
  
PLACK_MIDDLEWARE_STACKTRACE

$fatpacked{"Plack/Middleware/Static.pm"} = <<'PLACK_MIDDLEWARE_STATIC';
  package Plack::Middleware::Static;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Plack::App::File;
  
  use Plack::Util::Accessor qw( path root encoding pass_through );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->_handle_static($env);
      if ($res && not ($self->pass_through and $res->[0] == 404)) {
          return $res;
      }
  
      return $self->app->($env);
  }
  
  sub _handle_static {
      my($self, $env) = @_;
  
      my $path_match = $self->path or return;
      my $path = $env->{PATH_INFO};
  
      for ($path) {
          my $matched = 'CODE' eq ref $path_match ? $path_match->($_) : $_ =~ $path_match;
          return unless $matched;
      }
  
      $self->{file} ||= Plack::App::File->new({ root => $self->root || '.', encoding => $self->encoding });
      local $env->{PATH_INFO} = $path; # rewrite PATH
      return $self->{file}->call($env);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Static - serve static files with Plack
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::Static",
            path => qr{^/(images|js|css)/}, root => './htdocs/';
        $app;
    };
  
  =head1 DESCRIPTION
  
  Enable this middleware to allow your Plack-based application to serve
  static files.
  
  If the given request matches with the pattern defined in C<path>, this
  middleware will try to locate the file in C<root>. If the file exists
  it will be served but otherwise C<404> response will be returned. See
  C<pass_through> option below to change this behavior.
  
  If the requested document is not within the C<root> (i.e. directory
  traversal) or the file is there but not readable, a 403 Forbidden
  response will be returned.
  
  The content type returned will be determined from the file extension
  based on L<Plack::MIME>.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item path, root
  
    enable "Plack::Middleware::Static",
        path => qr{^/static/}, root => 'htdocs/';
  
  C<path> specifies the URL pattern (regular expression) or a callback
  to match with requests to serve static files for. C<root> specifies
  the root directory to serve those static files from. The default value
  of C<root> is the current directory.
  
  This examples configuration serves C</static/foo.jpg> from
  C<htdocs/static/foo.jpg>. Note that the matched C</static/> portion is
  still appears in the local mapped path. If you don't like it, use a
  callback instead to munge C<$_>:
  
    enable "Plack::Middleware::Static",
        path => sub { s!^/static/!! }, root => 'static-files/';
  
  This configuration would serve C</static/foo.png> from
  C<static-files/foo.png> (not C<static-files/static/foo.png>). The
  callback specified in C<path> option matches against C<$_> and then
  updates the value since it does s///, and returns the number of
  matches, so it will pass through when C</static/> doesn't match.
  
  If you want to map multiple static directories from different root,
  simply add "this", middleware multiple times with different
  configuration options.
  
  =item pass_through
  
  By turning on this option, this middleware will pass the request
  back to the application for further processing, if the incoming
  request path matches with the C<path> but the requested file is not
  found on the file system.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno, Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::Builder>
  
  =cut
  
  
PLACK_MIDDLEWARE_STATIC

$fatpacked{"Plack/Middleware/Writer.pm"} = <<'PLACK_MIDDLEWARE_WRITER';
  package Plack::Middleware::Writer;
  use strict;
  use parent qw(Plack::Middleware::BufferedStreaming);
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Writer - DEPRECATED
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::BufferedStreaming>
  
  =cut
PLACK_MIDDLEWARE_WRITER

$fatpacked{"Plack/Middleware/XFramework.pm"} = <<'PLACK_MIDDLEWARE_XFRAMEWORK';
  package Plack::Middleware::XFramework;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  
  use Plack::Util;
  use Plack::Util::Accessor qw( framework );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->( @_ );
      $self->response_cb($res, sub {
          my $res = shift;
          if ($self->framework) {
              Plack::Util::header_set $res->[1], 'X-Framework' => $self->framework;
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XFramework - Sample middleware to add X-Framework
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XFramework", framework => "Catalyst";
  
  =head1 DESCRIPTION
  
  This middleware adds C<X-Framework> header to the HTTP response.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item framework
  
  Sets the string value of C<X-Framework> header. If not set, the header is not set to the response.
  
  =back
  
  =head1 SEE ALSO
  
  L<Plack::Middleware>
  
  =cut
  
PLACK_MIDDLEWARE_XFRAMEWORK

$fatpacked{"Plack/Middleware/XSendfile.pm"} = <<'PLACK_MIDDLEWARE_XSENDFILE';
  package Plack::Middleware::XSendfile;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  use Scalar::Util;
  use Plack::Util::Accessor qw( variation );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my($status, $headers, $body) = @$res;
          return unless defined $body;
  
          if (Scalar::Util::blessed($body) && $body->can('path')) {
              my $type = $self->_variation($env) || '';
              my $h = Plack::Util::headers($headers);
              if ($type && !$h->exists($type)) {
                  if ($type eq 'X-Accel-Redirect') {
                      my $path = $body->path;
                      my $url = $self->map_accel_path($env, $path);
                      $h->set($type => $url) if $url;
                      $body = [];
                  } elsif ($type eq 'X-Sendfile' or $type eq 'X-Lighttpd-Send-File') {
                      my $path = $body->path;
                      $h->set($type => $path) if defined $path;
                      $body = [];
                  } else {
                      $env->{'psgi.errors'}->print("Unknown x-sendfile variation: $type");
                  }
              }
          }
  
          @$res = ( $status, $headers, $body );
      });
  }
  
  sub map_accel_path {
      my($self, $env, $path) = @_;
  
      if (my $mapping = $env->{HTTP_X_ACCEL_MAPPING}) {
          my($internal, $external) = split /=/, $mapping, 2;
          $path =~ s!^\Q$internal\E!$external!i;
      }
  
      return $path;
  }
  
  sub _variation {
      my($self, $env) = @_;
      $self->variation || $env->{'plack.xsendfile.type'} || $env->{HTTP_X_SENDFILE_TYPE};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XSendfile - Sets X-Sendfile (or a like) header for frontends
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XSendfile";
  
  =head1 DESCRIPTION
  
  You should use L<IO::File::WithPath> or L<Plack::Util>'s
  C<set_io_path> to add C<path> method to an IO object in the body.
  
  See L<http://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/sendfile.rb>
  for the frontend configuration.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_XSENDFILE

$fatpacked{"Plack/Request.pm"} = <<'PLACK_REQUEST';
  package Plack::Request;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  use HTTP::Headers;
  use Carp ();
  use Hash::MultiValue;
  use HTTP::Body;
  
  use Plack::Request::Upload;
  use Plack::TempBuffer;
  use URI;
  use URI::Escape ();
  
  sub _deprecated {
      my $alt = shift;
      my $method = (caller(1))[3];
      Carp::carp("$method is deprecated. Use '$alt' instead.");
  }
  
  sub new {
      my($class, $env) = @_;
      Carp::croak(q{$env is required})
          unless defined $env && ref($env) eq 'HASH';
  
      bless { env => $env }, $class;
  }
  
  sub env { $_[0]->{env} }
  
  sub address     { $_[0]->env->{REMOTE_ADDR} }
  sub remote_host { $_[0]->env->{REMOTE_HOST} }
  sub protocol    { $_[0]->env->{SERVER_PROTOCOL} }
  sub method      { $_[0]->env->{REQUEST_METHOD} }
  sub port        { $_[0]->env->{SERVER_PORT} }
  sub user        { $_[0]->env->{REMOTE_USER} }
  sub request_uri { $_[0]->env->{REQUEST_URI} }
  sub path_info   { $_[0]->env->{PATH_INFO} }
  sub path        { $_[0]->env->{PATH_INFO} || '/' }
  sub script_name { $_[0]->env->{SCRIPT_NAME} }
  sub scheme      { $_[0]->env->{'psgi.url_scheme'} }
  sub secure      { $_[0]->scheme eq 'https' }
  sub body        { $_[0]->env->{'psgi.input'} }
  sub input       { $_[0]->env->{'psgi.input'} }
  
  sub content_length   { $_[0]->env->{CONTENT_LENGTH} }
  sub content_type     { $_[0]->env->{CONTENT_TYPE} }
  
  sub session         { $_[0]->env->{'psgix.session'} }
  sub session_options { $_[0]->env->{'psgix.session.options'} }
  sub logger          { $_[0]->env->{'psgix.logger'} }
  
  sub cookies {
      my $self = shift;
  
      return {} unless $self->env->{HTTP_COOKIE};
  
      # HTTP_COOKIE hasn't changed: reuse the parsed cookie
      if (   $self->env->{'plack.cookie.parsed'}
          && $self->env->{'plack.cookie.string'} eq $self->env->{HTTP_COOKIE}) {
          return $self->env->{'plack.cookie.parsed'};
      }
  
      $self->env->{'plack.cookie.string'} = $self->env->{HTTP_COOKIE};
  
      my %results;
      my @pairs = grep /=/, split "[;,] ?", $self->env->{'plack.cookie.string'};
      for my $pair ( @pairs ) {
          # trim leading trailing whitespace
          $pair =~ s/^\s+//; $pair =~ s/\s+$//;
  
          my ($key, $value) = map URI::Escape::uri_unescape($_), split( "=", $pair, 2 );
  
          # Take the first one like CGI.pm or rack do
          $results{$key} = $value unless exists $results{$key};
      }
  
      $self->env->{'plack.cookie.parsed'} = \%results;
  }
  
  sub query_parameters {
      my $self = shift;
      $self->env->{'plack.request.query'} ||= Hash::MultiValue->new($self->uri->query_form);
  }
  
  sub content {
      my $self = shift;
  
      unless ($self->env->{'psgix.input.buffered'}) {
          $self->_parse_request_body;
      }
  
      my $fh = $self->input                 or return '';
      my $cl = $self->env->{CONTENT_LENGTH} or return'';
      $fh->read(my($content), $cl, 0);
      $fh->seek(0, 0);
  
      return $content;
  }
  
  sub raw_body { $_[0]->content }
  
  # XXX you can mutate headers with ->headers but it's not written through to the env
  
  sub headers {
      my $self = shift;
      if (!defined $self->{headers}) {
          my $env = $self->env;
          $self->{headers} = HTTP::Headers->new(
              map {
                  (my $field = $_) =~ s/^HTTPS?_//;
                  ( $field => $env->{$_} );
              }
                  grep { /^(?:HTTP|CONTENT|COOKIE)/i } keys %$env
              );
      }
      $self->{headers};
  }
  
  sub content_encoding { shift->headers->content_encoding(@_) }
  sub header           { shift->headers->header(@_) }
  sub referer          { shift->headers->referer(@_) }
  sub user_agent       { shift->headers->user_agent(@_) }
  
  sub body_parameters {
      my $self = shift;
  
      unless ($self->env->{'plack.request.body'}) {
          $self->_parse_request_body;
      }
  
      return $self->env->{'plack.request.body'};
  }
  
  # contains body + query
  sub parameters {
      my $self = shift;
  
      $self->env->{'plack.request.merged'} ||= do {
          my $query = $self->query_parameters;
          my $body  = $self->body_parameters;
          Hash::MultiValue->new($query->flatten, $body->flatten);
      };
  }
  
  sub uploads {
      my $self = shift;
  
      if ($self->env->{'plack.request.upload'}) {
          return $self->env->{'plack.request.upload'};
      }
  
      $self->_parse_request_body;
      return $self->env->{'plack.request.upload'};
  }
  
  sub hostname     { _deprecated 'remote_host';      $_[0]->remote_host || $_[0]->address }
  sub url_scheme   { _deprecated 'scheme';           $_[0]->scheme }
  sub params       { _deprecated 'parameters';       shift->parameters(@_) }
  sub query_params { _deprecated 'query_parameters'; shift->query_parameters(@_) }
  sub body_params  { _deprecated 'body_parameters';  shift->body_parameters(@_) }
  
  sub cookie {
      my $self = shift;
      _deprecated 'cookies';
  
      return keys %{ $self->cookies } if @_ == 0;
  
      my $name = shift;
      return $self->cookies->{$name};
  }
  
  sub param {
      my $self = shift;
  
      return keys %{ $self->parameters } if @_ == 0;
  
      my $key = shift;
      return $self->parameters->{$key} unless wantarray;
      return $self->parameters->get_all($key);
  }
  
  sub upload {
      my $self = shift;
  
      return keys %{ $self->uploads } if @_ == 0;
  
      my $key = shift;
      return $self->uploads->{$key} unless wantarray;
      return $self->uploads->get_all($key);
  }
  
  sub raw_uri {
      my $self = shift;
      _deprecated 'base';
  
      my $base = $self->base;
      $base->path_query($self->env->{REQUEST_URI});
  
      $base;
  }
  
  sub uri {
      my $self = shift;
  
      my $base = $self->_uri_base;
  
      # We have to escape back PATH_INFO in case they include stuff like
      # ? or # so that the URI parser won't be tricked. However we should
      # preserve '/' since encoding them into %2f doesn't make sense.
      # This means when a request like /foo%2fbar comes in, we recognize
      # it as /foo/bar which is not ideal, but that's how the PSGI PATH_INFO
      # spec goes and we can't do anything about it. See PSGI::FAQ for details.
      # http://github.com/miyagawa/Plack/issues#issue/118
      my $path_escape_class = '^A-Za-z0-9\-\._~/';
  
      my $path = URI::Escape::uri_escape($self->env->{PATH_INFO} || '', $path_escape_class);
      $path .= '?' . $self->env->{QUERY_STRING}
          if defined $self->env->{QUERY_STRING} && $self->env->{QUERY_STRING} ne '';
  
      $base =~ s!/$!! if $path =~ m!^/!;
  
      return URI->new($base . $path)->canonical;
  }
  
  sub base {
      my $self = shift;
      URI->new($self->_uri_base)->canonical;
  }
  
  sub _uri_base {
      my $self = shift;
  
      my $env = $self->env;
  
      my $uri = ($env->{'psgi.url_scheme'} || "http") .
          "://" .
          ($env->{HTTP_HOST} || (($env->{SERVER_NAME} || "") . ":" . ($env->{SERVER_PORT} || 80))) .
          ($env->{SCRIPT_NAME} || '/');
  
      return $uri;
  }
  
  sub new_response {
      my $self = shift;
      require Plack::Response;
      Plack::Response->new(@_);
  }
  
  sub _parse_request_body {
      my $self = shift;
  
      my $ct = $self->env->{CONTENT_TYPE};
      my $cl = $self->env->{CONTENT_LENGTH};
      if (!$ct && !$cl) {
          # No Content-Type nor Content-Length -> GET/HEAD
          $self->env->{'plack.request.body'}   = Hash::MultiValue->new;
          $self->env->{'plack.request.upload'} = Hash::MultiValue->new;
          return;
      }
  
      my $body = HTTP::Body->new($ct, $cl);
  
      # HTTP::Body will create temporary files in case there was an
      # upload.  Those temporary files can be cleaned up by telling
      # HTTP::Body to do so. It will run the cleanup when the request
      # env is destroyed. That the object will not go out of scope by
      # the end of this sub we will store a reference here.
      $self->env->{'plack.request.http.body'} = $body;
      $body->cleanup(1);
  
      my $input = $self->input;
  
      my $buffer;
      if ($self->env->{'psgix.input.buffered'}) {
          # Just in case if input is read by middleware/apps beforehand
          $input->seek(0, 0);
      } else {
          $buffer = Plack::TempBuffer->new($cl);
      }
  
      my $spin = 0;
      while ($cl) {
          $input->read(my $chunk, $cl < 8192 ? $cl : 8192);
          my $read = length $chunk;
          $cl -= $read;
          $body->add($chunk);
          $buffer->print($chunk) if $buffer;
  
          if ($read == 0 && $spin++ > 2000) {
              Carp::croak "Bad Content-Length: maybe client disconnect? ($cl bytes remaining)";
          }
      }
  
      if ($buffer) {
          $self->env->{'psgix.input.buffered'} = 1;
          $self->env->{'psgi.input'} = $buffer->rewind;
      } else {
          $input->seek(0, 0);
      }
  
      $self->env->{'plack.request.body'}   = Hash::MultiValue->from_mixed($body->param);
  
      my @uploads = Hash::MultiValue->from_mixed($body->upload)->flatten;
      my @obj;
      while (my($k, $v) = splice @uploads, 0, 2) {
          push @obj, $k, $self->_make_upload($v);
      }
  
      $self->env->{'plack.request.upload'} = Hash::MultiValue->new(@obj);
  
      1;
  }
  
  sub _make_upload {
      my($self, $upload) = @_;
      my %copy = %$upload;
      $copy{headers} = HTTP::Headers->new(%{$upload->{headers}});
      Plack::Request::Upload->new(%copy);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request - Portable HTTP request object from PSGI env hash
  
  =head1 SYNOPSIS
  
    use Plack::Request;
  
    my $app_or_middleware = sub {
        my $env = shift; # PSGI env
  
        my $req = Plack::Request->new($env);
  
        my $path_info = $req->path_info;
        my $query     = $req->param('query');
  
        my $res = $req->new_response(200); # new Plack::Response
        $res->finalize;
    };
  
  =head1 DESCRIPTION
  
  L<Plack::Request> provides a consistent API for request objects across
  web server environments.
  
  =head1 CAVEAT
  
  Note that this module is intended to be used by Plack middleware
  developers and web application framework developers rather than
  application developers (end users).
  
  Writing your web application directly using Plack::Request is
  certainly possible but not recommended: it's like doing so with
  mod_perl's Apache::Request: yet too low level.
  
  If you're writing a web application, not a framework, then you're
  encouraged to use one of the web application frameworks that support PSGI (L<http://plackperl.org/#frameworks>),
  or see modules like L<HTTP::Engine> to provide higher level
  Request and Response API on top of PSGI.
  
  =head1 METHODS
  
  Some of the methods defined in the earlier versions are deprecated in
  version 0.99. Take a look at L</"INCOMPATIBILITIES">.
  
  Unless otherwise noted, all methods and attributes are B<read-only>,
  and passing values to the method like an accessor doesn't work like
  you expect it to.
  
  =head2 new
  
      Plack::Request->new( $env );
  
  Creates a new request object.
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item env
  
  Returns the shared PSGI environment hash reference. This is a
  reference, so writing to this environment passes through during the
  whole PSGI request/response cycle.
  
  =item address
  
  Returns the IP address of the client (C<REMOTE_ADDR>).
  
  =item remote_host
  
  Returns the remote host (C<REMOTE_HOST>) of the client. It may be
  empty, in which case you have to get the IP address using C<address>
  method and resolve on your own.
  
  =item method
  
  Contains the request method (C<GET>, C<POST>, C<HEAD>, etc).
  
  =item protocol
  
  Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.
  
  =item request_uri
  
  Returns the raw, undecoded request URI path. You probably do B<NOT>
  want to use this to dispatch requests.
  
  =item path_info
  
  Returns B<PATH_INFO> in the environment. Use this to get the local
  path for the requests.
  
  =item path
  
  Similar to C<path_info> but returns C</> in case it is empty. In other
  words, it returns the virtual path of the request URI after C<<
  $req->base >>. See L</"DISPATCHING"> for details.
  
  =item script_name
  
  Returns B<SCRIPT_NAME> in the environment. This is the absolute path
  where your application is hosted.
  
  =item scheme
  
  Returns the scheme (C<http> or C<https>) of the request.
  
  =item secure
  
  Returns true or false, indicating whether the connection is secure (https).
  
  =item body, input
  
  Returns C<psgi.input> handle.
  
  =item session
  
  Returns (optional) C<psgix.session> hash. When it exists, you can
  retrieve and store per-session data from and to this hash.
  
  =item session_options
  
  Returns (optional) C<psgix.session.options> hash.
  
  =item logger
  
  Returns (optional) C<psgix.logger> code reference. When it exists,
  your application is supposed to send the log message to this logger,
  using:
  
    $req->logger->({ level => 'debug', message => "This is a debug message" });
  
  =item cookies
  
  Returns a reference to a hash containing the cookies. Values are
  strings that are sent by clients and are URI decoded.
  
  =item query_parameters
  
  Returns a reference to a hash containing query string (GET)
  parameters. This hash reference is L<Hash::MultiValue> object.
  
  =item body_parameters
  
  Returns a reference to a hash containing posted parameters in the
  request body (POST). As with C<query_parameters>, the hash
  reference is a L<Hash::MultiValue> object.
  
  =item parameters
  
  Returns a L<Hash::MultiValue> hash reference containing (merged) GET
  and POST parameters.
  
  =item content, raw_body
  
  Returns the request content in an undecoded byte string for POST requests.
  
  =item uri
  
  Returns an URI object for the current request. The URI is constructed
  using various environment values such as C<SCRIPT_NAME>, C<PATH_INFO>,
  C<QUERY_STRING>, C<HTTP_HOST>, C<SERVER_NAME> and C<SERVER_PORT>.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item base
  
  Returns an URI object for the base path of current request. This is
  like C<uri> but only contains up to C<SCRIPT_NAME> where your
  application is hosted at.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item user
  
  Returns C<REMOTE_USER> if it's set.
  
  =item headers
  
  Returns an L<HTTP::Headers> object containing the headers for the current request.
  
  =item uploads
  
  Returns a reference to a hash containing uploads. The hash reference
  is a L<Hash::MultiValue> object and values are L<Plack::Request::Upload>
  objects.
  
  =item content_encoding
  
  Shortcut to $req->headers->content_encoding.
  
  =item content_length
  
  Shortcut to $req->headers->content_length.
  
  =item content_type
  
  Shortcut to $req->headers->content_type.
  
  =item header
  
  Shortcut to $req->headers->header.
  
  =item referer
  
  Shortcut to $req->headers->referer.
  
  =item user_agent
  
  Shortcut to $req->headers->user_agent.
  
  =item param
  
  Returns GET and POST parameters with a CGI.pm-compatible param
  method. This is an alternative method for accessing parameters in
  $req->parameters. Unlike CGI.pm, it does I<not> allow
  setting or modifying query parameters.
  
      $value  = $req->param( 'foo' );
      @values = $req->param( 'foo' );
      @params = $req->param;
  
  =item upload
  
  A convenient method to access $req->uploads.
  
      $upload  = $req->upload('field');
      @uploads = $req->upload('field');
      @fields  = $req->upload;
  
      for my $upload ( $req->upload('field') ) {
          print $upload->filename;
      }
  
  =item new_response
  
    my $res = $req->new_response;
  
  Creates a new L<Plack::Response> object. Handy to remove dependency on
  L<Plack::Response> in your code for easy subclassing and duck typing
  in web application frameworks, as well as overriding Response
  generation in middlewares.
  
  =back
  
  =head2 Hash::MultiValue parameters
  
  Parameters that can take one or multiple values (i.e. C<parameters>,
  C<query_parameters>, C<body_parameters> and C<uploads>) store the
  hash reference as a L<Hash::MultiValue> object. This means you can use
  the hash reference as a plain hash where values are B<always> scalars
  (B<NOT> array references), so you don't need to code ugly and unsafe
  C<< ref ... eq 'ARRAY' >> anymore.
  
  And if you explicitly want to get multiple values of the same key, you
  can call the C<get_all> method on it, such as:
  
    my @foo = $req->query_parameters->get_all('foo');
  
  You can also call C<get_one> to always get one parameter independent
  of the context (unlike C<param>), and even call C<mixed> (with
  Hash::MultiValue 0.05 or later) to get the I<traditional> hash
  reference,
  
    my $params = $req->parameters->mixed;
  
  where values are either a scalar or an array reference depending on
  input, so it might be useful if you already have the code to deal with
  that ugliness.
  
  =head2 PARSING POST BODY and MULTIPLE OBJECTS
  
  The methods to parse request body (C<content>, C<body_parameters> and
  C<uploads>) are carefully coded to save the parsed body in the
  environment hash as well as in the temporary buffer, so you can call
  them multiple times and create Plack::Request objects multiple times
  in a request and they should work safely, and won't parse request body
  more than twice for the efficiency.
  
  =head1 DISPATCHING
  
  If your application or framework wants to dispatch (or route) actions
  based on request paths, be sure to use C<< $req->path_info >> not C<<
  $req->uri->path >>.
  
  This is because C<path_info> gives you the virtual path of the request,
  regardless of how your application is mounted. If your application is
  hosted with mod_perl or CGI scripts, or even multiplexed with tools
  like L<Plack::App::URLMap>, request's C<path_info> always gives you
  the action path.
  
  Note that C<path_info> might give you an empty string, in which case
  you should assume that the path is C</>.
  
  You will also want to use C<< $req->base >> as a base prefix when
  building URLs in your templates or in redirections. It's a good idea
  for you to subclass Plack::Request and define methods such as:
  
    sub uri_for {
        my($self, $path, $args) = @_;
        my $uri = $self->base;
        $uri->path($uri->path . $path);
        $uri->query_form(@$args) if $args;
        $uri;
    }
  
  So you can say:
  
    my $link = $req->uri_for('/logout', [ signoff => 1 ]);
  
  and if C<< $req->base >> is C</app> you'll get the full URI for
  C</app/logout?signoff=1>.
  
  =head1 INCOMPATIBILITIES
  
  In version 0.99, many utility methods are removed or deprecated, and
  most methods are made read-only.
  
  The following methods are deprecated: C<hostname>, C<url_scheme>,
  C<params>, C<query_params>, C<body_params>, C<cookie> and
  C<raw_uri>. They will be removed in the next major release.
  
  All parameter-related methods such as C<parameters>,
  C<body_parameters>, C<query_parameters> and C<uploads> now contains
  L<Hash::MultiValue> objects, rather than I<scalar or an array
  reference depending on the user input> which is insecure. See
  L<Hash::MultiValue> for more about this change.
  
  C<< $req->path >> method had a bug, where the code and the document
  was mismatching. The document was suggesting it returns the sub
  request path after C<< $req->base >> but the code was always returning
  the absolute URI path. The code is now updated to be an alias of C<<
  $req->path_info >> but returns C</> in case it's empty. If you need
  the older behavior, just call C<< $req->uri->path >> instead.
  
  Cookie handling is simplified, and doesn't use L<CGI::Simple::Cookie>
  anymore, which means you B<CAN NOT> set array reference or hash
  reference as a cookie value and expect it be serialized. You're always
  required to set string value, and encoding or decoding them is totally
  up to your application or framework. Also, C<cookies> hash reference
  now returns I<strings> for the cookies rather than CGI::Simple::Cookie
  objects, which means you no longer have to write a wacky code such as:
  
    $v = $req->cookie->{foo} ? $req->cookie->{foo}->value : undef;
  
  and instead, simply do:
  
    $v = $req->cookie->{foo};
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Kazuhiro Osawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Response> L<HTTP::Request>, L<Catalyst::Request>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_REQUEST

$fatpacked{"Plack/Request/Upload.pm"} = <<'PLACK_REQUEST_UPLOAD';
  package Plack::Request::Upload;
  use strict;
  use warnings;
  use Carp ();
  
  sub new {
      my($class, %args) = @_;
  
      bless {
          headers  => $args{headers},
          tempname => $args{tempname},
          size     => $args{size},
          filename => $args{filename},
      }, $class;
  }
  
  sub filename { $_[0]->{filename} }
  sub headers  { $_[0]->{headers} }
  sub size     { $_[0]->{size} }
  sub tempname { $_[0]->{tempname} }
  sub path     { $_[0]->{tempname} }
  
  sub content_type {
      my $self = shift;
      $self->{headers}->content_type(@_);
  }
  
  sub type { shift->content_type(@_) }
  
  sub basename {
      my $self = shift;
      unless (defined $self->{basename}) {
          require File::Spec::Unix;
          my $basename = $self->{filename};
          $basename =~ s|\\|/|g;
          $basename = ( File::Spec::Unix->splitpath($basename) )[2];
          $basename =~ s|[^\w\.-]+|_|g;
          $self->{basename} = $basename;
      }
      $self->{basename};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request::Upload - handles file upload requests
  
  =head1 SYNOPSIS
  
    # $req is Plack::Request
    my $upload = $req->uploads->{field};
  
    $upload->size;
    $upload->path;
    $upload->content_type;
    $upload->basename;
  
  =head1 METHODS
  
  =over 4
  
  =item size
  
  Returns the size of Uploaded file.
  
  =item path
  
  Returns the path to the temporary file where uploaded file is saved.
  
  =item content_type
  
  Returns the content type of the uploaded file.
  
  =item filename
  
  Returns the original filename in the client.
  
  =item basename
  
  Returns basename for "filename".
  
  =back
  
  =head1 AUTHORS
  
  Kazuhiro Osawa
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>, L<Catalyst::Request::Upload>
  
  =cut
PLACK_REQUEST_UPLOAD

$fatpacked{"Plack/Response.pm"} = <<'PLACK_RESPONSE';
  package Plack::Response;
  use strict;
  use warnings;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  use Plack::Util::Accessor qw(body status);
  use Carp ();
  use Scalar::Util ();
  use HTTP::Headers;
  use URI::Escape ();
  
  sub code    { shift->status(@_) }
  sub content { shift->body(@_)   }
  
  sub new {
      my($class, $rc, $headers, $content) = @_;
  
      my $self = bless {}, $class;
      $self->status($rc)       if defined $rc;
      $self->headers($headers) if defined $headers;
      $self->body($content)    if defined $content;
  
      $self;
  }
  
  sub headers {
      my $self = shift;
  
      if (@_) {
          my $headers = shift;
          if (ref $headers eq 'ARRAY') {
              Carp::carp("Odd number of headers") if @$headers % 2 != 0;
              $headers = HTTP::Headers->new(@$headers);
          } elsif (ref $headers eq 'HASH') {
              $headers = HTTP::Headers->new(%$headers);
          }
          return $self->{headers} = $headers;
      } else {
          return $self->{headers} ||= HTTP::Headers->new();
      }
  }
  
  sub cookies {
      my $self = shift;
      if (@_) {
          $self->{cookies} = shift;
      } else {
          return $self->{cookies} ||= +{ };
      }
  }
  
  sub header { shift->headers->header(@_) } # shortcut
  
  sub content_length {
      shift->headers->content_length(@_);
  }
  
  sub content_type {
      shift->headers->content_type(@_);
  }
  
  sub content_encoding {
      shift->headers->content_encoding(@_);
  }
  
  sub location {
      my $self = shift;
      return $self->headers->header('Location' => @_);
  }
  
  sub redirect {
      my $self = shift;
  
      if (@_) {
          my $url = shift;
          my $status = shift || 302;
          $self->location($url);
          $self->status($status);
      }
  
      return $self->location;
  }
  
  sub finalize {
      my $self = shift;
      Carp::croak "missing status" unless $self->status();
  
      my $headers = $self->headers->clone;
      $self->_finalize_cookies($headers);
  
      return [
          $self->status,
          +[
              map {
                  my $k = $_;
                  map {
                      my $v = $_;
                      $v =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
                      $v =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
  
                      ( $k => $v )
                  } $headers->header($_);
  
              } $headers->header_field_names
          ],
          $self->_body,
      ];
  }
  
  sub _body {
      my $self = shift;
      my $body = $self->body;
         $body = [] unless defined $body;
      if (!ref $body or Scalar::Util::blessed($body) && overload::Method($body, q("")) && !$body->can('getline')) {
          return [ $body ];
      } else {
          return $body;
      }
  }
  
  sub _finalize_cookies {
      my($self, $headers) = @_;
  
      while (my($name, $val) = each %{$self->cookies}) {
          my $cookie = $self->_bake_cookie($name, $val);
          $headers->push_header('Set-Cookie' => $cookie);
      }
  }
  
  sub _bake_cookie {
      my($self, $name, $val) = @_;
  
      return '' unless defined $val;
      $val = { value => $val } unless ref $val eq 'HASH';
  
      my @cookie = ( URI::Escape::uri_escape($name) . "=" . URI::Escape::uri_escape($val->{value}) );
      push @cookie, "domain=" . $val->{domain}   if $val->{domain};
      push @cookie, "path=" . $val->{path}       if $val->{path};
      push @cookie, "expires=" . $self->_date($val->{expires}) if $val->{expires};
      push @cookie, "secure"                     if $val->{secure};
      push @cookie, "HttpOnly"                   if $val->{httponly};
  
      return join "; ", @cookie;
  }
  
  my @MON  = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
  my @WDAY = qw( Sun Mon Tue Wed Thu Fri Sat );
  
  sub _date {
      my($self, $expires) = @_;
  
      if ($expires =~ /^\d+$/) {
          # all numbers -> epoch date
          # (cookies use '-' as date separator, HTTP uses ' ')
          my($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($expires);
          $year += 1900;
  
          return sprintf("%s, %02d-%s-%04d %02d:%02d:%02d GMT",
                         $WDAY[$wday], $mday, $MON[$mon], $year, $hour, $min, $sec);
  
      }
  
      return $expires;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Response - Portable HTTP Response object for PSGI response
  
  =head1 SYNOPSIS
  
    use Plack::Response;
  
    sub psgi_handler {
        my $env = shift;
  
        my $res = Plack::Response->new(200);
        $res->content_type('text/html');
        $res->body("Hello World");
  
        return $res->finalize;
    }
  
  =head1 DESCRIPTION
  
  Plack::Response allows you a way to create PSGI response array ref through a simple API.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $res = Plack::Response->new;
    $res = Plack::Response->new($status);
    $res = Plack::Response->new($status, $headers);
    $res = Plack::Response->new($status, $headers, $body);
  
  Creates a new Plack::Response object.
  
  =item status
  
    $res->status(200);
    $status = $res->status;
  
  Sets and gets HTTP status code. C<code> is an alias.
  
  =item headers
  
    $headers = $res->headers;
    $res->headers([ 'Content-Type' => 'text/html' ]);
    $res->headers({ 'Content-Type' => 'text/html' });
    $res->headers( HTTP::Headers->new );
  
  Sets and gets HTTP headers of the response. Setter can take either an
  array ref, a hash ref or L<HTTP::Headers> object containing a list of
  headers.
  
  =item body
  
    $res->body($body_str);
    $res->body([ "Hello", "World" ]);
    $res->body($io);
  
  Gets and sets HTTP response body. Setter can take either a string, an
  array ref, or an IO::Handle-like object. C<content> is an alias.
  
  Note that this method doesn't automatically set I<Content-Length> for
  the response. You have to set it manually if you want, with the
  C<content_length> method (see below).
  
  =item header
  
    $res->header('X-Foo' => 'bar');
    my $val = $res->header('X-Foo');
  
  Shortcut for C<< $res->headers->header >>.
  
  =item content_type, content_length, content_encoding
  
    $res->content_type('text/plain');
    $res->content_length(123);
    $res->content_encoding('gzip');
  
  Shortcut for the equivalent get/set methods in C<< $res->headers >>.
  
  =item redirect
  
    $res->redirect($url);
    $res->redirect($url, 301);
  
  Sets redirect URL with an optional status code, which defaults to 302.
  
  Note that this method doesn't normalize the given URI string. Users of
  this module have to be responsible about properly encoding URI paths
  and parameters.
  
  =item location
  
  Gets and sets C<Location> header.
  
  Note that this method doesn't normalize the given URI string in the
  setter. See above in C<redirect> for details.
  
  =item cookies
  
    $res->cookies->{foo} = 123;
    $res->cookies->{foo} = { value => '123' };
  
  Returns a hash reference containing cookies to be set in the
  response. The keys of the hash are the cookies' names, and their
  corresponding values are a plain string (for C<value> with everything
  else defaults) or a hash reference that can contain keys such as
  C<value>, C<domain>, C<expires>, C<path>, C<httponly>, C<secure>.
  
  C<expires> can take a string or an integer (as an epoch time) and
  B<does not> convert string formats such as C<+3M>.
  
    $res->cookies->{foo} = {
        value => 'test',
        path  => "/",
        domain => '.example.com',
        expires => time + 24 * 60 * 60,
    };
  
  =item finalize
  
    $res->finalize;
  
  Returns the status code, headers, and body of this response as a PSGI
  response array reference.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>
  
  =cut
PLACK_RESPONSE

$fatpacked{"Plack/Runner.pm"} = <<'PLACK_RUNNER';
  package Plack::Runner;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {
          env      => $ENV{PLACK_ENV},
          loader   => 'Plack::Loader',
          includes => [],
          modules  => [],
          @_,
      }, $class;
  }
  
  # delay the build process for reloader
  sub build(&;$) {
      my $block = shift;
      my $app   = shift || sub { };
      return sub { $block->($app->()) };
  }
  
  sub parse_options {
      my $self = shift;
  
      local @ARGV = @_;
  
      # From 'prove': Allow cuddling the paths with -I, -M and -e
      @ARGV = map { /^(-[IMe])(.+)/ ? ($1,$2) : $_ } @ARGV;
  
      my($host, $port, $socket, @listen);
  
      require Getopt::Long;
      my $parser = Getopt::Long::Parser->new(
          config => [ "no_ignore_case", "pass_through" ],
      );
  
      $parser->getoptions(
          "a|app=s"      => \$self->{app},
          "o|host=s"     => \$host,
          "p|port=i"     => \$port,
          "s|server=s"   => \$self->{server},
          "S|socket=s"   => \$socket,
          'l|listen=s@'  => \@listen,
          'D|daemonize'  => \$self->{daemonize},
          "E|env=s"      => \$self->{env},
          "e=s"          => \$self->{eval},
          'I=s@'         => $self->{includes},
          'M=s@'         => $self->{modules},
          'r|reload'     => sub { $self->{loader} = "Restarter" },
          'R|Reload=s'   => sub { $self->{loader} = "Restarter"; $self->loader->watch(split ",", $_[1]) },
          'L|loader=s'   => \$self->{loader},
          "access-log=s" => \$self->{access_log},
          "h|help"       => \$self->{help},
          "v|version"    => \$self->{version},
      );
  
      my(@options, @argv);
      while (defined(my $arg = shift @ARGV)) {
          if ($arg =~ s/^--?//) {
              my @v = split '=', $arg, 2;
              $v[0] =~ tr/-/_/;
              if (@v == 2) {
                  push @options, @v;
              } elsif ($v[0] =~ s/^(disable|enable)_//) {
                  push @options, $v[0], $1 eq 'enable';
              } else {
                  push @options, $v[0], shift @ARGV;
              }
          } else {
              push @argv, $arg;
          }
      }
  
      push @options, $self->mangle_host_port_socket($host, $port, $socket, @listen);
      push @options, daemonize => 1 if $self->{daemonize};
  
      $self->{options} = \@options;
      $self->{argv}    = \@argv;
  }
  
  sub set_options {
      my $self = shift;
      push @{$self->{options}}, @_;
  }
  
  sub mangle_host_port_socket {
      my($self, $host, $port, $socket, @listen) = @_;
  
      for my $listen (reverse @listen) {
          if ($listen =~ /:\d+$/) {
              ($host, $port) = split /:/, $listen, 2;
              $host = undef if $host eq '';
          } else {
              $socket ||= $listen;
          }
      }
  
      unless (@listen) {
          if ($socket) {
              @listen = ($socket);
          } else {
              $port ||= 5000;
              @listen = ($host ? "$host:$port" : ":$port");
          }
      }
  
      return host => $host, port => $port, listen => \@listen, socket => $socket;
  }
  
  sub version_cb {
      my $self = shift;
      $self->{version_cb} || sub {
          require Plack;
          print "Plack $Plack::VERSION\n";
      };
  }
  
  sub setup {
      my $self = shift;
  
      if ($self->{help}) {
          require Pod::Usage;
          Pod::Usage::pod2usage(0);
      }
  
      if ($self->{version}) {
          $self->version_cb->();
          exit;
      }
  
      if (@{$self->{includes}}) {
          require lib;
          lib->import(@{$self->{includes}});
      }
  
      if ($self->{eval}) {
          push @{$self->{modules}}, 'Plack::Builder';
      }
  
      for (@{$self->{modules}}) {
          my($module, @import) = split /[=,]/;
          eval "require $module" or die $@;
          $module->import(@import);
      }
  }
  
  sub locate_app {
      my($self, @args) = @_;
  
      my $psgi = $self->{app} || $args[0];
  
      if (ref $psgi eq 'CODE') {
          return sub { $psgi };
      }
  
      if ($self->{eval}) {
          $self->loader->watch("lib");
          return build {
              no strict;
              no warnings;
              my $eval = "builder { $self->{eval};";
              $eval .= "Plack::Util::load_psgi(\$psgi);" if $psgi;
              $eval .= "}";
              eval $eval or die $@;
          };
      }
  
      $psgi ||= "app.psgi";
  
      require File::Basename;
      $self->loader->watch( File::Basename::dirname($psgi) . "/lib", $psgi );
      build { Plack::Util::load_psgi $psgi };
  }
  
  sub watch {
      my($self, @dir) = @_;
  
      push @{$self->{watch}}, @dir
          if $self->{loader} eq 'Restarter';
  }
  
  sub apply_middleware {
      my($self, $app, $class, @args) = @_;
  
      my $mw_class = Plack::Util::load_class($class, 'Plack::Middleware');
      build { $mw_class->wrap($_[0], @args) } $app;
  }
  
  sub prepare_devel {
      my($self, $app) = @_;
  
      $app = $self->apply_middleware($app, 'Lint');
      $app = $self->apply_middleware($app, 'StackTrace');
      if (!$ENV{GATEWAY_INTERFACE} and !$self->{access_log}) {
          $app = $self->apply_middleware($app, 'AccessLog');
      }
  
      push @{$self->{options}}, server_ready => sub {
          my($args) = @_;
          my $name  = $args->{server_software} || ref($args); # $args is $server
          my $host  = $args->{host} || 0;
          my $proto = $args->{proto} || 'http';
          print STDERR "$name: Accepting connections at $proto://$host:$args->{port}/\n";
      };
  
      $app;
  }
  
  sub loader {
      my $self = shift;
      $self->{_loader} ||= Plack::Util::load_class($self->{loader}, 'Plack::Loader')->new;
  }
  
  sub load_server {
      my($self, $loader) = @_;
  
      if ($self->{server}) {
          return $loader->load($self->{server}, @{$self->{options}});
      } else {
          return $loader->auto(@{$self->{options}});
      }
  }
  
  sub run {
      my $self = shift;
  
      unless (ref $self) {
          $self = $self->new;
          $self->parse_options(@_);
          return $self->run;
      }
  
      unless ($self->{options}) {
          $self->parse_options();
      }
  
      my @args = @_ ? @_ : @{$self->{argv}};
  
      $self->setup;
  
      my $app = $self->locate_app(@args);
  
      $ENV{PLACK_ENV} ||= $self->{env} || 'development';
      if ($ENV{PLACK_ENV} eq 'development') {
          $app = $self->prepare_devel($app);
      }
  
      if ($self->{access_log}) {
          open my $logfh, ">>", $self->{access_log}
              or die "open($self->{access_log}): $!";
          $logfh->autoflush(1);
          $app = $self->apply_middleware($app, 'AccessLog', logger => sub { $logfh->print( @_ ) });
      }
  
      my $loader = $self->loader;
      $loader->preload_app($app);
  
      my $server = $self->load_server($loader);
      $loader->run($server);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Runner - plackup core
  
  =head1 SYNOPSIS
  
    # Your bootstrap script
    use Plack::Runner;
    my $app = sub { ... };
  
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Runner is the core of L<plackup> runner script. You can create
  your own frontend to run your application or framework, munge command
  line options and pass that to C<run> method of this class.
  
  C<run> method does exactly the same thing as the L<plackup> script
  does, but one notable addition is that you can pass a PSGI application
  code reference directly with C<--app> option, rather than via C<.psgi>
  file path or with C<-e> switch. This would be useful if you want to
  make an installable PSGI application.
  
  Also, when C<-h> or C<--help> switch is passed, the usage text is
  automatically extracted from your own script using L<Pod::Usage>.
  
  =head1 NOTES
  
  Do not directly call this module from your C<.psgi>, since that makes
  your PSGI application unnecessarily depend on L<plackup> and won't run
  other backends like L<Plack::Handler::Apache2> or mod_psgi.
  
  If you I<really> want to make your C<.psgi> runnable as a standalone
  script, you can do this:
  
    my $app = sub { ... };
  
    unless (caller) {
        require Plack::Runner;
        my $runner = Plack::Runner->new;
        $runner->parse_options(@ARGV);
        return $runner->run($app);
    }
  
    return $app;
  
  B<WARNING>: this section used to recommend C<if (__FILE__ eq $0)> but
  it's known to be broken since Plack 0.9971, since C<$0> is now
  I<always> set to the .psgi file path even when you run it from
  plackup.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
  
PLACK_RUNNER

$fatpacked{"Plack/Server.pm"} = <<'PLACK_SERVER';
  package Plack::Server;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server - DEPRECATED. See Plack::Handler
  
  =head1 SEE ALSO
  
  L<Plack::Handler>
  
  =cut
  
PLACK_SERVER

$fatpacked{"Plack/Server/Apache1.pm"} = <<'PLACK_SERVER_APACHE1';
  package Plack::Server::Apache1;
  use strict;
  use parent qw(Plack::Handler::Apache1);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Apache1 or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Apache1 - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Apache1>.
  
  =cut
PLACK_SERVER_APACHE1

$fatpacked{"Plack/Server/Apache2.pm"} = <<'PLACK_SERVER_APACHE2';
  package Plack::Server::Apache2;
  use strict;
  use parent qw(Plack::Handler::Apache2);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Apache2 or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Apache2 - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Apache2>.
  
  =cut
PLACK_SERVER_APACHE2

$fatpacked{"Plack/Server/CGI.pm"} = <<'PLACK_SERVER_CGI';
  package Plack::Server::CGI;
  use strict;
  use parent qw(Plack::Handler::CGI);
  
  sub new {
      my $class = shift;
      print STDERR "Use of $class is deprecated. Use Plack::Handler::CGI or Plack::Loader to upgrade.\n";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::CGI - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::CGI>.
  
  =cut
PLACK_SERVER_CGI

$fatpacked{"Plack/Server/FCGI.pm"} = <<'PLACK_SERVER_FCGI';
  package Plack::Server::FCGI;
  use strict;
  use parent qw(Plack::Handler::FCGI);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::FCGI or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::FCGI - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::FCGI>.
  
  =cut
PLACK_SERVER_FCGI

$fatpacked{"Plack/Server/ServerSimple.pm"} = <<'PLACK_SERVER_SERVERSIMPLE';
  package Plack::Server::ServerSimple;
  use strict;
  our $VERSION = '0.9985';
  $VERSION = eval $VERSION;
  
  use parent qw(Plack::Handler::HTTP::Server::Simple);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "$class is deprecated. Use -s HTTP::Server::Simple";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::ServerSimple - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<DEPRECATED>. Use Plack::Handler::HTTP::Server::Simple.
  
  =cut
PLACK_SERVER_SERVERSIMPLE

$fatpacked{"Plack/Server/Standalone.pm"} = <<'PLACK_SERVER_STANDALONE';
  package Plack::Server::Standalone;
  use strict;
  use parent qw(Plack::Handler::Standalone);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Standalone or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Standalone - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Standalone>.
  
  =cut
PLACK_SERVER_STANDALONE

$fatpacked{"Plack/Server/Standalone/Prefork.pm"} = <<'PLACK_SERVER_STANDALONE_PREFORK';
  package Plack::Server::Standalone::Prefork;
  use strict;
  use parent qw(HTTP::Server::PSGI); # because Standalone is a wrapper
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Starman or Starlet for preforking servers.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Standalone::Prefork - DEPRECATED use Starman or Starlet instead
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>.
  
  =head1 SEE ALSO
  
  L<HTTP::Server::PSGI> L<Starman> L<Starlet>
  
  =cut
PLACK_SERVER_STANDALONE_PREFORK

$fatpacked{"Plack/TempBuffer.pm"} = <<'PLACK_TEMPBUFFER';
  package Plack::TempBuffer;
  use strict;
  use warnings;
  use Plack::Util;
  use FileHandle; # for seek etc.
  
  our $MaxMemoryBufferSize = 1024 * 1024;
  
  sub new {
      my($class, $length) = @_;
  
      # $MaxMemoryBufferSize = 0  -> Always temp file
      # $MaxMemoryBufferSize = -1 -> Always PerlIO
      my $backend;
      if ($MaxMemoryBufferSize < 0) {
          $backend = "PerlIO";
      } elsif ($MaxMemoryBufferSize == 0) {
          $backend = "File";
      } elsif (!$length) {
          $backend = "Auto";
      } elsif ($length > $MaxMemoryBufferSize) {
          $backend = "File";
      } else {
          $backend = "PerlIO";
      }
  
      $class->create($backend, $length, $MaxMemoryBufferSize);
  }
  
  sub create {
      my($class, $backend, $length, $max) = @_;
      Plack::Util::load_class($backend, $class)->new($length, $max);
  }
  
  sub print;
  sub rewind;
  sub size;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::TempBuffer - temporary buffer to save bytes
  
  =head1 SYNOPSIS
  
    my $buf = Plack::TempBuffer->new($length);
    $buf->print($bytes);
  
    my $size = $buf->size;
    my $fh   = $buf->rewind;
  
  =head1 DESCRIPTION
  
  Plack::TempBuffer is a buffer class to store arbitrary length of byte
  strings and then get a seekable filehandle once everything is
  buffered. It uses PerlIO and/or temporary file to save the buffer
  depending on the length of the size.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Request>
  
  =cut
  
PLACK_TEMPBUFFER

$fatpacked{"Plack/TempBuffer/Auto.pm"} = <<'PLACK_TEMPBUFFER_AUTO';
  package Plack::TempBuffer::Auto;
  use strict;
  use parent 'Plack::TempBuffer';
  
  sub new {
      my($class, undef, $max_memory_size) = @_;
      bless {
          _buffer => Plack::TempBuffer->create('PerlIO'),
          _max => $max_memory_size,
      }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{_buffer}->print(@_);
  
      if ($self->{_max} && $self->{_buffer}->size > $self->{_max}) {
          my $buf = $self->{_buffer}->{buffer};
          $self->{_buffer} = Plack::TempBuffer->create('File'),
          $self->{_buffer}->print($buf);
          delete $self->{_max};
      }
  }
  
  sub size {
      my $self = shift;
      $self->{_buffer}->size;
  }
  
  sub rewind {
      my $self = shift;
      $self->{_buffer}->rewind;
  }
  
  1;
PLACK_TEMPBUFFER_AUTO

$fatpacked{"Plack/TempBuffer/File.pm"} = <<'PLACK_TEMPBUFFER_FILE';
  package Plack::TempBuffer::File;
  use strict;
  use parent 'Plack::TempBuffer';
  
  use IO::File;
  
  sub new {
      my $class = shift;
  
      my $fh = IO::File->new_tmpfile;
      $fh->binmode;
  
      bless { fh => $fh }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{fh}->print(@_);
  }
  
  sub size {
      my $self = shift;
      $self->{fh}->flush;
      -s $self->{fh};
  }
  
  sub rewind {
      my $self = shift;
      $self->{fh}->seek(0, 0);
      $self->{fh};
  }
  
  1;
PLACK_TEMPBUFFER_FILE

$fatpacked{"Plack/TempBuffer/PerlIO.pm"} = <<'PLACK_TEMPBUFFER_PERLIO';
  package Plack::TempBuffer::PerlIO;
  use strict;
  use parent 'Plack::TempBuffer';
  
  sub new {
      my $class = shift;
      bless { buffer => '' }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{buffer} .= "@_";
  }
  
  sub size {
      my $self = shift;
      length $self->{buffer};
  }
  
  sub rewind {
      my $self = shift;
      my $buffer = $self->{buffer};
      open my $io, "<", \$buffer;
      bless $io, 'FileHandle'; # This makes $io work as FileHandle under 5.8, .10 and .11 :/
      return $io;
  }
  
  1;
PLACK_TEMPBUFFER_PERLIO

$fatpacked{"Plack/Test.pm"} = <<'PLACK_TEST';
  package Plack::Test;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw(test_psgi);
  
  our $Impl;
  $Impl ||= $ENV{PLACK_TEST_IMPL} || "MockHTTP";
  
  sub test_psgi {
      eval "require Plack::Test::$Impl;";
      die $@ if $@;
      no strict 'refs';
      if (ref $_[0] && @_ == 2) {
          @_ = (app => $_[0], client => $_[1]);
      }
      &{"Plack::Test::$Impl\::test_psgi"}(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test - Test PSGI applications with various backends
  
  =head1 SYNOPSIS
  
    use Plack::Test;
  
    # named params
    test_psgi
        app => sub {
            my $env = shift;
            return [ 200, [ 'Content-Type' => 'text/plain' ], [ "Hello World" ] ],
        },
        client => sub {
            my $cb  = shift;
            my $req = HTTP::Request->new(GET => "http://localhost/hello");
            my $res = $cb->($req);
            like $res->content, qr/Hello World/;
        };
  
     use HTTP::Request::Common;
  
     # positional params (app, client)
     my $app = sub { return [ 200, [], [ "Hello "] ] };
     test_psgi $app, sub {
         my $cb  = shift;
         my $res = $cb->(GET "/");
         is $res->content, "Hello";
     };
  
  
  =head1 DESCRIPTION
  
  Plack::Test is a unified interface to test PSGI applications using
  L<HTTP::Request> and L<HTTP::Response> objects. It also allows you to run PSGI
  applications in various ways. The default backend is C<Plack::Test::MockHTTP>,
  but you may also use any L<Plack::Handler> implementation to run live HTTP
  requests against at web server
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item test_psgi
  
    test_psgi $app, $client;
    test_psgi app => $app, client => $client;
  
  Runs the client test code C<$client> against a PSGI application
  C<$app>. The client callback gets one argument C<$cb>, a
  callback that accepts an C<HTTP::Request> object and returns an
  C<HTTP::Response> object.
  
  Use L<HTTP::Request::Common> to import shortcuts for creating requests for
  C<GET>, C<POST>, C<DELETE>, and C<PUT> operations.
  
  For your convenience, the C<HTTP::Request> given to the callback automatically
  uses the HTTP protocol and the localhost (I<127.0.0.1> by default), so the
  following code just works:
  
    use HTTP::Request::Common;
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/hello");
    };
  
  Note that however, it is not a good idea to pass an arbitrary
  (i.e. user-input) string to C<GET> or even C<<
  HTTP::Request->new >> by assuming that it always represents a path,
  because:
  
    my $req = GET "//foo/bar";
  
  would represent a request for a URL that has no scheme, has a hostname
  I<foo> and a path I</bar>, instead of a path I<//foo/bar> which you
  might actually want.
  
  =back
  
  =head1 OPTIONS
  
  Specify the L<Plack::Test> backend using the environment
  variable C<PLACK_TEST_IMPL> or C<$Plack::Test::Impl> package variable.
  
  The available values for the backend are:
  
  =over 4
  
  =item MockHTTP
  
  (Default) Creates a PSGI env hash out of HTTP::Request object, runs
  the PSGI application in-process and returns HTTP::Response.
  
  =item Server
  
  Runs one of Plack::Handler backends (C<Standalone> by default) and
  sends live HTTP requests to test.
  
  =item ExternalServer
  
  Runs tests against an external server specified in the
  C<PLACK_TEST_EXTERNALSERVER_URI> environment variable instead of spawning the
  application in a server locally.
  
  =back
  
  For instance, test your application with the C<HTTP::Server::ServerSimple>
  server backend with:
  
    > env PLACK_TEST_IMPL=Server PLACK_SERVER=HTTP::Server::ServerSimple \
      prove -l t/test.t
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_TEST

$fatpacked{"Plack/Test/MockHTTP.pm"} = <<'PLACK_TEST_MOCKHTTP';
  package Plack::Test::MockHTTP;
  use strict;
  use warnings;
  
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use HTTP::Message::PSGI;
  use Try::Tiny;
  
  sub test_psgi {
      my %args = @_;
  
      my $client = delete $args{client} or croak "client test code needed";
      my $app    = delete $args{app}    or croak "app needed";
  
      my $cb = sub {
          my $req = shift;
          $req->uri->scheme('http')    unless defined $req->uri->scheme;
          $req->uri->host('localhost') unless defined $req->uri->host;
          my $env = $req->to_psgi;
  
          my $res = try {
              HTTP::Response->from_psgi($app->($env));
          } catch {
              HTTP::Response->from_psgi([ 500, [ 'Content-Type' => 'text/plain' ], [ $_ ] ]);
          };
  
          $res->request($req);
          return $res;
      };
  
      $client->($cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::MockHTTP - Run mocked HTTP tests through PSGI applications
  
  =head1 DESCRIPTION
  
  Plack::Test::MockHTTP is a utility to run PSGI application given
  HTTP::Request objects and return HTTP::Response object out of PSGI
  application response. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Test>
  
  =cut
  
  
PLACK_TEST_MOCKHTTP

$fatpacked{"Plack/Test/Server.pm"} = <<'PLACK_TEST_SERVER';
  package Plack::Test::Server;
  use strict;
  use warnings;
  use Carp;
  use LWP::UserAgent;
  use Test::TCP;
  use Plack::Loader;
  
  sub test_psgi {
      my %args = @_;
  
      my $client = delete $args{client} or croak "client test code needed";
      my $app    = delete $args{app}    or croak "app needed";
      my $ua     = delete $args{ua} || LWP::UserAgent->new;
  
      test_tcp(
          client => sub {
              my $port = shift;
              my $cb = sub {
                  my $req = shift;
                  $req->uri->scheme('http');
                  $req->uri->host($args{host} || '127.0.0.1');
                  $req->uri->port($port);
                  return $ua->request($req);
              };
              $client->($cb);
          },
          server => $args{server} || sub {
              my $port = shift;
              my $server = Plack::Loader->auto(port => $port, host => ($args{host} || '127.0.0.1'));
              $server->run($app);
          },
      );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::Server - Run HTTP tests through live Plack servers
  
  =head1 DESCRIPTION
  
  Plack::Test::Server is a utility to run PSGI application with Plack
  server implementations, and run the live HTTP tests with the server
  using a callback. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Loader> L<Test::TCP> L<Plack::Test>
  
  =cut
  
PLACK_TEST_SERVER

$fatpacked{"Plack/Test/Suite.pm"} = <<'PLACK_TEST_SUITE';
  package Plack::Test::Suite;
  use strict;
  use warnings;
  use Digest::MD5;
  use File::ShareDir;
  use HTTP::Request;
  use HTTP::Request::Common;
  use LWP::UserAgent;
  use Test::More;
  use Test::TCP;
  use Plack::Loader;
  use Plack::Middleware::Lint;
  use Plack::Util;
  use Plack::Request;
  use Try::Tiny;
  
  my $share_dir = try { File::ShareDir::dist_dir('Plack') } || 'share';
  
  $ENV{PLACK_TEST_SCRIPT_NAME} = '';
  
  # 0: test name
  # 1: request generator coderef.
  # 2: request handler
  # 3: test case for response
  our @TEST = (
      [
          'SCRIPT_NAME',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME};
          },
          sub {
              my $env = shift;
              return [ 200, ["Content-Type", "text/plain"], [ $env->{SCRIPT_NAME} ] ];
          },
      ],
      [
          'GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ 'Hello, ' . $env->{QUERY_STRING} ],
              ];
          },
      ],
      [
          'POST',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/", [name => 'tatsuhiko']);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), 14;
              is $res->header('Client-Content-Type'), 'application/x-www-form-urlencoded';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=tatsuhiko';
          },
          sub {
              my $env = shift;
              my $body;
              $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH});
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ 'Hello, ' . $body ],
              ];
          },
      ],
      [
          'big POST',
          sub {
              my $cb = shift;
              my $chunk = "abcdefgh" x 12000;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content_length(length $chunk);
              $req->content_type('application/octet-stream');
              $req->content($chunk);
  
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), length $chunk;
              is length $res->content, length $chunk;
              is Digest::MD5::md5_hex($res->content), Digest::MD5::md5_hex($chunk);
          },
          sub {
              my $env = shift;
              my $len = $env->{CONTENT_LENGTH};
              my $body = '';
              my $spin;
              while ($len > 0) {
                  my $rc = $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH}, length $body);
                  $len -= $rc;
                  last if $spin++ > 2000;
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ $body ],
              ];
          },
      ],
      [
          'psgi.url_scheme',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'http';
          },
          sub {
              my $env = $_[0];
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{'psgi.url_scheme'} ],
              ];
          },
      ],
      [
          'return glob',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr/^package /;
              like $res->content, qr/END_MARK_FOR_TESTING$/;
          },
          sub {
              my $env = shift;
              open my $fh, '<', __FILE__ or die $!;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  $fh,
              ];
          },
      ],
      [
          'filehandle',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'bigger file',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/baybridge.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 79838;
              is Digest::MD5::md5_hex($res->content), '983726ae0e4ce5081bef5fb2b7216950';
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/baybridge.jpg";
              binmode $fh;
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'handle HTTP-Header',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Foo => "Bar");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_FOO}],
              ];
          },
      ],
      [
          'handle HTTP-Cookie',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Cookie => "foo");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'foo';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_COOKIE}],
              ];
          },
      ],
      [
          'validate env',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, join("\n",
                  'REQUEST_METHOD:GET',
                  "SCRIPT_NAME:$ENV{PLACK_TEST_SCRIPT_NAME}",
                  'PATH_INFO:/foo/',
                  'QUERY_STRING:dankogai=kogaidan',
                  'SERVER_NAME:127.0.0.1',
                  "SERVER_PORT:" . $res->request->uri->port,
              )."\n";
          },
          sub {
              my $env = shift;
              my $body;
              $body .= $_ . ':' . $env->{$_} . "\n" for qw/REQUEST_METHOD SCRIPT_NAME PATH_INFO QUERY_STRING SERVER_NAME SERVER_PORT/;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$body],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%2cbaz");
              is $res->content, "/foo/bar,baz", "PATH_INFO should be decoded per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% double encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%252cbaz");
              is $res->content, "/foo/bar%2cbaz", "PATH_INFO should be decoded only once, per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO (outside of URI characters)',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo%E3%81%82");
              is $res->content, "/foo\x{e3}\x{81}\x{82}";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          'SERVER_PROTOCOL is required',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr{^HTTP/1\.[01]$};
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{SERVER_PROTOCOL}],
              ];
          },
      ],
      [
          'SCRIPT_NAME should not be undef',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $cont = defined $env->{'SCRIPT_NAME'};
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$cont],
              ];
          },
      ],
      [
          'call close after read IO::Handle-like',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/call_close");
              is($res->content, '1234');
          },
          sub {
              my $env = shift;
              {
                  our $closed = -1;
                  sub CalledClose::new { $closed = 0; my $i=0; bless \$i, 'CalledClose' }
                  sub CalledClose::getline {
                      my $self = shift;
                      return $$self++ < 4 ? $$self : undef;
                  }
                  sub CalledClose::close { ::ok(1, 'closed') if defined &::ok }
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  CalledClose->new(),
              ];
          },
      ],
      [
          'has errors',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/has_errors");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $err = $env->{'psgi.errors'};
              my $has_errors = defined $err;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$has_errors]
              ];
          },
      ],
      [
          'status line',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is($res->status_line, '200 OK');
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [1]
              ];
          },
      ],
      [
          'Do not crash when the app dies',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 500;
              is $res->message, 'Internal Server Error';
          },
          sub {
              my $env = shift;
              open my $io, '>', \my $error;
              $env->{'psgi.errors'} = $io;
              die "Throwing an exception from app handler. Server shouldn't crash.";
          },
      ],
      [
          'multi headers (request)',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Foo => "bar");
              $req->push_header(Foo => "baz");
              my $res = $cb->($req);
              like($res->content, qr/^bar,\s*baz$/);
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{HTTP_FOO} ]
              ];
          },
      ],
      [
          'multi headers (response)',
          sub {
              my $cb  = shift;
              my $res = $cb->(HTTP::Request->new(GET => "http://127.0.0.1/"));
              my $foo = $res->header('X-Foo');
              like $foo, qr/foo,\s*bar,\s*baz/;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Foo', 'foo', 'X-Foo', 'bar, baz' ],
                  [ 'hi' ]
              ];
          },
      ],
      [
          'Do not set $env->{COOKIE}',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Cookie => "foo=bar");
              my $res = $cb->($req);
              is($res->header('X-Cookie'), 0);
              is $res->content, 'foo=bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Cookie' => $env->{COOKIE} ? 1 : 0 ],
                  [ $env->{HTTP_COOKIE} ]
              ];
          },
      ],
      [
          'no entity headers on 304',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 304;
              is $res->message, 'Not Modified';
              is $res->content, '';
              ok ! defined $res->header('content_type'), "No Content-Type";
              ok ! defined $res->header('content_length'), "No Content-Length";
              ok ! defined $res->header('transfer_encoding'), "No Transfer-Encoding";
          },
          sub {
              my $env = shift;
              return [ 304, [], [] ];
          },
      ],
      [
          'REQUEST_URI is set',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%20baz%73?x=a");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME} . "/foo/bar%20baz%73?x=a";
          },
          sub {
              my $env = shift;
              return [ 200, [ 'Content-Type' => 'text/plain' ], [ $env->{REQUEST_URI} ] ];
          },
      ],
      [
          'filehandle with path()',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              Plack::Util::set_io_path($fh, "$share_dir/face.jpg");
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'a big header value > 128 bytes',
          sub {
              my $cb  = shift;
              my $req = GET "http://127.0.0.1/";
              my $v = ("abcdefgh" x 16);
              $req->header('X-Foo' => $v);
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->content, $v;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain' ],
                  [ $env->{HTTP_X_FOO} ],
              ];
          },
      ],
      [
          'coderef res',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
              return sub {
                  my $respond = shift;
                  $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                      [ 'Hello, ' . $env->{QUERY_STRING} ],
                  ]);
              }
          },
      ],
      [
          'coderef streaming',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
  
              return sub {
                  my $respond = shift;
  
                  my $writer = $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                  ]);
  
                  $writer->write("Hello, ");
                  $writer->write($env->{QUERY_STRING});
                  $writer->close();
              }
          },
      ],
      [
          'CRLF output and FCGI parse bug',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
  
              is $res->header("Foo"), undef;
              is $res->content, "Foo: Bar\r\n\r\nHello World";
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Foo: Bar\r\n\r\nHello World" ] ];
          },
      ],
      [
          'newlines',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is length($res->content), 7;
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Bar\nBaz" ] ];
          },
      ],
      [
          'test 404',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 404;
              is $res->message, 'Not Found';
              is $res->content, 'Not Found';
          },
          sub {
              return [ 404, [ "Content-Type", "text/plain" ], [ "Not Found" ] ];
          },
      ],
      [
          'request->input seekable',
          sub {
              my $cb = shift;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content("body");
              $req->content_type('text/plain');
              $req->content_length(4);
              my $res = $cb->($req);
              is $res->content, 'body';
          },
          sub {
              my $req = Plack::Request->new(shift);
              return [ 200, [ "Content-Type", "text/plain" ], [ $req->content ] ];
          },
      ],
      [
          'request->content on GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              ok $res->is_success;
          },
          sub {
              my $req = Plack::Request->new(shift);
              $req->content;
              return [ 200, [ "Content-Type", "text/plain" ], [ "OK" ] ];
          },
      ],
      [
          'handle Authorization header',
          sub {
              my $cb  = shift;
              SKIP: {
                  skip "Authorization header is unsupported under CGI", 4 if ($ENV{PLACK_TEST_HANDLER} || "") eq "CGI";
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      $req->push_header(Authorization => 'Basic XXXX');
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 1;
                      is $res->content, 'Basic XXXX';
                  };
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 0;
                      is $res->content, '';
                  };
              };
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-AUTHORIZATION' => exists($env->{HTTP_AUTHORIZATION}) ? 1 : 0 ],
                  [ $env->{HTTP_AUTHORIZATION} || '' ],
              ];
          },
      ],
      [
          'repeated slashes',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1//foo///bar/baz");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, '//foo///bar/baz';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
  );
  
  sub runtests {
      my($class, $runner) = @_;
      for my $test (@TEST) {
          $runner->(@$test);
      }
  }
  
  sub run_server_tests {
      my($class, $server, $server_port, $http_port, %args) = @_;
  
      if (ref $server ne 'CODE') {
          my $server_class = $server;
          $server = sub {
              my($port, $app) = @_;
              my $server = Plack::Loader->load($server_class, port => $port, host => "127.0.0.1", %args);
              $app = Plack::Middleware::Lint->wrap($app);
              $server->run($app);
          }
      }
  
      test_tcp(
          client => sub {
              my $port = shift;
  
              my $ua = LWP::UserAgent->new;
              for my $i (0..$#TEST) {
                  my $test = $TEST[$i];
                  note $test->[0];
                  my $cb = sub {
                      my $req = shift;
                      $req->uri->port($http_port || $port);
                      $req->uri->path(($ENV{PLACK_TEST_SCRIPT_NAME}||"") . $req->uri->path);
                      $req->header('X-Plack-Test' => $i);
                      return $ua->request($req);
                  };
  
                  $test->[1]->($cb);
              }
          },
          server => sub {
              my $port = shift;
              my $app  = $class->test_app_handler;
              $server->($port, $app);
              exit(0); # for Test::TCP
          },
          port => $server_port,
      );
  }
  
  sub test_app_handler {
      return sub {
          my $env = shift;
          $TEST[$env->{HTTP_X_PLACK_TEST}][2]->($env);
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Test::Suite - Test suite for Plack handlers
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Plack::Test::Suite;
    Plack::Test::Suite->run_server_tests('Your::Handler');
    done_testing;
  
  =head1 DESCRIPTION
  
  Plack::Test::Suite is a test suite to test a new PSGI server
  implementation. It automatically loads a new handler environment and
  uses LWP to send HTTP requests to the local server to make sure your
  handler implements the PSGI specification correctly.
  
  Note that the handler name doesn't include the C<Plack::Handler::>
  prefix, i.e. if you have a new Plack handler Plack::Handler::Foo, your
  test script would look like:
  
    Plack::Test::Suite->run_server_tests('Foo');
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  Kazuho Oku
  
  =cut
  
  END_MARK_FOR_TESTING
PLACK_TEST_SUITE

$fatpacked{"Plack/Util.pm"} = <<'PLACK_UTIL';
  package Plack::Util;
  use strict;
  use Carp ();
  use Scalar::Util;
  use IO::Handle;
  use overload ();
  
  sub TRUE()  { 1==1 }
  sub FALSE() { !TRUE }
  
  sub load_class {
      my($class, $prefix) = @_;
  
      if ($prefix) {
          unless ($class =~ s/^\+// || $class =~ /^$prefix/) {
              $class = "$prefix\::$class";
          }
      }
  
      my $file = $class;
      $file =~ s!::!/!g;
      require "$file.pm"; ## no critic
  
      return $class;
  }
  
  sub is_real_fh ($) {
      my $fh = shift;
  
      {
          no warnings 'uninitialized';
          return FALSE if -p $fh or -c _ or -b _;
      }
  
      my $reftype = Scalar::Util::reftype($fh) or return;
      if (   $reftype eq 'IO'
          or $reftype eq 'GLOB' && *{$fh}{IO}
      ) {
          # if it's a blessed glob make sure to not break encapsulation with
          # fileno($fh) (e.g. if you are filtering output then file descriptor
          # based operations might no longer be valid).
          # then ensure that the fileno *opcode* agrees too, that there is a
          # valid IO object inside $fh either directly or indirectly and that it
          # corresponds to a real file descriptor.
          my $m_fileno = $fh->fileno;
          return FALSE unless defined $m_fileno;
          return FALSE unless $m_fileno >= 0;
  
          my $f_fileno = fileno($fh);
          return FALSE unless defined $f_fileno;
          return FALSE unless $f_fileno >= 0;
          return TRUE;
      } else {
          # anything else, including GLOBS without IO (even if they are blessed)
          # and non GLOB objects that look like filehandle objects cannot have a
          # valid file descriptor in fileno($fh) context so may break.
          return FALSE;
      }
  }
  
  sub set_io_path {
      my($fh, $path) = @_;
      bless $fh, 'Plack::Util::IOWithPath';
      $fh->path($path);
  }
  
  sub content_length {
      my $body = shift;
  
      return unless defined $body;
  
      if (ref $body eq 'ARRAY') {
          my $cl = 0;
          for my $chunk (@$body) {
              $cl += length $chunk;
          }
          return $cl;
      } elsif ( is_real_fh($body) ) {
          return (-s $body) - tell($body);
      }
  
      return;
  }
  
  sub foreach {
      my($body, $cb) = @_;
  
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      } else {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
  }
  
  sub class_to_file {
      my $class = shift;
      $class =~ s!::!/!g;
      $class . ".pm";
  }
  
  sub _load_sandbox {
      my $_file = shift;
  
      my $_package = $_file;
      $_package =~ s/([^A-Za-z0-9_])/sprintf("_%2x", unpack("C", $1))/eg;
  
      _file_zero_check($_file) if $ENV{PLACK_ENV} eq 'development';
  
      local $0 = $_file; # so FindBin etc. works
      local @ARGV = ();  # Some frameworks might try to parse @ARGV
  
      return eval sprintf <<'END_EVAL', $_package;
  package Plack::Sandbox::%s;
  {
      my $app = do $_file;
      if ( !$app && ( my $error = $@ || $! )) { die $error; }
      $app;
  }
  END_EVAL
  }
  
  sub _file_zero_check {
      my $file = shift;
      open my $fh, "<", $file or return;
  
      my $code = join '', <$fh>;
      if ($code =~ /(__FILE__\s+eq\s+\$0|\$0\s+eq\s+__FILE__)/) {
          warn <<WARNING
  Your PSGI file ($file) seems to use the following idiom, which is known to be broken since Plack 0.9971:
  
    if ($1) {
        called_from_cmdline();
    }
  
  because now \$0 is _always_ localized to the PSGI file path you're evaluating. You should switch to other alternatives such as `unless (caller) {}`. See http://bit.ly/psgi-file-0 for details.
  
  This friendly warning and the code to generate this runs only when the Plack environment (-E) is set to 'development', and will go away in the next major release of Plack.
  
  WARNING
      }
  }
  
  sub load_psgi {
      my $stuff = shift;
  
      local $ENV{PLACK_ENV} = $ENV{PLACK_ENV} || 'development';
  
      my $file = $stuff =~ /^[a-zA-Z0-9\_\:]+$/ ? class_to_file($stuff) : $stuff;
      my $app = _load_sandbox($file);
      die "Error while loading $file: $@" if $@;
  
      return $app->to_app if $app and Scalar::Util::blessed($app) and $app->can('to_app');
      return $app;
  }
  
  sub run_app($$) {
      my($app, $env) = @_;
  
      return eval { $app->($env) } || do {
          my $body = "Internal Server Error";
          $env->{'psgi.errors'}->print($@);
          [ 500, [ 'Content-Type' => 'text/plain', 'Content-Length' => length($body) ], [ $body ] ];
      };
  }
  
  sub headers {
      my $headers = shift;
      inline_object(
          iter   => sub { header_iter($headers, @_) },
          get    => sub { header_get($headers, @_) },
          set    => sub { header_set($headers, @_) },
          push   => sub { header_push($headers, @_) },
          exists => sub { header_exists($headers, @_) },
          remove => sub { header_remove($headers, @_) },
          headers => sub { $headers },
      );
  }
  
  sub header_iter {
      my($headers, $code) = @_;
  
      my @headers = @$headers; # copy
      while (my($key, $val) = splice @headers, 0, 2) {
          $code->($key, $val);
      }
  }
  
  sub header_get {
      my($headers, $key) = (shift, lc shift);
  
      my @val;
      header_iter $headers, sub {
          push @val, $_[1] if lc $_[0] eq $key;
      };
  
      return wantarray ? @val : $val[0];
  }
  
  sub header_set {
      my($headers, $key, $val) = @_;
  
      my($set, @new_headers);
      header_iter $headers, sub {
          if (lc $key eq lc $_[0]) {
              return if $set;
              $_[1] = $val;
              $set++;
          }
          push @new_headers, $_[0], $_[1];
      };
  
      push @new_headers, $key, $val unless $set;
      @$headers = @new_headers;
  }
  
  sub header_push {
      my($headers, $key, $val) = @_;
      push @$headers, $key, $val;
  }
  
  sub header_exists {
      my($headers, $key) = (shift, lc shift);
  
      my $exists;
      header_iter $headers, sub {
          $exists = 1 if lc $_[0] eq $key;
      };
  
      return $exists;
  }
  
  sub header_remove {
      my($headers, $key) = (shift, lc shift);
  
      my @new_headers;
      header_iter $headers, sub {
          push @new_headers, $_[0], $_[1]
              unless lc $_[0] eq $key;
      };
  
      @$headers = @new_headers;
  }
  
  sub status_with_no_entity_body {
      my $status = shift;
      return $status < 200 || $status == 204 || $status == 304;
  }
  
  sub encode_html {
      my $str = shift;
      $str =~ s/&/&amp;/g;
      $str =~ s/>/&gt;/g;
      $str =~ s/</&lt;/g;
      $str =~ s/"/&quot;/g;
      $str =~ s/'/&#39;/g;
      return $str;
  }
  
  sub inline_object {
      my %args = @_;
      bless \%args, 'Plack::Util::Prototype';
  }
  
  sub response_cb {
      my($res, $cb) = @_;
  
      my $body_filter = sub {
          my($cb, $res) = @_;
          my $filter_cb = $cb->($res);
          # If response_cb returns a callback, treat it as a $body filter
          if (defined $filter_cb && ref $filter_cb eq 'CODE') {
              Plack::Util::header_remove($res->[1], 'Content-Length');
              if (defined $res->[2]) {
                  if (ref $res->[2] eq 'ARRAY') {
                      for my $line (@{$res->[2]}) {
                          $line = $filter_cb->($line);
                      }
                      # Send EOF.
                      my $eof = $filter_cb->( undef );
                      push @{ $res->[2] }, $eof if defined $eof;
                  } else {
                      my $body    = $res->[2];
                      my $getline = sub { $body->getline };
                      $res->[2] = Plack::Util::inline_object
                          getline => sub { $filter_cb->($getline->()) },
                          close => sub { $body->close };
                  }
              } else {
                  return $filter_cb;
              }
          }
      };
  
      if (ref $res eq 'ARRAY') {
          $body_filter->($cb, $res);
          return $res;
      } elsif (ref $res eq 'CODE') {
          return sub {
              my $respond = shift;
              my $cb = $cb;  # To avoid the nested closure leak for 5.8.x
              $res->(sub {
                  my $res = shift;
                  my $filter_cb = $body_filter->($cb, $res);
                  if ($filter_cb) {
                      my $writer = $respond->($res);
                      if ($writer) {
                          return Plack::Util::inline_object
                              write => sub { $writer->write($filter_cb->(@_)) },
                              close => sub {
                                  my $chunk = $filter_cb->(undef);
                                  $writer->write($chunk) if defined $chunk;
                                  $writer->close;
                              };
                      }
                  } else {
                      return $respond->($res);
                  }
              });
          };
      }
  
      return $res;
  }
  
  package Plack::Util::Prototype;
  
  our $AUTOLOAD;
  sub can {
      $_[0]->{$_[1]};
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $attr = $AUTOLOAD;
      $attr =~ s/.*://;
      if (ref($self->{$attr}) eq 'CODE') {
          $self->{$attr}->(@_);
      } else {
          Carp::croak(qq/Can't locate object method "$attr" via package "Plack::Util::Prototype"/);
      }
  }
  
  sub DESTROY { }
  
  package Plack::Util::IOWithPath;
  use parent qw(IO::Handle);
  
  sub path {
      my $self = shift;
      if (@_) {
          ${*$self}{+__PACKAGE__} = shift;
      }
      ${*$self}{+__PACKAGE__};
  }
  
  package Plack::Util;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util - Utility subroutines for Plack server and framework developers
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item TRUE, FALSE
  
    my $true  = Plack::Util::TRUE;
    my $false = Plack::Util::FALSE;
  
  Utility constants to include when you specify boolean variables in C<$env> hash (e.g. C<psgi.multithread>).
  
  =item load_class
  
    my $class = Plack::Util::load_class($class [, $prefix ]);
  
  Constructs a class name and C<require> the class. Throws an exception
  if the .pm file for the class is not found, just with the built-in
  C<require>.
  
  If C<$prefix> is set, the class name is prepended to the C<$class>
  unless C<$class> begins with C<+> sign, which means the class name is
  already fully qualified.
  
    my $class = Plack::Util::load_class("Foo");                   # Foo
    my $class = Plack::Util::load_class("Baz", "Foo::Bar");       # Foo::Bar::Baz
    my $class = Plack::Util::load_class("+XYZ::ZZZ", "Foo::Bar"); # XYZ::ZZZ
  
  =item is_real_fh
  
    if ( Plack::Util::is_real_fh($fh) ) { }
  
  returns true if a given C<$fh> is a real file handle that has a file
  descriptor. It returns false if C<$fh> is PerlIO handle that is not
  really related to the underlying file etc.
  
  =item content_length
  
    my $cl = Plack::Util::content_length($body);
  
  Returns the length of content from body if it can be calculated. If
  C<$body> is an array ref it's a sum of length of each chunk, if
  C<$body> is a real filehandle it's a remaining size of the filehandle,
  otherwise returns undef.
  
  =item set_io_path
  
    Plack::Util::set_io_path($fh, "/path/to/foobar.txt");
  
  Sets the (absolute) file path to C<$fh> filehandle object, so you can
  call C<< $fh->path >> on it. As a side effect C<$fh> is blessed to an
  internal package but it can still be treated as a normal file
  handle.
  
  This module doesn't normalize or absolutize the given path, and is
  intended to be used from Server or Middleware implementations. See
  also L<IO::File::WithPath>.
  
  =item foreach
  
    Plack::Util::foreach($body, $cb);
  
  Iterate through I<$body> which is an array reference or
  IO::Handle-like object and pass each line (which is NOT really
  guaranteed to be a I<line>) to the callback function.
  
  It internally sets the buffer length C<$/> to 4096 in case it reads
  the binary file, unless otherwise set in the caller's code.
  
  =item load_psgi
  
    my $app = Plack::Util::load_psgi $psgi_file_or_class;
  
  Load C<app.psgi> file or a class name (like C<MyApp::PSGI>) and
  require the file to get PSGI application handler. If the file can't be
  loaded (e.g. file doesn't exist or has a perl syntax error), it will
  throw an exception.
  
  B<Security>: If you give this function a class name or module name
  that is loadable from your system, it will load the module. This could
  lead to a security hole:
  
    my $psgi = ...; # user-input: consider "Moose.pm"
    $app = Plack::Util::load_psgi($psgi); # this does 'require "Moose.pm"'!
  
  Generally speaking, passing an external input to this function is
  considered very insecure. But if you really want to do that, be sure
  to validate the argument passed to this function. Also, if you do not
  want to accept an arbitrary class name but only load from a file path,
  make sure that the argument C<$psgi_file_or_class> begins with C</> so
  that Perl's built-in do function won't search the include path.
  
  =item run_app
  
    my $res = Plack::Util::run_app $app, $env;
  
  Runs the I<$app> by wrapping errors with I<eval> and if an error is
  found, logs it to C<< $env->{'psgi.errors'} >> and returns the
  template 500 Error response.
  
  =item header_get, header_exists, header_set, header_push, header_remove
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
  
    my $v = Plack::Util::header_get($hdrs, $key); # First found only
    my @v = Plack::Util::header_get($hdrs, $key);
    my $bool = Plack::Util::header_exists($hdrs, $key);
    Plack::Util::header_set($hdrs, $key, $val);   # overwrites existent header
    Plack::Util::header_push($hdrs, $key, $val);
    Plack::Util::header_remove($hdrs, $key);
  
  Utility functions to manipulate PSGI response headers array
  reference. The methods that read existent header value handles header
  name as case insensitive.
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
    my $v = Plack::Util::header_get($hdrs, 'content-type'); # 'text/plain'
  
  =item headers
  
    my $headers = [ 'Content-Type' => 'text/plain' ];
  
    my $h = Plack::Util::headers($headers);
    $h->get($key);
    if ($h->exists($key)) { ... }
    $h->set($key => $val);
    $h->push($key => $val);
    $h->remove($key);
    $h->headers; # same reference as $headers
  
  Given a header array reference, returns a convenient object that has
  an instance methods to access C<header_*> functions with an OO
  interface. The object holds a reference to the original given
  C<$headers> argument and updates the reference accordingly when called
  write methods like C<set>, C<push> or C<remove>. It also has C<headers>
  method that would return the same reference.
  
  =item status_with_no_entity_body
  
    if (status_with_no_entity_body($res->[0])) { }
  
  Returns true if the given status code doesn't have any Entity body in
  HTTP response, i.e. it's 100, 101, 204 or 304.
  
  =item inline_object
  
    my $o = Plack::Util::inline_object(
        write => sub { $h->push_write(@_) },
        close => sub { $h->push_shutdown },
    );
    $o->write(@stuff);
    $o->close;
  
  Creates an instant object that can react to methods passed in the
  constructor. Handy to create when you need to create an IO stream
  object for input or errors.
  
  =item response_cb
  
  See L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =cut
  
  
  
PLACK_UTIL

$fatpacked{"Plack/Util/Accessor.pm"} = <<'PLACK_UTIL_ACCESSOR';
  package Plack::Util::Accessor;
  use strict;
  use warnings;
  
  sub import {
      shift;
      return unless @_;
      my $package = caller();
      mk_accessors( $package, @_ );
  }
  
  sub mk_accessors {
      my $package = shift;
      no strict 'refs';
      foreach my $field ( @_ ) {
          *{ $package . '::' . $field } = sub {
              return $_[0]->{ $field } if scalar( @_ ) == 1;
              return $_[0]->{ $field }  = scalar( @_ ) == 2 ? $_[1] : [ @_[1..$#_] ];
          };
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util::Accessor - Accessor generation utility for Plack
  
  =head1 DESCRIPTION
  
  This module is just a simple accessor generator for Plack to replace
  the Class::Accessor::Fast usage and so our classes don't have to inherit
  from their accessor generator.
  
  =head1 SEE ALSO
  
  L<PSGI> L<http://plackperl.org/>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_UTIL_ACCESSOR

$fatpacked{"Role/Tiny.pm"} = <<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings FATAL => 'all';
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  
  # inlined from Moo::_Utils - update that first.
  
  sub _load_module {
    (my $proto = $_[0]) =~ s/::/\//g;
    return 1 if $INC{"${proto}.pm"};
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1 if grep !/::$/, keys %{_getstash($_[0])||{}};
    { local $@; require "${proto}.pm"; }
    return 1;
  }
  
  { # \[] is REF, not SCALAR. \v1 is VSTRING (thanks to doy for that one)
    my %reftypes = map +($_ => 1), qw(SCALAR REF VSTRING);
    sub _is_scalar_ref { $reftypes{ref($_[0])} }
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strictures->import;
    return if $INFO{$target}; # already exported into this package
    # get symbol table reference
    my $stash = do { no strict 'refs'; \%{"${target}::"} };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        { local $@; require Class::Method::Modifiers; }
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
    };
    *{_getglob "${target}::with"} = sub {
      die "Only one role supported at a time by with" if @_ > 1;
      $me->apply_role_to_package($target, $_[0]);
    };
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later)
    @{$INFO{$target}{not_methods}={}}{
      '', map { *$_{CODE}||() } grep !_is_scalar_ref($_), values %$stash
    } = ();
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
  }
  
  sub apply_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    die "This is apply_role_to_package" if ref($to);
    die "${role} is not a Role::Tiny" unless my $info = $INFO{$role};
  
    $me->_check_requires($to, $role, @{$info->{requires}||[]});
  
    $me->_install_methods($to, $role);
  
    $me->_install_modifiers($to, $info->{modifiers});
  
    # only add does() method to classes and only if they don't have one
    if (not $INFO{$to} and not $to->can('does')) {
      *{_getglob "${to}::does"} = \&does_role;
    }
  
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    die "No roles supplied!" unless @roles;
    my $class = ref($object);
    bless($object, $me->create_class_with_roles($class, @roles));
    $object;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    die "No roles supplied!" unless @roles;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      die "${role} is not a Role::Tiny" unless my $info = $INFO{$role};
    }
  
    if ($] >= 5.010) {
      { local $@; require mro; }
    } else {
      { local $@; require MRO::Compat; }
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    my @info = map +($INFO{$_} ? $INFO{$_} : ()), @roles;
  
    $me->_check_requires(
      $new_name, $compose_name,
      do { my %h; @h{map @{$_->{requires}||[]}, @info} = (); keys %h }
    );
  
    *{_getglob "${new_name}::does"} = \&does_role unless $new_name->can('does');
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    *{_getglob("${composed_name}::ISA")} = [ $base_name ];
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    foreach my $modified (
      do { my %h; @h{map $_->[1], @$modifiers} = (); keys %h }
    ) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      die "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    $me->_install_modifiers($composed_name, $modifiers);
    $COMPOSED{role}{$composed_name} = 1;
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, @requires) = @_;
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        die "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    $info->{methods} ||= do {
      # grab role symbol table
      my $stash = do { no strict 'refs'; \%{"${role}::"}};
      my $not_methods = $info->{not_methods};
      +{
        # grab all code entries that aren't in the not_methods list
        map {
          my $code = *{$stash->{$_}}{CODE};
          # rely on the '' key we added in import for "no code here"
          exists $not_methods->{$code||''} ? () : ($_ => $code)
        } grep !_is_scalar_ref($stash->{$_}), keys %$stash
      };
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    die "${role} is not a Role::Tiny" unless my $info = $INFO{$role};
    (keys %{$me->_concrete_methods_of($role)}, @{$info->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = do { no strict 'refs'; \%{"${to}::"}};
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(_is_scalar_ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      *{_getglob "${to}::${i}"} = $methods->{$i};
    }
  }
  
  sub _install_modifiers {
    my ($me, $to, $modifiers) = @_;
    if (my $info = $INFO{$to}) {
      push @{$info->{modifiers}}, @{$modifiers||[]};
    } else {
      foreach my $modifier (@{$modifiers||[]}) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    return exists $APPLIED_TO{ref($proto)||$proto}{$role};
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cusine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   1;
  
  else where
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where first wins.  In a more complete
  system (see L<Moose>) roles are checked to see if they clash.  The goal of this
  is to be much simpler, hence disallowing composition of multiple roles at once.
  
  =head1 METHODS
  
  =head2 apply_role_to_package
  
   Role::Tiny->apply_role_to_package('Some::Package', 'Some::Role');
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly.  Object is reblessed into the
  resulting class.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does_role('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  Composes another role into the current role.  Only one role may be composed in
  at a time to allow the code to remain as simple as possible.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = <<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings FATAL => 'all';
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_role_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = <<'SUB_DEFER';
  package Sub::Defer;
  
  use strictures 1;
  use base qw(Exporter);
  use Moo::_Utils;
  
  our @EXPORT = qw(defer_sub undefer_sub);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
      *{_getglob($target)} = $made;
    }
    push @{$DEFERRED{$made} = $DEFERRED{$deferred}}, $made;
  
    return $made;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    $DEFERRED{$deferred||''};
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_string;
    my $deferred = sub {
      goto &{$undeferred ||= undefer_sub($deferred_string)};
    };
    $deferred_string = "$deferred";
    $DEFERRED{$deferred} = [ $target, $maker, \$undeferred ];
    *{_getglob $target} = $deferred if defined($target);
    return $deferred;
  }
  
  1;
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
SUB_DEFER

$fatpacked{"Sub/Quote.pm"} = <<'SUB_QUOTE';
  package Sub::Quote;
  
  use strictures 1;
  
  sub _clean_eval { eval $_[0] }
  
  use Sub::Defer;
  use B 'perlstring';
  use Scalar::Util qw(weaken);
  use base qw(Exporter);
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub);
  
  our %QUOTE_OUTSTANDING;
  
  our %QUOTED;
  
  our %WEAK_REFS;
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if (my ($code_args, $body) = $code =~ / +my \(([^)]+)\) = \@_;(.*)$/s) {
      if ($code_args eq $args) {
        $do.$body.' }'
      } else {
        $do.'my ('.$code_args.') = ('.$args.'); '.$body.' }';
      }
    } else {
      $do.($local ? 'local ' : '').'@_ = ('.$args.'); '.$code.' }';
    }
  }
  
  sub _unquote_all_outstanding {
    return unless %QUOTE_OUTSTANDING;
    my ($assembled_code, @assembled_captures, @localize_these) = '';
    # we sort the keys in order to make debugging more predictable
    foreach my $outstanding (sort keys %QUOTE_OUTSTANDING) {
      my ($name, $code, $captures) = @{$QUOTE_OUTSTANDING{$outstanding}};
  
      push @localize_these, $name if $name;
  
      my $make_sub = "{\n";
  
      if (keys %$captures) {
        my $ass_cap_count = @assembled_captures;
        $make_sub .= capture_unroll("\$_[1][${ass_cap_count}]", $captures, 2);
        push @assembled_captures, $captures;
      }
  
      my $o_quoted = perlstring $outstanding;
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$Sub::Quote::QUOTED{${o_quoted}}[3] = sub {\n"
      );
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$Sub::Quote::QUOTED{${o_quoted}}[3] = \\&${name}\n";
      }
      $make_sub .= "}\n";
      $assembled_code .= $make_sub;
    }
    my $debug_code = $assembled_code;
    if (@localize_these) {
      $debug_code =
        "# localizing: ".join(', ', @localize_these)."\n"
        .$assembled_code;
      $assembled_code = join("\n",
        (map { "local *${_};" } @localize_these),
        'eval '.perlstring($assembled_code).'; die $@ if $@;'
      );
    } else {
      $ENV{SUB_QUOTE_DEBUG} && warn $assembled_code;
    }
    $assembled_code .= "\n1;";
    {
      local $@;
      unless (_clean_eval $assembled_code, \@assembled_captures) {
        die "Eval went very, very wrong:\n\n${debug_code}\n\n$@";
      }
    }
    $ENV{SUB_QUOTE_DEBUG} && warn $debug_code;
    %QUOTE_OUTSTANDING = ();
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = pop if ref($_[-1]) eq 'HASH';
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my $outstanding;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      unquote_sub($outstanding);
    };
    $outstanding = "$deferred";
    $QUOTE_OUTSTANDING{$outstanding} = $QUOTED{$outstanding} = [
      $name, $code, $captures
    ];
    weaken($WEAK_REFS{$outstanding} = $deferred);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    $WEAK_REFS{$sub||''} and $QUOTED{$sub||''};
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    _unquote_all_outstanding;
    $QUOTED{$sub}[3];
  }
  
  1;
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  See the L</SYNOPSIS>'s C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.  Note that for performance
  reasons all quoted subs declared so far will be globally unquoted/parsed in
  a single eval. This means that if you have a syntax error in one of your
  quoted subs you may find out when some other sub is unquoted.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll {
     '$x' => 1,
     '$y' => 2,
   };
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll {
     '$x' => 1,
     '$y' => 2,
   };
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  The keys are the names of the variables and the values are (duh)
  the values.  Note that references work as values.
SUB_QUOTE

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  
  use strict;
  #use warnings;
  
  use vars qw(@EXPORT @EXPORT_OK $VERSION @ISA);
  
  BEGIN {
  	require Exporter;
  	@ISA = qw(Exporter);
  }
  
  $VERSION = "0.11";
  
  $VERSION = eval $VERSION;
  
  @EXPORT = @EXPORT_OK = qw(try catch finally);
  
  $Carp::Internal{+__PACKAGE__}++;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
  	my ( $try, @code_refs ) = @_;
  
  	# we need to save this here, the eval block will be in scalar context due
  	# to $failed
  	my $wantarray = wantarray;
  
  	my ( $catch, @finally );
  
  	# find labeled blocks in the argument list.
  	# catch and finally tag the blocks by blessing a scalar reference to them.
  	foreach my $code_ref (@code_refs) {
  		next unless $code_ref;
  
  		my $ref = ref($code_ref);
  
  		if ( $ref eq 'Try::Tiny::Catch' ) {
  			$catch = ${$code_ref};
  		} elsif ( $ref eq 'Try::Tiny::Finally' ) {
  			push @finally, ${$code_ref};
  		} else {
  			use Carp;
  			confess("Unknown code ref type given '${ref}'. Check your usage & try again");
  		}
  	}
  
  	# save the value of $@ so we can set $@ back to it in the beginning of the eval
  	my $prev_error = $@;
  
  	my ( @ret, $error, $failed );
  
  	# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
  	# not perfect, but we could provide a list of additional errors for
  	# $catch->();
  
  	{
  		# localize $@ to prevent clobbering of previous value by a successful
  		# eval.
  		local $@;
  
  		# failed will be true if the eval dies, because 1 will not be returned
  		# from the eval body
  		$failed = not eval {
  			$@ = $prev_error;
  
  			# evaluate the try block in the correct context
  			if ( $wantarray ) {
  				@ret = $try->();
  			} elsif ( defined $wantarray ) {
  				$ret[0] = $try->();
  			} else {
  				$try->();
  			};
  
  			return 1; # properly set $fail to false
  		};
  
  		# copy $@ to $error; when we leave this scope, local $@ will revert $@
  		# back to its previous value
  		$error = $@;
  	}
  
  	# set up a scope guard to invoke the finally block at the end
  	my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
  	# at this point $failed contains a true value if the eval died, even if some
  	# destructor overwrote $@ as the eval was unwinding.
  	if ( $failed ) {
  		# if we got an error, invoke the catch block.
  		if ( $catch ) {
  			# This works like given($error), but is backwards compatible and
  			# sets $_ in the dynamic scope for the body of C<$catch>
  			for ($error) {
  				return $catch->($error);
  			}
  
  			# in case when() was used without an explicit return, the C<for>
  			# loop will be aborted and there's no useful return value
  		}
  
  		return;
  	} else {
  		# no failure, $@ is back to what it was, everything is fine
  		return $wantarray ? @ret : $ret[0];
  	}
  }
  
  sub catch (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Catch'),
  		@rest,
  	);
  }
  
  sub finally (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Finally'),
  		@rest,
  	);
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my @guts = @{ shift() };
      my $code = shift @guts;
      $code->(@guts);
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper localization of $@
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
  	# handle errors with a catch handler
  	try {
  		die "foo";
  	} catch {
  		warn "caught error: $_"; # not $@
  	};
  
  You can also use it like a stanalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
  	# just silence errors
  	try {
  		die "foo";
  	};
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the try block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L<BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the try block dies, it returns the value of the last statement executed in
  the catch block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following two examples both
  assign C<"bar"> to C<$x>.
  
  	my $x = try { die "foo" } catch { "bar" };
  
  	my $x = eval { die "foo" } || "bar";
  
  You can add finally blocks making the following true.
  
  	my $x;
  	try { die 'foo' } finally { $x = 'bar' };
  	try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  Finally blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many finally blocks to a
  given try block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory try subroutine, an optional catch subroutine & finally
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the finally block if given will execute.
  
  =item catch (&;$)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
  	catch { ... }
  
  Inside the catch block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
  	local $@ = $_;
  
  =item finally (&;$)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. Finally blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the finally block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the finally block does not
  localize C<$_> with the error, since unlike in a catch block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the finally block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an eval block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (before
  the localization) in the beginning of the C<eval> block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an eval block C<die> behaves sort of like:
  
  	sub die {
  		$@ = $_[0];
  		return_undef_from_eval();
  	}
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
  	my $error = do {
  		local $@;
  		eval { ... };
  		$@;
  	};
  
  	...
  	die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
  	if ( $@ ) {
  		...
  	}
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
  	sub Object::DESTROY {
  		eval { ... }
  	}
  
  	eval {
  		my $obj = Object->new;
  
  		die "foo";
  	};
  
  	if ( $@ ) {
  
  	}
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the eval was aborted due to an error:
  
  	my $failed = not eval {
  		...
  
  		return 1;
  	};
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
  	try {
  		require Foo;
  	} catch {
  		when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
  		default { die $_ }
  	};
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
  	sub foo {
  		my ( $self, @args ) = @_;
  		try { $self->bar(@args) }
  	}
  
  or
  
  	sub bar_in_place {
  		my $self = shift;
  		my $args = \@_;
  		try { $_ = $self->bar($_) for @$args }
  	}
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
        try {
            die;
        }
        catch {
            return;
        };
  
        say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
        my $success = try {
            die;
            1;
        }
        return unless $success;
  
        say "This text WILL NEVER appear!";
    }
  
  Note that if you have a catch block, it must return undef for this to work,
  since if a catch block exists, its return value is returned in place of undef
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
  	my $obj = try {
  		MightFail->new;
  	} catch {
  		...
  
  		return; # avoid returning a true value;
  	};
  
  	return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
  	given ($foo) {
  		when (...) {
  			try {
  				...
  			} catch {
  				warn $_; # will print $foo, not the error
  				warn $_[0]; # instead, get the error like this
  			}
  		}
  	}
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://nothingmuch.woobling.org/talks/takahashi.xul?data=yapc_asia_2009/try_tiny.txt>
  
  Or read the source:
  
  L<http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/nothingmuch/try-tiny/>
  
  =head1 AUTHOR
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2009 Yuval Kogman. All rights reserved.
  	This program is free software; you can redistribute
  	it and/or modify it under the terms of the MIT license.
  
  =cut
  
TRY_TINY

$fatpacked{"Twiggy.pm"} = <<'TWIGGY';
  package Twiggy;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.1010';
  
  1;
  __END__
  
  =head1 NAME
  
  Twiggy - AnyEvent HTTP server for PSGI (like Thin)
  
  =head1 SYNOPSIS
  
    twiggy --listen :8080
  
  See C<twiggy -h> for more details.
  
    use Twiggy::Server;
  
    my $server = Twiggy::Server->new(
        host => $host,
        port => $port,
    );
    $server->register_service($app);
  
    AE::cv->recv;
  
  =head1 DESCRIPTION
  
  Twiggy is a lightweight and fast HTTP server with unique features such
  as:
  
  =over 4
  
  =item PSGI
  
  Can run any PSGI applications. Fully supports I<psgi.nonblocking> and
  I<psgi.streaming> interfaces.
  
  =item AnyEvent
  
  This server uses AnyEvent and runs in a non-blocking event loop, so
  it's best to run event-driven web applications that runs I/O bound
  jobs or delayed responses such as long-poll, WebSocket or streaming
  content (server push).
  
  This software used to be called Plack::Server::AnyEvent but was
  renamed to Twiggy. See L</NAMING> for details.
  
  =item Fast header parser
  
  Uses XS/C based HTTP header parser for the best performance. (optional)
  
  =item Lightweight and Fast
  
  The memory required to run twiggy is 6MB and it can serve more than
  4500 req/s with a single process on Perl 5.10 with MacBook Pro 13"
  late 2009.
  
  =item Superdaemon aware
  
  Supports L<Server::Starter> for hot deploy and graceful restarts.
  
  =back
  
  =head1 NAMING
  
  =head2 Twiggy?
  
  Because it is like L<Thin|http://code.macournoyer.com/thin/>, Ruby's
  Rack web server using EventMachine. You know, Twiggy is thin :)
  
  =head2 Why the cute name instead of more descriptive namespace? Are you on drugs?
  
  I'm sick of naming Perl software like
  HTTP::Server::PSGI::How::Its::Written::With::What::Module and people
  call it HSPHIWWWM on IRC. It's hard to say on speeches and newbies
  would ask questions what they stand for every day. That's crazy.
  
  This module actually includes the longer alias and an empty subclass
  L<AnyEvent::Server::PSGI> for those who like to type more ::'s. It
  would actually help you find this software by searching for I<PSGI
  Server AnyEvent> on CPAN, which i believe is a good thing.
  
  Yes, maybe I'm on drugs. We'll see.
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  Yuval Kogman
  
  Hideki Yamamura
  
  Daisuke Maki
  
  =head1 SEE ALSO
  
  L<Plack> L<AnyEvent> L<Tatsumaki>
  
  =cut
TWIGGY

$fatpacked{"Twiggy/Server.pm"} = <<'TWIGGY_SERVER';
  package Twiggy::Server;
  use strict;
  use warnings;
  
  use Scalar::Util qw(blessed weaken);
  use Try::Tiny;
  use Carp;
  
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  use Errno qw(EAGAIN EINTR);
  use IO::Handle;
  
  use AnyEvent;
  use AnyEvent::Handle;
  use AnyEvent::Socket;
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  
  use HTTP::Status;
  use Plack::HTTPParser qw(parse_http_request);
  use Plack::Util;
  
  use constant DEBUG => $ENV{TWIGGY_DEBUG};
  use constant HAS_AIO => !$ENV{PLACK_NO_SENDFILE} && try {
      require AnyEvent::AIO;
      require IO::AIO;
      1;
  };
  
  open my $null_io, '<', \'';
  
  sub new {
      my($class, @args) = @_;
  
      return bless {
          no_delay => 1,
          timeout => 300,
          read_chunk_size => 4096,
          @args,
      }, $class;
  }
  
  sub start_listen {
      my ($self, $app) = @_;
      my @listen = @{$self->{listen} || [ ($self->{host} || '') . ":" . ($self->{port} || 0) ]};
      for my $listen (@listen) {
          push @{$self->{listen_guards}}, $self->_create_tcp_server($listen, $app);
      }
  }
  
  sub register_service {
      my($self, $app) = @_;
  
      $self->start_listen($app);
  
      $self->{exit_guard} = AE::cv {
          # Make sure that we are not listening on a socket anymore, while
          # other events are being flushed
          delete $self->{listen_guards};
      };
      $self->{exit_guard}->begin;
  }
  
  sub _create_tcp_server {
      my ( $self, $listen, $app ) = @_;
  
      my($host, $port, $is_tcp);
      if ($listen =~ /:\d+$/) {
          ($host, $port) = split /:/, $listen;
          $host = undef if $host eq '';
          $port = undef if $port == 0;
          $is_tcp = 1;
      } else {
          $host = "unix/";
          $port = $listen;
      }
  
      return tcp_server $host, $port, $self->_accept_handler($app, $is_tcp),
          $self->_accept_prepare_handler;
  }
  
  sub _accept_prepare_handler {
      my $self = shift;
      return sub {
          my ( $fh, $host, $port ) = @_;
          DEBUG && warn "Listening on $host:$port\n";
          $self->{prepared_host} = $host;
          $self->{prepared_port} = $port;
          $self->{server_ready}->({
              host => $host,
              port => $port,
              server_software => 'Twiggy',
          }) if $self->{server_ready};
  
          return $self->{backlog} || 0;
      };
  }
  
  sub _accept_handler {
      my ( $self, $app, $is_tcp ) = @_;
  
      return sub {
          my ( $sock, $peer_host, $peer_port ) = @_;
  
          DEBUG && warn "$sock Accepted connection from $peer_host:$peer_port\n";
          return unless $sock;
          $self->{exit_guard}->begin;
  
          if ( $is_tcp && $self->{no_delay} ) {
              setsockopt($sock, IPPROTO_TCP, TCP_NODELAY, 1)
                  or die "setsockopt(TCP_NODELAY) failed:$!";
          }
  
          my $headers = "";
          my $try_parse = sub {
              if ( $self->_try_read_headers($sock, $headers) ) {
                  my $env = {
                      SERVER_PORT         => $self->{prepared_port},
                      SERVER_NAME         => $self->{prepared_host},
                      SCRIPT_NAME         => '',
                      REMOTE_ADDR         => $peer_host,
                      'psgi.version'      => [ 1, 0 ],
                      'psgi.errors'       => *STDERR,
                      'psgi.url_scheme'   => 'http',
                      'psgi.nonblocking'  => Plack::Util::TRUE,
                      'psgi.streaming'    => Plack::Util::TRUE,
                      'psgi.run_once'     => Plack::Util::FALSE,
                      'psgi.multithread'  => Plack::Util::FALSE,
                      'psgi.multiprocess' => Plack::Util::FALSE,
                      'psgi.input'        => undef, # will be set by _run_app()
                      'psgix.io'          => $sock,
                      'psgix.input.buffered' => Plack::Util::TRUE,
                  };
  
                  my $reqlen = parse_http_request($headers, $env);
                  DEBUG && warn "$sock Parsed HTTP headers: request length=$reqlen\n";
  
                  if ( $reqlen < 0 ) {
                      die "bad request";
                  } else {
                      return $env;
                  }
              }
  
              return;
          };
  
          local $@;
          unless ( eval {
              if ( my $env = $try_parse->() ) {
                  # the request data is already available, no need to parse more
                  $self->_run_app($app, $env, $sock);
              } else {
                  # there's not yet enough data to parse the request,
                  # set up a watcher
                  $self->_create_req_parsing_watcher( $sock, $try_parse, $app );
              };
  
              1;
          }) {
              $self->_bad_request($sock);
          }
      };
  }
  
  # returns a closure that tries to parse
  # this is not a method because it needs a buffer per socket
  sub _try_read_headers {
      my ( $self, $sock, undef ) = @_;
  
      # FIXME add a timer to manage read timeouts
      local $/ = "\012";
  
      read_more: for my $headers ( $_[2] ) {
          if ( defined(my $line = <$sock>) ) {
              $headers .= $line;
  
              if ( $line eq "\015\012" or $line eq "\012" ) {
                  # got an empty line, we're done reading the headers
                  return 1;
              } else {
                  # try to read more lines using buffered IO
                  redo read_more;
              }
          } elsif ($! and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK ) {
              die $!;
          } elsif (!$!) {
              die "client disconnected";
          }
      }
  
      DEBUG && warn "$sock did not read to end of req, wait for more data to arrive\n";
      return;
  }
  
  sub _create_req_parsing_watcher {
      my ( $self, $sock, $try_parse, $app ) = @_;
  
      my $headers_io_watcher;
  
      my $timeout_timer = AE::timer $self->{timeout}, 0, sub {
          DEBUG && warn "$sock Timeout\n";
          undef $headers_io_watcher;
          undef $try_parse;
          undef $sock;
      } if $self->{timeout};
  
      $headers_io_watcher = AE::io $sock, 0, sub {
          try {
              if ( my $env = $try_parse->() ) {
                  undef $headers_io_watcher;
                  undef $timeout_timer;
                  $self->_run_app($app, $env, $sock);
              }
          } catch {
              undef $headers_io_watcher;
              undef $timeout_timer;
              $self->_bad_request($sock);
          }
      };
  }
  
  sub _bad_request {
      my ( $self, $sock ) = @_;
  
      return unless defined $sock and defined fileno $sock;
  
      $self->_write_psgi_response(
          $sock,
          [
              400,
              [ 'Content-Type' => 'text/plain' ],
              [ ],
          ],
      );
  
      return;
  }
  
  sub _read_chunk {
      my ($self, $sock, $remaining, $cb) = @_;
  
      my $data = '';
      my $read_chunk_size = $self->{read_chunk_size};
  
      my $try_read = sub {
          READ_MORE: {
              my $read_size = $remaining > $read_chunk_size ? $read_chunk_size : $remaining;
              my $rlen = read($sock, $data, $read_size, length($data));
  
              if (defined $rlen and $rlen > 0) {
                  $remaining -= $rlen;
  
                  if ($remaining <= 0) {
                      $cb->($data);
                      return 1;
                  } else {
                      redo READ_MORE;
                  }
              } elsif (defined $rlen) {
                  $cb->($data);
                  return 1;
              } elsif ($! and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
                  die $!;
              }
          }
  
          return;
      };
  
      unless ($try_read->()) {
          my $rw; $rw = AE::io($sock, 0, sub {
              try {
                  if ($try_read->()) {
                      undef $rw;
                  }
              } catch {
                  undef $rw;
                  $self->_bad_request($sock);
              };
          });
      }
  }
  
  sub _run_app {
      my($self, $app, $env, $sock) = @_;
  
      unless ($env->{'psgi.input'}) {
          if ($env->{CONTENT_LENGTH} && $env->{REQUEST_METHOD} =~ /^(?:POST|PUT)$/) {
              $self->_read_chunk($sock, $env->{CONTENT_LENGTH}, sub {
                  my ($data) = @_;
                  open my $input, '<', \$data;
                  $env->{'psgi.input'} = $input;
                  $self->_run_app($app, $env, $sock);
              });
              return;
          } else {
              $env->{'psgi.input'} = $null_io;
          }
      }
  
      my $res = Plack::Util::run_app $app, $env;
  
      if ( ref $res eq 'ARRAY' ) {
          $self->_write_psgi_response($sock, $res);
      } elsif ( blessed($res) and $res->isa("AnyEvent::CondVar") ) {
          Carp::carp("Returning AnyEvent condvar is deprecated and will be removed in the next release of Twiggy. Use the streaming callback interface intstead.");
          $res->cb(sub { $self->_write_psgi_response($sock, shift->recv) });
      } elsif ( ref $res eq 'CODE' ) {
          $res->(
              sub {
                  my $res = shift;
  
                  if ( @$res < 2 ) {
                      croak "Insufficient arguments";
                  } elsif ( @$res == 2 ) {
                      my ( $status, $headers ) = @$res;
  
                      $self->_flush($sock);
  
                      my $writer = Twiggy::Writer->new($sock, $self->{exit_guard});
  
                      my $buf = $self->_format_headers($status, $headers);
                      $writer->write($$buf);
  
                      return $writer;
                  } else {
                      my ( $status, $headers, $body, $post ) = @$res;
                      my $cv = $self->_write_psgi_response($sock, [ $status, $headers, $body ]);
                      $cv->cb(sub { $post->() }) if $post;
                  }
              },
              $sock,
          );
      } else {
          croak("Unknown response type: $res");
      }
  }
  
  sub _write_psgi_response {
      my ( $self, $sock, $res ) = @_;
  
      if ( ref $res eq 'ARRAY' ) {
          if ( scalar @$res == 0 ) {
              # no response
              $self->{exit_guard}->end;
              return;
          }
  
          my ( $status, $headers, $body ) = @$res;
  
          my $cv = AE::cv;
  
          $self->_write_headers( $sock, $status, $headers )->cb(sub {
              local $@;
              if ( eval { $_[0]->recv; 1 } ) {
                  $self->_write_body($sock, $body)->cb(sub {
                      shutdown $sock, 1;
                      close $sock;
                      $self->{exit_guard}->end;
                      local $@;
                      eval { $cv->send($_[0]->recv); 1 } or $cv->croak($@);
                  });
              }
          });
  
          return $cv;
      } else {
          no warnings 'uninitialized';
          warn "Unknown response type: $res";
          return $self->_write_psgi_response($sock, [ 204, [], [] ]);
      }
  }
  
  sub _write_headers {
      my ( $self, $sock, $status, $headers ) = @_;
  
      $self->_write_buf( $sock, $self->_format_headers($status, $headers) );
  }
  
  sub _format_headers {
      my ( $self, $status, $headers ) = @_;
  
      my $hdr = sprintf "HTTP/1.0 %d %s\015\012", $status, HTTP::Status::status_message($status);
  
      my $i = 0;
  
      my @delim = ("\015\012", ": ");
  
      foreach my $str ( @$headers ) {
          $hdr .= $str . $delim[++$i % 2];
      }
  
      $hdr .= "\015\012";
  
      return \$hdr;
  }
  
  # this flushes just the output buffer, not the input buffer (unlike
  # $handle->flush)
  sub _flush {
  	my ( $self, $sock ) = @_;
  
      local $| = 1;
      print $sock '';
  }
  
  # helper routine, similar to push write, but respects buffering, and refcounts
  # itself
  sub _write_buf {
      my($self, $socket, $data) = @_;
  
      no warnings 'uninitialized';
  
      # try writing immediately
      if ( (my $written = syswrite($socket, $$data)) < length($$data) ) {
          my $done = defined(wantarray) && AE::cv;
  
          # either the write failed or was incomplete
  
          if ( !defined($written) and $! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              # a real write error occured, like EPIPE
              $done->croak($!) if $done;
              return $done;
          }
  
          # the write was either incomplete or a non fatal error occured, so we
          # need to set up an IO watcher to wait until we can properly write
  
          my $length = length($$data);
  
          my $write_watcher;
          $write_watcher = AE::io $socket, 1, sub {
              write_more: {
                  my $out = syswrite($socket, $$data, $length - $written, $written);
  
                  if ( defined($out) ) {
                      $written += $out;
  
                      if ( $written == $length ) {
                          undef $write_watcher;
                          $done->send(1) if $done;
                      } else {
                          redo write_more;
                      }
                  } elsif ($! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
                      $done->croak($!) if $done;
                      undef $write_watcher;
                  }
              }
          };
  
          return $done;
      } elsif ( defined wantarray ) {
          my $done = AE::cv;
          $done->send(1);
          return $done;
      }
  }
  
  sub _write_body {
      my ( $self, $sock, $body ) = @_;
  
      if ( ref $body eq 'ARRAY' ) {
          my $buf = join "", @$body;
          return $self->_write_buf($sock, \$buf);
      } elsif ( Plack::Util::is_real_fh($body) ) {
          # real handles use nonblocking IO
          # either AIO or using watchers, with sendfile or with copying IO
          return $self->_write_real_fh($sock, $body);
      } elsif ( blessed($body) and $body->can("string_ref") ) {
          # optimize IO::String to not use its incredibly slow getline
          if ( my $pos = $body->tell ) {
              my $str = substr ${ $body->string_ref }, $pos;
              return $self->_write_buf($sock, \$str);
          } else {
              return $self->_write_buf($sock, $body->string_ref);
          }
      } else {
          return $self->_write_fh($sock, $body);
      }
  }
  
  # like Plack::Util::foreach, but nonblocking on the output
  # handle
  sub _write_fh {
      my ( $self, $sock, $body ) = @_;
  
      my $handle = AnyEvent::Handle->new( fh => $sock );
      my $ret = AE::cv;
  
      $handle->on_error(sub {
          my $err = $_[2];
          $handle->destroy;
          $ret->send($err);
      });
  
      no warnings 'recursion';
      $handle->on_drain( $self->_drain($body, $ret) );
  
      return $ret;
  }
  
  sub _drain {
      my ($self, $body, $ret) = @_;
      return sub {
          my $handle = shift;
          local $/ = \ $self->{read_chunk_size};
          if ( defined( my $buf = $body->getline ) ) {
              if (length($buf)) {
                  $handle->push_write($buf);
              }
              else {
                  # if on_drain is called and we don't do any
                  # push_write, anyevent::handle thinks we are done.
                  # this fails for the deflater mw, since one 4096 chunk
                  # of getline might not generate a deflated packet yet,
                  # which gets us an empty string here.
                  return $self->_drain($body, $ret)->($handle);
              }
          } elsif ( $! ) {
              $ret->croak($!);
              $handle->destroy;
          } else {
              $body->close;
              $handle->on_drain(sub {
                  shutdown $handle->fh, 1;
                  $handle->destroy;
                  $ret->send(1);
              });
          }
  
      }
  }
  
  # when the body handle is a real filehandle we use this routine, which is more
  # careful not to block when reading the response too
  
  # FIXME support only reading $length bytes from $body, instead of until EOF
  # FIXME use len = 0 param to sendfile
  # FIXME use Sys::Sendfile in nonblocking mode if AIO is not available
  # FIXME test sendfile on non file backed handles
  sub _write_real_fh {
      my ( $self, $sock, $body ) = @_;
  
      if ( HAS_AIO and -s $body ) {
          my $cv = AE::cv;
          my $offset = 0;
          my $length = -s $body;
          $sock->blocking(1);
          my $sendfile; $sendfile = sub {
              IO::AIO::aio_sendfile( $sock, $body, $offset, $length - $offset, sub {
                  my $ret = shift;
                  $offset += $ret if $ret > 0;
                  if ($offset >= $length || ($ret == -1 && ! ($! == EAGAIN || $! == EINTR))) {
                      if ( $ret == -1 ) {
                          $cv->croak($!);
                      } else {
                          $cv->send(1);
                      }
  
                      undef $sendfile;
                      undef $sock;
                  } else {
                      $sendfile->();
                  }
              });
          };
          $sendfile->();
          return $cv;
      } else {
          return $self->_write_fh($sock, $body);
      }
  }
  
  sub run {
      my $self = shift;
      $self->register_service(@_);
  
      my $w; $w = AE::signal QUIT => sub { $self->{exit_guard}->end; undef $w };
      $self->{exit_guard}->recv;
  }
  
  package Twiggy::Writer;
  use AnyEvent::Handle;
  
  sub new {
      my ( $class, $socket, $exit ) = @_;
  
      bless { handle => AnyEvent::Handle->new( fh => $socket ), exit_guard => $exit }, $class;
  }
  
  sub write { $_[0]{handle}->push_write($_[1]) }
  
  sub close {
      my $self = shift;
  
      my $exit_guard = delete $self->{exit_guard};
      $exit_guard->end if $exit_guard;
  
      my $handle = delete $self->{handle};
      if ($handle) {
          $handle->on_drain;
          $handle->on_error;
  
          $handle->on_drain(sub {
              shutdown $_[0]->fh, 1;
              $_[0]->destroy;
              undef $handle;
          });
      }
  }
  
  sub DESTROY { $_[0]->close }
  
  package Twiggy::Server;
  
  1;
  __END__
TWIGGY_SERVER

$fatpacked{"Twiggy/Server/SS.pm"} = <<'TWIGGY_SERVER_SS';
  package Twiggy::Server::SS;
  use strict;
  use warnings;
  use base qw(Twiggy::Server);
  use AnyEvent;
  use AnyEvent::Util qw(fh_nonblocking guard);
  use AnyEvent::Socket qw(format_address);
  use Server::Starter qw(server_ports);
  
  sub start_listen {
      my ($self, $app) = @_;
  
      if (Twiggy::Server::DEBUG() && $self->{listen}) {
          warn "'listen' option is currently ignored when used in conjunction with Server::Starter (start_server script)";
      }
  
      my $host = $self->{host} || '';
  
      my @listen;
      my $ports = server_ports();
      while (my ($hostport, $fd) = each %$ports ) {
          push @listen, $hostport;
          $self->_create_ss_tcp_server($hostport, $fd, $app);
      }
  
      # overwrite, just in case somebody wants to refer to it afterwards
      $self->{listen} = \@listen;
  }
  
  sub _create_ss_tcp_server {
      my ($self, $hostport, $fd, $app) = @_;
  
      my $is_tcp = 1; # currently no unix socket support
  
      my ($host, $port);
      if ($hostport =~ /(.*):(\d+)/) {
          $host = $1;
          $port = $2;
      } else {
          $host ||= '0.0.0.0';
          $port = $hostport;
      }
  
      # /WE/ don't care what the address family, type of socket we got, just
      # create a new handle, and perform a fdopen on it. So that part of
      # AE::Socket::tcp_server is stripped out
  
      my %state;
      $state{fh} = IO::Socket::INET->new(
          Proto => 'tcp',
          Listen => 128, 
      );
  
      $state{fh}->fdopen( $fd, 'w' ) or
          Carp::croak "failed to bind to listening socket: $!";
      fh_nonblocking $state{fh}, 1;
  
      my $len;
      my $prepare = $self->_accept_prepare_handler;
      if ($prepare) {
          my ($service, $host) = AnyEvent::Socket::unpack_sockaddr getsockname $state{fh};
          $len = $prepare && $prepare->( $state{fh}, format_address $host, $service );
      }
  
      $len ||= 128;
  
      listen $state{fh}, $len or Carp::croak "listen: $!";
  
      my $accept = $self->_accept_handler($app, $is_tcp);
      $state{aw} = AE::io $state{fh}, 0, sub {
          # this closure keeps $state alive
          while ($state{fh} && (my $peer = accept my $fh, $state{fh})) {
              fh_nonblocking $fh, 1; # POSIX requires inheritance, the outside world does not
  
              my ($service, $host) = AnyEvent::Socket::unpack_sockaddr($peer);
              $accept->($fh, format_address $host, $service);
          }
      };
  
      defined wantarray
          ? guard { %state = () } # clear fh and watcher, which breaks the circular dependency
          : ()
  }
  
  1;
TWIGGY_SERVER_SS

$fatpacked{"darwin-2level/AE.pm"} = <<'DARWIN-2LEVEL_AE';
  =head1 NAME
  
  AE - simpler/faster/newer/cooler AnyEvent API
  
  =head1 SYNOPSIS
  
    use AnyEvent; # not AE
  
    # file handle or descriptor readable
    my $w = AE::io $fh, 0, sub { ...  };
  
    # one-shot or repeating timers
    my $w = AE::timer $seconds,         0, sub { ... }; # once
    my $w = AE::timer $seconds, $interval, sub { ... }; # repeated
  
    print AE::now;  # prints current event loop time
    print AE::time; # think Time::HiRes::time or simply CORE::time.
  
    # POSIX signal
    my $w = AE::signal TERM => sub { ... };
  
    # child process exit
    my $w = AE::child $pid, sub {
       my ($pid, $status) = @_;
       ...
    };
  
    # called when event loop idle (if applicable)
    my $w = AE::idle sub { ... };
  
    my $cv = AE::cv; # stores whether a condition was flagged
    $cv->send; # wake up current and all future recv's
    $cv->recv; # enters "main loop" till $condvar gets ->send
    # use a condvar in callback mode:
    $cv->cb (sub { $_[0]->recv });
  
  
  =head1 DESCRIPTION
  
  This module documents the new simpler AnyEvent API.
  
  The rationale for the new API is that experience with L<EV> shows that
  this API actually "works", despite its lack of extensibility, leading to
  a shorter, easier and faster API.
  
  The main differences from AnyEvent is that function calls are used
  instead of method calls, and that no named arguments are used.
  
  This makes calls to watcher creation functions really short, which can
  make a program more readable despite the lack of named parameters.
  Function calls also allow more static type checking than method calls, so
  many mistakes are caught at compile-time with this API.
  
  Also, some backends (Perl and EV) are so fast that the method call
  overhead is very noticeable (with EV it increases the execution time five-
  to six-fold, with Perl the method call overhead is about a factor of two).
  
  Note that the C<AE> API is an alternative to, not the future version of,
  the AnyEvent API. Both APIs can be used interchangeably and there are
  no plans to "switch", so if in doubt, feel free to use the L<AnyEvent>
  API in new code.
  
  As the AE API is complementary, not everything in the AnyEvent API is
  available, and you still need to use AnyEvent for the finer stuff. Also,
  you should not C<use AE> directly, C<use AnyEvent> will provide the AE
  namespace.
  
  At the moment, these functions will become slower then their method-call
  counterparts when using L<AnyEvent::Strict> or L<AnyEvent::Debug>::wrap.
  
  =head2 FUNCTIONS
  
  This section briefly describes the alternative watcher constructors and
  other functions available inside the C<AE> namespace. Semantics are not
  described here; please refer to the description of the function or method
  with the same name in the L<AnyEvent> manpage for the details.
  
  =over 4
  
  =cut
  
  package AE;
  
  use AnyEvent (); # BEGIN { AnyEvent::common_sense }
  
  our $VERSION = $AnyEvent::VERSION;
  
  =item $w = AE::io $fh_or_fd, $watch_write, $cb
  
  Creates an I/O watcher that listens for read events (C<$watch_write>
  false) or write events (C<$watch_write> is true) on the file handle or
  file descriptor C<$fh_or_fd>.
  
  The callback C<$cb> is invoked as soon and as long as I/O of the type
  specified by C<$watch_write>) can be done on the file handle/descriptor.
  
  Example: wait until STDIN becomes readable.
  
    $stdin_ready = AE::io *STDIN, 0, sub { scalar <STDIN> };
  
  Example: wait until STDOUT becomes writable and print something.
  
    $stdout_ready = AE::io *STDOUT, 1, sub { print STDOUT "woaw\n" };
  
  =item $w = AE::timer $after, $interval, $cb
  
  Creates a timer watcher that invokes the callback C<$cb> after at least
  C<$after> second have passed (C<$after> can be negative or C<0>).
  
  If C<$interval> is C<0>, then the callback will only be invoked once,
  otherwise it must be a positive number of seconds that specifies the
  interval between successive invocations of the callback.
  
  Example: print "too late" after at least one second has passed.
  
    $timer_once = AE::timer 1, 0, sub { print "too late\n" };
  
  Example: print "blubb" once a second, starting as soon as possible.
  
    $timer_repeated = AE::timer 0, 1, sub { print "blubb\n" };
  
  =item $w = AE::signal $signame, $cb
  
  Invoke the callback C<$cb> each time one or more occurrences of the
  named signal C<$signame> are detected.
  
  =item $w = AE::child $pid, $cb
  
  Invokes the callback C<$cb> when the child with the given C<$pid> exits
  (or all children, when C<$pid> is zero).
  
  The callback will get the actual pid and exit status as arguments.
  
  =item $w = AE::idle $cb
  
  Invoke the callback C<$cb> each time the event loop is "idle" (has no
  events outstanding), but do not prevent the event loop from polling for
  more events.
  
  =item $cv = AE::cv
  
  =item $cv = AE::cv { BLOCK }
  
  Create a new condition variable. The first form is identical to C<<
  AnyEvent->condvar >>, the second form additionally sets the callback (as
  if the C<cb> method is called on the condition variable).
  
  =item AE::now
  
  Returns the current event loop time (may be cached by the event loop).
  
  =item AE::now_update
  
  Ensures that the current event loop time is up to date.
  
  =item AE::time
  
  Return the current time (not cached, always consults a hardware clock).
  
  =item AE::postpone { BLOCK }
  
  Exactly the same as C<AnyEvent:::postpone>.
  
  =item AE::log $level, $msg[, @args]
  
  Exactly the same as C<AnyEvent::log> (or C<AnyEvent::Log::log>).
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
DARWIN-2LEVEL_AE

$fatpacked{"darwin-2level/AnyEvent.pm"} = <<'DARWIN-2LEVEL_ANYEVENT';
  =head1 NAME
  
  AnyEvent - the DBI of event loop programming
  
  EV, Event, Glib, Tk, Perl, Event::Lib, Irssi, rxvt-unicode, IO::Async, Qt,
  FLTK and POE are various supported event loops/environments.
  
  =head1 SYNOPSIS
  
     use AnyEvent;
  
     # if you prefer function calls, look at the AE manpage for
     # an alternative API.
  
     # file handle or descriptor readable
     my $w = AnyEvent->io (fh => $fh, poll => "r", cb => sub { ...  });
  
     # one-shot or repeating timers
     my $w = AnyEvent->timer (after => $seconds, cb => sub { ...  });
     my $w = AnyEvent->timer (after => $seconds, interval => $seconds, cb => ...);
  
     print AnyEvent->now;  # prints current event loop time
     print AnyEvent->time; # think Time::HiRes::time or simply CORE::time.
  
     # POSIX signal
     my $w = AnyEvent->signal (signal => "TERM", cb => sub { ... });
  
     # child process exit
     my $w = AnyEvent->child (pid => $pid, cb => sub {
        my ($pid, $status) = @_;
        ...
     });
  
     # called when event loop idle (if applicable)
     my $w = AnyEvent->idle (cb => sub { ... });
  
     my $w = AnyEvent->condvar; # stores whether a condition was flagged
     $w->send; # wake up current and all future recv's
     $w->recv; # enters "main loop" till $condvar gets ->send
     # use a condvar in callback mode:
     $w->cb (sub { $_[0]->recv });
  
  =head1 INTRODUCTION/TUTORIAL
  
  This manpage is mainly a reference manual. If you are interested
  in a tutorial or some gentle introduction, have a look at the
  L<AnyEvent::Intro> manpage.
  
  =head1 SUPPORT
  
  An FAQ document is available as L<AnyEvent::FAQ>.
  
  There also is a mailinglist for discussing all things AnyEvent, and an IRC
  channel, too.
  
  See the AnyEvent project page at the B<Schmorpforge Ta-Sa Software
  Repository>, at L<http://anyevent.schmorp.de>, for more info.
  
  =head1 WHY YOU SHOULD USE THIS MODULE (OR NOT)
  
  Glib, POE, IO::Async, Event... CPAN offers event models by the dozen
  nowadays. So what is different about AnyEvent?
  
  Executive Summary: AnyEvent is I<compatible>, AnyEvent is I<free of
  policy> and AnyEvent is I<small and efficient>.
  
  First and foremost, I<AnyEvent is not an event model> itself, it only
  interfaces to whatever event model the main program happens to use, in a
  pragmatic way. For event models and certain classes of immortals alike,
  the statement "there can only be one" is a bitter reality: In general,
  only one event loop can be active at the same time in a process. AnyEvent
  cannot change this, but it can hide the differences between those event
  loops.
  
  The goal of AnyEvent is to offer module authors the ability to do event
  programming (waiting for I/O or timer events) without subscribing to a
  religion, a way of living, and most importantly: without forcing your
  module users into the same thing by forcing them to use the same event
  model you use.
  
  For modules like POE or IO::Async (which is a total misnomer as it is
  actually doing all I/O I<synchronously>...), using them in your module is
  like joining a cult: After you join, you are dependent on them and you
  cannot use anything else, as they are simply incompatible to everything
  that isn't them. What's worse, all the potential users of your
  module are I<also> forced to use the same event loop you use.
  
  AnyEvent is different: AnyEvent + POE works fine. AnyEvent + Glib works
  fine. AnyEvent + Tk works fine etc. etc. but none of these work together
  with the rest: POE + EV? No go. Tk + Event? No go. Again: if your module
  uses one of those, every user of your module has to use it, too. But if
  your module uses AnyEvent, it works transparently with all event models it
  supports (including stuff like IO::Async, as long as those use one of the
  supported event loops. It is easy to add new event loops to AnyEvent, too,
  so it is future-proof).
  
  In addition to being free of having to use I<the one and only true event
  model>, AnyEvent also is free of bloat and policy: with POE or similar
  modules, you get an enormous amount of code and strict rules you have to
  follow. AnyEvent, on the other hand, is lean and to the point, by only
  offering the functionality that is necessary, in as thin as a wrapper as
  technically possible.
  
  Of course, AnyEvent comes with a big (and fully optional!) toolbox
  of useful functionality, such as an asynchronous DNS resolver, 100%
  non-blocking connects (even with TLS/SSL, IPv6 and on broken platforms
  such as Windows) and lots of real-world knowledge and workarounds for
  platform bugs and differences.
  
  Now, if you I<do want> lots of policy (this can arguably be somewhat
  useful) and you want to force your users to use the one and only event
  model, you should I<not> use this module.
  
  =head1 DESCRIPTION
  
  L<AnyEvent> provides a uniform interface to various event loops. This
  allows module authors to use event loop functionality without forcing
  module users to use a specific event loop implementation (since more
  than one event loop cannot coexist peacefully).
  
  The interface itself is vaguely similar, but not identical to the L<Event>
  module.
  
  During the first call of any watcher-creation method, the module tries
  to detect the currently loaded event loop by probing whether one of the
  following modules is already loaded: L<EV>, L<AnyEvent::Loop>,
  L<Event>, L<Glib>, L<Tk>, L<Event::Lib>, L<Qt>, L<POE>. The first one
  found is used. If none are detected, the module tries to load the first
  four modules in the order given; but note that if L<EV> is not
  available, the pure-perl L<AnyEvent::Loop> should always work, so
  the other two are not normally tried.
  
  Because AnyEvent first checks for modules that are already loaded, loading
  an event model explicitly before first using AnyEvent will likely make
  that model the default. For example:
  
     use Tk;
     use AnyEvent;
  
     # .. AnyEvent will likely default to Tk
  
  The I<likely> means that, if any module loads another event model and
  starts using it, all bets are off - this case should be very rare though,
  as very few modules hardcode event loops without announcing this very
  loudly.
  
  The pure-perl implementation of AnyEvent is called C<AnyEvent::Loop>. Like
  other event modules you can load it explicitly and enjoy the high
  availability of that event loop :)
  
  =head1 WATCHERS
  
  AnyEvent has the central concept of a I<watcher>, which is an object that
  stores relevant data for each kind of event you are waiting for, such as
  the callback to call, the file handle to watch, etc.
  
  These watchers are normal Perl objects with normal Perl lifetime. After
  creating a watcher it will immediately "watch" for events and invoke the
  callback when the event occurs (of course, only when the event model
  is in control).
  
  Note that B<callbacks must not permanently change global variables>
  potentially in use by the event loop (such as C<$_> or C<$[>) and that B<<
  callbacks must not C<die> >>. The former is good programming practice in
  Perl and the latter stems from the fact that exception handling differs
  widely between event loops.
  
  To disable a watcher you have to destroy it (e.g. by setting the
  variable you store it in to C<undef> or otherwise deleting all references
  to it).
  
  All watchers are created by calling a method on the C<AnyEvent> class.
  
  Many watchers either are used with "recursion" (repeating timers for
  example), or need to refer to their watcher object in other ways.
  
  One way to achieve that is this pattern:
  
     my $w; $w = AnyEvent->type (arg => value ..., cb => sub {
        # you can use $w here, for example to undef it
        undef $w;
     });
  
  Note that C<my $w; $w => combination. This is necessary because in Perl,
  my variables are only visible after the statement in which they are
  declared.
  
  =head2 I/O WATCHERS
  
     $w = AnyEvent->io (
        fh   => <filehandle_or_fileno>,
        poll => <"r" or "w">,
        cb   => <callback>,
     );
  
  You can create an I/O watcher by calling the C<< AnyEvent->io >> method
  with the following mandatory key-value pairs as arguments:
  
  C<fh> is the Perl I<file handle> (or a naked file descriptor) to watch
  for events (AnyEvent might or might not keep a reference to this file
  handle). Note that only file handles pointing to things for which
  non-blocking operation makes sense are allowed. This includes sockets,
  most character devices, pipes, fifos and so on, but not for example files
  or block devices.
  
  C<poll> must be a string that is either C<r> or C<w>, which creates a
  watcher waiting for "r"eadable or "w"ritable events, respectively.
  
  C<cb> is the callback to invoke each time the file handle becomes ready.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to I/O watcher callbacks.
  
  The I/O watcher might use the underlying file descriptor or a copy of it.
  You must not close a file handle as long as any watcher is active on the
  underlying file descriptor.
  
  Some event loops issue spurious readiness notifications, so you should
  always use non-blocking calls when reading/writing from/to your file
  handles.
  
  Example: wait for readability of STDIN, then read a line and disable the
  watcher.
  
     my $w; $w = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
        chomp (my $input = <STDIN>);
        warn "read: $input\n";
        undef $w;
     });
  
  =head2 TIME WATCHERS
  
     $w = AnyEvent->timer (after => <seconds>, cb => <callback>);
  
     $w = AnyEvent->timer (
        after    => <fractional_seconds>,
        interval => <fractional_seconds>,
        cb       => <callback>,
     );
  
  You can create a time watcher by calling the C<< AnyEvent->timer >>
  method with the following mandatory arguments:
  
  C<after> specifies after how many seconds (fractional values are
  supported) the callback should be invoked. C<cb> is the callback to invoke
  in that case.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to time watcher callbacks.
  
  The callback will normally be invoked only once. If you specify another
  parameter, C<interval>, as a strictly positive number (> 0), then the
  callback will be invoked regularly at that interval (in fractional
  seconds) after the first invocation. If C<interval> is specified with a
  false value, then it is treated as if it were not specified at all.
  
  The callback will be rescheduled before invoking the callback, but no
  attempt is made to avoid timer drift in most backends, so the interval is
  only approximate.
  
  Example: fire an event after 7.7 seconds.
  
     my $w = AnyEvent->timer (after => 7.7, cb => sub {
        warn "timeout\n";
     });
  
     # to cancel the timer:
     undef $w;
  
  Example 2: fire an event after 0.5 seconds, then roughly every second.
  
     my $w = AnyEvent->timer (after => 0.5, interval => 1, cb => sub {
        warn "timeout\n";
     };
  
  =head3 TIMING ISSUES
  
  There are two ways to handle timers: based on real time (relative, "fire
  in 10 seconds") and based on wallclock time (absolute, "fire at 12
  o'clock").
  
  While most event loops expect timers to specified in a relative way, they
  use absolute time internally. This makes a difference when your clock
  "jumps", for example, when ntp decides to set your clock backwards from
  the wrong date of 2014-01-01 to 2008-01-01, a watcher that is supposed to
  fire "after a second" might actually take six years to finally fire.
  
  AnyEvent cannot compensate for this. The only event loop that is conscious
  of these issues is L<EV>, which offers both relative (ev_timer, based
  on true relative time) and absolute (ev_periodic, based on wallclock time)
  timers.
  
  AnyEvent always prefers relative timers, if available, matching the
  AnyEvent API.
  
  AnyEvent has two additional methods that return the "current time":
  
  =over 4
  
  =item AnyEvent->time
  
  This returns the "current wallclock time" as a fractional number of
  seconds since the Epoch (the same thing as C<time> or C<Time::HiRes::time>
  return, and the result is guaranteed to be compatible with those).
  
  It progresses independently of any event loop processing, i.e. each call
  will check the system clock, which usually gets updated frequently.
  
  =item AnyEvent->now
  
  This also returns the "current wallclock time", but unlike C<time>, above,
  this value might change only once per event loop iteration, depending on
  the event loop (most return the same time as C<time>, above). This is the
  time that AnyEvent's timers get scheduled against.
  
  I<In almost all cases (in all cases if you don't care), this is the
  function to call when you want to know the current time.>
  
  This function is also often faster then C<< AnyEvent->time >>, and
  thus the preferred method if you want some timestamp (for example,
  L<AnyEvent::Handle> uses this to update its activity timeouts).
  
  The rest of this section is only of relevance if you try to be very exact
  with your timing; you can skip it without a bad conscience.
  
  For a practical example of when these times differ, consider L<Event::Lib>
  and L<EV> and the following set-up:
  
  The event loop is running and has just invoked one of your callbacks at
  time=500 (assume no other callbacks delay processing). In your callback,
  you wait a second by executing C<sleep 1> (blocking the process for a
  second) and then (at time=501) you create a relative timer that fires
  after three seconds.
  
  With L<Event::Lib>, C<< AnyEvent->time >> and C<< AnyEvent->now >> will
  both return C<501>, because that is the current time, and the timer will
  be scheduled to fire at time=504 (C<501> + C<3>).
  
  With L<EV>, C<< AnyEvent->time >> returns C<501> (as that is the current
  time), but C<< AnyEvent->now >> returns C<500>, as that is the time the
  last event processing phase started. With L<EV>, your timer gets scheduled
  to run at time=503 (C<500> + C<3>).
  
  In one sense, L<Event::Lib> is more exact, as it uses the current time
  regardless of any delays introduced by event processing. However, most
  callbacks do not expect large delays in processing, so this causes a
  higher drift (and a lot more system calls to get the current time).
  
  In another sense, L<EV> is more exact, as your timer will be scheduled at
  the same time, regardless of how long event processing actually took.
  
  In either case, if you care (and in most cases, you don't), then you
  can get whatever behaviour you want with any event loop, by taking the
  difference between C<< AnyEvent->time >> and C<< AnyEvent->now >> into
  account.
  
  =item AnyEvent->now_update
  
  Some event loops (such as L<EV> or L<AnyEvent::Loop>) cache the current
  time for each loop iteration (see the discussion of L<< AnyEvent->now >>,
  above).
  
  When a callback runs for a long time (or when the process sleeps), then
  this "current" time will differ substantially from the real time, which
  might affect timers and time-outs.
  
  When this is the case, you can call this method, which will update the
  event loop's idea of "current time".
  
  A typical example would be a script in a web server (e.g. C<mod_perl>) -
  when mod_perl executes the script, then the event loop will have the wrong
  idea about the "current time" (being potentially far in the past, when the
  script ran the last time). In that case you should arrange a call to C<<
  AnyEvent->now_update >> each time the web server process wakes up again
  (e.g. at the start of your script, or in a handler).
  
  Note that updating the time I<might> cause some events to be handled.
  
  =back
  
  =head2 SIGNAL WATCHERS
  
     $w = AnyEvent->signal (signal => <uppercase_signal_name>, cb => <callback>);
  
  You can watch for signals using a signal watcher, C<signal> is the signal
  I<name> in uppercase and without any C<SIG> prefix, C<cb> is the Perl
  callback to be invoked whenever a signal occurs.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to signal watcher callbacks.
  
  Multiple signal occurrences can be clumped together into one callback
  invocation, and callback invocation will be synchronous. Synchronous means
  that it might take a while until the signal gets handled by the process,
  but it is guaranteed not to interrupt any other callbacks.
  
  The main advantage of using these watchers is that you can share a signal
  between multiple watchers, and AnyEvent will ensure that signals will not
  interrupt your program at bad times.
  
  This watcher might use C<%SIG> (depending on the event loop used),
  so programs overwriting those signals directly will likely not work
  correctly.
  
  Example: exit on SIGINT
  
     my $w = AnyEvent->signal (signal => "INT", cb => sub { exit 1 });
  
  =head3 Restart Behaviour
  
  While restart behaviour is up to the event loop implementation, most will
  not restart syscalls (that includes L<Async::Interrupt> and AnyEvent's
  pure perl implementation).
  
  =head3 Safe/Unsafe Signals
  
  Perl signals can be either "safe" (synchronous to opcode handling)
  or "unsafe" (asynchronous) - the former might delay signal delivery
  indefinitely, the latter might corrupt your memory.
  
  AnyEvent signal handlers are, in addition, synchronous to the event loop,
  i.e. they will not interrupt your running perl program but will only be
  called as part of the normal event handling (just like timer, I/O etc.
  callbacks, too).
  
  =head3 Signal Races, Delays and Workarounds
  
  Many event loops (e.g. Glib, Tk, Qt, IO::Async) do not support
  attaching callbacks to signals in a generic way, which is a pity,
  as you cannot do race-free signal handling in perl, requiring
  C libraries for this. AnyEvent will try to do its best, which
  means in some cases, signals will be delayed. The maximum time
  a signal might be delayed is 10 seconds by default, but can
  be overriden via C<$ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY}> or
  C<$AnyEvent::MAX_SIGNAL_LATENCY> - see the Ö<ENVIRONMENT VARIABLES>
  section for details.
  
  All these problems can be avoided by installing the optional
  L<Async::Interrupt> module, which works with most event loops. It will not
  work with inherently broken event loops such as L<Event> or L<Event::Lib>
  (and not with L<POE> currently). For those, you just have to suffer the
  delays.
  
  =head2 CHILD PROCESS WATCHERS
  
     $w = AnyEvent->child (pid => <process id>, cb => <callback>);
  
  You can also watch for a child process exit and catch its exit status.
  
  The child process is specified by the C<pid> argument (on some backends,
  using C<0> watches for any child process exit, on others this will
  croak). The watcher will be triggered only when the child process has
  finished and an exit status is available, not on any trace events
  (stopped/continued).
  
  The callback will be called with the pid and exit status (as returned by
  waitpid), so unlike other watcher types, you I<can> rely on child watcher
  callback arguments.
  
  This watcher type works by installing a signal handler for C<SIGCHLD>,
  and since it cannot be shared, nothing else should use SIGCHLD or reap
  random child processes (waiting for specific child processes, e.g. inside
  C<system>, is just fine).
  
  There is a slight catch to child watchers, however: you usually start them
  I<after> the child process was created, and this means the process could
  have exited already (and no SIGCHLD will be sent anymore).
  
  Not all event models handle this correctly (neither POE nor IO::Async do,
  see their AnyEvent::Impl manpages for details), but even for event models
  that I<do> handle this correctly, they usually need to be loaded before
  the process exits (i.e. before you fork in the first place). AnyEvent's
  pure perl event loop handles all cases correctly regardless of when you
  start the watcher.
  
  This means you cannot create a child watcher as the very first
  thing in an AnyEvent program, you I<have> to create at least one
  watcher before you C<fork> the child (alternatively, you can call
  C<AnyEvent::detect>).
  
  As most event loops do not support waiting for child events, they will be
  emulated by AnyEvent in most cases, in which case the latency and race
  problems mentioned in the description of signal watchers apply.
  
  Example: fork a process and wait for it
  
     my $done = AnyEvent->condvar;
    
     my $pid = fork or exit 5;
    
     my $w = AnyEvent->child (
        pid => $pid,
        cb  => sub {
           my ($pid, $status) = @_;
           warn "pid $pid exited with status $status";
           $done->send;
        },
     );
    
     # do something else, then wait for process exit
     $done->recv;
  
  =head2 IDLE WATCHERS
  
     $w = AnyEvent->idle (cb => <callback>);
  
  This will repeatedly invoke the callback after the process becomes idle,
  until either the watcher is destroyed or new events have been detected.
  
  Idle watchers are useful when there is a need to do something, but it
  is not so important (or wise) to do it instantly. The callback will be
  invoked only when there is "nothing better to do", which is usually
  defined as "all outstanding events have been handled and no new events
  have been detected". That means that idle watchers ideally get invoked
  when the event loop has just polled for new events but none have been
  detected. Instead of blocking to wait for more events, the idle watchers
  will be invoked.
  
  Unfortunately, most event loops do not really support idle watchers (only
  EV, Event and Glib do it in a usable fashion) - for the rest, AnyEvent
  will simply call the callback "from time to time".
  
  Example: read lines from STDIN, but only process them when the
  program is otherwise idle:
  
     my @lines; # read data
     my $idle_w;
     my $io_w = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
        push @lines, scalar <STDIN>;
  
        # start an idle watcher, if not already done
        $idle_w ||= AnyEvent->idle (cb => sub {
           # handle only one line, when there are lines left
           if (my $line = shift @lines) {
              print "handled when idle: $line";
           } else {
              # otherwise disable the idle watcher again
              undef $idle_w;
           }
        });
     });
  
  =head2 CONDITION VARIABLES
  
     $cv = AnyEvent->condvar;
  
     $cv->send (<list>);
     my @res = $cv->recv;
  
  If you are familiar with some event loops you will know that all of them
  require you to run some blocking "loop", "run" or similar function that
  will actively watch for new events and call your callbacks.
  
  AnyEvent is slightly different: it expects somebody else to run the event
  loop and will only block when necessary (usually when told by the user).
  
  The tool to do that is called a "condition variable", so called because
  they represent a condition that must become true.
  
  Now is probably a good time to look at the examples further below.
  
  Condition variables can be created by calling the C<< AnyEvent->condvar
  >> method, usually without arguments. The only argument pair allowed is
  C<cb>, which specifies a callback to be called when the condition variable
  becomes true, with the condition variable as the first argument (but not
  the results).
  
  After creation, the condition variable is "false" until it becomes "true"
  by calling the C<send> method (or calling the condition variable as if it
  were a callback, read about the caveats in the description for the C<<
  ->send >> method).
  
  Since condition variables are the most complex part of the AnyEvent API, here are
  some different mental models of what they are - pick the ones you can connect to:
  
  =over 4
  
  =item * Condition variables are like callbacks - you can call them (and pass them instead
  of callbacks). Unlike callbacks however, you can also wait for them to be called.
  
  =item * Condition variables are signals - one side can emit or send them,
  the other side can wait for them, or install a handler that is called when
  the signal fires.
  
  =item * Condition variables are like "Merge Points" - points in your program
  where you merge multiple independent results/control flows into one.
  
  =item * Condition variables represent a transaction - functions that start
  some kind of transaction can return them, leaving the caller the choice
  between waiting in a blocking fashion, or setting a callback.
  
  =item * Condition variables represent future values, or promises to deliver
  some result, long before the result is available.
  
  =back
  
  Condition variables are very useful to signal that something has finished,
  for example, if you write a module that does asynchronous http requests,
  then a condition variable would be the ideal candidate to signal the
  availability of results. The user can either act when the callback is
  called or can synchronously C<< ->recv >> for the results.
  
  You can also use them to simulate traditional event loops - for example,
  you can block your main program until an event occurs - for example, you
  could C<< ->recv >> in your main program until the user clicks the Quit
  button of your app, which would C<< ->send >> the "quit" event.
  
  Note that condition variables recurse into the event loop - if you have
  two pieces of code that call C<< ->recv >> in a round-robin fashion, you
  lose. Therefore, condition variables are good to export to your caller, but
  you should avoid making a blocking wait yourself, at least in callbacks,
  as this asks for trouble.
  
  Condition variables are represented by hash refs in perl, and the keys
  used by AnyEvent itself are all named C<_ae_XXX> to make subclassing
  easy (it is often useful to build your own transaction class on top of
  AnyEvent). To subclass, use C<AnyEvent::CondVar> as base class and call
  its C<new> method in your own C<new> method.
  
  There are two "sides" to a condition variable - the "producer side" which
  eventually calls C<< -> send >>, and the "consumer side", which waits
  for the send to occur.
  
  Example: wait for a timer.
  
     # condition: "wait till the timer is fired"
     my $timer_fired = AnyEvent->condvar;
  
     # create the timer - we could wait for, say
     # a handle becomign ready, or even an
     # AnyEvent::HTTP request to finish, but
     # in this case, we simply use a timer:
     my $w = AnyEvent->timer (
        after => 1,
        cb    => sub { $timer_fired->send },
     );
  
     # this "blocks" (while handling events) till the callback
     # calls ->send
     $timer_fired->recv;
  
  Example: wait for a timer, but take advantage of the fact that condition
  variables are also callable directly.
  
     my $done = AnyEvent->condvar;
     my $delay = AnyEvent->timer (after => 5, cb => $done);
     $done->recv;
  
  Example: Imagine an API that returns a condvar and doesn't support
  callbacks. This is how you make a synchronous call, for example from
  the main program:
  
     use AnyEvent::CouchDB;
  
     ...
  
     my @info = $couchdb->info->recv;
  
  And this is how you would just set a callback to be called whenever the
  results are available:
  
     $couchdb->info->cb (sub {
        my @info = $_[0]->recv;
     });
  
  =head3 METHODS FOR PRODUCERS
  
  These methods should only be used by the producing side, i.e. the
  code/module that eventually sends the signal. Note that it is also
  the producer side which creates the condvar in most cases, but it isn't
  uncommon for the consumer to create it as well.
  
  =over 4
  
  =item $cv->send (...)
  
  Flag the condition as ready - a running C<< ->recv >> and all further
  calls to C<recv> will (eventually) return after this method has been
  called. If nobody is waiting the send will be remembered.
  
  If a callback has been set on the condition variable, it is called
  immediately from within send.
  
  Any arguments passed to the C<send> call will be returned by all
  future C<< ->recv >> calls.
  
  Condition variables are overloaded so one can call them directly (as if
  they were a code reference). Calling them directly is the same as calling
  C<send>.
  
  =item $cv->croak ($error)
  
  Similar to send, but causes all calls to C<< ->recv >> to invoke
  C<Carp::croak> with the given error message/object/scalar.
  
  This can be used to signal any errors to the condition variable
  user/consumer. Doing it this way instead of calling C<croak> directly
  delays the error detection, but has the overwhelming advantage that it
  diagnoses the error at the place where the result is expected, and not
  deep in some event callback with no connection to the actual code causing
  the problem.
  
  =item $cv->begin ([group callback])
  
  =item $cv->end
  
  These two methods can be used to combine many transactions/events into
  one. For example, a function that pings many hosts in parallel might want
  to use a condition variable for the whole process.
  
  Every call to C<< ->begin >> will increment a counter, and every call to
  C<< ->end >> will decrement it.  If the counter reaches C<0> in C<< ->end
  >>, the (last) callback passed to C<begin> will be executed, passing the
  condvar as first argument. That callback is I<supposed> to call C<< ->send
  >>, but that is not required. If no group callback was set, C<send> will
  be called without any arguments.
  
  You can think of C<< $cv->send >> giving you an OR condition (one call
  sends), while C<< $cv->begin >> and C<< $cv->end >> giving you an AND
  condition (all C<begin> calls must be C<end>'ed before the condvar sends).
  
  Let's start with a simple example: you have two I/O watchers (for example,
  STDOUT and STDERR for a program), and you want to wait for both streams to
  close before activating a condvar:
  
     my $cv = AnyEvent->condvar;
  
     $cv->begin; # first watcher
     my $w1 = AnyEvent->io (fh => $fh1, cb => sub {
        defined sysread $fh1, my $buf, 4096
           or $cv->end;
     });
  
     $cv->begin; # second watcher
     my $w2 = AnyEvent->io (fh => $fh2, cb => sub {
        defined sysread $fh2, my $buf, 4096
           or $cv->end;
     });
  
     $cv->recv;
  
  This works because for every event source (EOF on file handle), there is
  one call to C<begin>, so the condvar waits for all calls to C<end> before
  sending.
  
  The ping example mentioned above is slightly more complicated, as the
  there are results to be passwd back, and the number of tasks that are
  begun can potentially be zero:
  
     my $cv = AnyEvent->condvar;
  
     my %result;
     $cv->begin (sub { shift->send (\%result) });
  
     for my $host (@list_of_hosts) {
        $cv->begin;
        ping_host_then_call_callback $host, sub {
           $result{$host} = ...;
           $cv->end;
        };
     }
  
     $cv->end;
  
  This code fragment supposedly pings a number of hosts and calls
  C<send> after results for all then have have been gathered - in any
  order. To achieve this, the code issues a call to C<begin> when it starts
  each ping request and calls C<end> when it has received some result for
  it. Since C<begin> and C<end> only maintain a counter, the order in which
  results arrive is not relevant.
  
  There is an additional bracketing call to C<begin> and C<end> outside the
  loop, which serves two important purposes: first, it sets the callback
  to be called once the counter reaches C<0>, and second, it ensures that
  C<send> is called even when C<no> hosts are being pinged (the loop
  doesn't execute once).
  
  This is the general pattern when you "fan out" into multiple (but
  potentially zero) subrequests: use an outer C<begin>/C<end> pair to set
  the callback and ensure C<end> is called at least once, and then, for each
  subrequest you start, call C<begin> and for each subrequest you finish,
  call C<end>.
  
  =back
  
  =head3 METHODS FOR CONSUMERS
  
  These methods should only be used by the consuming side, i.e. the
  code awaits the condition.
  
  =over 4
  
  =item $cv->recv
  
  Wait (blocking if necessary) until the C<< ->send >> or C<< ->croak
  >> methods have been called on C<$cv>, while servicing other watchers
  normally.
  
  You can only wait once on a condition - additional calls are valid but
  will return immediately.
  
  If an error condition has been set by calling C<< ->croak >>, then this
  function will call C<croak>.
  
  In list context, all parameters passed to C<send> will be returned,
  in scalar context only the first one will be returned.
  
  Note that doing a blocking wait in a callback is not supported by any
  event loop, that is, recursive invocation of a blocking C<< ->recv
  >> is not allowed, and the C<recv> call will C<croak> if such a
  condition is detected. This condition can be slightly loosened by using
  L<Coro::AnyEvent>, which allows you to do a blocking C<< ->recv >> from
  any thread that doesn't run the event loop itself.
  
  Not all event models support a blocking wait - some die in that case
  (programs might want to do that to stay interactive), so I<if you are
  using this from a module, never require a blocking wait>. Instead, let the
  caller decide whether the call will block or not (for example, by coupling
  condition variables with some kind of request results and supporting
  callbacks so the caller knows that getting the result will not block,
  while still supporting blocking waits if the caller so desires).
  
  You can ensure that C<< ->recv >> never blocks by setting a callback and
  only calling C<< ->recv >> from within that callback (or at a later
  time). This will work even when the event loop does not support blocking
  waits otherwise.
  
  =item $bool = $cv->ready
  
  Returns true when the condition is "true", i.e. whether C<send> or
  C<croak> have been called.
  
  =item $cb = $cv->cb ($cb->($cv))
  
  This is a mutator function that returns the callback set and optionally
  replaces it before doing so.
  
  The callback will be called when the condition becomes "true", i.e. when
  C<send> or C<croak> are called, with the only argument being the
  condition variable itself. If the condition is already true, the
  callback is called immediately when it is set. Calling C<recv> inside
  the callback or at any later time is guaranteed not to block.
  
  =back
  
  =head1 SUPPORTED EVENT LOOPS/BACKENDS
  
  The available backend classes are (every class has its own manpage):
  
  =over 4
  
  =item Backends that are autoprobed when no other event loop can be found.
  
  EV is the preferred backend when no other event loop seems to be in
  use. If EV is not installed, then AnyEvent will fall back to its own
  pure-perl implementation, which is available everywhere as it comes with
  AnyEvent itself.
  
     AnyEvent::Impl::EV        based on EV (interface to libev, best choice).
     AnyEvent::Impl::Perl      pure-perl AnyEvent::Loop, fast and portable.
  
  =item Backends that are transparently being picked up when they are used.
  
  These will be used if they are already loaded when the first watcher
  is created, in which case it is assumed that the application is using
  them. This means that AnyEvent will automatically pick the right backend
  when the main program loads an event module before anything starts to
  create watchers. Nothing special needs to be done by the main program.
  
     AnyEvent::Impl::Event     based on Event, very stable, few glitches.
     AnyEvent::Impl::Glib      based on Glib, slow but very stable.
     AnyEvent::Impl::Tk        based on Tk, very broken.
     AnyEvent::Impl::EventLib  based on Event::Lib, leaks memory and worse.
     AnyEvent::Impl::POE       based on POE, very slow, some limitations.
     AnyEvent::Impl::Irssi     used when running within irssi.
     AnyEvent::Impl::IOAsync   based on IO::Async.
     AnyEvent::Impl::Cocoa     based on Cocoa::EventLoop.
     AnyEvent::Impl::FLTK      based on FLTK (fltk 2 binding).
  
  =item Backends with special needs.
  
  Qt requires the Qt::Application to be instantiated first, but will
  otherwise be picked up automatically. As long as the main program
  instantiates the application before any AnyEvent watchers are created,
  everything should just work.
  
     AnyEvent::Impl::Qt        based on Qt.
  
  =item Event loops that are indirectly supported via other backends.
  
  Some event loops can be supported via other modules:
  
  There is no direct support for WxWidgets (L<Wx>) or L<Prima>.
  
  B<WxWidgets> has no support for watching file handles. However, you can
  use WxWidgets through the POE adaptor, as POE has a Wx backend that simply
  polls 20 times per second, which was considered to be too horrible to even
  consider for AnyEvent.
  
  B<Prima> is not supported as nobody seems to be using it, but it has a POE
  backend, so it can be supported through POE.
  
  AnyEvent knows about both L<Prima> and L<Wx>, however, and will try to
  load L<POE> when detecting them, in the hope that POE will pick them up,
  in which case everything will be automatic.
  
  =back
  
  =head1 GLOBAL VARIABLES AND FUNCTIONS
  
  These are not normally required to use AnyEvent, but can be useful to
  write AnyEvent extension modules.
  
  =over 4
  
  =item $AnyEvent::MODEL
  
  Contains C<undef> until the first watcher is being created, before the
  backend has been autodetected.
  
  Afterwards it contains the event model that is being used, which is the
  name of the Perl class implementing the model. This class is usually one
  of the C<AnyEvent::Impl::xxx> modules, but can be any other class in the
  case AnyEvent has been extended at runtime (e.g. in I<rxvt-unicode> it
  will be C<urxvt::anyevent>).
  
  =item AnyEvent::detect
  
  Returns C<$AnyEvent::MODEL>, forcing autodetection of the event model
  if necessary. You should only call this function right before you would
  have created an AnyEvent watcher anyway, that is, as late as possible at
  runtime, and not e.g. during initialisation of your module.
  
  The effect of calling this function is as if a watcher had been created
  (specifically, actions that happen "when the first watcher is created"
  happen when calling detetc as well).
  
  If you need to do some initialisation before AnyEvent watchers are
  created, use C<post_detect>.
  
  =item $guard = AnyEvent::post_detect { BLOCK }
  
  Arranges for the code block to be executed as soon as the event model is
  autodetected (or immediately if that has already happened).
  
  The block will be executed I<after> the actual backend has been detected
  (C<$AnyEvent::MODEL> is set), but I<before> any watchers have been
  created, so it is possible to e.g. patch C<@AnyEvent::ISA> or do
  other initialisations - see the sources of L<AnyEvent::Strict> or
  L<AnyEvent::AIO> to see how this is used.
  
  The most common usage is to create some global watchers, without forcing
  event module detection too early, for example, L<AnyEvent::AIO> creates
  and installs the global L<IO::AIO> watcher in a C<post_detect> block to
  avoid autodetecting the event module at load time.
  
  If called in scalar or list context, then it creates and returns an object
  that automatically removes the callback again when it is destroyed (or
  C<undef> when the hook was immediately executed). See L<AnyEvent::AIO> for
  a case where this is useful.
  
  Example: Create a watcher for the IO::AIO module and store it in
  C<$WATCHER>, but do so only do so after the event loop is initialised.
  
     our WATCHER;
  
     my $guard = AnyEvent::post_detect {
        $WATCHER = AnyEvent->io (fh => IO::AIO::poll_fileno, poll => 'r', cb => \&IO::AIO::poll_cb);
     };
  
     # the ||= is important in case post_detect immediately runs the block,
     # as to not clobber the newly-created watcher. assigning both watcher and
     # post_detect guard to the same variable has the advantage of users being
     # able to just C<undef $WATCHER> if the watcher causes them grief.
  
     $WATCHER ||= $guard;
  
  =item @AnyEvent::post_detect
  
  If there are any code references in this array (you can C<push> to it
  before or after loading AnyEvent), then they will be called directly
  after the event loop has been chosen.
  
  You should check C<$AnyEvent::MODEL> before adding to this array, though:
  if it is defined then the event loop has already been detected, and the
  array will be ignored.
  
  Best use C<AnyEvent::post_detect { BLOCK }> when your application allows
  it, as it takes care of these details.
  
  This variable is mainly useful for modules that can do something useful
  when AnyEvent is used and thus want to know when it is initialised, but do
  not need to even load it by default. This array provides the means to hook
  into AnyEvent passively, without loading it.
  
  Example: To load Coro::AnyEvent whenever Coro and AnyEvent are used
  together, you could put this into Coro (this is the actual code used by
  Coro to accomplish this):
  
     if (defined $AnyEvent::MODEL) {
        # AnyEvent already initialised, so load Coro::AnyEvent
        require Coro::AnyEvent;
     } else {
        # AnyEvent not yet initialised, so make sure to load Coro::AnyEvent
        # as soon as it is
        push @AnyEvent::post_detect, sub { require Coro::AnyEvent };
     }
  
  =item AnyEvent::postpone { BLOCK }
  
  Arranges for the block to be executed as soon as possible, but not before
  the call itself returns. In practise, the block will be executed just
  before the event loop polls for new events, or shortly afterwards.
  
  This function never returns anything (to make the C<return postpone { ...
  }> idiom more useful.
  
  To understand the usefulness of this function, consider a function that
  asynchronously does something for you and returns some transaction
  object or guard to let you cancel the operation. For example,
  C<AnyEvent::Socket::tcp_connect>:
  
     # start a conenction attempt unless one is active
     $self->{connect_guard} ||= AnyEvent::Socket::tcp_connect "www.example.net", 80, sub {
        delete $self->{connect_guard};
        ...
     };
  
  Imagine that this function could instantly call the callback, for
  example, because it detects an obvious error such as a negative port
  number. Invoking the callback before the function returns causes problems
  however: the callback will be called and will try to delete the guard
  object. But since the function hasn't returned yet, there is nothing to
  delete. When the function eventually returns it will assign the guard
  object to C<< $self->{connect_guard} >>, where it will likely never be
  deleted, so the program thinks it is still trying to connect.
  
  This is where C<AnyEvent::postpone> should be used. Instead of calling the
  callback directly on error:
  
     $cb->(undef), return # signal error to callback, BAD!
        if $some_error_condition;
  
  It should use C<postpone>:
  
     AnyEvent::postpone { $cb->(undef) }, return # signal error to callback, later
        if $some_error_condition;
  
  =item AnyEvent::log $level, $msg[, @args]
  
  Log the given C<$msg> at the given C<$level>.
  
  If L<AnyEvent::Log> is not loaded then this function makes a simple test
  to see whether the message will be logged. If the test succeeds it will
  load AnyEvent::Log and call C<AnyEvent::Log::log> - consequently, look at
  the L<AnyEvent::Log> documentation for details.
  
  If the test fails it will simply return. Right now this happens when a
  numerical loglevel is used and it is larger than the level specified via
  C<$ENV{PERL_ANYEVENT_VERBOSE}>.
  
  If you want to sprinkle loads of logging calls around your code, consider
  creating a logger callback with the C<AnyEvent::Log::logger> function,
  which can reduce typing, codesize and can reduce the logging overhead
  enourmously.
  
  =back
  
  =head1 WHAT TO DO IN A MODULE
  
  As a module author, you should C<use AnyEvent> and call AnyEvent methods
  freely, but you should not load a specific event module or rely on it.
  
  Be careful when you create watchers in the module body - AnyEvent will
  decide which event module to use as soon as the first method is called, so
  by calling AnyEvent in your module body you force the user of your module
  to load the event module first.
  
  Never call C<< ->recv >> on a condition variable unless you I<know> that
  the C<< ->send >> method has been called on it already. This is
  because it will stall the whole program, and the whole point of using
  events is to stay interactive.
  
  It is fine, however, to call C<< ->recv >> when the user of your module
  requests it (i.e. if you create a http request object ad have a method
  called C<results> that returns the results, it may call C<< ->recv >>
  freely, as the user of your module knows what she is doing. Always).
  
  =head1 WHAT TO DO IN THE MAIN PROGRAM
  
  There will always be a single main program - the only place that should
  dictate which event model to use.
  
  If the program is not event-based, it need not do anything special, even
  when it depends on a module that uses an AnyEvent. If the program itself
  uses AnyEvent, but does not care which event loop is used, all it needs
  to do is C<use AnyEvent>. In either case, AnyEvent will choose the best
  available loop implementation.
  
  If the main program relies on a specific event model - for example, in
  Gtk2 programs you have to rely on the Glib module - you should load the
  event module before loading AnyEvent or any module that uses it: generally
  speaking, you should load it as early as possible. The reason is that
  modules might create watchers when they are loaded, and AnyEvent will
  decide on the event model to use as soon as it creates watchers, and it
  might choose the wrong one unless you load the correct one yourself.
  
  You can chose to use a pure-perl implementation by loading the
  C<AnyEvent::Loop> module, which gives you similar behaviour
  everywhere, but letting AnyEvent chose the model is generally better.
  
  =head2 MAINLOOP EMULATION
  
  Sometimes (often for short test scripts, or even standalone programs who
  only want to use AnyEvent), you do not want to run a specific event loop.
  
  In that case, you can use a condition variable like this:
  
     AnyEvent->condvar->recv;
  
  This has the effect of entering the event loop and looping forever.
  
  Note that usually your program has some exit condition, in which case
  it is better to use the "traditional" approach of storing a condition
  variable somewhere, waiting for it, and sending it when the program should
  exit cleanly.
  
  
  =head1 OTHER MODULES
  
  The following is a non-exhaustive list of additional modules that use
  AnyEvent as a client and can therefore be mixed easily with other
  AnyEvent modules and other event loops in the same program. Some of the
  modules come as part of AnyEvent, the others are available via CPAN (see
  L<http://search.cpan.org/search?m=module&q=anyevent%3A%3A*> for
  a longer non-exhaustive list), and the list is heavily biased towards
  modules of the AnyEvent author himself :)
  
  =over 4
  
  =item L<AnyEvent::Util>
  
  Contains various utility functions that replace often-used blocking
  functions such as C<inet_aton> with event/callback-based versions.
  
  =item L<AnyEvent::Socket>
  
  Provides various utility functions for (internet protocol) sockets,
  addresses and name resolution. Also functions to create non-blocking tcp
  connections or tcp servers, with IPv6 and SRV record support and more.
  
  =item L<AnyEvent::Handle>
  
  Provide read and write buffers, manages watchers for reads and writes,
  supports raw and formatted I/O, I/O queued and fully transparent and
  non-blocking SSL/TLS (via L<AnyEvent::TLS>).
  
  =item L<AnyEvent::DNS>
  
  Provides rich asynchronous DNS resolver capabilities.
  
  =item L<AnyEvent::HTTP>, L<AnyEvent::IRC>, L<AnyEvent::XMPP>, L<AnyEvent::GPSD>, L<AnyEvent::IGS>, L<AnyEvent::FCP>
  
  Implement event-based interfaces to the protocols of the same name (for
  the curious, IGS is the International Go Server and FCP is the Freenet
  Client Protocol).
  
  =item L<AnyEvent::AIO>
  
  Truly asynchronous (as opposed to non-blocking) I/O, should be in the
  toolbox of every event programmer. AnyEvent::AIO transparently fuses
  L<IO::AIO> and AnyEvent together, giving AnyEvent access to event-based
  file I/O, and much more.
  
  =item L<AnyEvent::Filesys::Notify>
  
  AnyEvent is good for non-blocking stuff, but it can't detect file or
  path changes (e.g. "watch this directory for new files", "watch this
  file for changes"). The L<AnyEvent::Filesys::Notify> module promises to
  do just that in a portbale fashion, supporting inotify on GNU/Linux and
  some weird, without doubt broken, stuff on OS X to monitor files. It can
  fall back to blocking scans at regular intervals transparently on other
  platforms, so it's about as portable as it gets.
  
  (I haven't used it myself, but I haven't heard anybody complaining about
  it yet).
  
  =item L<AnyEvent::DBI>
  
  Executes L<DBI> requests asynchronously in a proxy process for you,
  notifying you in an event-based way when the operation is finished.
  
  =item L<AnyEvent::HTTPD>
  
  A simple embedded webserver.
  
  =item L<AnyEvent::FastPing>
  
  The fastest ping in the west.
  
  =item L<Coro>
  
  Has special support for AnyEvent via L<Coro::AnyEvent>, which allows you
  to simply invert the flow control - don't call us, we will call you:
  
     async {
        Coro::AnyEvent::sleep 5; # creates a 5s timer and waits for it
        print "5 seconds later!\n";
  
        Coro::AnyEvent::readable *STDIN; # uses an I/O watcher
        my $line = <STDIN>; # works for ttys
  
        AnyEvent::HTTP::http_get "url", Coro::rouse_cb;
        my ($body, $hdr) = Coro::rouse_wait;
     };
  
  =back
  
  =cut
  
  package AnyEvent;
  
  # basically a tuned-down version of common::sense
  sub common_sense {
     # from common:.sense 3.4
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x3c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00";
     # use strict vars subs - NO UTF-8, as Util.pm doesn't like this atm. (uts46data.pl)
     $^H |= 0x00000600;
  }
  
  BEGIN { AnyEvent::common_sense }
  
  use Carp ();
  
  our $VERSION = '6.14';
  our $MODEL;
  our @ISA;
  our @REGISTRY;
  our $VERBOSE;
  our %PROTOCOL; # (ipv4|ipv6) => (1|2), higher numbers are preferred
  our $MAX_SIGNAL_LATENCY = $ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY} || 10; # executes after the BEGIN block below (tainting!)
  
  BEGIN {
     require "AnyEvent/constants.pl";
  
     eval "sub TAINT (){" . (${^TAINT}*1) . "}";
  
     delete @ENV{grep /^PERL_ANYEVENT_/, keys %ENV}
        if ${^TAINT};
  
     $ENV{"PERL_ANYEVENT_$_"} = $ENV{"AE_$_"}
        for grep s/^AE_// && !exists $ENV{"PERL_ANYEVENT_$_"}, keys %ENV;
  
     @ENV{grep /^PERL_ANYEVENT_/, keys %ENV} = ()
        if ${^TAINT};
  
     # $ENV{PERL_ANYEVENT_xxx} now valid
  
     $VERBOSE = length $ENV{PERL_ANYEVENT_VERBOSE} ? $ENV{PERL_ANYEVENT_VERBOSE}*1 : 4;
  
     my $idx;
     $PROTOCOL{$_} = ++$idx
        for reverse split /\s*,\s*/,
               $ENV{PERL_ANYEVENT_PROTOCOLS} || "ipv4,ipv6";
  }
  
  our @post_detect;
  
  sub post_detect(&) {
     my ($cb) = @_;
  
     push @post_detect, $cb;
  
     defined wantarray
        ? bless \$cb, "AnyEvent::Util::postdetect"
        : ()
  }
  
  sub AnyEvent::Util::postdetect::DESTROY {
     @post_detect = grep $_ != ${$_[0]}, @post_detect;
  }
  
  our $POSTPONE_W;
  our @POSTPONE;
  
  sub _postpone_exec {
     undef $POSTPONE_W;
  
     &{ shift @POSTPONE }
        while @POSTPONE;
  }
  
  sub postpone(&) {
     push @POSTPONE, shift;
  
     $POSTPONE_W ||= AE::timer (0, 0, \&_postpone_exec);
  
     ()
  }
  
  sub log($$;@) {
     # only load the big bloated module when we actually are about to log something
     if ($_[0] <= ($VERBOSE || 1)) { # also catches non-numeric levels(!) and fatal
        local ($!, $@);
        require AnyEvent::Log; # among other things, sets $VERBOSE to 9
        # AnyEvent::Log overwrites this function
        goto &log;
     }
  
     0 # not logged
  }
  
  sub _logger($;$) {
     my ($level, $renabled) = @_;
  
     $$renabled = $level <= $VERBOSE;
  
     my $logger = [(caller)[0], $level, $renabled];
  
     $AnyEvent::Log::LOGGER{$logger+0} = $logger;
  
  #   return unless defined wantarray;
  # 
  #   require AnyEvent::Util;
  #   my $guard = AnyEvent::Util::guard (sub {
  #      # "clean up"
  #      delete $LOGGER{$logger+0};
  #   });
  # 
  #   sub {
  #      return 0 unless $$renabled;
  # 
  #      $guard if 0; # keep guard alive, but don't cause runtime overhead
  #      require AnyEvent::Log unless $AnyEvent::Log::VERSION;
  #      package AnyEvent::Log;
  #      _log ($logger->[0], $level, @_) # logger->[0] has been converted at load time
  #   }
  }
  
  if (length $ENV{PERL_ANYEVENT_LOG}) {
     require AnyEvent::Log; # AnyEvent::Log does the thing for us
  }
  
  our @models = (
     [EV::                   => AnyEvent::Impl::EV::],
     [AnyEvent::Loop::       => AnyEvent::Impl::Perl::],
     # everything below here will not (normally) be autoprobed
     # as the pure perl backend should work everywhere
     # and is usually faster
     [Irssi::                => AnyEvent::Impl::Irssi::],    # Irssi has a bogus "Event" package, so msut be near the top
     [Event::                => AnyEvent::Impl::Event::],    # slow, stable
     [Glib::                 => AnyEvent::Impl::Glib::],     # becomes extremely slow with many watchers
     # everything below here should not be autoloaded
     [Event::Lib::           => AnyEvent::Impl::EventLib::], # too buggy
     [Tk::                   => AnyEvent::Impl::Tk::],       # crashes with many handles
     [Qt::                   => AnyEvent::Impl::Qt::],       # requires special main program
     [POE::Kernel::          => AnyEvent::Impl::POE::],      # lasciate ogni speranza
     [Wx::                   => AnyEvent::Impl::POE::],
     [Prima::                => AnyEvent::Impl::POE::],
     [IO::Async::Loop::      => AnyEvent::Impl::IOAsync::],  # a bitch to autodetect
     [Cocoa::EventLoop::     => AnyEvent::Impl::Cocoa::],
     [FLTK::                 => AnyEvent::Impl::FLTK::],
  );
  
  our @isa_hook;
  
  sub _isa_set {
     my @pkg = ("AnyEvent", (map $_->[0], grep defined, @isa_hook), $MODEL);
  
     @{"$pkg[$_-1]::ISA"} = $pkg[$_]
        for 1 .. $#pkg;
  
     grep $_ && $_->[1], @isa_hook
        and AE::_reset ();
  }
  
  # used for hooking AnyEvent::Strict and AnyEvent::Debug::Wrap into the class hierarchy
  sub _isa_hook($$;$) {
     my ($i, $pkg, $reset_ae) = @_;
  
     $isa_hook[$i] = $pkg ? [$pkg, $reset_ae] : undef;
  
     _isa_set;
  }
  
  # all autoloaded methods reserve the complete glob, not just the method slot.
  # due to bugs in perls method cache implementation.
  our @methods = qw(io timer time now now_update signal child idle condvar);
  
  sub detect() {
     return $MODEL if $MODEL; # some programs keep references to detect
  
     # IO::Async::Loop::AnyEvent is extremely evil, refuse to work with it
     # the author knows about the problems and what it does to AnyEvent as a whole
     # (and the ability of others to use AnyEvent), but simply wants to abuse AnyEvent
     # anyway.
     AnyEvent::log fatal => "AnyEvent: IO::Async::Loop::AnyEvent detected - that module is broken by\n"
                          . "design, abuses internals and breaks AnyEvent - will not continue."
        if exists $INC{"IO/Async/Loop/AnyEvent.pm"};
  
     local $!; # for good measure
     local $SIG{__DIE__}; # we use eval
  
     # free some memory
     *detect = sub () { $MODEL };
     # undef &func doesn't correctly update the method cache. grmbl.
     # so we delete the whole glob. grmbl.
     # otoh, perl doesn't let me undef an active usb, but it lets me free
     # a glob with an active sub. hrm. i hope it works, but perl is
     # usually buggy in this department. sigh.
     delete @{"AnyEvent::"}{@methods};
     undef @methods;
  
     if ($ENV{PERL_ANYEVENT_MODEL} =~ /^([a-zA-Z0-9:]+)$/) {
        my $model = $1;
        $model = "AnyEvent::Impl::$model" unless $model =~ s/::$//;
        if (eval "require $model") {
           AnyEvent::log 7 => "loaded model '$model' (forced by \$ENV{PERL_ANYEVENT_MODEL}), using it.";
           $MODEL = $model;
        } else {
           AnyEvent::log 4 => "unable to load model '$model' (from \$ENV{PERL_ANYEVENT_MODEL}):\n$@";
        }
     }
  
     # check for already loaded models
     unless ($MODEL) {
        for (@REGISTRY, @models) {
           my ($package, $model) = @$_;
           if (${"$package\::VERSION"} > 0) {
              if (eval "require $model") {
                 AnyEvent::log 7 => "autodetected model '$model', using it.";
                 $MODEL = $model;
                 last;
              } else {
                 AnyEvent::log 8 => "detected event loop $package, but cannot load '$model', skipping: $@";
              }
           }
        }
  
        unless ($MODEL) {
           # try to autoload a model
           for (@REGISTRY, @models) {
              my ($package, $model) = @$_;
              if (
                 eval "require $package"
                 and ${"$package\::VERSION"} > 0
                 and eval "require $model"
              ) {
                 AnyEvent::log 7 => "autoloaded model '$model', using it.";
                 $MODEL = $model;
                 last;
              }
           }
  
           $MODEL
             or AnyEvent::log fatal => "AnyEvent: backend autodetection failed - did you properly install AnyEvent?";
        }
     }
  
     # free memory only needed for probing
     undef @models;
     undef @REGISTRY;
  
     push @{"$MODEL\::ISA"}, "AnyEvent::Base";
  
     # now nuke some methods that are overridden by the backend.
     # SUPER usage is not allowed in these.
     for (qw(time signal child idle)) {
        undef &{"AnyEvent::Base::$_"}
           if defined &{"$MODEL\::$_"};
     }
  
     _isa_set;
  
     # we're officially open!
  
     if ($ENV{PERL_ANYEVENT_STRICT}) {
        require AnyEvent::Strict;
     }
  
     if ($ENV{PERL_ANYEVENT_DEBUG_WRAP}) {
        require AnyEvent::Debug;
        AnyEvent::Debug::wrap ($ENV{PERL_ANYEVENT_DEBUG_WRAP});
     }
  
     if (length $ENV{PERL_ANYEVENT_DEBUG_SHELL}) {
        require AnyEvent::Socket;
        require AnyEvent::Debug;
  
        my $shell = $ENV{PERL_ANYEVENT_DEBUG_SHELL};
        $shell =~ s/\$\$/$$/g;
  
        my ($host, $service) = AnyEvent::Socket::parse_hostport ($shell);
        $AnyEvent::Debug::SHELL = AnyEvent::Debug::shell ($host, $service);
     }
  
     # now the anyevent environment is set up as the user told us to, so
     # call the actual user code - post detects
  
     (shift @post_detect)->() while @post_detect;
     undef @post_detect;
  
     *post_detect = sub(&) {
        shift->();
  
        undef
     };
  
     $MODEL
  }
  
  for my $name (@methods) {
     *$name = sub {
        detect;
        # we use goto because
        # a) it makes the thunk more transparent
        # b) it allows us to delete the thunk later
        goto &{ UNIVERSAL::can AnyEvent => "SUPER::$name" }
     };
  }
  
  # utility function to dup a filehandle. this is used by many backends
  # to support binding more than one watcher per filehandle (they usually
  # allow only one watcher per fd, so we dup it to get a different one).
  sub _dupfh($$;$$) {
     my ($poll, $fh, $r, $w) = @_;
  
     # cygwin requires the fh mode to be matching, unix doesn't
     my ($rw, $mode) = $poll eq "r" ? ($r, "<&") : ($w, ">&");
  
     open my $fh2, $mode, $fh
        or die "AnyEvent->io: cannot dup() filehandle in mode '$poll': $!,";
  
     # we assume CLOEXEC is already set by perl in all important cases
  
     ($fh2, $rw)
  }
  
  =head1 SIMPLIFIED AE API
  
  Starting with version 5.0, AnyEvent officially supports a second, much
  simpler, API that is designed to reduce the calling, typing and memory
  overhead by using function call syntax and a fixed number of parameters.
  
  See the L<AE> manpage for details.
  
  =cut
  
  package AE;
  
  our $VERSION = $AnyEvent::VERSION;
  
  sub _reset() {
     eval q{ 
        # fall back to the main API by default - backends and AnyEvent::Base
        # implementations can overwrite these.
  
        sub io($$$) {
           AnyEvent->io (fh => $_[0], poll => $_[1] ? "w" : "r", cb => $_[2])
        }
  
        sub timer($$$) {
           AnyEvent->timer (after => $_[0], interval => $_[1], cb => $_[2])
        }
  
        sub signal($$) {
           AnyEvent->signal (signal => $_[0], cb => $_[1])
        }
  
        sub child($$) {
           AnyEvent->child (pid => $_[0], cb => $_[1])
        }
  
        sub idle($) {
           AnyEvent->idle (cb => $_[0]);
        }
  
        sub cv(;&) {
           AnyEvent->condvar (@_ ? (cb => $_[0]) : ())
        }
  
        sub now() {
           AnyEvent->now
        }
  
        sub now_update() {
           AnyEvent->now_update
        }
  
        sub time() {
           AnyEvent->time
        }
  
        *postpone = \&AnyEvent::postpone;
        *log      = \&AnyEvent::log;
     };
     die if $@;
  }
  
  BEGIN { _reset }
  
  package AnyEvent::Base;
  
  # default implementations for many methods
  
  sub time {
     eval q{ # poor man's autoloading {}
        # probe for availability of Time::HiRes
        if (eval "use Time::HiRes (); Time::HiRes::time (); 1") {
           *time     = sub { Time::HiRes::time () };
           *AE::time = \&    Time::HiRes::time     ;
           *now      = \&time;
           AnyEvent::log 8 => "AnyEvent: using Time::HiRes for sub-second timing accuracy.";
           # if (eval "use POSIX (); (POSIX::times())...
        } else {
           *time     = sub   { CORE::time };
           *AE::time = sub (){ CORE::time };
           *now      = \&time;
           AnyEvent::log 3 => "using built-in time(), WARNING, no sub-second resolution!";
        }
     };
     die if $@;
  
     &time
  }
  
  *now = \&time;
  sub now_update { }
  
  sub _poll {
     Carp::croak "$AnyEvent::MODEL does not support blocking waits. Caught";
  }
  
  # default implementation for ->condvar
  # in fact, the default should not be overwritten
  
  sub condvar {
     eval q{ # poor man's autoloading {}
        *condvar = sub {
           bless { @_ == 3 ? (_ae_cb => $_[2]) : () }, "AnyEvent::CondVar"
        };
  
        *AE::cv = sub (;&) {
           bless { @_ ? (_ae_cb => shift) : () }, "AnyEvent::CondVar"
        };
     };
     die if $@;
  
     &condvar
  }
  
  # default implementation for ->signal
  
  our $HAVE_ASYNC_INTERRUPT;
  
  sub _have_async_interrupt() {
     $HAVE_ASYNC_INTERRUPT = 1*(!$ENV{PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT}
                                && eval "use Async::Interrupt 1.02 (); 1")
        unless defined $HAVE_ASYNC_INTERRUPT;
  
     $HAVE_ASYNC_INTERRUPT
  }
  
  our ($SIGPIPE_R, $SIGPIPE_W, %SIG_CB, %SIG_EV, $SIG_IO);
  our (%SIG_ASY, %SIG_ASY_W);
  our ($SIG_COUNT, $SIG_TW);
  
  # install a dummy wakeup watcher to reduce signal catching latency
  # used by Impls
  sub _sig_add() {
     unless ($SIG_COUNT++) {
        # try to align timer on a full-second boundary, if possible
        my $NOW = AE::now;
  
        $SIG_TW = AE::timer
           $MAX_SIGNAL_LATENCY - ($NOW - int $NOW),
           $MAX_SIGNAL_LATENCY,
           sub { } # just for the PERL_ASYNC_CHECK
        ;
     }
  }
  
  sub _sig_del {
     undef $SIG_TW
        unless --$SIG_COUNT;
  }
  
  our $_sig_name_init; $_sig_name_init = sub {
     eval q{ # poor man's autoloading {}
        undef $_sig_name_init;
  
        if (_have_async_interrupt) {
           *sig2num  = \&Async::Interrupt::sig2num;
           *sig2name = \&Async::Interrupt::sig2name;
        } else {
           require Config;
  
           my %signame2num;
           @signame2num{ split ' ', $Config::Config{sig_name} }
                          = split ' ', $Config::Config{sig_num};
  
           my @signum2name;
           @signum2name[values %signame2num] = keys %signame2num;
  
           *sig2num = sub($) {
              $_[0] > 0 ? shift : $signame2num{+shift}
           };
           *sig2name = sub ($) {
              $_[0] > 0 ? $signum2name[+shift] : shift
           };
        }
     };
     die if $@;
  };
  
  sub sig2num ($) { &$_sig_name_init; &sig2num  }
  sub sig2name($) { &$_sig_name_init; &sig2name }
  
  sub signal {
     eval q{ # poor man's autoloading {}
        # probe for availability of Async::Interrupt 
        if (_have_async_interrupt) {
           AnyEvent::log 8 => "using Async::Interrupt for race-free signal handling.";
  
           $SIGPIPE_R = new Async::Interrupt::EventPipe;
           $SIG_IO = AE::io $SIGPIPE_R->fileno, 0, \&_signal_exec;
  
        } else {
           AnyEvent::log 8 => "using emulated perl signal handling with latency timer.";
  
           if (AnyEvent::WIN32) {
              require AnyEvent::Util;
  
              ($SIGPIPE_R, $SIGPIPE_W) = AnyEvent::Util::portable_pipe ();
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_R, 1) if $SIGPIPE_R;
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_W, 1) if $SIGPIPE_W; # just in case
           } else {
              pipe $SIGPIPE_R, $SIGPIPE_W;
              fcntl $SIGPIPE_R, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_R;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_W; # just in case
  
              # not strictly required, as $^F is normally 2, but let's make sure...
              fcntl $SIGPIPE_R, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
           }
  
           $SIGPIPE_R
              or Carp::croak "AnyEvent: unable to create a signal reporting pipe: $!\n";
  
           $SIG_IO = AE::io $SIGPIPE_R, 0, \&_signal_exec;
        }
  
        *signal = $HAVE_ASYNC_INTERRUPT
           ? sub {
                my (undef, %arg) = @_;
  
                # async::interrupt
                my $signal = sig2num $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG_ASY{$signal} ||= new Async::Interrupt
                   cb             => sub { undef $SIG_EV{$signal} },
                   signal         => $signal,
                   pipe           => [$SIGPIPE_R->filenos],
                   pipe_autodrain => 0,
                ;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
           : sub {
                my (undef, %arg) = @_;
  
                # pure perl
                my $signal = sig2name $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG{$signal} ||= sub {
                   local $!;
                   syswrite $SIGPIPE_W, "\x00", 1 unless %SIG_EV;
                   undef $SIG_EV{$signal};
                };
  
                # can't do signal processing without introducing races in pure perl,
                # so limit the signal latency.
                _sig_add;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
        ;
  
        *AnyEvent::Base::signal::DESTROY = sub {
           my ($signal, $cb) = @{$_[0]};
  
           _sig_del;
  
           delete $SIG_CB{$signal}{$cb};
  
           $HAVE_ASYNC_INTERRUPT
              ? delete $SIG_ASY{$signal}
              : # delete doesn't work with older perls - they then
                # print weird messages, or just unconditionally exit
                # instead of getting the default action.
                undef $SIG{$signal}
              unless keys %{ $SIG_CB{$signal} };
        };
  
        *_signal_exec = sub {
           $HAVE_ASYNC_INTERRUPT
              ? $SIGPIPE_R->drain
              : sysread $SIGPIPE_R, (my $dummy), 9;
  
           while (%SIG_EV) {
              for (keys %SIG_EV) {
                 delete $SIG_EV{$_};
                 &$_ for values %{ $SIG_CB{$_} || {} };
              }
           }
        };
     };
     die if $@;
  
     &signal
  }
  
  # default implementation for ->child
  
  our %PID_CB;
  our $CHLD_W;
  our $CHLD_DELAY_W;
  
  # used by many Impl's
  sub _emit_childstatus($$) {
     my (undef, $rpid, $rstatus) = @_;
  
     $_->($rpid, $rstatus)
        for values %{ $PID_CB{$rpid} || {} },
            values %{ $PID_CB{0}     || {} };
  }
  
  sub child {
     eval q{ # poor man's autoloading {}
        *_sigchld = sub {
           my $pid;
  
           AnyEvent->_emit_childstatus ($pid, $?)
              while ($pid = waitpid -1, WNOHANG) > 0;
        };
  
        *child = sub {
           my (undef, %arg) = @_;
  
           my $pid = $arg{pid};
           my $cb  = $arg{cb};
  
           $PID_CB{$pid}{$cb+0} = $cb;
  
           unless ($CHLD_W) {
              $CHLD_W = AE::signal CHLD => \&_sigchld;
              # child could be a zombie already, so make at least one round
              &_sigchld;
           }
  
           bless [$pid, $cb+0], "AnyEvent::Base::child"
        };
  
        *AnyEvent::Base::child::DESTROY = sub {
           my ($pid, $icb) = @{$_[0]};
  
           delete $PID_CB{$pid}{$icb};
           delete $PID_CB{$pid} unless keys %{ $PID_CB{$pid} };
  
           undef $CHLD_W unless keys %PID_CB;
        };
     };
     die if $@;
  
     &child
  }
  
  # idle emulation is done by simply using a timer, regardless
  # of whether the process is idle or not, and not letting
  # the callback use more than 50% of the time.
  sub idle {
     eval q{ # poor man's autoloading {}
        *idle = sub {
           my (undef, %arg) = @_;
  
           my ($cb, $w, $rcb) = $arg{cb};
  
           $rcb = sub {
              if ($cb) {
                 $w = AE::time;
                 &$cb;
                 $w = AE::time - $w;
  
                 # never use more then 50% of the time for the idle watcher,
                 # within some limits
                 $w = 0.0001 if $w < 0.0001;
                 $w = 5      if $w > 5;
  
                 $w = AE::timer $w, 0, $rcb;
              } else {
                 # clean up...
                 undef $w;
                 undef $rcb;
              }
           };
  
           $w = AE::timer 0.05, 0, $rcb;
  
           bless \\$cb, "AnyEvent::Base::idle"
        };
  
        *AnyEvent::Base::idle::DESTROY = sub {
           undef $${$_[0]};
        };
     };
     die if $@;
  
     &idle
  }
  
  package AnyEvent::CondVar;
  
  our @ISA = AnyEvent::CondVar::Base::;
  
  # only to be used for subclassing
  sub new {
     my $class = shift;
     bless AnyEvent->condvar (@_), $class
  }
  
  package AnyEvent::CondVar::Base;
  
  #use overload
  #   '&{}'    => sub { my $self = shift; sub { $self->send (@_) } },
  #   fallback => 1;
  
  # save 300+ kilobytes by dirtily hardcoding overloading
  ${"AnyEvent::CondVar::Base::OVERLOAD"}{dummy}++; # Register with magic by touching.
  *{'AnyEvent::CondVar::Base::()'}   = sub { }; # "Make it findable via fetchmethod."
  *{'AnyEvent::CondVar::Base::(&{}'} = sub { my $self = shift; sub { $self->send (@_) } }; # &{}
  ${'AnyEvent::CondVar::Base::()'}   = 1; # fallback
  
  our $WAITING;
  
  sub _send {
     # nop
  }
  
  sub _wait {
     AnyEvent->_poll until $_[0]{_ae_sent};
  }
  
  sub send {
     my $cv = shift;
     $cv->{_ae_sent} = [@_];
     (delete $cv->{_ae_cb})->($cv) if $cv->{_ae_cb};
     $cv->_send;
  }
  
  sub croak {
     $_[0]{_ae_croak} = $_[1];
     $_[0]->send;
  }
  
  sub ready {
     $_[0]{_ae_sent}
  }
  
  sub recv {
     unless ($_[0]{_ae_sent}) {
        $WAITING
           and Carp::croak "AnyEvent::CondVar: recursive blocking wait attempted";
  
        local $WAITING = 1;
        $_[0]->_wait;
     }
  
     $_[0]{_ae_croak}
        and Carp::croak $_[0]{_ae_croak};
  
     wantarray
        ? @{ $_[0]{_ae_sent} }
        : $_[0]{_ae_sent}[0]
  }
  
  sub cb {
     my $cv = shift;
  
     @_
        and $cv->{_ae_cb} = shift
        and $cv->{_ae_sent}
        and (delete $cv->{_ae_cb})->($cv);
  
     $cv->{_ae_cb}
  }
  
  sub begin {
     ++$_[0]{_ae_counter};
     $_[0]{_ae_end_cb} = $_[1] if @_ > 1;
  }
  
  sub end {
     return if --$_[0]{_ae_counter};
     &{ $_[0]{_ae_end_cb} || sub { $_[0]->send } };
  }
  
  # undocumented/compatibility with pre-3.4
  *broadcast = \&send;
  *wait      = \&recv;
  
  =head1 ERROR AND EXCEPTION HANDLING
  
  In general, AnyEvent does not do any error handling - it relies on the
  caller to do that if required. The L<AnyEvent::Strict> module (see also
  the C<PERL_ANYEVENT_STRICT> environment variable, below) provides strict
  checking of all AnyEvent methods, however, which is highly useful during
  development.
  
  As for exception handling (i.e. runtime errors and exceptions thrown while
  executing a callback), this is not only highly event-loop specific, but
  also not in any way wrapped by this module, as this is the job of the main
  program.
  
  The pure perl event loop simply re-throws the exception (usually
  within C<< condvar->recv >>), the L<Event> and L<EV> modules call C<<
  $Event/EV::DIED->() >>, L<Glib> uses C<< install_exception_handler >> and
  so on.
  
  =head1 ENVIRONMENT VARIABLES
  
  AnyEvent supports a number of environment variables that tune the
  runtime behaviour. They are usually evaluated when AnyEvent is
  loaded, initialised, or a submodule that uses them is loaded. Many of
  them also cause AnyEvent to load additional modules - for example,
  C<PERL_ANYEVENT_DEBUG_WRAP> causes the L<AnyEvent::Debug> module to be
  loaded.
  
  All the environment variables documented here start with
  C<PERL_ANYEVENT_>, which is what AnyEvent considers its own
  namespace. Other modules are encouraged (but by no means required) to use
  C<PERL_ANYEVENT_SUBMODULE> if they have registered the AnyEvent::Submodule
  namespace on CPAN, for any submodule. For example, L<AnyEvent::HTTP> could
  be expected to use C<PERL_ANYEVENT_HTTP_PROXY> (it should not access env
  variables starting with C<AE_>, see below).
  
  All variables can also be set via the C<AE_> prefix, that is, instead
  of setting C<PERL_ANYEVENT_VERBOSE> you can also set C<AE_VERBOSE>. In
  case there is a clash btween anyevent and another program that uses
  C<AE_something> you can set the corresponding C<PERL_ANYEVENT_something>
  variable to the empty string, as those variables take precedence.
  
  When AnyEvent is first loaded, it copies all C<AE_xxx> env variables
  to their C<PERL_ANYEVENT_xxx> counterpart unless that variable already
  exists. If taint mode is on, then AnyEvent will remove I<all> environment
  variables starting with C<PERL_ANYEVENT_> from C<%ENV> (or replace them
  with C<undef> or the empty string, if the corresaponding C<AE_> variable
  is set).
  
  The exact algorithm is currently:
  
     1. if taint mode enabled, delete all PERL_ANYEVENT_xyz variables from %ENV
     2. copy over AE_xyz to PERL_ANYEVENT_xyz unless the latter alraedy exists
     3. if taint mode enabled, set all PERL_ANYEVENT_xyz variables to undef.
  
  This ensures that child processes will not see the C<AE_> variables.
  
  The following environment variables are currently known to AnyEvent:
  
  =over 4
  
  =item C<PERL_ANYEVENT_VERBOSE>
  
  By default, AnyEvent will only log messages with loglevel C<3>
  (C<critical>) or higher (see L<AnyEvent::Log>). You can set this
  environment variable to a numerical loglevel to make AnyEvent more (or
  less) talkative.
  
  If you want to do more than just set the global logging level
  you should have a look at C<PERL_ANYEVENT_LOG>, which allows much more
  complex specifications.
  
  When set to C<0> (C<off>), then no messages whatsoever will be logged with
  the default logging settings.
  
  When set to C<5> or higher (C<warn>), causes AnyEvent to warn about
  unexpected conditions, such as not being able to load the event model
  specified by C<PERL_ANYEVENT_MODEL>, or a guard callback throwing an
  exception - this is the minimum recommended level.
  
  When set to C<7> or higher (info), cause AnyEvent to report which event model it
  chooses.
  
  When set to C<8> or higher (debug), then AnyEvent will report extra information on
  which optional modules it loads and how it implements certain features.
  
  =item C<PERL_ANYEVENT_LOG>
  
  Accepts rather complex logging specifications. For example, you could log
  all C<debug> messages of some module to stderr, warnings and above to
  stderr, and errors and above to syslog, with:
  
     PERL_ANYEVENT_LOG=Some::Module=debug,+log:filter=warn,+%syslog:%syslog=error,syslog
  
  For the rather extensive details, see L<AnyEvent::Log>.
  
  This variable is evaluated when AnyEvent (or L<AnyEvent::Log>) is loaded,
  so will take effect even before AnyEvent has initialised itself.
  
  Note that specifying this environment variable causes the L<AnyEvent::Log>
  module to be loaded, while C<PERL_ANYEVENT_VERBOSE> does not, so only
  using the latter saves a few hundred kB of memory until the first message
  is being logged.
  
  =item C<PERL_ANYEVENT_STRICT>
  
  AnyEvent does not do much argument checking by default, as thorough
  argument checking is very costly. Setting this variable to a true value
  will cause AnyEvent to load C<AnyEvent::Strict> and then to thoroughly
  check the arguments passed to most method calls. If it finds any problems,
  it will croak.
  
  In other words, enables "strict" mode.
  
  Unlike C<use strict> (or its modern cousin, C<< use L<common::sense>
  >>, it is definitely recommended to keep it off in production. Keeping
  C<PERL_ANYEVENT_STRICT=1> in your environment while developing programs
  can be very useful, however.
  
  =item C<PERL_ANYEVENT_DEBUG_SHELL>
  
  If this env variable is nonempty, then its contents will be interpreted by
  C<AnyEvent::Socket::parse_hostport> and C<AnyEvent::Debug::shell> (after
  replacing every occurance of C<$$> by the process pid). The shell object
  is saved in C<$AnyEvent::Debug::SHELL>.
  
  This happens when the first watcher is created.
  
  For example, to bind a debug shell on a unix domain socket in
  F<< /tmp/debug<pid>.sock >>, you could use this:
  
     PERL_ANYEVENT_DEBUG_SHELL=/tmp/debug\$\$.sock perlprog
     # connect with e.g.: socat readline /tmp/debug123.sock
  
  Or to bind to tcp port 4545 on localhost:
  
     PERL_ANYEVENT_DEBUG_SHELL=127.0.0.1:4545 perlprog
     # connect with e.g.: telnet localhost 4545
  
  Note that creating sockets in F</tmp> or on localhost is very unsafe on
  multiuser systems.
  
  =item C<PERL_ANYEVENT_DEBUG_WRAP>
  
  Can be set to C<0>, C<1> or C<2> and enables wrapping of all watchers for
  debugging purposes. See C<AnyEvent::Debug::wrap> for details.
  
  =item C<PERL_ANYEVENT_MODEL>
  
  This can be used to specify the event model to be used by AnyEvent, before
  auto detection and -probing kicks in.
  
  It normally is a string consisting entirely of ASCII letters (e.g. C<EV>
  or C<IOAsync>). The string C<AnyEvent::Impl::> gets prepended and the
  resulting module name is loaded and - if the load was successful - used as
  event model backend. If it fails to load then AnyEvent will proceed with
  auto detection and -probing.
  
  If the string ends with C<::> instead (e.g. C<AnyEvent::Impl::EV::>) then
  nothing gets prepended and the module name is used as-is (hint: C<::> at
  the end of a string designates a module name and quotes it appropriately).
  
  For example, to force the pure perl model (L<AnyEvent::Loop::Perl>) you
  could start your program like this:
  
     PERL_ANYEVENT_MODEL=Perl perl ...
  
  =item C<PERL_ANYEVENT_PROTOCOLS>
  
  Used by both L<AnyEvent::DNS> and L<AnyEvent::Socket> to determine preferences
  for IPv4 or IPv6. The default is unspecified (and might change, or be the result
  of auto probing).
  
  Must be set to a comma-separated list of protocols or address families,
  current supported: C<ipv4> and C<ipv6>. Only protocols mentioned will be
  used, and preference will be given to protocols mentioned earlier in the
  list.
  
  This variable can effectively be used for denial-of-service attacks
  against local programs (e.g. when setuid), although the impact is likely
  small, as the program has to handle conenction and other failures anyways.
  
  Examples: C<PERL_ANYEVENT_PROTOCOLS=ipv4,ipv6> - prefer IPv4 over IPv6,
  but support both and try to use both.  C<PERL_ANYEVENT_PROTOCOLS=ipv4>
  - only support IPv4, never try to resolve or contact IPv6
  addresses. C<PERL_ANYEVENT_PROTOCOLS=ipv6,ipv4> support either IPv4 or
  IPv6, but prefer IPv6 over IPv4.
  
  =item C<PERL_ANYEVENT_HOSTS>
  
  This variable, if specified, overrides the F</etc/hosts> file used by
  L<AnyEvent::Socket>C<::resolve_sockaddr>, i.e. hosts aliases will be read
  from that file instead.
  
  =item C<PERL_ANYEVENT_EDNS0>
  
  Used by L<AnyEvent::DNS> to decide whether to use the EDNS0 extension for
  DNS. This extension is generally useful to reduce DNS traffic, especially
  when DNSSEC is involved, but some (broken) firewalls drop such DNS
  packets, which is why it is off by default.
  
  Setting this variable to C<1> will cause L<AnyEvent::DNS> to announce
  EDNS0 in its DNS requests.
  
  =item C<PERL_ANYEVENT_MAX_FORKS>
  
  The maximum number of child processes that C<AnyEvent::Util::fork_call>
  will create in parallel.
  
  =item C<PERL_ANYEVENT_MAX_OUTSTANDING_DNS>
  
  The default value for the C<max_outstanding> parameter for the default DNS
  resolver - this is the maximum number of parallel DNS requests that are
  sent to the DNS server.
  
  =item C<PERL_ANYEVENT_MAX_SIGNAL_LATENCY>
  
  Perl has inherently racy signal handling (you can basically choose between
  losing signals and memory corruption) - pure perl event loops (including
  C<AnyEvent::Loop>, when C<Async::Interrupt> isn't available) therefore
  have to poll regularly to avoid losing signals.
  
  Some event loops are racy, but don't poll regularly, and some event loops
  are written in C but are still racy. For those event loops, AnyEvent
  installs a timer that regularly wakes up the event loop.
  
  By default, the interval for this timer is C<10> seconds, but you can
  override this delay with this environment variable (or by setting
  the C<$AnyEvent::MAX_SIGNAL_LATENCY> variable before creating signal
  watchers).
  
  Lower values increase CPU (and energy) usage, higher values can introduce
  long delays when reaping children or waiting for signals.
  
  The L<AnyEvent::Async> module, if available, will be used to avoid this
  polling (with most event loops).
  
  =item C<PERL_ANYEVENT_RESOLV_CONF>
  
  The absolute path to a F<resolv.conf>-style file to use instead of
  F</etc/resolv.conf> (or the OS-specific configuration) in the default
  resolver, or the empty string to select the default configuration.
  
  =item C<PERL_ANYEVENT_CA_FILE>, C<PERL_ANYEVENT_CA_PATH>.
  
  When neither C<ca_file> nor C<ca_path> was specified during
  L<AnyEvent::TLS> context creation, and either of these environment
  variables are nonempty, they will be used to specify CA certificate
  locations instead of a system-dependent default.
  
  =item C<PERL_ANYEVENT_AVOID_GUARD> and C<PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT>
  
  When these are set to C<1>, then the respective modules are not
  loaded. Mostly good for testing AnyEvent itself.
  
  =back
  
  =head1 SUPPLYING YOUR OWN EVENT MODEL INTERFACE
  
  This is an advanced topic that you do not normally need to use AnyEvent in
  a module. This section is only of use to event loop authors who want to
  provide AnyEvent compatibility.
  
  If you need to support another event library which isn't directly
  supported by AnyEvent, you can supply your own interface to it by
  pushing, before the first watcher gets created, the package name of
  the event module and the package name of the interface to use onto
  C<@AnyEvent::REGISTRY>. You can do that before and even without loading
  AnyEvent, so it is reasonably cheap.
  
  Example:
  
     push @AnyEvent::REGISTRY, [urxvt => urxvt::anyevent::];
  
  This tells AnyEvent to (literally) use the C<urxvt::anyevent::>
  package/class when it finds the C<urxvt> package/module is already loaded.
  
  When AnyEvent is loaded and asked to find a suitable event model, it
  will first check for the presence of urxvt by trying to C<use> the
  C<urxvt::anyevent> module.
  
  The class should provide implementations for all watcher types. See
  L<AnyEvent::Impl::EV> (source code), L<AnyEvent::Impl::Glib> (Source code)
  and so on for actual examples. Use C<perldoc -m AnyEvent::Impl::Glib> to
  see the sources.
  
  If you don't provide C<signal> and C<child> watchers than AnyEvent will
  provide suitable (hopefully) replacements.
  
  The above example isn't fictitious, the I<rxvt-unicode> (a.k.a. urxvt)
  terminal emulator uses the above line as-is. An interface isn't included
  in AnyEvent because it doesn't make sense outside the embedded interpreter
  inside I<rxvt-unicode>, and it is updated and maintained as part of the
  I<rxvt-unicode> distribution.
  
  I<rxvt-unicode> also cheats a bit by not providing blocking access to
  condition variables: code blocking while waiting for a condition will
  C<die>. This still works with most modules/usages, and blocking calls must
  not be done in an interactive application, so it makes sense.
  
  =head1 EXAMPLE PROGRAM
  
  The following program uses an I/O watcher to read data from STDIN, a timer
  to display a message once per second, and a condition variable to quit the
  program when the user enters quit:
  
     use AnyEvent;
  
     my $cv = AnyEvent->condvar;
  
     my $io_watcher = AnyEvent->io (
        fh   => \*STDIN,
        poll => 'r',
        cb   => sub {
           warn "io event <$_[0]>\n";   # will always output <r>
           chomp (my $input = <STDIN>); # read a line
           warn "read: $input\n";       # output what has been read
           $cv->send if $input =~ /^q/i; # quit program if /^q/i
        },
     );
  
     my $time_watcher = AnyEvent->timer (after => 1, interval => 1, cb => sub {
        warn "timeout\n"; # print 'timeout' at most every second
     });
  
     $cv->recv; # wait until user enters /^q/i
  
  =head1 REAL-WORLD EXAMPLE
  
  Consider the L<Net::FCP> module. It features (among others) the following
  API calls, which are to freenet what HTTP GET requests are to http:
  
     my $data = $fcp->client_get ($url); # blocks
  
     my $transaction = $fcp->txn_client_get ($url); # does not block
     $transaction->cb ( sub { ... } ); # set optional result callback
     my $data = $transaction->result; # possibly blocks
  
  The C<client_get> method works like C<LWP::Simple::get>: it requests the
  given URL and waits till the data has arrived. It is defined to be:
  
     sub client_get { $_[0]->txn_client_get ($_[1])->result }
  
  And in fact is automatically generated. This is the blocking API of
  L<Net::FCP>, and it works as simple as in any other, similar, module.
  
  More complicated is C<txn_client_get>: It only creates a transaction
  (completion, result, ...) object and initiates the transaction.
  
     my $txn = bless { }, Net::FCP::Txn::;
  
  It also creates a condition variable that is used to signal the completion
  of the request:
  
     $txn->{finished} = AnyAvent->condvar;
  
  It then creates a socket in non-blocking mode.
  
     socket $txn->{fh}, ...;
     fcntl $txn->{fh}, F_SETFL, O_NONBLOCK;
     connect $txn->{fh}, ...
        and !$!{EWOULDBLOCK}
        and !$!{EINPROGRESS}
        and Carp::croak "unable to connect: $!\n";
  
  Then it creates a write-watcher which gets called whenever an error occurs
  or the connection succeeds:
  
     $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'w', cb => sub { $txn->fh_ready_w });
  
  And returns this transaction object. The C<fh_ready_w> callback gets
  called as soon as the event loop detects that the socket is ready for
  writing.
  
  The C<fh_ready_w> method makes the socket blocking again, writes the
  request data and replaces the watcher by a read watcher (waiting for reply
  data). The actual code is more complicated, but that doesn't matter for
  this example:
  
     fcntl $txn->{fh}, F_SETFL, 0;
     syswrite $txn->{fh}, $txn->{request}
        or die "connection or write error";
     $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'r', cb => sub { $txn->fh_ready_r });
  
  Again, C<fh_ready_r> waits till all data has arrived, and then stores the
  result and signals any possible waiters that the request has finished:
  
     sysread $txn->{fh}, $txn->{buf}, length $txn->{$buf};
  
     if (end-of-file or data complete) {
       $txn->{result} = $txn->{buf};
       $txn->{finished}->send;
       $txb->{cb}->($txn) of $txn->{cb}; # also call callback
     }
  
  The C<result> method, finally, just waits for the finished signal (if the
  request was already finished, it doesn't wait, of course, and returns the
  data:
  
     $txn->{finished}->recv;
     return $txn->{result};
  
  The actual code goes further and collects all errors (C<die>s, exceptions)
  that occurred during request processing. The C<result> method detects
  whether an exception as thrown (it is stored inside the $txn object)
  and just throws the exception, which means connection errors and other
  problems get reported to the code that tries to use the result, not in a
  random callback.
  
  All of this enables the following usage styles:
  
  1. Blocking:
  
     my $data = $fcp->client_get ($url);
  
  2. Blocking, but running in parallel:
  
     my @datas = map $_->result,
                    map $fcp->txn_client_get ($_),
                       @urls;
  
  Both blocking examples work without the module user having to know
  anything about events.
  
  3a. Event-based in a main program, using any supported event module:
  
     use EV;
  
     $fcp->txn_client_get ($url)->cb (sub {
        my $txn = shift;
        my $data = $txn->result;
        ...
     });
  
     EV::loop;
  
  3b. The module user could use AnyEvent, too:
  
     use AnyEvent;
  
     my $quit = AnyEvent->condvar;
  
     $fcp->txn_client_get ($url)->cb (sub {
        ...
        $quit->send;
     });
  
     $quit->recv;
  
  
  =head1 BENCHMARKS
  
  To give you an idea of the performance and overheads that AnyEvent adds
  over the event loops themselves and to give you an impression of the speed
  of various event loops I prepared some benchmarks.
  
  =head2 BENCHMARKING ANYEVENT OVERHEAD
  
  Here is a benchmark of various supported event models used natively and
  through AnyEvent. The benchmark creates a lot of timers (with a zero
  timeout) and I/O watchers (watching STDOUT, a pty, to become writable,
  which it is), lets them fire exactly once and destroys them again.
  
  Source code for this benchmark is found as F<eg/bench> in the AnyEvent
  distribution. It uses the L<AE> interface, which makes a real difference
  for the EV and Perl backends only.
  
  =head3 Explanation of the columns
  
  I<watcher> is the number of event watchers created/destroyed. Since
  different event models feature vastly different performances, each event
  loop was given a number of watchers so that overall runtime is acceptable
  and similar between tested event loop (and keep them from crashing): Glib
  would probably take thousands of years if asked to process the same number
  of watchers as EV in this benchmark.
  
  I<bytes> is the number of bytes (as measured by the resident set size,
  RSS) consumed by each watcher. This method of measuring captures both C
  and Perl-based overheads.
  
  I<create> is the time, in microseconds (millionths of seconds), that it
  takes to create a single watcher. The callback is a closure shared between
  all watchers, to avoid adding memory overhead. That means closure creation
  and memory usage is not included in the figures.
  
  I<invoke> is the time, in microseconds, used to invoke a simple
  callback. The callback simply counts down a Perl variable and after it was
  invoked "watcher" times, it would C<< ->send >> a condvar once to
  signal the end of this phase.
  
  I<destroy> is the time, in microseconds, that it takes to destroy a single
  watcher.
  
  =head3 Results
  
            name watchers bytes create invoke destroy comment
           EV/EV   100000   223   0.47   0.43    0.27 EV native interface
          EV/Any   100000   223   0.48   0.42    0.26 EV + AnyEvent watchers
    Coro::EV/Any   100000   223   0.47   0.42    0.26 coroutines + Coro::Signal
        Perl/Any   100000   431   2.70   0.74    0.92 pure perl implementation
     Event/Event    16000   516  31.16  31.84    0.82 Event native interface
       Event/Any    16000  1203  42.61  34.79    1.80 Event + AnyEvent watchers
     IOAsync/Any    16000  1911  41.92  27.45   16.81 via IO::Async::Loop::IO_Poll
     IOAsync/Any    16000  1726  40.69  26.37   15.25 via IO::Async::Loop::Epoll
        Glib/Any    16000  1118  89.00  12.57   51.17 quadratic behaviour
          Tk/Any     2000  1346  20.96  10.75    8.00 SEGV with >> 2000 watchers
         POE/Any     2000  6951 108.97 795.32   14.24 via POE::Loop::Event
         POE/Any     2000  6648  94.79 774.40  575.51 via POE::Loop::Select
  
  =head3 Discussion
  
  The benchmark does I<not> measure scalability of the event loop very
  well. For example, a select-based event loop (such as the pure perl one)
  can never compete with an event loop that uses epoll when the number of
  file descriptors grows high. In this benchmark, all events become ready at
  the same time, so select/poll-based implementations get an unnatural speed
  boost.
  
  Also, note that the number of watchers usually has a nonlinear effect on
  overall speed, that is, creating twice as many watchers doesn't take twice
  the time - usually it takes longer. This puts event loops tested with a
  higher number of watchers at a disadvantage.
  
  To put the range of results into perspective, consider that on the
  benchmark machine, handling an event takes roughly 1600 CPU cycles with
  EV, 3100 CPU cycles with AnyEvent's pure perl loop and almost 3000000 CPU
  cycles with POE.
  
  C<EV> is the sole leader regarding speed and memory use, which are both
  maximal/minimal, respectively. When using the L<AE> API there is zero
  overhead (when going through the AnyEvent API create is about 5-6 times
  slower, with other times being equal, so still uses far less memory than
  any other event loop and is still faster than Event natively).
  
  The pure perl implementation is hit in a few sweet spots (both the
  constant timeout and the use of a single fd hit optimisations in the perl
  interpreter and the backend itself). Nevertheless this shows that it
  adds very little overhead in itself. Like any select-based backend its
  performance becomes really bad with lots of file descriptors (and few of
  them active), of course, but this was not subject of this benchmark.
  
  The C<Event> module has a relatively high setup and callback invocation
  cost, but overall scores in on the third place.
  
  C<IO::Async> performs admirably well, about on par with C<Event>, even
  when using its pure perl backend.
  
  C<Glib>'s memory usage is quite a bit higher, but it features a
  faster callback invocation and overall ends up in the same class as
  C<Event>. However, Glib scales extremely badly, doubling the number of
  watchers increases the processing time by more than a factor of four,
  making it completely unusable when using larger numbers of watchers
  (note that only a single file descriptor was used in the benchmark, so
  inefficiencies of C<poll> do not account for this).
  
  The C<Tk> adaptor works relatively well. The fact that it crashes with
  more than 2000 watchers is a big setback, however, as correctness takes
  precedence over speed. Nevertheless, its performance is surprising, as the
  file descriptor is dup()ed for each watcher. This shows that the dup()
  employed by some adaptors is not a big performance issue (it does incur a
  hidden memory cost inside the kernel which is not reflected in the figures
  above).
  
  C<POE>, regardless of underlying event loop (whether using its pure perl
  select-based backend or the Event module, the POE-EV backend couldn't
  be tested because it wasn't working) shows abysmal performance and
  memory usage with AnyEvent: Watchers use almost 30 times as much memory
  as EV watchers, and 10 times as much memory as Event (the high memory
  requirements are caused by requiring a session for each watcher). Watcher
  invocation speed is almost 900 times slower than with AnyEvent's pure perl
  implementation.
  
  The design of the POE adaptor class in AnyEvent can not really account
  for the performance issues, though, as session creation overhead is
  small compared to execution of the state machine, which is coded pretty
  optimally within L<AnyEvent::Impl::POE> (and while everybody agrees that
  using multiple sessions is not a good approach, especially regarding
  memory usage, even the author of POE could not come up with a faster
  design).
  
  =head3 Summary
  
  =over 4
  
  =item * Using EV through AnyEvent is faster than any other event loop
  (even when used without AnyEvent), but most event loops have acceptable
  performance with or without AnyEvent.
  
  =item * The overhead AnyEvent adds is usually much smaller than the overhead of
  the actual event loop, only with extremely fast event loops such as EV
  does AnyEvent add significant overhead.
  
  =item * You should avoid POE like the plague if you want performance or
  reasonable memory usage.
  
  =back
  
  =head2 BENCHMARKING THE LARGE SERVER CASE
  
  This benchmark actually benchmarks the event loop itself. It works by
  creating a number of "servers": each server consists of a socket pair, a
  timeout watcher that gets reset on activity (but never fires), and an I/O
  watcher waiting for input on one side of the socket. Each time the socket
  watcher reads a byte it will write that byte to a random other "server".
  
  The effect is that there will be a lot of I/O watchers, only part of which
  are active at any one point (so there is a constant number of active
  fds for each loop iteration, but which fds these are is random). The
  timeout is reset each time something is read because that reflects how
  most timeouts work (and puts extra pressure on the event loops).
  
  In this benchmark, we use 10000 socket pairs (20000 sockets), of which 100
  (1%) are active. This mirrors the activity of large servers with many
  connections, most of which are idle at any one point in time.
  
  Source code for this benchmark is found as F<eg/bench2> in the AnyEvent
  distribution. It uses the L<AE> interface, which makes a real difference
  for the EV and Perl backends only.
  
  =head3 Explanation of the columns
  
  I<sockets> is the number of sockets, and twice the number of "servers" (as
  each server has a read and write socket end).
  
  I<create> is the time it takes to create a socket pair (which is
  nontrivial) and two watchers: an I/O watcher and a timeout watcher.
  
  I<request>, the most important value, is the time it takes to handle a
  single "request", that is, reading the token from the pipe and forwarding
  it to another server. This includes deleting the old timeout and creating
  a new one that moves the timeout into the future.
  
  =head3 Results
  
       name sockets create  request 
         EV   20000  62.66     7.99 
       Perl   20000  68.32    32.64 
    IOAsync   20000 174.06   101.15 epoll
    IOAsync   20000 174.67   610.84 poll
      Event   20000 202.69   242.91 
       Glib   20000 557.01  1689.52 
        POE   20000 341.54 12086.32 uses POE::Loop::Event
  
  =head3 Discussion
  
  This benchmark I<does> measure scalability and overall performance of the
  particular event loop.
  
  EV is again fastest. Since it is using epoll on my system, the setup time
  is relatively high, though.
  
  Perl surprisingly comes second. It is much faster than the C-based event
  loops Event and Glib.
  
  IO::Async performs very well when using its epoll backend, and still quite
  good compared to Glib when using its pure perl backend.
  
  Event suffers from high setup time as well (look at its code and you will
  understand why). Callback invocation also has a high overhead compared to
  the C<< $_->() for .. >>-style loop that the Perl event loop uses. Event
  uses select or poll in basically all documented configurations.
  
  Glib is hit hard by its quadratic behaviour w.r.t. many watchers. It
  clearly fails to perform with many filehandles or in busy servers.
  
  POE is still completely out of the picture, taking over 1000 times as long
  as EV, and over 100 times as long as the Perl implementation, even though
  it uses a C-based event loop in this case.
  
  =head3 Summary
  
  =over 4
  
  =item * The pure perl implementation performs extremely well.
  
  =item * Avoid Glib or POE in large projects where performance matters.
  
  =back
  
  =head2 BENCHMARKING SMALL SERVERS
  
  While event loops should scale (and select-based ones do not...) even to
  large servers, most programs we (or I :) actually write have only a few
  I/O watchers.
  
  In this benchmark, I use the same benchmark program as in the large server
  case, but it uses only eight "servers", of which three are active at any
  one time. This should reflect performance for a small server relatively
  well.
  
  The columns are identical to the previous table.
  
  =head3 Results
  
      name sockets create request 
        EV      16  20.00    6.54 
      Perl      16  25.75   12.62 
     Event      16  81.27   35.86 
      Glib      16  32.63   15.48 
       POE      16 261.87  276.28 uses POE::Loop::Event
  
  =head3 Discussion
  
  The benchmark tries to test the performance of a typical small
  server. While knowing how various event loops perform is interesting, keep
  in mind that their overhead in this case is usually not as important, due
  to the small absolute number of watchers (that is, you need efficiency and
  speed most when you have lots of watchers, not when you only have a few of
  them).
  
  EV is again fastest.
  
  Perl again comes second. It is noticeably faster than the C-based event
  loops Event and Glib, although the difference is too small to really
  matter.
  
  POE also performs much better in this case, but is is still far behind the
  others.
  
  =head3 Summary
  
  =over 4
  
  =item * C-based event loops perform very well with small number of
  watchers, as the management overhead dominates.
  
  =back
  
  =head2 THE IO::Lambda BENCHMARK
  
  Recently I was told about the benchmark in the IO::Lambda manpage, which
  could be misinterpreted to make AnyEvent look bad. In fact, the benchmark
  simply compares IO::Lambda with POE, and IO::Lambda looks better (which
  shouldn't come as a surprise to anybody). As such, the benchmark is
  fine, and mostly shows that the AnyEvent backend from IO::Lambda isn't
  very optimal. But how would AnyEvent compare when used without the extra
  baggage? To explore this, I wrote the equivalent benchmark for AnyEvent.
  
  The benchmark itself creates an echo-server, and then, for 500 times,
  connects to the echo server, sends a line, waits for the reply, and then
  creates the next connection. This is a rather bad benchmark, as it doesn't
  test the efficiency of the framework or much non-blocking I/O, but it is a
  benchmark nevertheless.
  
     name                    runtime
     Lambda/select           0.330 sec
        + optimized          0.122 sec
     Lambda/AnyEvent         0.327 sec
        + optimized          0.138 sec
     Raw sockets/select      0.077 sec
     POE/select, components  0.662 sec
     POE/select, raw sockets 0.226 sec
     POE/select, optimized   0.404 sec
  
     AnyEvent/select/nb      0.085 sec
     AnyEvent/EV/nb          0.068 sec
        +state machine       0.134 sec
  
  The benchmark is also a bit unfair (my fault): the IO::Lambda/POE
  benchmarks actually make blocking connects and use 100% blocking I/O,
  defeating the purpose of an event-based solution. All of the newly
  written AnyEvent benchmarks use 100% non-blocking connects (using
  AnyEvent::Socket::tcp_connect and the asynchronous pure perl DNS
  resolver), so AnyEvent is at a disadvantage here, as non-blocking connects
  generally require a lot more bookkeeping and event handling than blocking
  connects (which involve a single syscall only).
  
  The last AnyEvent benchmark additionally uses L<AnyEvent::Handle>, which
  offers similar expressive power as POE and IO::Lambda, using conventional
  Perl syntax. This means that both the echo server and the client are 100%
  non-blocking, further placing it at a disadvantage.
  
  As you can see, the AnyEvent + EV combination even beats the
  hand-optimised "raw sockets benchmark", while AnyEvent + its pure perl
  backend easily beats IO::Lambda and POE.
  
  And even the 100% non-blocking version written using the high-level (and
  slow :) L<AnyEvent::Handle> abstraction beats both POE and IO::Lambda
  higher level ("unoptimised") abstractions by a large margin, even though
  it does all of DNS, tcp-connect and socket I/O in a non-blocking way.
  
  The two AnyEvent benchmarks programs can be found as F<eg/ae0.pl> and
  F<eg/ae2.pl> in the AnyEvent distribution, the remaining benchmarks are
  part of the IO::Lambda distribution and were used without any changes.
  
  
  =head1 SIGNALS
  
  AnyEvent currently installs handlers for these signals:
  
  =over 4
  
  =item SIGCHLD
  
  A handler for C<SIGCHLD> is installed by AnyEvent's child watcher
  emulation for event loops that do not support them natively. Also, some
  event loops install a similar handler.
  
  Additionally, when AnyEvent is loaded and SIGCHLD is set to IGNORE, then
  AnyEvent will reset it to default, to avoid losing child exit statuses.
  
  =item SIGPIPE
  
  A no-op handler is installed for C<SIGPIPE> when C<$SIG{PIPE}> is C<undef>
  when AnyEvent gets loaded.
  
  The rationale for this is that AnyEvent users usually do not really depend
  on SIGPIPE delivery (which is purely an optimisation for shell use, or
  badly-written programs), but C<SIGPIPE> can cause spurious and rare
  program exits as a lot of people do not expect C<SIGPIPE> when writing to
  some random socket.
  
  The rationale for installing a no-op handler as opposed to ignoring it is
  that this way, the handler will be restored to defaults on exec.
  
  Feel free to install your own handler, or reset it to defaults.
  
  =back
  
  =cut
  
  undef $SIG{CHLD}
     if $SIG{CHLD} eq 'IGNORE';
  
  $SIG{PIPE} = sub { }
     unless defined $SIG{PIPE};
  
  =head1 RECOMMENDED/OPTIONAL MODULES
  
  One of AnyEvent's main goals is to be 100% Pure-Perl(tm): only perl (and
  its built-in modules) are required to use it.
  
  That does not mean that AnyEvent won't take advantage of some additional
  modules if they are installed.
  
  This section explains which additional modules will be used, and how they
  affect AnyEvent's operation.
  
  =over 4
  
  =item L<Async::Interrupt>
  
  This slightly arcane module is used to implement fast signal handling: To
  my knowledge, there is no way to do completely race-free and quick
  signal handling in pure perl. To ensure that signals still get
  delivered, AnyEvent will start an interval timer to wake up perl (and
  catch the signals) with some delay (default is 10 seconds, look for
  C<$AnyEvent::MAX_SIGNAL_LATENCY>).
  
  If this module is available, then it will be used to implement signal
  catching, which means that signals will not be delayed, and the event loop
  will not be interrupted regularly, which is more efficient (and good for
  battery life on laptops).
  
  This affects not just the pure-perl event loop, but also other event loops
  that have no signal handling on their own (e.g. Glib, Tk, Qt).
  
  Some event loops (POE, Event, Event::Lib) offer signal watchers natively,
  and either employ their own workarounds (POE) or use AnyEvent's workaround
  (using C<$AnyEvent::MAX_SIGNAL_LATENCY>). Installing L<Async::Interrupt>
  does nothing for those backends.
  
  =item L<EV>
  
  This module isn't really "optional", as it is simply one of the backend
  event loops that AnyEvent can use. However, it is simply the best event
  loop available in terms of features, speed and stability: It supports
  the AnyEvent API optimally, implements all the watcher types in XS, does
  automatic timer adjustments even when no monotonic clock is available,
  can take avdantage of advanced kernel interfaces such as C<epoll> and
  C<kqueue>, and is the fastest backend I<by far>. You can even embed
  L<Glib>/L<Gtk2> in it (or vice versa, see L<EV::Glib> and L<Glib::EV>).
  
  If you only use backends that rely on another event loop (e.g. C<Tk>),
  then this module will do nothing for you.
  
  =item L<Guard>
  
  The guard module, when used, will be used to implement
  C<AnyEvent::Util::guard>. This speeds up guards considerably (and uses a
  lot less memory), but otherwise doesn't affect guard operation much. It is
  purely used for performance.
  
  =item L<JSON> and L<JSON::XS>
  
  One of these modules is required when you want to read or write JSON data
  via L<AnyEvent::Handle>. L<JSON> is also written in pure-perl, but can take
  advantage of the ultra-high-speed L<JSON::XS> module when it is installed.
  
  =item L<Net::SSLeay>
  
  Implementing TLS/SSL in Perl is certainly interesting, but not very
  worthwhile: If this module is installed, then L<AnyEvent::Handle> (with
  the help of L<AnyEvent::TLS>), gains the ability to do TLS/SSL.
  
  =item L<Time::HiRes>
  
  This module is part of perl since release 5.008. It will be used when the
  chosen event library does not come with a timing source of its own. The
  pure-perl event loop (L<AnyEvent::Loop>) will additionally load it to
  try to use a monotonic clock for timing stability.
  
  =back
  
  
  =head1 FORK
  
  Most event libraries are not fork-safe. The ones who are usually are
  because they rely on inefficient but fork-safe C<select> or C<poll> calls
  - higher performance APIs such as BSD's kqueue or the dreaded Linux epoll
  are usually badly thought-out hacks that are incompatible with fork in
  one way or another. Only L<EV> is fully fork-aware and ensures that you
  continue event-processing in both parent and child (or both, if you know
  what you are doing).
  
  This means that, in general, you cannot fork and do event processing in
  the child if the event library was initialised before the fork (which
  usually happens when the first AnyEvent watcher is created, or the library
  is loaded).
  
  If you have to fork, you must either do so I<before> creating your first
  watcher OR you must not use AnyEvent at all in the child OR you must do
  something completely out of the scope of AnyEvent.
  
  The problem of doing event processing in the parent I<and> the child
  is much more complicated: even for backends that I<are> fork-aware or
  fork-safe, their behaviour is not usually what you want: fork clones all
  watchers, that means all timers, I/O watchers etc. are active in both
  parent and child, which is almost never what you want. USing C<exec>
  to start worker children from some kind of manage rprocess is usually
  preferred, because it is much easier and cleaner, at the expense of having
  to have another binary.
  
  
  =head1 SECURITY CONSIDERATIONS
  
  AnyEvent can be forced to load any event model via
  $ENV{PERL_ANYEVENT_MODEL}. While this cannot (to my knowledge) be used to
  execute arbitrary code or directly gain access, it can easily be used to
  make the program hang or malfunction in subtle ways, as AnyEvent watchers
  will not be active when the program uses a different event model than
  specified in the variable.
  
  You can make AnyEvent completely ignore this variable by deleting it
  before the first watcher gets created, e.g. with a C<BEGIN> block:
  
     BEGIN { delete $ENV{PERL_ANYEVENT_MODEL} }
    
     use AnyEvent;
  
  Similar considerations apply to $ENV{PERL_ANYEVENT_VERBOSE}, as that can
  be used to probe what backend is used and gain other information (which is
  probably even less useful to an attacker than PERL_ANYEVENT_MODEL), and
  $ENV{PERL_ANYEVENT_STRICT}.
  
  Note that AnyEvent will remove I<all> environment variables starting with
  C<PERL_ANYEVENT_> from C<%ENV> when it is loaded while taint mode is
  enabled.
  
  
  =head1 BUGS
  
  Perl 5.8 has numerous memleaks that sometimes hit this module and are hard
  to work around. If you suffer from memleaks, first upgrade to Perl 5.10
  and check wether the leaks still show up. (Perl 5.10.0 has other annoying
  memleaks, such as leaking on C<map> and C<grep> but it is usually not as
  pronounced).
  
  
  =head1 SEE ALSO
  
  Tutorial/Introduction: L<AnyEvent::Intro>.
  
  FAQ: L<AnyEvent::FAQ>.
  
  Utility functions: L<AnyEvent::Util> (misc. grab-bag), L<AnyEvent::Log>
  (simply logging).
  
  Development/Debugging: L<AnyEvent::Strict> (stricter checking),
  L<AnyEvent::Debug> (interactive shell, watcher tracing).
  
  Supported event modules: L<AnyEvent::Loop>, L<EV>, L<EV::Glib>,
  L<Glib::EV>, L<Event>, L<Glib::Event>, L<Glib>, L<Tk>, L<Event::Lib>,
  L<Qt>, L<POE>, L<FLTK>.
  
  Implementations: L<AnyEvent::Impl::EV>, L<AnyEvent::Impl::Event>,
  L<AnyEvent::Impl::Glib>, L<AnyEvent::Impl::Tk>, L<AnyEvent::Impl::Perl>,
  L<AnyEvent::Impl::EventLib>, L<AnyEvent::Impl::Qt>,
  L<AnyEvent::Impl::POE>, L<AnyEvent::Impl::IOAsync>, L<Anyevent::Impl::Irssi>,
  L<AnyEvent::Impl::FLTK>.
  
  Non-blocking handles, pipes, stream sockets, TCP clients and
  servers: L<AnyEvent::Handle>, L<AnyEvent::Socket>, L<AnyEvent::TLS>.
  
  Asynchronous DNS: L<AnyEvent::DNS>.
  
  Thread support: L<Coro>, L<Coro::AnyEvent>, L<Coro::EV>, L<Coro::Event>.
  
  Nontrivial usage examples: L<AnyEvent::GPSD>, L<AnyEvent::IRC>,
  L<AnyEvent::HTTP>.
  
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
  1
  
DARWIN-2LEVEL_ANYEVENT

$fatpacked{"darwin-2level/AnyEvent/DNS.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_DNS';
  =head1 NAME
  
  AnyEvent::DNS - fully asynchronous DNS resolution
  
  =head1 SYNOPSIS
  
     use AnyEvent::DNS;
     
     my $cv = AnyEvent->condvar;
     AnyEvent::DNS::a "www.google.de", $cv;
     # ... later
     my @addrs = $cv->recv;
  
  =head1 DESCRIPTION
  
  This module offers both a number of DNS convenience functions as well
  as a fully asynchronous and high-performance pure-perl stub resolver.
  
  The stub resolver supports DNS over IPv4 and IPv6, UDP and TCP, optional
  EDNS0 support for up to 4kiB datagrams and automatically falls back to
  virtual circuit mode for large responses.
  
  =head2 CONVENIENCE FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::DNS;
  
  use Carp ();
  use Socket qw(AF_INET SOCK_DGRAM SOCK_STREAM);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(AF_INET6);
  
  our $VERSION = $AnyEvent::VERSION;
  our @DNS_FALLBACK; # some public dns servers as fallback
  
  {
     my $prep = sub {
        $_ = $_->[rand @$_] for @_;
        push @_, splice @_, rand $_, 1 for reverse 1..@_; # shuffle
        $_ = pack "H*", $_ for @_;
        \@_
     };
  
     my $ipv4 = $prep->(
        ["08080808", "08080404"], # 8.8.8.8, 8.8.4.4 - google public dns
  #      ["d1f40003", "d1f30004"], # v209.244.0.3/4 - resolver1/2.level3.net - status unknown
        ["04020201", "04020203", "04020204", "04020205", "04020206"], # v4.2.2.1/3/4/5/6 - vnsc-pri.sys.gtei.net - effectively public
        ["cdd22ad2", "4044c8c8"], # 205.210.42.205, 64.68.200.200 - cache1/2.dnsresolvers.com - verified public
  #      ["8d010101"], # 141.1.1.1 - cable&wireless - status unknown
     );
  
     my $ipv6 = $prep->(
        ["20014860486000000000000000008888", "20014860486000000000000000008844"], # 2001:4860:4860::8888/8844 - google ipv6
     );
  
     undef $ipv4 unless $AnyEvent::PROTOCOL{ipv4};
     undef $ipv6 unless $AnyEvent::PROTOCOL{ipv6};
  
     ($ipv6, $ipv4) = ($ipv4, $ipv6)
        if $AnyEvent::PROTOCOL{ipv6} > $AnyEvent::PROTOCOL{ipv4};
  
     @DNS_FALLBACK = (@$ipv4, @$ipv6);
  }
  
  =item AnyEvent::DNS::a $domain, $cb->(@addrs)
  
  Tries to resolve the given domain to IPv4 address(es).
  
  =item AnyEvent::DNS::aaaa $domain, $cb->(@addrs)
  
  Tries to resolve the given domain to IPv6 address(es).
  
  =item AnyEvent::DNS::mx $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain into a sorted (lower preference value
  first) list of domain names.
  
  =item AnyEvent::DNS::ns $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain name into a list of name servers.
  
  =item AnyEvent::DNS::txt $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain name into a list of text records. Only
  the first text string per record will be returned. If you want all
  strings, you need to call the resolver manually:
  
     resolver->resolve ($domain => "txt", sub {
        for my $record (@_) {
           my (undef, undef, undef, @txt) = @$record;
           # strings now in @txt
        }
     });
  
  =item AnyEvent::DNS::srv $service, $proto, $domain, $cb->(@srv_rr)
  
  Tries to resolve the given service, protocol and domain name into a list
  of service records.
  
  Each C<$srv_rr> is an array reference with the following contents: 
  C<[$priority, $weight, $transport, $target]>.
  
  They will be sorted with lowest priority first, then randomly
  distributed by weight as per RFC 2782.
  
  Example:
  
     AnyEvent::DNS::srv "sip", "udp", "schmorp.de", sub { ...
     # @_ = ( [10, 10, 5060, "sip1.schmorp.de" ] )
  
  =item AnyEvent::DNS::any $domain, $cb->(@rrs)
  
  Tries to resolve the given domain and passes all resource records found to
  the callback.
  
  =item AnyEvent::DNS::ptr $domain, $cb->(@hostnames)
  
  Tries to make a PTR lookup on the given domain. See C<reverse_lookup>
  and C<reverse_verify> if you want to resolve an IP address to a hostname
  instead.
  
  =item AnyEvent::DNS::reverse_lookup $ipv4_or_6, $cb->(@hostnames)
  
  Tries to reverse-resolve the given IPv4 or IPv6 address (in textual form)
  into its hostname(s). Handles V4MAPPED and V4COMPAT IPv6 addresses
  transparently.
  
  =item AnyEvent::DNS::reverse_verify $ipv4_or_6, $cb->(@hostnames)
  
  The same as C<reverse_lookup>, but does forward-lookups to verify that
  the resolved hostnames indeed point to the address, which makes spoofing
  harder.
  
  If you want to resolve an address into a hostname, this is the preferred
  method: The DNS records could still change, but at least this function
  verified that the hostname, at one point in the past, pointed at the IP
  address you originally resolved.
  
  Example:
  
     AnyEvent::DNS::reverse_verify "2001:500:2f::f", sub { print shift };
     # => f.root-servers.net
  
  =cut
  
  sub MAX_PKT() { 4096 } # max packet size we advertise and accept
  
  sub DOMAIN_PORT() { 53 } # if this changes drop me a note
  
  sub resolver ();
  
  sub a($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "a", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub aaaa($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "aaaa", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub mx($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "mx", sub {
        $cb->(map $_->[5], sort { $a->[4] <=> $b->[4] } @_);
     });
  }
  
  sub ns($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "ns", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub txt($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "txt", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub srv($$$$) {
     my ($service, $proto, $domain, $cb) = @_;
  
     # todo, ask for any and check glue records
     resolver->resolve ("_$service._$proto.$domain" => "srv", sub {
        my @res;
  
        # classify by priority
        my %pri;
        push @{ $pri{$_->[4]} }, [ @$_[4,5,6,7] ]
           for @_;
  
        # order by priority
        for my $pri (sort { $a <=> $b } keys %pri) {
           # order by weight
           my @rr = sort { $a->[1] <=> $b->[1] } @{ delete $pri{$pri} };
  
           my $sum; $sum += $_->[1] for @rr;
  
           while (@rr) {
              my $w = int rand $sum + 1;
              for (0 .. $#rr) {
                 if (($w -= $rr[$_][1]) <= 0) {
                    $sum -= $rr[$_][1];
                    push @res, splice @rr, $_, 1, ();
                    last;
                 }
              }
           }
        }
  
        $cb->(@res);
     });
  }
  
  sub ptr($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "ptr", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub any($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "*", $cb);
  }
  
  # convert textual ip address into reverse lookup form
  sub _munge_ptr($) {
     my $ipn = $_[0]
        or return;
  
     my $ptr;
  
     my $af = AnyEvent::Socket::address_family ($ipn);
  
     if ($af == AF_INET6) {
        $ipn = substr $ipn, 0, 16; # anticipate future expansion
  
        # handle v4mapped and v4compat
        if ($ipn =~ s/^\x00{10}(?:\xff\xff|\x00\x00)//) {
           $af = AF_INET;
        } else {
           $ptr = join ".", (reverse split //, unpack "H32", $ipn), "ip6.arpa.";
        }
     }
  
     if ($af == AF_INET) {
        $ptr = join ".", (reverse unpack "C4", $ipn), "in-addr.arpa.";
     }
  
     $ptr
  }
  
  sub reverse_lookup($$) {
     my ($ip, $cb) = @_;
  
     $ip = _munge_ptr AnyEvent::Socket::parse_address ($ip)
        or return $cb->();
  
     resolver->resolve ($ip => "ptr", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub reverse_verify($$) {
     my ($ip, $cb) = @_;
     
     my $ipn = AnyEvent::Socket::parse_address ($ip)
        or return $cb->();
  
     my $af = AnyEvent::Socket::address_family ($ipn);
  
     my @res;
     my $cnt;
  
     my $ptr = _munge_ptr $ipn
        or return $cb->();
  
     $ip = AnyEvent::Socket::format_address ($ipn); # normalise into the same form
  
     ptr $ptr, sub {
        for my $name (@_) {
           ++$cnt;
           
           # () around AF_INET to work around bug in 5.8
           resolver->resolve ("$name." => ($af == (AF_INET) ? "a" : "aaaa"), sub {
              for (@_) {
                 push @res, $name
                    if $_->[4] eq $ip;
              }
              $cb->(@res) unless --$cnt;
           });
        }
  
        $cb->() unless $cnt;
     };
  }
  
  #################################################################################
  
  =back
  
  =head2 LOW-LEVEL DNS EN-/DECODING FUNCTIONS
  
  =over 4
  
  =item $AnyEvent::DNS::EDNS0
  
  This variable decides whether dns_pack automatically enables EDNS0
  support. By default, this is disabled (C<0>), unless overridden by
  C<$ENV{PERL_ANYEVENT_EDNS0}>, but when set to C<1>, AnyEvent::DNS will use
  EDNS0 in all requests.
  
  =cut
  
  our $EDNS0 = $ENV{PERL_ANYEVENT_EDNS0}*1; # set to 1 to enable (partial) edns0
  
  our %opcode_id = (
     query  => 0,
     iquery => 1,
     status => 2,
     notify => 4,
     update => 5,
     map +($_ => $_), 3, 6..15
  );
  
  our %opcode_str = reverse %opcode_id;
  
  our %rcode_id = (
     noerror  =>  0,
     formerr  =>  1,
     servfail =>  2,
     nxdomain =>  3,
     notimp   =>  4,
     refused  =>  5,
     yxdomain =>  6, # Name Exists when it should not     [RFC 2136]
     yxrrset  =>  7, # RR Set Exists when it should not   [RFC 2136]
     nxrrset  =>  8, # RR Set that should exist does not  [RFC 2136]
     notauth  =>  9, # Server Not Authoritative for zone  [RFC 2136]
     notzone  => 10, # Name not contained in zone         [RFC 2136]
  # EDNS0  16    BADVERS   Bad OPT Version                    [RFC 2671]
  # EDNS0  16    BADSIG    TSIG Signature Failure             [RFC 2845]
  # EDNS0  17    BADKEY    Key not recognized                 [RFC 2845]
  # EDNS0  18    BADTIME   Signature out of time window       [RFC 2845]
  # EDNS0  19    BADMODE   Bad TKEY Mode                      [RFC 2930]
  # EDNS0  20    BADNAME   Duplicate key name                 [RFC 2930]
  # EDNS0  21    BADALG    Algorithm not supported            [RFC 2930]
     map +($_ => $_), 11..15
  );
  
  our %rcode_str = reverse %rcode_id;
  
  our %type_id = (
     a     =>   1,
     ns    =>   2,
     md    =>   3,
     mf    =>   4,
     cname =>   5,
     soa   =>   6,
     mb    =>   7,
     mg    =>   8,
     mr    =>   9,
     null  =>  10,
     wks   =>  11,
     ptr   =>  12,
     hinfo =>  13,
     minfo =>  14,
     mx    =>  15,
     txt   =>  16,
     aaaa  =>  28,
     srv   =>  33,
     naptr =>  35, # rfc2915
     dname =>  39, # rfc2672
     opt   =>  41,
     spf   =>  99,
     tkey  => 249,
     tsig  => 250,
     ixfr  => 251,
     axfr  => 252,
     mailb => 253,
     "*"   => 255,
  );
  
  our %type_str = reverse %type_id;
  
  our %class_id = (
     in   =>   1,
     ch   =>   3,
     hs   =>   4,
     none => 254,
     "*"  => 255,
  );
  
  our %class_str = reverse %class_id;
  
  sub _enc_name($) {
     pack "(C/a*)*", (split /\./, shift), ""
  }
  
  if ($] < 5.008) {
     # special slower 5.6 version
     *_enc_name = sub ($) {
        join "", map +(pack "C/a*", $_), (split /\./, shift), ""
     };
  }
  
  sub _enc_qd() {
     (_enc_name $_->[0]) . pack "nn",
       ($_->[1] > 0 ? $_->[1] : $type_id {$_->[1]}),
       ($_->[3] > 0 ? $_->[2] : $class_id{$_->[2] || "in"})
  }
  
  sub _enc_rr() {
     die "encoding of resource records is not supported";
  }
  
  =item $pkt = AnyEvent::DNS::dns_pack $dns
  
  Packs a perl data structure into a DNS packet. Reading RFC 1035 is strongly
  recommended, then everything will be totally clear. Or maybe not.
  
  Resource records are not yet encodable.
  
  Examples:
  
     # very simple request, using lots of default values:
     { rd => 1, qd => [ [ "host.domain", "a"] ] }
    
     # more complex example, showing how flags etc. are named:
    
     {
        id => 10000,
        op => "query",
        rc => "nxdomain",
    
        # flags
        qr => 1,
        aa => 0,
        tc => 0,
        rd => 0,
        ra => 0,
        ad => 0,
        cd => 0,
    
        qd => [@rr], # query section
        an => [@rr], # answer section
        ns => [@rr], # authority section
        ar => [@rr], # additional records section
     }
  
  =cut
  
  sub dns_pack($) {
     my ($req) = @_;
  
     pack "nn nnnn a* a* a* a* a*",
        $req->{id},
  
        ! !$req->{qr}   * 0x8000
        + $opcode_id{$req->{op}} * 0x0800
        + ! !$req->{aa} * 0x0400
        + ! !$req->{tc} * 0x0200
        + ! !$req->{rd} * 0x0100
        + ! !$req->{ra} * 0x0080
        + ! !$req->{ad} * 0x0020
        + ! !$req->{cd} * 0x0010
        + $rcode_id{$req->{rc}} * 0x0001,
  
        scalar @{ $req->{qd} || [] },
        scalar @{ $req->{an} || [] },
        scalar @{ $req->{ns} || [] },
        $EDNS0 + scalar @{ $req->{ar} || [] }, # EDNS0 option included here
  
        (join "", map _enc_qd, @{ $req->{qd} || [] }),
        (join "", map _enc_rr, @{ $req->{an} || [] }),
        (join "", map _enc_rr, @{ $req->{ns} || [] }),
        (join "", map _enc_rr, @{ $req->{ar} || [] }),
  
        ($EDNS0 ? pack "C nnNn", 0, 41, MAX_PKT, 0, 0 : "") # EDNS0 option
  }
  
  our $ofs;
  our $pkt;
  
  # bitches
  sub _dec_name {
     my @res;
     my $redir;
     my $ptr = $ofs;
     my $cnt;
  
     while () {
        return undef if ++$cnt >= 256; # to avoid DoS attacks
  
        my $len = ord substr $pkt, $ptr++, 1;
  
        if ($len >= 0xc0) {
           $ptr++;
           $ofs = $ptr if $ptr > $ofs;
           $ptr = (unpack "n", substr $pkt, $ptr - 2, 2) & 0x3fff;
        } elsif ($len) {
           push @res, substr $pkt, $ptr, $len;
           $ptr += $len;
        } else {
           $ofs = $ptr if $ptr > $ofs;
           return join ".", @res;
        }
     }
  }
  
  sub _dec_qd {
     my $qname = _dec_name;
     my ($qt, $qc) = unpack "nn", substr $pkt, $ofs; $ofs += 4;
     [$qname, $type_str{$qt} || $qt, $class_str{$qc} || $qc]
  }
  
  our %dec_rr = (
       1 => sub { join ".", unpack "C4", $_ }, # a
       2 => sub { local $ofs = $ofs - length; _dec_name }, # ns
       5 => sub { local $ofs = $ofs - length; _dec_name }, # cname
       6 => sub { 
               local $ofs = $ofs - length;
               my $mname = _dec_name;
               my $rname = _dec_name;
               ($mname, $rname, unpack "NNNNN", substr $pkt, $ofs)
            }, # soa
      11 => sub { ((join ".", unpack "C4", $_), unpack "C a*", substr $_, 4) }, # wks
      12 => sub { local $ofs = $ofs - length; _dec_name }, # ptr
      13 => sub { unpack "C/a* C/a*", $_ }, # hinfo
      15 => sub { local $ofs = $ofs + 2 - length; ((unpack "n", $_), _dec_name) }, # mx
      16 => sub { unpack "(C/a*)*", $_ }, # txt
      28 => sub { AnyEvent::Socket::format_ipv6 ($_) }, # aaaa
      33 => sub { local $ofs = $ofs + 6 - length; ((unpack "nnn", $_), _dec_name) }, # srv
      35 => sub { # naptr
         # requires perl 5.10, sorry
         my ($order, $preference, $flags, $service, $regexp, $offset) = unpack "nn C/a* C/a* C/a* .", $_;
         local $ofs = $ofs + $offset - length;
         ($order, $preference, $flags, $service, $regexp, _dec_name)
      },
      39 => sub { local $ofs = $ofs - length; _dec_name }, # dname
      99 => sub { unpack "(C/a*)*", $_ }, # spf
  );
  
  sub _dec_rr {
     my $name = _dec_name;
  
     my ($rt, $rc, $ttl, $rdlen) = unpack "nn N n", substr $pkt, $ofs; $ofs += 10;
     local $_ = substr $pkt, $ofs, $rdlen; $ofs += $rdlen;
  
     [
        $name,
        $type_str{$rt}  || $rt,
        $class_str{$rc} || $rc,
        $ttl,
        ($dec_rr{$rt} || sub { $_ })->(),
     ]
  }
  
  =item $dns = AnyEvent::DNS::dns_unpack $pkt
  
  Unpacks a DNS packet into a perl data structure.
  
  Examples:
  
     # an unsuccessful reply
     {
       'qd' => [
                 [ 'ruth.plan9.de.mach.uni-karlsruhe.de', '*', 'in' ]
               ],
       'rc' => 'nxdomain',
       'ar' => [],
       'ns' => [
                 [
                   'uni-karlsruhe.de',
                   'soa',
                   'in',
                   600,
                   'netserv.rz.uni-karlsruhe.de',
                   'hostmaster.rz.uni-karlsruhe.de',
                   2008052201, 10800, 1800, 2592000, 86400
                 ]
               ],
       'tc' => '',
       'ra' => 1,
       'qr' => 1,
       'id' => 45915,
       'aa' => '',
       'an' => [],
       'rd' => 1,
       'op' => 'query'
     }
     
     # a successful reply
     
     {
       'qd' => [ [ 'www.google.de', 'a', 'in' ] ],
       'rc' => 0,
       'ar' => [
                 [ 'a.l.google.com', 'a', 'in', 3600, '209.85.139.9' ],
                 [ 'b.l.google.com', 'a', 'in', 3600, '64.233.179.9' ],
                 [ 'c.l.google.com', 'a', 'in', 3600, '64.233.161.9' ],
               ],
       'ns' => [
                 [ 'l.google.com', 'ns', 'in', 3600, 'a.l.google.com' ],
                 [ 'l.google.com', 'ns', 'in', 3600, 'b.l.google.com' ],
               ],
       'tc' => '',
       'ra' => 1,
       'qr' => 1,
       'id' => 64265,
       'aa' => '',
       'an' => [
                 [ 'www.google.de', 'cname', 'in', 3600, 'www.google.com' ],
                 [ 'www.google.com', 'cname', 'in', 3600, 'www.l.google.com' ],
                 [ 'www.l.google.com', 'a', 'in', 3600, '66.249.93.104' ],
                 [ 'www.l.google.com', 'a', 'in', 3600, '66.249.93.147' ],
               ],
       'rd' => 1,
       'op' => 0
     }
  
  =cut
  
  sub dns_unpack($) {
     local $pkt = shift;
     my ($id, $flags, $qd, $an, $ns, $ar)
        = unpack "nn nnnn A*", $pkt;
  
     local $ofs = 6 * 2;
  
     {
        id => $id,
        qr => ! ! ($flags & 0x8000),
        aa => ! ! ($flags & 0x0400),
        tc => ! ! ($flags & 0x0200),
        rd => ! ! ($flags & 0x0100),
        ra => ! ! ($flags & 0x0080),
        ad => ! ! ($flags & 0x0020),
        cd => ! ! ($flags & 0x0010),
        op => $opcode_str{($flags & 0x001e) >> 11},
        rc => $rcode_str{($flags & 0x000f)},
  
        qd => [map _dec_qd, 1 .. $qd],
        an => [map _dec_rr, 1 .. $an],
        ns => [map _dec_rr, 1 .. $ns],
        ar => [map _dec_rr, 1 .. $ar],
     }
  }
  
  #############################################################################
  
  =back
  
  =head2 THE AnyEvent::DNS RESOLVER CLASS
  
  This is the class which does the actual protocol work.
  
  =over 4
  
  =cut
  
  use Carp ();
  use Scalar::Util ();
  use Socket ();
  
  our $NOW;
  
  =item AnyEvent::DNS::resolver
  
  This function creates and returns a resolver that is ready to use and
  should mimic the default resolver for your system as good as possible. It
  is used by AnyEvent itself as well.
  
  It only ever creates one resolver and returns this one on subsequent calls
  - see C<$AnyEvent::DNS::RESOLVER>, below, for details.
  
  Unless you have special needs, prefer this function over creating your own
  resolver object.
  
  The resolver is created with the following parameters:
  
     untaint          enabled
     max_outstanding  $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}
  
  C<os_config> will be used for OS-specific configuration, unless
  C<$ENV{PERL_ANYEVENT_RESOLV_CONF}> is specified, in which case that file
  gets parsed.
  
  =item $AnyEvent::DNS::RESOLVER
  
  This variable stores the default resolver returned by
  C<AnyEvent::DNS::resolver>, or C<undef> when the default resolver hasn't
  been instantiated yet.
  
  One can provide a custom resolver (e.g. one with caching functionality)
  by storing it in this variable, causing all subsequent resolves done via
  C<AnyEvent::DNS::resolver> to be done via the custom one.
  
  =cut
  
  our $RESOLVER;
  
  sub resolver() {
     $RESOLVER || do {
        $RESOLVER = new AnyEvent::DNS
           untaint         => 1,
           max_outstanding => $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}*1 || 1,
        ;
  
        $ENV{PERL_ANYEVENT_RESOLV_CONF}
           ? $RESOLVER->_parse_resolv_conf_file ($ENV{PERL_ANYEVENT_RESOLV_CONF})
           : $RESOLVER->os_config;
  
        $RESOLVER
     }
  }
  
  =item $resolver = new AnyEvent::DNS key => value...
  
  Creates and returns a new resolver.
  
  The following options are supported:
  
  =over 4
  
  =item server => [...]
  
  A list of server addresses (default: C<v127.0.0.1> or C<::1>) in network
  format (i.e. as returned by C<AnyEvent::Socket::parse_address> - both IPv4
  and IPv6 are supported).
  
  =item timeout => [...]
  
  A list of timeouts to use (also determines the number of retries). To make
  three retries with individual time-outs of 2, 5 and 5 seconds, use C<[2,
  5, 5]>, which is also the default.
  
  =item search => [...]
  
  The default search list of suffixes to append to a domain name (default: none).
  
  =item ndots => $integer
  
  The number of dots (default: C<1>) that a name must have so that the resolver
  tries to resolve the name without any suffixes first.
  
  =item max_outstanding => $integer
  
  Most name servers do not handle many parallel requests very well. This
  option limits the number of outstanding requests to C<$integer>
  (default: C<10>), that means if you request more than this many requests,
  then the additional requests will be queued until some other requests have
  been resolved.
  
  =item reuse => $seconds
  
  The number of seconds (default: C<300>) that a query id cannot be re-used
  after a timeout. If there was no time-out then query ids can be reused
  immediately.
  
  =item untaint => $boolean
  
  When true, then the resolver will automatically untaint results, and might
  also ignore certain environment variables.
  
  =back
  
  =cut
  
  sub new {
     my ($class, %arg) = @_;
  
     my $self = bless {
        server  => [],
        timeout => [2, 5, 5],
        search  => [],
        ndots   => 1,
        max_outstanding => 10,
        reuse   => 300,
        %arg,
        reuse_q => [],
     }, $class;
  
     # search should default to gethostname's domain
     # but perl lacks a good posix module
  
     # try to create an ipv4 and an ipv6 socket
     # only fail when we cannot create either
     my $got_socket;
  
     Scalar::Util::weaken (my $wself = $self);
  
     if (socket my $fh4, AF_INET , Socket::SOCK_DGRAM(), 0) {
        ++$got_socket;
  
        AnyEvent::Util::fh_nonblocking $fh4, 1;
        $self->{fh4} = $fh4;
        $self->{rw4} = AE::io $fh4, 0, sub {
           if (my $peer = recv $fh4, my $pkt, MAX_PKT, 0) {
              $wself->_recv ($pkt, $peer);
           }
        };
     }
  
     if (AF_INET6 && socket my $fh6, AF_INET6, Socket::SOCK_DGRAM(), 0) {
        ++$got_socket;
  
        $self->{fh6} = $fh6;
        AnyEvent::Util::fh_nonblocking $fh6, 1;
        $self->{rw6} = AE::io $fh6, 0, sub {
           if (my $peer = recv $fh6, my $pkt, MAX_PKT, 0) {
              $wself->_recv ($pkt, $peer);
           }
        };
     }
  
     $got_socket
        or Carp::croak "unable to create either an IPv4 or an IPv6 socket";
  
     $self->_compile;
  
     $self
  }
  
  =item $resolver->parse_resolv_conf ($string)
  
  Parses the given string as if it were a F<resolv.conf> file. The following
  directives are supported (but not necessarily implemented).
  
  C<#>- and C<;>-style comments, C<nameserver>, C<domain>, C<search>, C<sortlist>,
  C<options> (C<timeout>, C<attempts>, C<ndots>).
  
  Everything else is silently ignored.
  
  =cut
  
  sub parse_resolv_conf {
     my ($self, $resolvconf) = @_;
  
     $self->{server} = [];
     $self->{search} = [];
  
     my $attempts;
  
     for (split /\n/, $resolvconf) {
        s/\s*[;#].*$//; # not quite legal, but many people insist
  
        if (/^\s*nameserver\s+(\S+)\s*$/i) {
           my $ip = $1;
           if (my $ipn = AnyEvent::Socket::parse_address ($ip)) {
              push @{ $self->{server} }, $ipn;
           } else {
              AE::log 5 => "nameserver $ip invalid and ignored, while parsing resolver config.";
           }
        } elsif (/^\s*domain\s+(\S*)\s*$/i) {
           $self->{search} = [$1];
        } elsif (/^\s*search\s+(.*?)\s*$/i) {
           $self->{search} = [split /\s+/, $1];
        } elsif (/^\s*sortlist\s+(.*?)\s*$/i) {
           # ignored, NYI
        } elsif (/^\s*options\s+(.*?)\s*$/i) {
           for (split /\s+/, $1) {
              if (/^timeout:(\d+)$/) {
                 $self->{timeout} = [$1];
              } elsif (/^attempts:(\d+)$/) {
                 $attempts = $1;
              } elsif (/^ndots:(\d+)$/) {
                 $self->{ndots} = $1;
              } else {
                 # debug, rotate, no-check-names, inet6
              }
           }
        } else {
           # silently skip stuff we don't understand
        }
     }
  
     $self->{timeout} = [($self->{timeout}[0]) x $attempts]
        if $attempts;
  
     $self->_compile;
  }
  
  sub _parse_resolv_conf_file {
     my ($self, $resolv_conf) = @_;
  
     open my $fh, "<", $resolv_conf
        or Carp::croak "$resolv_conf: $!";
  
     local $/;
     $self->parse_resolv_conf (<$fh>);
  }
  
  =item $resolver->os_config
  
  Tries so load and parse F</etc/resolv.conf> on portable operating
  systems. Tries various egregious hacks on windows to force the DNS servers
  and searchlist out of the system.
  
  =cut
  
  sub os_config {
     my ($self) = @_;
  
     $self->{server} = [];
     $self->{search} = [];
  
     if ((AnyEvent::WIN32 || $^O =~ /cygwin/i)) {
        #no strict 'refs';
  
        # there are many options to find the current nameservers etc. on windows
        # all of them don't work consistently:
        # - the registry thing needs separate code on win32 native vs. cygwin
        # - the registry layout differs between windows versions
        # - calling windows api functions doesn't work on cygwin
        # - ipconfig uses locale-specific messages
  
        # we use Net::DNS::Resolver first, and if it fails, will fall back to
        # ipconfig parsing.
        unless (eval {
           # Net::DNS::Resolver uses a LOT of ram (~10mb), but what can we do :/
           # (this seems mostly to be due to Win32::API).
           require Net::DNS::Resolver;
           my $r = Net::DNS::Resolver->new;
  
           $r->nameservers
              or die;
  
           for my $s ($r->nameservers) {
              if (my $ipn = AnyEvent::Socket::parse_address ($s)) {
                 push @{ $self->{server} }, $ipn;
              }
           }
           $self->{search} = [$r->searchlist];
  
           1
        }) {
           # we use ipconfig parsing because, despite all its brokenness,
           # it seems most stable in practise.
           # unfortunately it wants a console window.
           # for good measure, we append a fallback nameserver to our list.
  
           if (open my $fh, "ipconfig /all |") {
              # parsing strategy: we go through the output and look for
              # :-lines with DNS in them. everything in those is regarded as
              # either a nameserver (if it parses as an ip address), or a suffix
              # (all else).
  
              my $dns;
              local $_;
              while (<$fh>) {
                 if (s/^\s.*\bdns\b.*://i) {
                    $dns = 1;
                 } elsif (/^\S/ || /^\s[^:]{16,}: /) {
                    $dns = 0;
                 }
                 if ($dns && /^\s*(\S+)\s*$/) {
                    my $s = $1;
                    $s =~ s/%\d+(?!\S)//; # get rid of ipv6 scope id
                    if (my $ipn = AnyEvent::Socket::parse_address ($s)) {
                       push @{ $self->{server} }, $ipn;
                    } else {
                       push @{ $self->{search} }, $s;
                    }
                 }
              }
           }
        }
  
        # always add the fallback servers on windows
        push @{ $self->{server} }, @DNS_FALLBACK;
  
        $self->_compile;
     } else {
        # try resolv.conf everywhere else
  
        $self->_parse_resolv_conf_file ("/etc/resolv.conf")
           if -e "/etc/resolv.conf";
     }
  }
  
  =item $resolver->timeout ($timeout, ...)
  
  Sets the timeout values. See the C<timeout> constructor argument (and note
  that this method uses the values itself, not an array-reference).
  
  =cut
  
  sub timeout {
     my ($self, @timeout) = @_;
  
     $self->{timeout} = \@timeout;
     $self->_compile;
  }
  
  =item $resolver->max_outstanding ($nrequests)
  
  Sets the maximum number of outstanding requests to C<$nrequests>. See the
  C<max_outstanding> constructor argument.
  
  =cut
  
  sub max_outstanding {
     my ($self, $max) = @_;
  
     $self->{max_outstanding} = $max;
     $self->_scheduler;
  }
  
  sub _compile {
     my $self = shift;
  
     my %search; $self->{search} = [grep 0 < length, grep !$search{$_}++, @{ $self->{search} }];
     my %server; $self->{server} = [grep 0 < length, grep !$server{$_}++, @{ $self->{server} }];
  
     unless (@{ $self->{server} }) {
        # use 127.0.0.1/::1 by default, add public nameservers as fallback
        my $default = $AnyEvent::PROTOCOL{ipv6} > $AnyEvent::PROTOCOL{ipv4}
                      ? "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1" : "\x7f\x00\x00\x01";
        $self->{server} = [$default, @DNS_FALLBACK];
     }
  
     my @retry;
  
     for my $timeout (@{ $self->{timeout} }) {
        for my $server (@{ $self->{server} }) {
           push @retry, [$server, $timeout];
        }
     }
  
     $self->{retry} = \@retry;
  }
  
  sub _feed {
     my ($self, $res) = @_;
  
     ($res) = $res =~ /^(.*)$/s
        if AnyEvent::TAINT && $self->{untaint};
  
     $res = dns_unpack $res
        or return;
  
     my $id = $self->{id}{$res->{id}};
  
     return unless ref $id;
  
     $NOW = time;
     $id->[1]->($res);
  }
  
  sub _recv {
     my ($self, $pkt, $peer) = @_;
  
     # we ignore errors (often one gets port unreachable, but there is
     # no good way to take advantage of that.
  
     my ($port, $host) = AnyEvent::Socket::unpack_sockaddr ($peer);
  
     return unless $port == 53 && grep $_ eq $host, @{ $self->{server} };
  
     $self->_feed ($pkt);
  }
  
  sub _free_id {
     my ($self, $id, $timeout) = @_;
  
     if ($timeout) {
        # we need to block the id for a while
        $self->{id}{$id} = 1;
        push @{ $self->{reuse_q} }, [$NOW + $self->{reuse}, $id];
     } else {
        # we can quickly recycle the id
        delete $self->{id}{$id};
     }
  
     --$self->{outstanding};
     $self->_scheduler;
  }
  
  # execute a single request, involves sending it with timeouts to multiple servers
  sub _exec {
     my ($self, $req) = @_;
  
     my $retry; # of retries
     my $do_retry;
  
     $do_retry = sub {
        my $retry_cfg = $self->{retry}[$retry++]
           or do {
              # failure
              $self->_free_id ($req->[2], $retry > 1);
              undef $do_retry; return $req->[1]->();
           };
  
        my ($server, $timeout) = @$retry_cfg;
        
        $self->{id}{$req->[2]} = [(AE::timer $timeout, 0, sub {
           $NOW = time;
  
           # timeout, try next
           &$do_retry if $do_retry;
        }), sub {
           my ($res) = @_;
  
           if ($res->{tc}) {
              # success, but truncated, so use tcp
              AnyEvent::Socket::tcp_connect (AnyEvent::Socket::format_address ($server), DOMAIN_PORT, sub {
                 return unless $do_retry; # some other request could have invalidated us already
  
                 my ($fh) = @_
                    or return &$do_retry;
  
                 require AnyEvent::Handle;
  
                 my $handle; $handle = new AnyEvent::Handle
                    fh       => $fh,
                    timeout  => $timeout,
                    on_error => sub {
                       undef $handle;
                       return unless $do_retry; # some other request could have invalidated us already
                       # failure, try next
                       &$do_retry;
                    };
  
                 $handle->push_write (pack "n/a*", $req->[0]);
                 $handle->push_read (chunk => 2, sub {
                    $handle->unshift_read (chunk => (unpack "n", $_[1]), sub {
                       undef $handle;
                       $self->_feed ($_[1]);
                    });
                 });
  
              }, sub { $timeout });
  
           } else {
              # success
              $self->_free_id ($req->[2], $retry > 1);
              undef $do_retry; return $req->[1]->($res);
           }
        }];
        
        my $sa = AnyEvent::Socket::pack_sockaddr (DOMAIN_PORT, $server);
  
        my $fh = AF_INET == AnyEvent::Socket::sockaddr_family ($sa)
                 ? $self->{fh4} : $self->{fh6}
           or return &$do_retry;
  
        send $fh, $req->[0], 0, $sa;
     };
  
     &$do_retry;
  }
  
  sub _scheduler {
     my ($self) = @_;
  
     #no strict 'refs';
  
     $NOW = time;
  
     # first clear id reuse queue
     delete $self->{id}{ (shift @{ $self->{reuse_q} })->[1] }
        while @{ $self->{reuse_q} } && $self->{reuse_q}[0][0] <= $NOW;
  
     while ($self->{outstanding} < $self->{max_outstanding}) {
  
        if (@{ $self->{reuse_q} } >= 30000) {
           # we ran out of ID's, wait a bit
           $self->{reuse_to} ||= AE::timer $self->{reuse_q}[0][0] - $NOW, 0, sub {
              delete $self->{reuse_to};
              $self->_scheduler;
           };
           last;
        }
  
        if (my $req = shift @{ $self->{queue} }) {
           # found a request in the queue, execute it
           while () {
              $req->[2] = int rand 65536;
              last unless exists $self->{id}{$req->[2]};
           }
  
           ++$self->{outstanding};
           $self->{id}{$req->[2]} = 1;
           substr $req->[0], 0, 2, pack "n", $req->[2];
  
           $self->_exec ($req);
  
        } elsif (my $cb = shift @{ $self->{wait} }) {
           # found a wait_for_slot callback, call that one first
           $cb->($self);
  
        } else {
           # nothing to do, just exit
           last;
        }
     }
  }
  
  =item $resolver->request ($req, $cb->($res))
  
  This is the main low-level workhorse for sending DNS requests.
  
  This function sends a single request (a hash-ref formated as specified
  for C<dns_pack>) to the configured nameservers in turn until it gets a
  response. It handles timeouts, retries and automatically falls back to
  virtual circuit mode (TCP) when it receives a truncated reply. It does not
  handle anything else, such as the domain searchlist or relative names -
  use C<< ->resolve >> for that.
  
  Calls the callback with the decoded response packet if a reply was
  received, or no arguments in case none of the servers answered.
  
  =cut
  
  sub request($$) {
     my ($self, $req, $cb) = @_;
  
     # _enc_name barfs on names that are too long, which is often outside
     # program control, so check for too long names here.
     for (@{ $req->{qd} }) {
        return AE::postpone sub { $cb->(undef) }
           if 255 < length $_->[0];
     }
  
     push @{ $self->{queue} }, [dns_pack $req, $cb];
     $self->_scheduler;
  }
  
  =item $resolver->resolve ($qname, $qtype, %options, $cb->(@rr))
  
  Queries the DNS for the given domain name C<$qname> of type C<$qtype>.
  
  A C<$qtype> is either a numerical query type (e.g. C<1> for A records) or
  a lowercase name (you have to look at the source to see which aliases are
  supported, but all types from RFC 1035, C<aaaa>, C<srv>, C<spf> and a few
  more are known to this module). A C<$qtype> of "*" is supported and means
  "any" record type.
  
  The callback will be invoked with a list of matching result records or
  none on any error or if the name could not be found.
  
  CNAME chains (although illegal) are followed up to a length of 10.
  
  The callback will be invoked with arraryefs of the form C<[$name,
  $type, $class, $ttl, @data>], where C<$name> is the domain name,
  C<$type> a type string or number, C<$class> a class name, C<$ttl> is the
  remaining time-to-live and C<@data> is resource-record-dependent data, in
  seconds. For C<a> records, this will be the textual IPv4 addresses, for
  C<ns> or C<cname> records this will be a domain name, for C<txt> records
  these are all the strings and so on.
  
  All types mentioned in RFC 1035, C<aaaa>, C<srv>, C<naptr> and C<spf> are
  decoded. All resource records not known to this module will have the raw
  C<rdata> field as fifth array element.
  
  Note that this resolver is just a stub resolver: it requires a name server
  supporting recursive queries, will not do any recursive queries itself and
  is not secure when used against an untrusted name server.
  
  The following options are supported:
  
  =over 4
  
  =item search => [$suffix...]
  
  Use the given search list (which might be empty), by appending each one
  in turn to the C<$qname>. If this option is missing then the configured
  C<ndots> and C<search> values define its value (depending on C<ndots>, the
  empty suffix will be prepended or appended to that C<search> value). If
  the C<$qname> ends in a dot, then the searchlist will be ignored.
  
  =item accept => [$type...]
  
  Lists the acceptable result types: only result types in this set will be
  accepted and returned. The default includes the C<$qtype> and nothing
  else. If this list includes C<cname>, then CNAME-chains will not be
  followed (because you asked for the CNAME record).
  
  =item class => "class"
  
  Specify the query class ("in" for internet, "ch" for chaosnet and "hs" for
  hesiod are the only ones making sense). The default is "in", of course.
  
  =back
  
  Examples:
  
     # full example, you can paste this into perl:
     use Data::Dumper;
     use AnyEvent::DNS;
     AnyEvent::DNS::resolver->resolve (
        "google.com", "*", my $cv = AnyEvent->condvar);
     warn Dumper [$cv->recv];
  
     # shortened result:
     # [
     #   [ 'google.com', 'soa', 'in', 3600, 'ns1.google.com', 'dns-admin.google.com',
     #     2008052701, 7200, 1800, 1209600, 300 ],
     #   [
     #     'google.com', 'txt', 'in', 3600,
     #     'v=spf1 include:_netblocks.google.com ~all'
     #   ],
     #   [ 'google.com', 'a', 'in', 3600, '64.233.187.99' ],
     #   [ 'google.com', 'mx', 'in', 3600, 10, 'smtp2.google.com' ],
     #   [ 'google.com', 'ns', 'in', 3600, 'ns2.google.com' ],
     # ]
  
     # resolve a records:
     $res->resolve ("ruth.plan9.de", "a", sub { warn Dumper [@_] });
  
     # result:
     # [
     #   [ 'ruth.schmorp.de', 'a', 'in', 86400, '129.13.162.95' ]
     # ]
  
     # resolve any records, but return only a and aaaa records:
     $res->resolve ("test1.laendle", "*",
        accept => ["a", "aaaa"],
        sub {
           warn Dumper [@_];
        }
     );
  
     # result:
     # [
     #   [ 'test1.laendle', 'a', 'in', 86400, '10.0.0.255' ],
     #   [ 'test1.laendle', 'aaaa', 'in', 60, '3ffe:1900:4545:0002:0240:0000:0000:f7e1' ]
     # ]
  
  =cut
  
  sub resolve($%) {
     my $cb = pop;
     my ($self, $qname, $qtype, %opt) = @_;
  
     my @search = $qname =~ s/\.$//
        ? ""
        : $opt{search}
          ? @{ $opt{search} }
          : ($qname =~ y/.//) >= $self->{ndots}
            ? ("", @{ $self->{search} })
            : (@{ $self->{search} }, "");
  
     my $class = $opt{class} || "in";
  
     my %atype = $opt{accept}
        ? map +($_ => 1), @{ $opt{accept} }
        : ($qtype => 1);
  
     # advance in searchlist
     my ($do_search, $do_req);
     
     $do_search = sub {
        @search
           or (undef $do_search), (undef $do_req), return $cb->();
  
        (my $name = lc "$qname." . shift @search) =~ s/\.$//;
        my $depth = 10;
  
        # advance in cname-chain
        $do_req = sub {
           $self->request ({
              rd => 1,
              qd => [[$name, $qtype, $class]],
           }, sub {
              my ($res) = @_
                 or return $do_search->();
  
              my $cname;
  
              while () {
                 # results found?
                 my @rr = grep $name eq lc $_->[0] && ($atype{"*"} || $atype{$_->[1]}), @{ $res->{an} };
  
                 (undef $do_search), (undef $do_req), return $cb->(@rr)
                    if @rr;
  
                 # see if there is a cname we can follow
                 my @rr = grep $name eq lc $_->[0] && $_->[1] eq "cname", @{ $res->{an} };
  
                 if (@rr) {
                    $depth--
                       or return $do_search->(); # cname chain too long
  
                    $cname = 1;
                    $name = lc $rr[0][4];
  
                 } elsif ($cname) {
                    # follow the cname
                    return $do_req->();
  
                 } else {
                    # no, not found anything
                    return $do_search->();
                 }
               }
           });
        };
  
        $do_req->();
     };
  
     $do_search->();
  }
  
  =item $resolver->wait_for_slot ($cb->($resolver))
  
  Wait until a free request slot is available and call the callback with the
  resolver object.
  
  A request slot is used each time a request is actually sent to the
  nameservers: There are never more than C<max_outstanding> of them.
  
  Although you can submit more requests (they will simply be queued until
  a request slot becomes available), sometimes, usually for rate-limiting
  purposes, it is useful to instead wait for a slot before generating the
  request (or simply to know when the request load is low enough so one can
  submit requests again).
  
  This is what this method does: The callback will be called when submitting
  a DNS request will not result in that request being queued. The callback
  may or may not generate any requests in response.
  
  Note that the callback will only be invoked when the request queue is
  empty, so this does not play well if somebody else keeps the request queue
  full at all times.
  
  =cut
  
  sub wait_for_slot {
     my ($self, $cb) = @_;
  
     push @{ $self->{wait} }, $cb;
     $self->_scheduler;
  }
  
  use AnyEvent::Socket (); # circular dependency, so do not import anything and do it at the end
  
  1;
  
  =back
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_DNS

$fatpacked{"darwin-2level/AnyEvent/Debug.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_DEBUG';
  =head1 NAME
  
  AnyEvent::Debug - debugging utilities for AnyEvent
  
  =head1 SYNOPSIS
  
     use AnyEvent::Debug;
  
     # create an interactive shell into the program
     my $shell = AnyEvent::Debug::shell "unix/", "/home/schmorp/myshell";
     # then on the shell: "socat readline /home/schmorp/myshell"
  
  =head1 DESCRIPTION
  
  This module provides functionality hopefully useful for debugging.
  
  At the moment, "only" an interactive shell is implemented. This shell
  allows you to interactively "telnet into" your program and execute Perl
  code, e.g. to look at global variables.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::Debug;
  
  use B ();
  use Carp ();
  use Errno ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  use AnyEvent::Socket ();
  use AnyEvent::Log ();
  
  our $TRACE = 1; # trace status
  
  our ($TRACE_LOGGER, $TRACE_ENABLED);
  
  # cache often-used strings, purely to save memory, at the expense of speed
  our %STRCACHE;
  
  =item $shell = AnyEvent::Debug::shell $host, $service
  
  This function binds on the given host and service port and returns a
  shell object, which determines the lifetime of the shell. Any number
  of conenctions are accepted on the port, and they will give you a very
  primitive shell that simply executes every line you enter.
  
  All commands will be executed "blockingly" with the socket C<select>ed for
  output. For a less "blocking" interface see L<Coro::Debug>.
  
  The commands will be executed in the C<AnyEvent::Debug::shell> package,
  which currently has "help" and a few other commands, and can be freely
  modified by all shells. Code is evaluated under C<use strict 'subs'>.
  
  Every shell has a logging context (C<$LOGGER>) that is attached to
  C<$AnyEvent::Log::COLLECT>), which is especially useful to gether debug
  and trace messages.
  
  As a general programming guide, consider the beneficial aspects of
  using more global (C<our>) variables than local ones (C<my>) in package
  scope: Earlier all my modules tended to hide internal variables inside
  C<my> variables, so users couldn't accidentally access them. Having
  interactive access to your programs changed that: having internal
  variables still in the global scope means you can debug them easier.
  
  As no authentication is done, in most cases it is best not to use a TCP
  port, but a unix domain socket, whcih can be put wherever you can access
  it, but not others:
  
     our $SHELL = AnyEvent::Debug::shell "unix/", "/home/schmorp/shell";
  
  Then you can use a tool to connect to the shell, such as the ever
  versatile C<socat>, which in addition can give you readline support:
  
     socat readline /home/schmorp/shell
     # or:
     cd /home/schmorp; socat readline unix:shell
  
  Socat can even give you a persistent history:
  
     socat readline,history=.anyevent-history unix:shell
  
  Binding on C<127.0.0.1> (or C<::1>) might be a less secure but sitll not
  totally insecure (on single-user machines) alternative to let you use
  other tools, such as telnet:
  
     our $SHELL = AnyEvent::Debug::shell "127.1", "1357";
  
  And then:
  
     telnet localhost 1357
  
  =cut
  
  sub shell($$) {
     local $TRACE = 0;
  
     AnyEvent::Socket::tcp_server $_[0], $_[1], sub {
        my ($fh, $host, $port) = @_;
  
        syswrite $fh, "Welcome, $host:$port, use 'help' for more info!\015\012> ";
        my $rbuf;
  
        my $logger = new AnyEvent::Log::Ctx
           log_cb => sub {
              syswrite $fh, shift;
              0
           };
  
        my $logger_guard = AnyEvent::Util::guard {
           $AnyEvent::Log::COLLECT->detach ($logger);
        };
        $AnyEvent::Log::COLLECT->attach ($logger);
  
        local $TRACE = 0;
        my $rw; $rw = AE::io $fh, 0, sub {
           my $len = sysread $fh, $rbuf, 1024, length $rbuf;
  
           $logger_guard if 0; # reference it
  
           if (defined $len ? $len == 0 : $! != Errno::EAGAIN) {
              undef $rw;
           } else {
              while ($rbuf =~ s/^(.*)\015?\012//) {
                 my $line = $1;
  
                 AnyEvent::Util::fh_nonblocking $fh, 0;
  
                 if ($line =~ /^\s*exit\b/) {
                    syswrite $fh, "sorry, no... if you want to execute exit, try CORE::exit.\015\012";
                 } else {
                    package AnyEvent::Debug::shell;
  
                    no strict 'vars';
                    local $LOGGER = $logger;
                    my $old_stdout = select $fh;
                    local $| = 1;
  
                    my @res = eval $line;
  
                    select $old_stdout;
                    syswrite $fh, "$@" if $@;
                    syswrite $fh, "\015\012";
  
                    if (@res > 1) {
                       syswrite $fh, "$_: $res[$_]\015\012" for 0 .. $#res;
                    } elsif (@res == 1) {
                       syswrite $fh, "$res[0]\015\012";
                    }
                 }
  
                 syswrite $fh, "> ";
                 AnyEvent::Util::fh_nonblocking $fh, 1;
              }
           }
        };
     }
  }
  
  {
     package AnyEvent::Debug::shell;
  
     our $LOGGER;
  
     sub help() {
        <<EOF
  help         this command
  wr [level]   sets wrap level to level (or toggles if missing)
  v [level]    sets verbosity (or toggles between 0 and 9 if missing)
  wl 'regex'   print wrapped watchers matching the regex (or all if missing)
  i id,...     prints the watcher with the given ids in more detail
  t            enable tracing for newly created watchers (enabled by default)
  ut           disable tracing for newly created watchers
  t  id,...    enable tracing for the given watcher (enabled by default)
  ut id,...    disable tracing for the given weatcher
  w id,...     converts the watcher ids to watcher objects (for scripting)
  EOF
     }
  
     sub wl(;$) {
        my $re = @_ ? qr<$_[0]>i : qr<.>;
  
        my %res;
  
        while (my ($k, $v) = each %AnyEvent::Debug::Wrapped) {
           my $s = "$v";
           $res{$s} = $k . (exists $v->{error} ? "*" : " ")
              if $s =~ $re;
        }
  
        join "", map "$res{$_} $_\n", sort keys %res
     }
  
     sub w {
        map {
           $AnyEvent::Debug::Wrapped{$_} || do {
              print "$_: no such wrapped watcher.\n";
              ()
           }
        } @_
     }
  
     sub i {
        join "",
           map $_->id . " $_\n" . $_->verbose . "\n",
              &w
     }
  
     sub wr {
        AnyEvent::Debug::wrap (@_);
  
        "wrap level now $AnyEvent::Debug::WRAP_LEVEL"
     }
  
     sub t {
        if (@_) {
           @_ = &w;
           $_->trace (1)
              for @_;
           "tracing enabled for @_."
        } else {
           $AnyEvent::Debug::TRACE = 1;
           "tracing for newly created watchers is now enabled."
        }
     }
  
     sub u {
        if (@_) {
           @_ = &w;
           $_->trace (0)
              for @_;
           "tracing disabled for @_."
        } else {
           $AnyEvent::Debug::TRACE = 0;
           "tracing for newly created watchers is now disabled."
        }
     }
  
     sub v {
        $LOGGER->level (@_ ? $_[0] : $LOGGER->[1] ? 0 : 9);
  
        "verbose logging is now " . ($LOGGER->[1] ? "enabled" : "disabled") . "."
     }
  }
  
  =item AnyEvent::Debug::wrap [$level]
  
  Sets the instrumenting/wrapping level of all watchers that are being
  created after this call. If no C<$level> has been specified, then it
  toggles between C<0> and C<1>.
  
  The default wrap level is C<0>, or whatever
  C<$ENV{PERL_ANYEVENT_DEBUG_WRAP}> specifies.
  
  A level of C<0> disables wrapping, i.e. AnyEvent works normally, and in
  its most efficient mode.
  
  A level of C<1> or higher enables wrapping, which replaces all watchers
  by AnyEvent::Debug::Wrapped objects, stores the location where a
  watcher was created and wraps the callback to log all invocations at
  "trace" loglevel if tracing is enabled fore the watcher. The initial
  state of tracing when creating a watcher is taken from the global
  variable C<$AnyEvent:Debug::TRACE>. The default value of that variable
  is C<1>, but it can make sense to set it to C<0> and then do C<< local
  $AnyEvent::Debug::TRACE = 1 >> in a block where you create "interesting"
  watchers. Tracing can also be enabled and disabled later by calling the
  watcher's C<trace> method.
  
  The wrapper will also count how many times the callback was invoked and
  will record up to ten runtime errors with corresponding backtraces. It
  will also log runtime errors at "error" loglevel.
  
  To see the trace messages, you can invoke your program with
  C<PERL_ANYEVENT_VERBOSE=9>, or you can use AnyEvent::Log to divert
  the trace messages in any way you like (the EXAMPLES section in
  L<AnyEvent::Log> has some examples).
  
  A level of C<2> does everything that level C<1> does, but also stores a
  full backtrace of the location the watcher was created, which slows down
  watcher creation considerably.
  
  Every wrapped watcher will be linked into C<%AnyEvent::Debug::Wrapped>,
  with its address as key. The C<wl> command in the debug shell can be used
  to list watchers.
  
  Instrumenting can increase the size of each watcher multiple times, and,
  especially when backtraces are involved, also slows down watcher creation
  a lot.
  
  Also, enabling and disabling instrumentation will not recover the full
  performance that you had before wrapping (the AE::xxx functions will stay
  slower, for example).
  
  If you are developing your program, also consider using AnyEvent::Strict
  to check for common mistakes.
  
  =cut
  
  our $WRAP_LEVEL;
  our $TRACE_CUR;
  our $POST_DETECT;
  
  sub wrap(;$) {
     my $PREV_LEVEL = $WRAP_LEVEL;
     $WRAP_LEVEL = @_ ? 0+shift : $WRAP_LEVEL ? 0 : 1;
  
     if ($AnyEvent::MODEL) {
        if ($WRAP_LEVEL && !$PREV_LEVEL) {
           $TRACE_LOGGER = AnyEvent::Log::logger trace => \$TRACE_ENABLED;
           AnyEvent::_isa_hook 0 => "AnyEvent::Debug::Wrap", 1;
           AnyEvent::Debug::Wrap::_reset ();
        } elsif (!$WRAP_LEVEL && $PREV_LEVEL) {
           AnyEvent::_isa_hook 0 => undef;
        }
     } else {
        $POST_DETECT ||= AnyEvent::post_detect {
           undef $POST_DETECT;
           return unless $WRAP_LEVEL;
  
           (my $level, $WRAP_LEVEL) = ($WRAP_LEVEL, undef);
  
           require AnyEvent::Strict unless $AnyEvent::Strict::VERSION;
  
           AnyEvent::post_detect { # make sure we run after AnyEvent::Strict
              wrap ($level);
           };
        };
     }
  }
  
  =item AnyEvent::Debug::path2mod $path
  
  Tries to replace a path (e.g. the file name returned by caller)
  by a module name. Returns the path unchanged if it fails.
  
  Example:
  
     print AnyEvent::Debug::path2mod "/usr/lib/perl5/AnyEvent/Debug.pm";
     # might print "AnyEvent::Debug"
  
  =cut
  
  sub path2mod($) {
     keys %INC; # reset iterator
  
     while (my ($k, $v) = each %INC) {
        if ($_[0] eq $v) {
           $k =~ s%/%::%g if $k =~ s/\.pm$//;
           return $k;
        }
     }
  
     my $path = shift;
  
     $path =~ s%^\./%%;
  
     $path
  }
  
  =item AnyEvent::Debug::cb2str $cb
  
  Using various gambits, tries to convert a callback (e.g. a code reference)
  into a more useful string.
  
  Very useful if you debug a program and have some callback, but you want to
  know where in the program the callback is actually defined.
  
  =cut
  
  sub cb2str($) {
     my $cb = shift;
  
     "CODE" eq ref $cb
        or return "$cb";
  
     eval {
        my $cv = B::svref_2object ($cb);
  
        my $gv = $cv->GV
           or return "$cb";
  
        my $name = $gv->NAME;
  
        return (AnyEvent::Debug::path2mod $gv->FILE) . ":" . $gv->LINE
           if $name eq "__ANON__";
  
        $gv->STASH->NAME . "::" . $name;
     } || "$cb"
  }
  
  sub sv2str($) {
     if (ref $_[0]) {
        if (ref $_[0] eq "CODE") {
           return "$_[0]=" . cb2str $_[0];
        } else {
           return "$_[0]";
        }
     } else {
        for ("\'$_[0]\'") { # make copy
           substr $_, $Carp::MaxArgLen, length, "'..."
              if length > $Carp::MaxArgLen;
           return $_;
        }
     }
  }
  
  =item AnyEvent::Debug::backtrace [$skip]
  
  Creates a backtrace (actually an AnyEvent::Debug::Backtrace object
  that you can stringify), not unlike the Carp module would. Unlike the
  Carp module it resolves some references (such as callbacks) to more
  user-friendly strings, has a more succinct output format and most
  importantly: doesn't leak memory like hell.
  
  The reason it creates an object is to save time, as formatting can be
  done at a later time. Still, creating a backtrace is a relatively slow
  operation.
  
  =cut
  
  sub backtrace(;$) {
     my $w = shift;
  
     my (@bt, @c);
     my ($modlen, $sub);
  
     for (;;) {
        #         0          1      2            3         4           5          6            7       8         9         10
        # ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
        package DB;
        @c = caller $w++
           or last;
        package AnyEvent::Debug; # no block for speed reasons
  
        if ($c[7]) {
           $sub = "require $c[6]";
        } elsif (defined $c[6]) {
           $sub = "eval \"\"";
        } else {
           $sub = ($c[4] ? "" : "&") . $c[3];
  
           $sub .= "("
                   . (join ",",
                         map sv2str $DB::args[$_],
                            0 .. (@DB::args < $Carp::MaxArgNums ? @DB::args : $Carp::MaxArgNums) - 1)
                   . ")"
              if $c[4];
        }
  
        push @bt, [\($STRCACHE{$c[1]} ||= $c[1]), $c[2], $sub];
     }
  
     @DB::args = ();
  
     bless \@bt, "AnyEvent::Debug::Backtrace"
  }
  
  =back
  
  =cut
  
  package AnyEvent::Debug::Wrap;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Scalar::Util ();
  use Carp ();
  
  sub _reset {
     for my $name (qw(io timer signal child idle)) {
        my $super = "SUPER::$name";
  
        *$name = sub {
           my ($self, %arg) = @_;
  
           my $w;
  
           my $t = $TRACE;
  
           my ($pkg, $file, $line, $sub);
           
           $w = 0;
           do {
              ($pkg, $file, $line) = caller $w++;
           } while $pkg =~ /^(?:AE|AnyEvent::(?:Socket|Handle|Util|Debug|Strict|Base|CondVar|CondVar::Base|Impl::.*)|Coro::AnyEvent::CondVar)$/;
  
           $sub = (caller $w)[3];
  
           my $cb = $arg{cb};
           $arg{cb} = sub {
              ++$w->{called};
  
              local $TRACE_CUR = $w;
  
              $TRACE_LOGGER->("enter $w") if $TRACE_ENABLED && $t;
              eval {
                 local $SIG{__DIE__} = sub {
                    die $_[0] . AnyEvent::Debug::backtrace
                       if defined $^S;
                 };
                 &$cb;
              };
              if ($@) {
                 my $err = "$@";
                 push @{ $w->{error} }, [AE::now, $err]
                    if @{ $w->{error} } < 10;
                 AE::log die => "($w) $err"
                    or warn "($w) $err";
              }
              $TRACE_LOGGER->("leave $w") if $TRACE_ENABLED && $t;
           };
  
           $self = bless {
              type   => $name,
              w      => $self->$super (%arg),
              rfile  => \($STRCACHE{$file} ||= $file),
              line   => $line,
              sub    => $sub,
              cur    => "$TRACE_CUR",
              now    => AE::now,
              arg    => \%arg,
              cb     => $cb,
              called => 0,
              rt     => \$t,
           }, "AnyEvent::Debug::Wrapped";
  
           delete $arg{cb};
  
           $self->{bt} = AnyEvent::Debug::backtrace 1
              if $WRAP_LEVEL >= 2;
  
           Scalar::Util::weaken ($w = $self);
           Scalar::Util::weaken ($AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $self} = $self);
  
           $TRACE_LOGGER->("creat $w") if $TRACE_ENABLED && $t;
  
           $self
        };
     }
  }
  
  package AnyEvent::Debug::Wrapped;
  
  =head1 THE AnyEvent::Debug::Wrapped CLASS
  
  All watchers created while the wrap level is non-zero will be wrapped
  inside an AnyEvent::Debug::Wrapped object. The address of the
  wrapped watcher will become its ID - every watcher will be stored in
  C<$AnyEvent::Debug::Wrapped{$id}>.
  
  These wrapper objects can be stringified and have some methods defined on
  them.
  
  For debugging, of course, it can be helpful to look into these objects,
  which is why this is documented here, but this might change at any time in
  future versions.
  
  Each object is a relatively standard hash with the following members:
  
     type   => name of the method used ot create the watcher (e.g. C<io>, C<timer>).
     w      => the actual watcher
     rfile  => reference to the filename of the file the watcher was created in
     line   => line number where it was created
     sub    => function name (or a special string) which created the watcher
     cur    => if created inside another watcher callback, this is the string rep of the other watcher
     now    => the timestamp (AE::now) when the watcher was created
     arg    => the arguments used to create the watcher (sans C<cb>)
     cb     => the original callback used to create the watcher
     called => the number of times the callback was called
  
  Each object supports the following mehtods (warning: these are only
  available on wrapped watchers, so are best for interactive use via the
  debug shell).
  
  =over 4
  
  =cut
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use overload
     '""'     => sub {
        $_[0]{str} ||= do {
           my ($pkg, $line) = @{ $_[0]{caller} };
  
           my $mod = AnyEvent::Debug::path2mod ${ $_[0]{rfile} };
           my $sub = $_[0]{sub};
  
           if (defined $sub) {
              $sub =~ s/^\Q$mod\E:://;
              $sub = "($sub)";
           }
  
           "$mod:$_[0]{line}$sub>$_[0]{type}>"
           . (AnyEvent::Debug::cb2str $_[0]{cb})
        };
     },
     fallback => 1,
  ;
  
  =item $w->id
  
  Returns the numerical id of the watcher, as used in the debug shell.
  
  =cut
  
  sub id {
     Scalar::Util::refaddr shift
  }
  
  =item $w->verbose
  
  Returns a multiline textual description of the watcher, including the
  first ten exceptions caught while executing the callback.
  
  =cut
  
  sub verbose {
     my ($self) = @_;
  
     my $res = "type:    $self->{type} watcher\n"
             . "args:    " . (join " ", %{ $self->{arg} }) . "\n" # TODO: decode fh?
             . "created: " . (AnyEvent::Log::ft $self->{now}) . " ($self->{now})\n"
             . "file:    ${ $self->{rfile} }\n"
             . "line:    $self->{line}\n"
             . "subname: $self->{sub}\n"
             . "context: $self->{cur}\n"
             . "tracing: " . (${ $self->{rt} } ? "enabled" : "disabled") . "\n"
             . "cb:      $self->{cb} (" . (AnyEvent::Debug::cb2str $self->{cb}) . ")\n"
             . "invoked: $self->{called} times\n";
  
     if (exists $self->{bt}) {
        $res .= "created\n$self->{bt}";
     }
  
     if (exists $self->{error}) {
        $res .= "errors:   " . @{$self->{error}} . "\n";
  
        $res .= "error: " . (AnyEvent::Log::ft $_->[0]) . " ($_->[0]) $_->[1]\n"
           for @{$self->{error}};
     }
  
     $res
  }
  
  =item $w->trace ($on)
  
  Enables (C<$on> is true) or disables (C<$on> is false) tracing on this
  watcher.
  
  To get tracing messages, both the global logging settings must have trace
  messages enabled for the context C<AnyEvent::Debug> and tracing must be
  enabled for the wrapped watcher.
  
  To enable trace messages globally, the simplest way is to start the
  program with C<PERL_ANYEVENT_VERBOSE=9> in the environment.
  
  Tracing for each individual watcher is enabled by default (unless
  C<$AnyEvent::Debug::TRACE> has been set to false).
  
  =cut
  
  sub trace {
     ${ $_[0]{rt} } = $_[1];
  }
  
  sub DESTROY {
     $TRACE_LOGGER->("dstry $_[0]") if $TRACE_ENABLED && ${ $_[0]{rt} };
  
     delete $AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $_[0]};
  }
  
  =back
  
  =cut
  
  package AnyEvent::Debug::Backtrace;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  sub as_string {
     my ($self) = @_;
  
     my @bt;
     my $modlen;
  
     for (@$self) {
        my ($rpath, $line, $sub) = @$_;
  
        $rpath = (AnyEvent::Debug::path2mod $$rpath) . " line $line";
        $modlen = length $rpath if $modlen < length $rpath;
  
        $sub =~ s/\r/\\r/g;
        $sub =~ s/\n/\\n/g;
        $sub =~ s/([\x00-\x1f\x7e-\xff])/sprintf "\\x%02x", ord $1/ge;
        $sub =~ s/([^\x20-\x7e])/sprintf "\\x{%x}", ord $1/ge;
  
        push @bt, [$rpath, $sub];
     }
  
     join "",
        map { sprintf "%*s %s\n", -$modlen, $_->[0], $_->[1] }
           @bt
  }
  
  use overload
     '""'     => \&as_string,
     fallback => 1,
  ;
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_DEBUG

$fatpacked{"darwin-2level/AnyEvent/Handle.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_HANDLE';
  =head1 NAME
  
  AnyEvent::Handle - non-blocking I/O on streaming handles via AnyEvent
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use AnyEvent::Handle;
  
     my $cv = AnyEvent->condvar;
  
     my $hdl; $hdl = new AnyEvent::Handle
        fh => \*STDIN,
        on_error => sub {
           my ($hdl, $fatal, $msg) = @_;
           AE::log error => "got error $msg\n";
           $hdl->destroy;
           $cv->send;
        };
  
     # send some request line
     $hdl->push_write ("getinfo\015\012");
  
     # read the response line
     $hdl->push_read (line => sub {
        my ($hdl, $line) = @_;
        say "got line <$line>";
        $cv->send;
     });
  
     $cv->recv;
  
  =head1 DESCRIPTION
  
  This is a helper module to make it easier to do event-based I/O on
  stream-based filehandles (sockets, pipes, and other stream things).
  
  The L<AnyEvent::Intro> tutorial contains some well-documented
  AnyEvent::Handle examples.
  
  In the following, where the documentation refers to "bytes", it means
  characters. As sysread and syswrite are used for all I/O, their
  treatment of characters applies to this module as well.
  
  At the very minimum, you should specify C<fh> or C<connect>, and the
  C<on_error> callback.
  
  All callbacks will be invoked with the handle object as their first
  argument.
  
  =cut
  
  package AnyEvent::Handle;
  
  use Scalar::Util ();
  use List::Util ();
  use Carp ();
  use Errno qw(EAGAIN EINTR);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  
  our $VERSION = $AnyEvent::VERSION;
  
  sub _load_func($) {
     my $func = $_[0];
  
     unless (defined &$func) {
        my $pkg = $func;
        do {
           $pkg =~ s/::[^:]+$//
              or return;
           eval "require $pkg";
        } until defined &$func;
     }
  
     \&$func
  }
  
  sub MAX_READ_SIZE() { 131072 }
  
  =head1 METHODS
  
  =over 4
  
  =item $handle = B<new> AnyEvent::Handle fh => $filehandle, key => value...
  
  The constructor supports these arguments (all as C<< key => value >> pairs).
  
  =over 4
  
  =item fh => $filehandle     [C<fh> or C<connect> MANDATORY]
  
  The filehandle this L<AnyEvent::Handle> object will operate on.
  NOTE: The filehandle will be set to non-blocking mode (using
  C<AnyEvent::Util::fh_nonblocking>) by the constructor and needs to stay in
  that mode.
  
  =item connect => [$host, $service]      [C<fh> or C<connect> MANDATORY]
  
  Try to connect to the specified host and service (port), using
  C<AnyEvent::Socket::tcp_connect>. The C<$host> additionally becomes the
  default C<peername>.
  
  You have to specify either this parameter, or C<fh>, above.
  
  It is possible to push requests on the read and write queues, and modify
  properties of the stream, even while AnyEvent::Handle is connecting.
  
  When this parameter is specified, then the C<on_prepare>,
  C<on_connect_error> and C<on_connect> callbacks will be called under the
  appropriate circumstances:
  
  =over 4
  
  =item on_prepare => $cb->($handle)
  
  This (rarely used) callback is called before a new connection is
  attempted, but after the file handle has been created (you can access that
  file handle via C<< $handle->{fh} >>). It could be used to prepare the
  file handle with parameters required for the actual connect (as opposed to
  settings that can be changed when the connection is already established).
  
  The return value of this callback should be the connect timeout value in
  seconds (or C<0>, or C<undef>, or the empty list, to indicate that the
  default timeout is to be used).
  
  =item on_connect => $cb->($handle, $host, $port, $retry->())
  
  This callback is called when a connection has been successfully established.
  
  The peer's numeric host and port (the socket peername) are passed as
  parameters, together with a retry callback.
  
  If, for some reason, the handle is not acceptable, calling C<$retry>
  will continue with the next connection target (in case of multi-homed
  hosts or SRV records there can be multiple connection endpoints). At the
  time it is called the read and write queues, eof status, tls status and
  similar properties of the handle will have been reset.
  
  In most cases, you should ignore the C<$retry> parameter.
  
  =item on_connect_error => $cb->($handle, $message)
  
  This callback is called when the connection could not be
  established. C<$!> will contain the relevant error code, and C<$message> a
  message describing it (usually the same as C<"$!">).
  
  If this callback isn't specified, then C<on_error> will be called with a
  fatal error instead.
  
  =back
  
  =item on_error => $cb->($handle, $fatal, $message)
  
  This is the error callback, which is called when, well, some error
  occured, such as not being able to resolve the hostname, failure to
  connect, or a read error.
  
  Some errors are fatal (which is indicated by C<$fatal> being true). On
  fatal errors the handle object will be destroyed (by a call to C<< ->
  destroy >>) after invoking the error callback (which means you are free to
  examine the handle object). Examples of fatal errors are an EOF condition
  with active (but unsatisfiable) read watchers (C<EPIPE>) or I/O errors. In
  cases where the other side can close the connection at will, it is
  often easiest to not report C<EPIPE> errors in this callback.
  
  AnyEvent::Handle tries to find an appropriate error code for you to check
  against, but in some cases (TLS errors), this does not work well. It is
  recommended to always output the C<$message> argument in human-readable
  error messages (it's usually the same as C<"$!">).
  
  Non-fatal errors can be retried by returning, but it is recommended
  to simply ignore this parameter and instead abondon the handle object
  when this callback is invoked. Examples of non-fatal errors are timeouts
  C<ETIMEDOUT>) or badly-formatted data (C<EBADMSG>).
  
  On entry to the callback, the value of C<$!> contains the operating
  system error code (or C<ENOSPC>, C<EPIPE>, C<ETIMEDOUT>, C<EBADMSG> or
  C<EPROTO>).
  
  While not mandatory, it is I<highly> recommended to set this callback, as
  you will not be notified of errors otherwise. The default just calls
  C<croak>.
  
  =item on_read => $cb->($handle)
  
  This sets the default read callback, which is called when data arrives
  and no read request is in the queue (unlike read queue callbacks, this
  callback will only be called when at least one octet of data is in the
  read buffer).
  
  To access (and remove data from) the read buffer, use the C<< ->rbuf >>
  method or access the C<< $handle->{rbuf} >> member directly. Note that you
  must not enlarge or modify the read buffer, you can only remove data at
  the beginning from it.
  
  You can also call C<< ->push_read (...) >> or any other function that
  modifies the read queue. Or do both. Or ...
  
  When an EOF condition is detected, AnyEvent::Handle will first try to
  feed all the remaining data to the queued callbacks and C<on_read> before
  calling the C<on_eof> callback. If no progress can be made, then a fatal
  error will be raised (with C<$!> set to C<EPIPE>).
  
  Note that, unlike requests in the read queue, an C<on_read> callback
  doesn't mean you I<require> some data: if there is an EOF and there
  are outstanding read requests then an error will be flagged. With an
  C<on_read> callback, the C<on_eof> callback will be invoked.
  
  =item on_eof => $cb->($handle)
  
  Set the callback to be called when an end-of-file condition is detected,
  i.e. in the case of a socket, when the other side has closed the
  connection cleanly, and there are no outstanding read requests in the
  queue (if there are read requests, then an EOF counts as an unexpected
  connection close and will be flagged as an error).
  
  For sockets, this just means that the other side has stopped sending data,
  you can still try to write data, and, in fact, one can return from the EOF
  callback and continue writing data, as only the read part has been shut
  down.
  
  If an EOF condition has been detected but no C<on_eof> callback has been
  set, then a fatal error will be raised with C<$!> set to <0>.
  
  =item on_drain => $cb->($handle)
  
  This sets the callback that is called when the write buffer becomes empty
  (or immediately if the buffer is empty already).
  
  To append to the write buffer, use the C<< ->push_write >> method.
  
  This callback is useful when you don't want to put all of your write data
  into the queue at once, for example, when you want to write the contents
  of some file to the socket you might not want to read the whole file into
  memory and push it into the queue, but instead only read more data from
  the file when the write queue becomes empty.
  
  =item timeout => $fractional_seconds
  
  =item rtimeout => $fractional_seconds
  
  =item wtimeout => $fractional_seconds
  
  If non-zero, then these enables an "inactivity" timeout: whenever this
  many seconds pass without a successful read or write on the underlying
  file handle (or a call to C<timeout_reset>), the C<on_timeout> callback
  will be invoked (and if that one is missing, a non-fatal C<ETIMEDOUT>
  error will be raised).
  
  There are three variants of the timeouts that work independently of each
  other, for both read and write (triggered when nothing was read I<OR>
  written), just read (triggered when nothing was read), and just write:
  C<timeout>, C<rtimeout> and C<wtimeout>, with corresponding callbacks
  C<on_timeout>, C<on_rtimeout> and C<on_wtimeout>, and reset functions
  C<timeout_reset>, C<rtimeout_reset>, and C<wtimeout_reset>.
  
  Note that timeout processing is active even when you do not have any
  outstanding read or write requests: If you plan to keep the connection
  idle then you should disable the timeout temporarily or ignore the
  timeout in the corresponding C<on_timeout> callback, in which case
  AnyEvent::Handle will simply restart the timeout.
  
  Zero (the default) disables the corresponding timeout.
  
  =item on_timeout => $cb->($handle)
  
  =item on_rtimeout => $cb->($handle)
  
  =item on_wtimeout => $cb->($handle)
  
  Called whenever the inactivity timeout passes. If you return from this
  callback, then the timeout will be reset as if some activity had happened,
  so this condition is not fatal in any way.
  
  =item rbuf_max => <bytes>
  
  If defined, then a fatal error will be raised (with C<$!> set to C<ENOSPC>)
  when the read buffer ever (strictly) exceeds this size. This is useful to
  avoid some forms of denial-of-service attacks.
  
  For example, a server accepting connections from untrusted sources should
  be configured to accept only so-and-so much data that it cannot act on
  (for example, when expecting a line, an attacker could send an unlimited
  amount of data without a callback ever being called as long as the line
  isn't finished).
  
  =item wbuf_max => <bytes>
  
  If defined, then a fatal error will be raised (with C<$!> set to C<ENOSPC>)
  when the write buffer ever (strictly) exceeds this size. This is useful to
  avoid some forms of denial-of-service attacks.
  
  Although the units of this parameter is bytes, this is the I<raw> number
  of bytes not yet accepted by the kernel. This can make a difference when
  you e.g. use TLS, as TLS typically makes your write data larger (but it
  can also make it smaller due to compression).
  
  As an example of when this limit is useful, take a chat server that sends
  chat messages to a client. If the client does not read those in a timely
  manner then the send buffer in the server would grow unbounded.
  
  =item autocork => <boolean>
  
  When disabled (the default), C<push_write> will try to immediately
  write the data to the handle if possible. This avoids having to register
  a write watcher and wait for the next event loop iteration, but can
  be inefficient if you write multiple small chunks (on the wire, this
  disadvantage is usually avoided by your kernel's nagle algorithm, see
  C<no_delay>, but this option can save costly syscalls).
  
  When enabled, writes will always be queued till the next event loop
  iteration. This is efficient when you do many small writes per iteration,
  but less efficient when you do a single write only per iteration (or when
  the write buffer often is full). It also increases write latency.
  
  =item no_delay => <boolean>
  
  When doing small writes on sockets, your operating system kernel might
  wait a bit for more data before actually sending it out. This is called
  the Nagle algorithm, and usually it is beneficial.
  
  In some situations you want as low a delay as possible, which can be
  accomplishd by setting this option to a true value.
  
  The default is your operating system's default behaviour (most likely
  enabled). This option explicitly enables or disables it, if possible.
  
  =item keepalive => <boolean>
  
  Enables (default disable) the SO_KEEPALIVE option on the stream socket:
  normally, TCP connections have no time-out once established, so TCP
  connections, once established, can stay alive forever even when the other
  side has long gone. TCP keepalives are a cheap way to take down long-lived
  TCP connections when the other side becomes unreachable. While the default
  is OS-dependent, TCP keepalives usually kick in after around two hours,
  and, if the other side doesn't reply, take down the TCP connection some 10
  to 15 minutes later.
  
  It is harmless to specify this option for file handles that do not support
  keepalives, and enabling it on connections that are potentially long-lived
  is usually a good idea.
  
  =item oobinline => <boolean>
  
  BSD majorly fucked up the implementation of TCP urgent data. The result
  is that almost no OS implements TCP according to the specs, and every OS
  implements it slightly differently.
  
  If you want to handle TCP urgent data, then setting this flag (the default
  is enabled) gives you the most portable way of getting urgent data, by
  putting it into the stream.
  
  Since BSD emulation of OOB data on top of TCP's urgent data can have
  security implications, AnyEvent::Handle sets this flag automatically
  unless explicitly specified. Note that setting this flag after
  establishing a connection I<may> be a bit too late (data loss could
  already have occured on BSD systems), but at least it will protect you
  from most attacks.
  
  =item read_size => <bytes>
  
  The initial read block size, the number of bytes this module will try
  to read during each loop iteration. Each handle object will consume
  at least this amount of memory for the read buffer as well, so when
  handling many connections watch out for memory requirements). See also
  C<max_read_size>. Default: C<2048>.
  
  =item max_read_size => <bytes>
  
  The maximum read buffer size used by the dynamic adjustment
  algorithm: Each time AnyEvent::Handle can read C<read_size> bytes in
  one go it will double C<read_size> up to the maximum given by this
  option. Default: C<131072> or C<read_size>, whichever is higher.
  
  =item low_water_mark => <bytes>
  
  Sets the number of bytes (default: C<0>) that make up an "empty" write
  buffer: If the buffer reaches this size or gets even samller it is
  considered empty.
  
  Sometimes it can be beneficial (for performance reasons) to add data to
  the write buffer before it is fully drained, but this is a rare case, as
  the operating system kernel usually buffers data as well, so the default
  is good in almost all cases.
  
  =item linger => <seconds>
  
  If this is non-zero (default: C<3600>), the destructor of the
  AnyEvent::Handle object will check whether there is still outstanding
  write data and will install a watcher that will write this data to the
  socket. No errors will be reported (this mostly matches how the operating
  system treats outstanding data at socket close time).
  
  This will not work for partial TLS data that could not be encoded
  yet. This data will be lost. Calling the C<stoptls> method in time might
  help.
  
  =item peername => $string
  
  A string used to identify the remote site - usually the DNS hostname
  (I<not> IDN!) used to create the connection, rarely the IP address.
  
  Apart from being useful in error messages, this string is also used in TLS
  peername verification (see C<verify_peername> in L<AnyEvent::TLS>). This
  verification will be skipped when C<peername> is not specified or is
  C<undef>.
  
  =item tls => "accept" | "connect" | Net::SSLeay::SSL object
  
  When this parameter is given, it enables TLS (SSL) mode, that means
  AnyEvent will start a TLS handshake as soon as the connection has been
  established and will transparently encrypt/decrypt data afterwards.
  
  All TLS protocol errors will be signalled as C<EPROTO>, with an
  appropriate error message.
  
  TLS mode requires Net::SSLeay to be installed (it will be loaded
  automatically when you try to create a TLS handle): this module doesn't
  have a dependency on that module, so if your module requires it, you have
  to add the dependency yourself.
  
  Unlike TCP, TLS has a server and client side: for the TLS server side, use
  C<accept>, and for the TLS client side of a connection, use C<connect>
  mode.
  
  You can also provide your own TLS connection object, but you have
  to make sure that you call either C<Net::SSLeay::set_connect_state>
  or C<Net::SSLeay::set_accept_state> on it before you pass it to
  AnyEvent::Handle. Also, this module will take ownership of this connection
  object.
  
  At some future point, AnyEvent::Handle might switch to another TLS
  implementation, then the option to use your own session object will go
  away.
  
  B<IMPORTANT:> since Net::SSLeay "objects" are really only integers,
  passing in the wrong integer will lead to certain crash. This most often
  happens when one uses a stylish C<< tls => 1 >> and is surprised about the
  segmentation fault.
  
  Use the C<< ->starttls >> method if you need to start TLS negotiation later.
  
  =item tls_ctx => $anyevent_tls
  
  Use the given C<AnyEvent::TLS> object to create the new TLS connection
  (unless a connection object was specified directly). If this
  parameter is missing (or C<undef>), then AnyEvent::Handle will use
  C<AnyEvent::Handle::TLS_CTX>.
  
  Instead of an object, you can also specify a hash reference with C<< key
  => value >> pairs. Those will be passed to L<AnyEvent::TLS> to create a
  new TLS context object.
  
  =item on_starttls => $cb->($handle, $success[, $error_message])
  
  This callback will be invoked when the TLS/SSL handshake has finished. If
  C<$success> is true, then the TLS handshake succeeded, otherwise it failed
  (C<on_stoptls> will not be called in this case).
  
  The session in C<< $handle->{tls} >> can still be examined in this
  callback, even when the handshake was not successful.
  
  TLS handshake failures will not cause C<on_error> to be invoked when this
  callback is in effect, instead, the error message will be passed to C<on_starttls>.
  
  Without this callback, handshake failures lead to C<on_error> being
  called as usual.
  
  Note that you cannot just call C<starttls> again in this callback. If you
  need to do that, start an zero-second timer instead whose callback can
  then call C<< ->starttls >> again.
  
  =item on_stoptls => $cb->($handle)
  
  When a SSLv3/TLS shutdown/close notify/EOF is detected and this callback is
  set, then it will be invoked after freeing the TLS session. If it is not,
  then a TLS shutdown condition will be treated like a normal EOF condition
  on the handle.
  
  The session in C<< $handle->{tls} >> can still be examined in this
  callback.
  
  This callback will only be called on TLS shutdowns, not when the
  underlying handle signals EOF.
  
  =item json => JSON or JSON::XS object
  
  This is the json coder object used by the C<json> read and write types.
  
  If you don't supply it, then AnyEvent::Handle will create and use a
  suitable one (on demand), which will write and expect UTF-8 encoded JSON
  texts.
  
  Note that you are responsible to depend on the JSON module if you want to
  use this functionality, as AnyEvent does not have a dependency itself.
  
  =back
  
  =cut
  
  sub new {
     my $class = shift;
     my $self = bless { @_ }, $class;
  
     if ($self->{fh}) {
        $self->_start;
        return unless $self->{fh}; # could be gone by now
  
     } elsif ($self->{connect}) {
        require AnyEvent::Socket;
  
        $self->{peername} = $self->{connect}[0]
           unless exists $self->{peername};
  
        $self->{_skip_drain_rbuf} = 1;
  
        {
           Scalar::Util::weaken (my $self = $self);
  
           $self->{_connect} =
              AnyEvent::Socket::tcp_connect (
                 $self->{connect}[0],
                 $self->{connect}[1],
                 sub {
                    my ($fh, $host, $port, $retry) = @_;
  
                    delete $self->{_connect}; # no longer needed
  
                    if ($fh) {
                       $self->{fh} = $fh;
  
                       delete $self->{_skip_drain_rbuf};
                       $self->_start;
  
                       $self->{on_connect}
                          and $self->{on_connect}($self, $host, $port, sub {
                                 delete @$self{qw(fh _tw _rtw _wtw _ww _rw _eof _queue rbuf _wbuf tls _tls_rbuf _tls_wbuf)};
                                 $self->{_skip_drain_rbuf} = 1;
                                 &$retry;
                              });
  
                    } else {
                       if ($self->{on_connect_error}) {
                          $self->{on_connect_error}($self, "$!");
                          $self->destroy if $self;
                       } else {
                          $self->_error ($!, 1);
                       }
                    }
                 },
                 sub {
                    local $self->{fh} = $_[0];
  
                    $self->{on_prepare}
                       ? $self->{on_prepare}->($self)
                       : ()
                 }
              );
        }
  
     } else {
        Carp::croak "AnyEvent::Handle: either an existing fh or the connect parameter must be specified";
     }
  
     $self
  }
  
  sub _start {
     my ($self) = @_;
  
     # too many clueless people try to use udp and similar sockets
     # with AnyEvent::Handle, do them a favour.
     my $type = getsockopt $self->{fh}, Socket::SOL_SOCKET (), Socket::SO_TYPE ();
     Carp::croak "AnyEvent::Handle: only stream sockets supported, anything else will NOT work!"
        if Socket::SOCK_STREAM () != (unpack "I", $type) && defined $type;
  
     AnyEvent::Util::fh_nonblocking $self->{fh}, 1;
  
     $self->{_activity}  =
     $self->{_ractivity} =
     $self->{_wactivity} = AE::now;
  
     $self->{read_size} ||= 2048;
     $self->{max_read_size} = $self->{read_size}
        if $self->{read_size} > ($self->{max_read_size} || MAX_READ_SIZE);
  
     $self->timeout   (delete $self->{timeout}  ) if $self->{timeout};
     $self->rtimeout  (delete $self->{rtimeout} ) if $self->{rtimeout};
     $self->wtimeout  (delete $self->{wtimeout} ) if $self->{wtimeout};
  
     $self->no_delay  (delete $self->{no_delay} ) if exists $self->{no_delay}  && $self->{no_delay};
     $self->keepalive (delete $self->{keepalive}) if exists $self->{keepalive} && $self->{keepalive};
  
     $self->oobinline (exists $self->{oobinline} ? delete $self->{oobinline} : 1);
  
     $self->starttls  (delete $self->{tls}, delete $self->{tls_ctx})
        if $self->{tls};
  
     $self->on_drain  (delete $self->{on_drain} ) if $self->{on_drain};
  
     $self->start_read
        if $self->{on_read} || @{ $self->{_queue} };
  
     $self->_drain_wbuf;
  }
  
  sub _error {
     my ($self, $errno, $fatal, $message) = @_;
  
     $! = $errno;
     $message ||= "$!";
  
     if ($self->{on_error}) {
        $self->{on_error}($self, $fatal, $message);
        $self->destroy if $fatal;
     } elsif ($self->{fh} || $self->{connect}) {
        $self->destroy;
        Carp::croak "AnyEvent::Handle uncaught error: $message";
     }
  }
  
  =item $fh = $handle->fh
  
  This method returns the file handle used to create the L<AnyEvent::Handle> object.
  
  =cut
  
  sub fh { $_[0]{fh} }
  
  =item $handle->on_error ($cb)
  
  Replace the current C<on_error> callback (see the C<on_error> constructor argument).
  
  =cut
  
  sub on_error {
     $_[0]{on_error} = $_[1];
  }
  
  =item $handle->on_eof ($cb)
  
  Replace the current C<on_eof> callback (see the C<on_eof> constructor argument).
  
  =cut
  
  sub on_eof {
     $_[0]{on_eof} = $_[1];
  }
  
  =item $handle->on_timeout ($cb)
  
  =item $handle->on_rtimeout ($cb)
  
  =item $handle->on_wtimeout ($cb)
  
  Replace the current C<on_timeout>, C<on_rtimeout> or C<on_wtimeout>
  callback, or disables the callback (but not the timeout) if C<$cb> =
  C<undef>. See the C<timeout> constructor argument and method.
  
  =cut
  
  # see below
  
  =item $handle->autocork ($boolean)
  
  Enables or disables the current autocork behaviour (see C<autocork>
  constructor argument). Changes will only take effect on the next write.
  
  =cut
  
  sub autocork {
     $_[0]{autocork} = $_[1];
  }
  
  =item $handle->no_delay ($boolean)
  
  Enables or disables the C<no_delay> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub no_delay {
     $_[0]{no_delay} = $_[1];
  
     setsockopt $_[0]{fh}, Socket::IPPROTO_TCP (), Socket::TCP_NODELAY (), int $_[1]
        if $_[0]{fh};
  }
  
  =item $handle->keepalive ($boolean)
  
  Enables or disables the C<keepalive> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub keepalive {
     $_[0]{keepalive} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_KEEPALIVE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->oobinline ($boolean)
  
  Enables or disables the C<oobinline> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub oobinline {
     $_[0]{oobinline} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_OOBINLINE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->keepalive ($boolean)
  
  Enables or disables the C<keepalive> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub keepalive {
     $_[0]{keepalive} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_KEEPALIVE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->on_starttls ($cb)
  
  Replace the current C<on_starttls> callback (see the C<on_starttls> constructor argument).
  
  =cut
  
  sub on_starttls {
     $_[0]{on_starttls} = $_[1];
  }
  
  =item $handle->on_stoptls ($cb)
  
  Replace the current C<on_stoptls> callback (see the C<on_stoptls> constructor argument).
  
  =cut
  
  sub on_stoptls {
     $_[0]{on_stoptls} = $_[1];
  }
  
  =item $handle->rbuf_max ($max_octets)
  
  Configures the C<rbuf_max> setting (C<undef> disables it).
  
  =item $handle->wbuf_max ($max_octets)
  
  Configures the C<wbuf_max> setting (C<undef> disables it).
  
  =cut
  
  sub rbuf_max {
     $_[0]{rbuf_max} = $_[1];
  }
  
  sub wbuf_max {
     $_[0]{wbuf_max} = $_[1];
  }
  
  #############################################################################
  
  =item $handle->timeout ($seconds)
  
  =item $handle->rtimeout ($seconds)
  
  =item $handle->wtimeout ($seconds)
  
  Configures (or disables) the inactivity timeout.
  
  The timeout will be checked instantly, so this method might destroy the
  handle before it returns.
  
  =item $handle->timeout_reset
  
  =item $handle->rtimeout_reset
  
  =item $handle->wtimeout_reset
  
  Reset the activity timeout, as if data was received or sent.
  
  These methods are cheap to call.
  
  =cut
  
  for my $dir ("", "r", "w") {
     my $timeout    = "${dir}timeout";
     my $tw         = "_${dir}tw";
     my $on_timeout = "on_${dir}timeout";
     my $activity   = "_${dir}activity";
     my $cb;
  
     *$on_timeout = sub {
        $_[0]{$on_timeout} = $_[1];
     };
  
     *$timeout = sub {
        my ($self, $new_value) = @_;
  
        $new_value >= 0
           or Carp::croak "AnyEvent::Handle->$timeout called with negative timeout ($new_value), caught";
  
        $self->{$timeout} = $new_value;
        delete $self->{$tw}; &$cb;
     };
  
     *{"${dir}timeout_reset"} = sub {
        $_[0]{$activity} = AE::now;
     };
  
     # main workhorse:
     # reset the timeout watcher, as neccessary
     # also check for time-outs
     $cb = sub {
        my ($self) = @_;
  
        if ($self->{$timeout} && $self->{fh}) {
           my $NOW = AE::now;
  
           # when would the timeout trigger?
           my $after = $self->{$activity} + $self->{$timeout} - $NOW;
  
           # now or in the past already?
           if ($after <= 0) {
              $self->{$activity} = $NOW;
  
              if ($self->{$on_timeout}) {
                 $self->{$on_timeout}($self);
              } else {
                 $self->_error (Errno::ETIMEDOUT);
              }
  
              # callback could have changed timeout value, optimise
              return unless $self->{$timeout};
  
              # calculate new after
              $after = $self->{$timeout};
           }
  
           Scalar::Util::weaken $self;
           return unless $self; # ->error could have destroyed $self
  
           $self->{$tw} ||= AE::timer $after, 0, sub {
              delete $self->{$tw};
              $cb->($self);
           };
        } else {
           delete $self->{$tw};
        }
     }
  }
  
  #############################################################################
  
  =back
  
  =head2 WRITE QUEUE
  
  AnyEvent::Handle manages two queues per handle, one for writing and one
  for reading.
  
  The write queue is very simple: you can add data to its end, and
  AnyEvent::Handle will automatically try to get rid of it for you.
  
  When data could be written and the write buffer is shorter then the low
  water mark, the C<on_drain> callback will be invoked.
  
  =over 4
  
  =item $handle->on_drain ($cb)
  
  Sets the C<on_drain> callback or clears it (see the description of
  C<on_drain> in the constructor).
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub on_drain {
     my ($self, $cb) = @_;
  
     $self->{on_drain} = $cb;
  
     $cb->($self)
        if $cb && $self->{low_water_mark} >= (length $self->{wbuf}) + (length $self->{_tls_wbuf});
  }
  
  =item $handle->push_write ($data)
  
  Queues the given scalar to be written. You can push as much data as
  you want (only limited by the available memory and C<wbuf_max>), as
  C<AnyEvent::Handle> buffers it independently of the kernel.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub _drain_wbuf {
     my ($self) = @_;
  
     if (!$self->{_ww} && length $self->{wbuf}) {
  
        Scalar::Util::weaken $self;
  
        my $cb = sub {
           my $len = syswrite $self->{fh}, $self->{wbuf};
  
           if (defined $len) {
              substr $self->{wbuf}, 0, $len, "";
  
              $self->{_activity} = $self->{_wactivity} = AE::now;
  
              $self->{on_drain}($self)
                 if $self->{low_water_mark} >= (length $self->{wbuf}) + (length $self->{_tls_wbuf})
                    && $self->{on_drain};
  
              delete $self->{_ww} unless length $self->{wbuf};
           } elsif ($! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              $self->_error ($!, 1);
           }
        };
  
        # try to write data immediately
        $cb->() unless $self->{autocork};
  
        # if still data left in wbuf, we need to poll
        $self->{_ww} = AE::io $self->{fh}, 1, $cb
           if length $self->{wbuf};
  
        if (
           defined $self->{wbuf_max}
           && $self->{wbuf_max} < length $self->{wbuf}
        ) {
           $self->_error (Errno::ENOSPC, 1), return;
        }
     };
  }
  
  our %WH;
  
  # deprecated
  sub register_write_type($$) {
     $WH{$_[0]} = $_[1];
  }
  
  sub push_write {
     my $self = shift;
  
     if (@_ > 1) {
        my $type = shift;
  
        @_ = ($WH{$type} ||= _load_func "$type\::anyevent_write_type"
              or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_write")
             ->($self, @_);
     }
  
     # we downgrade here to avoid hard-to-track-down bugs,
     # and diagnose the problem earlier and better.
  
     if ($self->{tls}) {
        utf8::downgrade $self->{_tls_wbuf} .= $_[0];
        &_dotls ($self)    if $self->{fh};
     } else {
        utf8::downgrade $self->{wbuf}      .= $_[0];
        $self->_drain_wbuf if $self->{fh};
     }
  }
  
  =item $handle->push_write (type => @args)
  
  Instead of formatting your data yourself, you can also let this module
  do the job by specifying a type and type-specific arguments. You
  can also specify the (fully qualified) name of a package, in which
  case AnyEvent tries to load the package and then expects to find the
  C<anyevent_write_type> function inside (see "custom write types", below).
  
  Predefined types are (if you have ideas for additional types, feel free to
  drop by and tell us):
  
  =over 4
  
  =item netstring => $string
  
  Formats the given value as netstring
  (http://cr.yp.to/proto/netstrings.txt, this is not a recommendation to use them).
  
  =cut
  
  register_write_type netstring => sub {
     my ($self, $string) = @_;
  
     (length $string) . ":$string,"
  };
  
  =item packstring => $format, $data
  
  An octet string prefixed with an encoded length. The encoding C<$format>
  uses the same format as a Perl C<pack> format, but must specify a single
  integer only (only one of C<cCsSlLqQiInNvVjJw> is allowed, plus an
  optional C<!>, C<< < >> or C<< > >> modifier).
  
  =cut
  
  register_write_type packstring => sub {
     my ($self, $format, $string) = @_;
  
     pack "$format/a*", $string
  };
  
  =item json => $array_or_hashref
  
  Encodes the given hash or array reference into a JSON object. Unless you
  provide your own JSON object, this means it will be encoded to JSON text
  in UTF-8.
  
  JSON objects (and arrays) are self-delimiting, so you can write JSON at
  one end of a handle and read them at the other end without using any
  additional framing.
  
  The generated JSON text is guaranteed not to contain any newlines: While
  this module doesn't need delimiters after or between JSON texts to be
  able to read them, many other languages depend on that.
  
  A simple RPC protocol that interoperates easily with others is to send
  JSON arrays (or objects, although arrays are usually the better choice as
  they mimic how function argument passing works) and a newline after each
  JSON text:
  
     $handle->push_write (json => ["method", "arg1", "arg2"]); # whatever
     $handle->push_write ("\012");
   
  An AnyEvent::Handle receiver would simply use the C<json> read type and
  rely on the fact that the newline will be skipped as leading whitespace:
  
     $handle->push_read (json => sub { my $array = $_[1]; ... });
  
  Other languages could read single lines terminated by a newline and pass
  this line into their JSON decoder of choice.
  
  =cut
  
  sub json_coder() {
     eval { require JSON::XS; JSON::XS->new->utf8 }
        || do { require JSON; JSON->new->utf8 }
  }
  
  register_write_type json => sub {
     my ($self, $ref) = @_;
  
     my $json = $self->{json} ||= json_coder;
  
     $json->encode ($ref)
  };
  
  =item storable => $reference
  
  Freezes the given reference using L<Storable> and writes it to the
  handle. Uses the C<nfreeze> format.
  
  =cut
  
  register_write_type storable => sub {
     my ($self, $ref) = @_;
  
     require Storable unless $Storable::VERSION;
  
     pack "w/a*", Storable::nfreeze ($ref)
  };
  
  =back
  
  =item $handle->push_shutdown
  
  Sometimes you know you want to close the socket after writing your data
  before it was actually written. One way to do that is to replace your
  C<on_drain> handler by a callback that shuts down the socket (and set
  C<low_water_mark> to C<0>). This method is a shorthand for just that, and
  replaces the C<on_drain> callback with:
  
     sub { shutdown $_[0]{fh}, 1 }
  
  This simply shuts down the write side and signals an EOF condition to the
  the peer.
  
  You can rely on the normal read queue and C<on_eof> handling
  afterwards. This is the cleanest way to close a connection.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub push_shutdown {
     my ($self) = @_;
  
     delete $self->{low_water_mark};
     $self->on_drain (sub { shutdown $_[0]{fh}, 1 });
  }
  
  =item custom write types - Package::anyevent_write_type $handle, @args
  
  Instead of one of the predefined types, you can also specify the name of
  a package. AnyEvent will try to load the package and then expects to find
  a function named C<anyevent_write_type> inside. If it isn't found, it
  progressively tries to load the parent package until it either finds the
  function (good) or runs out of packages (bad).
  
  Whenever the given C<type> is used, C<push_write> will the function with
  the handle object and the remaining arguments.
  
  The function is supposed to return a single octet string that will be
  appended to the write buffer, so you can mentally treat this function as a
  "arguments to on-the-wire-format" converter.
  
  Example: implement a custom write type C<join> that joins the remaining
  arguments using the first one.
  
     $handle->push_write (My::Type => " ", 1,2,3);
  
     # uses the following package, which can be defined in the "My::Type" or in
     # the "My" modules to be auto-loaded, or just about anywhere when the
     # My::Type::anyevent_write_type is defined before invoking it.
  
     package My::Type;
  
     sub anyevent_write_type {
        my ($handle, $delim, @args) = @_;
  
        join $delim, @args
     }
  
  =cut
  
  #############################################################################
  
  =back
  
  =head2 READ QUEUE
  
  AnyEvent::Handle manages two queues per handle, one for writing and one
  for reading.
  
  The read queue is more complex than the write queue. It can be used in two
  ways, the "simple" way, using only C<on_read> and the "complex" way, using
  a queue.
  
  In the simple case, you just install an C<on_read> callback and whenever
  new data arrives, it will be called. You can then remove some data (if
  enough is there) from the read buffer (C<< $handle->rbuf >>). Or you can
  leave the data there if you want to accumulate more (e.g. when only a
  partial message has been received so far), or change the read queue with
  e.g. C<push_read>.
  
  In the more complex case, you want to queue multiple callbacks. In this
  case, AnyEvent::Handle will call the first queued callback each time new
  data arrives (also the first time it is queued) and remove it when it has
  done its job (see C<push_read>, below).
  
  This way you can, for example, push three line-reads, followed by reading
  a chunk of data, and AnyEvent::Handle will execute them in order.
  
  Example 1: EPP protocol parser. EPP sends 4 byte length info, followed by
  the specified number of bytes which give an XML datagram.
  
     # in the default state, expect some header bytes
     $handle->on_read (sub {
        # some data is here, now queue the length-header-read (4 octets)
        shift->unshift_read (chunk => 4, sub {
           # header arrived, decode
           my $len = unpack "N", $_[1];
  
           # now read the payload
           shift->unshift_read (chunk => $len, sub {
              my $xml = $_[1];
              # handle xml
           });
        });
     });
  
  Example 2: Implement a client for a protocol that replies either with "OK"
  and another line or "ERROR" for the first request that is sent, and 64
  bytes for the second request. Due to the availability of a queue, we can
  just pipeline sending both requests and manipulate the queue as necessary
  in the callbacks.
  
  When the first callback is called and sees an "OK" response, it will
  C<unshift> another line-read. This line-read will be queued I<before> the
  64-byte chunk callback.
  
     # request one, returns either "OK + extra line" or "ERROR"
     $handle->push_write ("request 1\015\012");
  
     # we expect "ERROR" or "OK" as response, so push a line read
     $handle->push_read (line => sub {
        # if we got an "OK", we have to _prepend_ another line,
        # so it will be read before the second request reads its 64 bytes
        # which are already in the queue when this callback is called
        # we don't do this in case we got an error
        if ($_[1] eq "OK") {
           $_[0]->unshift_read (line => sub {
              my $response = $_[1];
              ...
           });
        }
     });
  
     # request two, simply returns 64 octets
     $handle->push_write ("request 2\015\012");
  
     # simply read 64 bytes, always
     $handle->push_read (chunk => 64, sub {
        my $response = $_[1];
        ...
     });
  
  =over 4
  
  =cut
  
  sub _drain_rbuf {
     my ($self) = @_;
  
     # avoid recursion
     return if $self->{_skip_drain_rbuf};
     local $self->{_skip_drain_rbuf} = 1;
  
     while () {
        # we need to use a separate tls read buffer, as we must not receive data while
        # we are draining the buffer, and this can only happen with TLS.
        $self->{rbuf} .= delete $self->{_tls_rbuf}
           if exists $self->{_tls_rbuf};
  
        my $len = length $self->{rbuf};
  
        if (my $cb = shift @{ $self->{_queue} }) {
           unless ($cb->($self)) {
              # no progress can be made
              # (not enough data and no data forthcoming)
              $self->_error (Errno::EPIPE, 1), return
                 if $self->{_eof};
  
              unshift @{ $self->{_queue} }, $cb;
              last;
           }
        } elsif ($self->{on_read}) {
           last unless $len;
  
           $self->{on_read}($self);
  
           if (
              $len == length $self->{rbuf} # if no data has been consumed
              && !@{ $self->{_queue} }     # and the queue is still empty
              && $self->{on_read}          # but we still have on_read
           ) {
              # no further data will arrive
              # so no progress can be made
              $self->_error (Errno::EPIPE, 1), return
                 if $self->{_eof};
  
              last; # more data might arrive
           }
        } else {
           # read side becomes idle
           delete $self->{_rw} unless $self->{tls};
           last;
        }
     }
  
     if ($self->{_eof}) {
        $self->{on_eof}
           ? $self->{on_eof}($self)
           : $self->_error (0, 1, "Unexpected end-of-file");
  
        return;
     }
  
     if (
        defined $self->{rbuf_max}
        && $self->{rbuf_max} < length $self->{rbuf}
     ) {
        $self->_error (Errno::ENOSPC, 1), return;
     }
  
     # may need to restart read watcher
     unless ($self->{_rw}) {
        $self->start_read
           if $self->{on_read} || @{ $self->{_queue} };
     }
  }
  
  =item $handle->on_read ($cb)
  
  This replaces the currently set C<on_read> callback, or clears it (when
  the new callback is C<undef>). See the description of C<on_read> in the
  constructor.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub on_read {
     my ($self, $cb) = @_;
  
     $self->{on_read} = $cb;
     $self->_drain_rbuf if $cb;
  }
  
  =item $handle->rbuf
  
  Returns the read buffer (as a modifiable lvalue). You can also access the
  read buffer directly as the C<< ->{rbuf} >> member, if you want (this is
  much faster, and no less clean).
  
  The only operation allowed on the read buffer (apart from looking at it)
  is removing data from its beginning. Otherwise modifying or appending to
  it is not allowed and will lead to hard-to-track-down bugs.
  
  NOTE: The read buffer should only be used or modified in the C<on_read>
  callback or when C<push_read> or C<unshift_read> are used with a single
  callback (i.e. untyped). Typed C<push_read> and C<unshift_read> methods
  will manage the read buffer on their own.
  
  =cut
  
  sub rbuf : lvalue {
     $_[0]{rbuf}
  }
  
  =item $handle->push_read ($cb)
  
  =item $handle->unshift_read ($cb)
  
  Append the given callback to the end of the queue (C<push_read>) or
  prepend it (C<unshift_read>).
  
  The callback is called each time some additional read data arrives.
  
  It must check whether enough data is in the read buffer already.
  
  If not enough data is available, it must return the empty list or a false
  value, in which case it will be called repeatedly until enough data is
  available (or an error condition is detected).
  
  If enough data was available, then the callback must remove all data it is
  interested in (which can be none at all) and return a true value. After returning
  true, it will be removed from the queue.
  
  These methods may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  our %RH;
  
  sub register_read_type($$) {
     $RH{$_[0]} = $_[1];
  }
  
  sub push_read {
     my $self = shift;
     my $cb = pop;
  
     if (@_) {
        my $type = shift;
  
        $cb = ($RH{$type} ||= _load_func "$type\::anyevent_read_type"
               or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_read")
              ->($self, $cb, @_);
     }
  
     push @{ $self->{_queue} }, $cb;
     $self->_drain_rbuf;
  }
  
  sub unshift_read {
     my $self = shift;
     my $cb = pop;
  
     if (@_) {
        my $type = shift;
  
        $cb = ($RH{$type} ||= _load_func "$type\::anyevent_read_type"
               or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::unshift_read")
              ->($self, $cb, @_);
     }
  
     unshift @{ $self->{_queue} }, $cb;
     $self->_drain_rbuf;
  }
  
  =item $handle->push_read (type => @args, $cb)
  
  =item $handle->unshift_read (type => @args, $cb)
  
  Instead of providing a callback that parses the data itself you can chose
  between a number of predefined parsing formats, for chunks of data, lines
  etc. You can also specify the (fully qualified) name of a package, in
  which case AnyEvent tries to load the package and then expects to find the
  C<anyevent_read_type> function inside (see "custom read types", below).
  
  Predefined types are (if you have ideas for additional types, feel free to
  drop by and tell us):
  
  =over 4
  
  =item chunk => $octets, $cb->($handle, $data)
  
  Invoke the callback only once C<$octets> bytes have been read. Pass the
  data read to the callback. The callback will never be called with less
  data.
  
  Example: read 2 bytes.
  
     $handle->push_read (chunk => 2, sub {
        say "yay " . unpack "H*", $_[1];
     });
  
  =cut
  
  register_read_type chunk => sub {
     my ($self, $cb, $len) = @_;
  
     sub {
        $len <= length $_[0]{rbuf} or return;
        $cb->($_[0], substr $_[0]{rbuf}, 0, $len, "");
        1
     }
  };
  
  =item line => [$eol, ]$cb->($handle, $line, $eol)
  
  The callback will be called only once a full line (including the end of
  line marker, C<$eol>) has been read. This line (excluding the end of line
  marker) will be passed to the callback as second argument (C<$line>), and
  the end of line marker as the third argument (C<$eol>).
  
  The end of line marker, C<$eol>, can be either a string, in which case it
  will be interpreted as a fixed record end marker, or it can be a regex
  object (e.g. created by C<qr>), in which case it is interpreted as a
  regular expression.
  
  The end of line marker argument C<$eol> is optional, if it is missing (NOT
  undef), then C<qr|\015?\012|> is used (which is good for most internet
  protocols).
  
  Partial lines at the end of the stream will never be returned, as they are
  not marked by the end of line marker.
  
  =cut
  
  register_read_type line => sub {
     my ($self, $cb, $eol) = @_;
  
     if (@_ < 3) {
        # this is more than twice as fast as the generic code below
        sub {
           $_[0]{rbuf} =~ s/^([^\015\012]*)(\015?\012)// or return;
  
           $cb->($_[0], "$1", "$2");
           1
        }
     } else {
        $eol = quotemeta $eol unless ref $eol;
        $eol = qr|^(.*?)($eol)|s;
  
        sub {
           $_[0]{rbuf} =~ s/$eol// or return;
  
           $cb->($_[0], "$1", "$2");
           1
        }
     }
  };
  
  =item regex => $accept[, $reject[, $skip], $cb->($handle, $data)
  
  Makes a regex match against the regex object C<$accept> and returns
  everything up to and including the match.
  
  Example: read a single line terminated by '\n'.
  
     $handle->push_read (regex => qr<\n>, sub { ... });
  
  If C<$reject> is given and not undef, then it determines when the data is
  to be rejected: it is matched against the data when the C<$accept> regex
  does not match and generates an C<EBADMSG> error when it matches. This is
  useful to quickly reject wrong data (to avoid waiting for a timeout or a
  receive buffer overflow).
  
  Example: expect a single decimal number followed by whitespace, reject
  anything else (not the use of an anchor).
  
     $handle->push_read (regex => qr<^[0-9]+\s>, qr<[^0-9]>, sub { ... });
  
  If C<$skip> is given and not C<undef>, then it will be matched against
  the receive buffer when neither C<$accept> nor C<$reject> match,
  and everything preceding and including the match will be accepted
  unconditionally. This is useful to skip large amounts of data that you
  know cannot be matched, so that the C<$accept> or C<$reject> regex do not
  have to start matching from the beginning. This is purely an optimisation
  and is usually worth it only when you expect more than a few kilobytes.
  
  Example: expect a http header, which ends at C<\015\012\015\012>. Since we
  expect the header to be very large (it isn't in practice, but...), we use
  a skip regex to skip initial portions. The skip regex is tricky in that
  it only accepts something not ending in either \015 or \012, as these are
  required for the accept regex.
  
     $handle->push_read (regex =>
        qr<\015\012\015\012>,
        undef, # no reject
        qr<^.*[^\015\012]>,
        sub { ... });
  
  =cut
  
  register_read_type regex => sub {
     my ($self, $cb, $accept, $reject, $skip) = @_;
  
     my $data;
     my $rbuf = \$self->{rbuf};
  
     sub {
        # accept
        if ($$rbuf =~ $accept) {
           $data .= substr $$rbuf, 0, $+[0], "";
           $cb->($_[0], $data);
           return 1;
        }
        
        # reject
        if ($reject && $$rbuf =~ $reject) {
           $_[0]->_error (Errno::EBADMSG);
        }
  
        # skip
        if ($skip && $$rbuf =~ $skip) {
           $data .= substr $$rbuf, 0, $+[0], "";
        }
  
        ()
     }
  };
  
  =item netstring => $cb->($handle, $string)
  
  A netstring (http://cr.yp.to/proto/netstrings.txt, this is not an endorsement).
  
  Throws an error with C<$!> set to EBADMSG on format violations.
  
  =cut
  
  register_read_type netstring => sub {
     my ($self, $cb) = @_;
  
     sub {
        unless ($_[0]{rbuf} =~ s/^(0|[1-9][0-9]*)://) {
           if ($_[0]{rbuf} =~ /[^0-9]/) {
              $_[0]->_error (Errno::EBADMSG);
           }
           return;
        }
  
        my $len = $1;
  
        $_[0]->unshift_read (chunk => $len, sub {
           my $string = $_[1];
           $_[0]->unshift_read (chunk => 1, sub {
              if ($_[1] eq ",") {
                 $cb->($_[0], $string);
              } else {
                 $_[0]->_error (Errno::EBADMSG);
              }
           });
        });
  
        1
     }
  };
  
  =item packstring => $format, $cb->($handle, $string)
  
  An octet string prefixed with an encoded length. The encoding C<$format>
  uses the same format as a Perl C<pack> format, but must specify a single
  integer only (only one of C<cCsSlLqQiInNvVjJw> is allowed, plus an
  optional C<!>, C<< < >> or C<< > >> modifier).
  
  For example, DNS over TCP uses a prefix of C<n> (2 octet network order),
  EPP uses a prefix of C<N> (4 octtes).
  
  Example: read a block of data prefixed by its length in BER-encoded
  format (very efficient).
  
     $handle->push_read (packstring => "w", sub {
        my ($handle, $data) = @_;
     });
  
  =cut
  
  register_read_type packstring => sub {
     my ($self, $cb, $format) = @_;
  
     sub {
        # when we can use 5.10 we can use ".", but for 5.8 we use the re-pack method
        defined (my $len = eval { unpack $format, $_[0]{rbuf} })
           or return;
  
        $format = length pack $format, $len;
  
        # bypass unshift if we already have the remaining chunk
        if ($format + $len <= length $_[0]{rbuf}) {
           my $data = substr $_[0]{rbuf}, $format, $len;
           substr $_[0]{rbuf}, 0, $format + $len, "";
           $cb->($_[0], $data);
        } else {
           # remove prefix
           substr $_[0]{rbuf}, 0, $format, "";
  
           # read remaining chunk
           $_[0]->unshift_read (chunk => $len, $cb);
        }
  
        1
     }
  };
  
  =item json => $cb->($handle, $hash_or_arrayref)
  
  Reads a JSON object or array, decodes it and passes it to the
  callback. When a parse error occurs, an C<EBADMSG> error will be raised.
  
  If a C<json> object was passed to the constructor, then that will be used
  for the final decode, otherwise it will create a JSON coder expecting UTF-8.
  
  This read type uses the incremental parser available with JSON version
  2.09 (and JSON::XS version 2.2) and above. You have to provide a
  dependency on your own: this module will load the JSON module, but
  AnyEvent does not depend on it itself.
  
  Since JSON texts are fully self-delimiting, the C<json> read and write
  types are an ideal simple RPC protocol: just exchange JSON datagrams. See
  the C<json> write type description, above, for an actual example.
  
  =cut
  
  register_read_type json => sub {
     my ($self, $cb) = @_;
  
     my $json = $self->{json} ||= json_coder;
  
     my $data;
     my $rbuf = \$self->{rbuf};
  
     sub {
        my $ref = eval { $json->incr_parse ($_[0]{rbuf}) };
  
        if ($ref) {
           $_[0]{rbuf} = $json->incr_text;
           $json->incr_text = "";
           $cb->($_[0], $ref);
  
           1
        } elsif ($@) {
           # error case
           $json->incr_skip;
  
           $_[0]{rbuf} = $json->incr_text;
           $json->incr_text = "";
  
           $_[0]->_error (Errno::EBADMSG);
  
           ()
        } else {
           $_[0]{rbuf} = "";
  
           ()
        }
     }
  };
  
  =item storable => $cb->($handle, $ref)
  
  Deserialises a L<Storable> frozen representation as written by the
  C<storable> write type (BER-encoded length prefix followed by nfreeze'd
  data).
  
  Raises C<EBADMSG> error if the data could not be decoded.
  
  =cut
  
  register_read_type storable => sub {
     my ($self, $cb) = @_;
  
     require Storable unless $Storable::VERSION;
  
     sub {
        # when we can use 5.10 we can use ".", but for 5.8 we use the re-pack method
        defined (my $len = eval { unpack "w", $_[0]{rbuf} })
           or return;
  
        my $format = length pack "w", $len;
  
        # bypass unshift if we already have the remaining chunk
        if ($format + $len <= length $_[0]{rbuf}) {
           my $data = substr $_[0]{rbuf}, $format, $len;
           substr $_[0]{rbuf}, 0, $format + $len, "";
           $cb->($_[0], Storable::thaw ($data));
        } else {
           # remove prefix
           substr $_[0]{rbuf}, 0, $format, "";
  
           # read remaining chunk
           $_[0]->unshift_read (chunk => $len, sub {
              if (my $ref = eval { Storable::thaw ($_[1]) }) {
                 $cb->($_[0], $ref);
              } else {
                 $_[0]->_error (Errno::EBADMSG);
              }
           });
        }
  
        1
     }
  };
  
  =back
  
  =item custom read types - Package::anyevent_read_type $handle, $cb, @args
  
  Instead of one of the predefined types, you can also specify the name
  of a package. AnyEvent will try to load the package and then expects to
  find a function named C<anyevent_read_type> inside. If it isn't found, it
  progressively tries to load the parent package until it either finds the
  function (good) or runs out of packages (bad).
  
  Whenever this type is used, C<push_read> will invoke the function with the
  handle object, the original callback and the remaining arguments.
  
  The function is supposed to return a callback (usually a closure) that
  works as a plain read callback (see C<< ->push_read ($cb) >>), so you can
  mentally treat the function as a "configurable read type to read callback"
  converter.
  
  It should invoke the original callback when it is done reading (remember
  to pass C<$handle> as first argument as all other callbacks do that,
  although there is no strict requirement on this).
  
  For examples, see the source of this module (F<perldoc -m
  AnyEvent::Handle>, search for C<register_read_type>)).
  
  =item $handle->stop_read
  
  =item $handle->start_read
  
  In rare cases you actually do not want to read anything from the
  socket. In this case you can call C<stop_read>. Neither C<on_read> nor
  any queued callbacks will be executed then. To start reading again, call
  C<start_read>.
  
  Note that AnyEvent::Handle will automatically C<start_read> for you when
  you change the C<on_read> callback or push/unshift a read callback, and it
  will automatically C<stop_read> for you when neither C<on_read> is set nor
  there are any read requests in the queue.
  
  In older versions of this module (<= 5.3), these methods had no effect,
  as TLS does not support half-duplex connections. In current versions they
  work as expected, as this behaviour is required to avoid certain resource
  attacks, where the program would be forced to read (and buffer) arbitrary
  amounts of data before being able to send some data. The drawback is that
  some readings of the the SSL/TLS specifications basically require this
  attack to be working, as SSL/TLS implementations might stall sending data
  during a rehandshake.
  
  As a guideline, during the initial handshake, you should not stop reading,
  and as a client, it might cause problems, depending on your application.
  
  =cut
  
  sub stop_read {
     my ($self) = @_;
  
     delete $self->{_rw};
  }
  
  sub start_read {
     my ($self) = @_;
  
     unless ($self->{_rw} || $self->{_eof} || !$self->{fh}) {
        Scalar::Util::weaken $self;
  
        $self->{_rw} = AE::io $self->{fh}, 0, sub {
           my $rbuf = \($self->{tls} ? my $buf : $self->{rbuf});
           my $len = sysread $self->{fh}, $$rbuf, $self->{read_size}, length $$rbuf;
  
           if ($len > 0) {
              $self->{_activity} = $self->{_ractivity} = AE::now;
  
              if ($self->{tls}) {
                 Net::SSLeay::BIO_write ($self->{_rbio}, $$rbuf);
  
                 &_dotls ($self);
              } else {
                 $self->_drain_rbuf;
              }
  
              if ($len == $self->{read_size}) {
                 $self->{read_size} *= 2;
                 $self->{read_size} = $self->{max_read_size} || MAX_READ_SIZE
                    if $self->{read_size} > ($self->{max_read_size} || MAX_READ_SIZE);
              }
  
           } elsif (defined $len) {
              delete $self->{_rw};
              $self->{_eof} = 1;
              $self->_drain_rbuf;
  
           } elsif ($! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK) {
              return $self->_error ($!, 1);
           }
        };
     }
  }
  
  our $ERROR_SYSCALL;
  our $ERROR_WANT_READ;
  
  sub _tls_error {
     my ($self, $err) = @_;
  
     return $self->_error ($!, 1)
        if $err == Net::SSLeay::ERROR_SYSCALL ();
  
     my $err =Net::SSLeay::ERR_error_string (Net::SSLeay::ERR_get_error ());
  
     # reduce error string to look less scary
     $err =~ s/^error:[0-9a-fA-F]{8}:[^:]+:([^:]+):/\L$1: /;
  
     if ($self->{_on_starttls}) {
        (delete $self->{_on_starttls})->($self, undef, $err);
        &_freetls;
     } else {
        &_freetls;
        $self->_error (Errno::EPROTO, 1, $err);
     }
  }
  
  # poll the write BIO and send the data if applicable
  # also decode read data if possible
  # this is basiclaly our TLS state machine
  # more efficient implementations are possible with openssl,
  # but not with the buggy and incomplete Net::SSLeay.
  sub _dotls {
     my ($self) = @_;
  
     my $tmp;
  
     if (length $self->{_tls_wbuf}) {
        while (($tmp = Net::SSLeay::write ($self->{tls}, $self->{_tls_wbuf})) > 0) {
           substr $self->{_tls_wbuf}, 0, $tmp, "";
        }
  
        $tmp = Net::SSLeay::get_error ($self->{tls}, $tmp);
        return $self->_tls_error ($tmp)
           if $tmp != $ERROR_WANT_READ
              && ($tmp != $ERROR_SYSCALL || $!);
     }
  
     while (defined ($tmp = Net::SSLeay::read ($self->{tls}))) {
        unless (length $tmp) {
           $self->{_on_starttls}
              and (delete $self->{_on_starttls})->($self, undef, "EOF during handshake"); # ???
           &_freetls;
  
           if ($self->{on_stoptls}) {
              $self->{on_stoptls}($self);
              return;
           } else {
              # let's treat SSL-eof as we treat normal EOF
              delete $self->{_rw};
              $self->{_eof} = 1;
           }
        }
  
        $self->{_tls_rbuf} .= $tmp;
        $self->_drain_rbuf;
        $self->{tls} or return; # tls session might have gone away in callback
     }
  
     $tmp = Net::SSLeay::get_error ($self->{tls}, -1);
     return $self->_tls_error ($tmp)
        if $tmp != $ERROR_WANT_READ
           && ($tmp != $ERROR_SYSCALL || $!);
  
     while (length ($tmp = Net::SSLeay::BIO_read ($self->{_wbio}))) {
        $self->{wbuf} .= $tmp;
        $self->_drain_wbuf;
        $self->{tls} or return; # tls session might have gone away in callback
     }
  
     $self->{_on_starttls}
        and Net::SSLeay::state ($self->{tls}) == Net::SSLeay::ST_OK ()
        and (delete $self->{_on_starttls})->($self, 1, "TLS/SSL connection established");
  }
  
  =item $handle->starttls ($tls[, $tls_ctx])
  
  Instead of starting TLS negotiation immediately when the AnyEvent::Handle
  object is created, you can also do that at a later time by calling
  C<starttls>.
  
  Starting TLS is currently an asynchronous operation - when you push some
  write data and then call C<< ->starttls >> then TLS negotiation will start
  immediately, after which the queued write data is then sent.
  
  The first argument is the same as the C<tls> constructor argument (either
  C<"connect">, C<"accept"> or an existing Net::SSLeay object).
  
  The second argument is the optional C<AnyEvent::TLS> object that is used
  when AnyEvent::Handle has to create its own TLS connection object, or
  a hash reference with C<< key => value >> pairs that will be used to
  construct a new context.
  
  The TLS connection object will end up in C<< $handle->{tls} >>, the TLS
  context in C<< $handle->{tls_ctx} >> after this call and can be used or
  changed to your liking. Note that the handshake might have already started
  when this function returns.
  
  Due to bugs in OpenSSL, it might or might not be possible to do multiple
  handshakes on the same stream. It is best to not attempt to use the
  stream after stopping TLS.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  our %TLS_CACHE; #TODO not yet documented, should we?
  
  sub starttls {
     my ($self, $tls, $ctx) = @_;
  
     Carp::croak "It is an error to call starttls on an AnyEvent::Handle object while TLS is already active, caught"
        if $self->{tls};
  
     $self->{tls}     = $tls;
     $self->{tls_ctx} = $ctx if @_ > 2;
  
     return unless $self->{fh};
  
     require Net::SSLeay;
  
     $ERROR_SYSCALL   = Net::SSLeay::ERROR_SYSCALL     ();
     $ERROR_WANT_READ = Net::SSLeay::ERROR_WANT_READ   ();
  
     $tls = delete $self->{tls};
     $ctx = $self->{tls_ctx};
  
     local $Carp::CarpLevel = 1; # skip ourselves when creating a new context or session
  
     if ("HASH" eq ref $ctx) {
        require AnyEvent::TLS;
  
        if ($ctx->{cache}) {
           my $key = $ctx+0;
           $ctx = $TLS_CACHE{$key} ||= new AnyEvent::TLS %$ctx;
        } else {
           $ctx = new AnyEvent::TLS %$ctx;
        }
     }
     
     $self->{tls_ctx} = $ctx || TLS_CTX ();
     $self->{tls}     = $tls = $self->{tls_ctx}->_get_session ($tls, $self, $self->{peername});
  
     # basically, this is deep magic (because SSL_read should have the same issues)
     # but the openssl maintainers basically said: "trust us, it just works".
     # (unfortunately, we have to hardcode constants because the abysmally misdesigned
     # and mismaintained ssleay-module doesn't even offer them).
     # http://www.mail-archive.com/openssl-dev@openssl.org/msg22420.html
     #
     # in short: this is a mess.
     # 
     # note that we do not try to keep the length constant between writes as we are required to do.
     # we assume that most (but not all) of this insanity only applies to non-blocking cases,
     # and we drive openssl fully in blocking mode here. Or maybe we don't - openssl seems to
     # have identity issues in that area.
  #   Net::SSLeay::CTX_set_mode ($ssl,
  #      (eval { local $SIG{__DIE__}; Net::SSLeay::MODE_ENABLE_PARTIAL_WRITE () } || 1)
  #      | (eval { local $SIG{__DIE__}; Net::SSLeay::MODE_ACCEPT_MOVING_WRITE_BUFFER () } || 2));
     Net::SSLeay::CTX_set_mode ($tls, 1|2);
  
     $self->{_rbio} = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
     $self->{_wbio} = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
  
     Net::SSLeay::BIO_write ($self->{_rbio}, $self->{rbuf});
     $self->{rbuf} = "";
  
     Net::SSLeay::set_bio ($tls, $self->{_rbio}, $self->{_wbio});
  
     $self->{_on_starttls} = sub { $_[0]{on_starttls}(@_) }
        if $self->{on_starttls};
  
     &_dotls; # need to trigger the initial handshake
     $self->start_read; # make sure we actually do read
  }
  
  =item $handle->stoptls
  
  Shuts down the SSL connection - this makes a proper EOF handshake by
  sending a close notify to the other side, but since OpenSSL doesn't
  support non-blocking shut downs, it is not guaranteed that you can re-use
  the stream afterwards.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub stoptls {
     my ($self) = @_;
  
     if ($self->{tls} && $self->{fh}) {
        Net::SSLeay::shutdown ($self->{tls});
  
        &_dotls;
  
  #      # we don't give a shit. no, we do, but we can't. no...#d#
  #      # we, we... have to use openssl :/#d#
  #      &_freetls;#d#
     }
  }
  
  sub _freetls {
     my ($self) = @_;
  
     return unless $self->{tls};
  
     $self->{tls_ctx}->_put_session (delete $self->{tls})
        if $self->{tls} > 0;
     
     delete @$self{qw(_rbio _wbio _tls_wbuf _on_starttls)};
  }
  
  =item $handle->resettls
  
  This rarely-used method simply resets and TLS state on the handle, usually
  causing data loss.
  
  One case where it may be useful is when you want to skip over the data in
  the stream but you are not interested in interpreting it, so data loss is
  no concern.
  
  =cut
  
  *resettls = \&_freetls;
  
  sub DESTROY {
     my ($self) = @_;
  
     &_freetls;
  
     my $linger = exists $self->{linger} ? $self->{linger} : 3600;
  
     if ($linger && length $self->{wbuf} && $self->{fh}) {
        my $fh   = delete $self->{fh};
        my $wbuf = delete $self->{wbuf};
  
        my @linger;
  
        push @linger, AE::io $fh, 1, sub {
           my $len = syswrite $fh, $wbuf, length $wbuf;
  
           if ($len > 0) {
              substr $wbuf, 0, $len, "";
           } elsif (defined $len || ($! != EAGAIN && $! != EINTR && $! != WSAEWOULDBLOCK)) {
              @linger = (); # end
           }
        };
        push @linger, AE::timer $linger, 0, sub {
           @linger = ();
        };
     }
  }
  
  =item $handle->destroy
  
  Shuts down the handle object as much as possible - this call ensures that
  no further callbacks will be invoked and as many resources as possible
  will be freed. Any method you will call on the handle object after
  destroying it in this way will be silently ignored (and it will return the
  empty list).
  
  Normally, you can just "forget" any references to an AnyEvent::Handle
  object and it will simply shut down. This works in fatal error and EOF
  callbacks, as well as code outside. It does I<NOT> work in a read or write
  callback, so when you want to destroy the AnyEvent::Handle object from
  within such an callback. You I<MUST> call C<< ->destroy >> explicitly in
  that case.
  
  Destroying the handle object in this way has the advantage that callbacks
  will be removed as well, so if those are the only reference holders (as
  is common), then one doesn't need to do anything special to break any
  reference cycles.
  
  The handle might still linger in the background and write out remaining
  data, as specified by the C<linger> option, however.
  
  =cut
  
  sub destroy {
     my ($self) = @_;
  
     $self->DESTROY;
     %$self = ();
     bless $self, "AnyEvent::Handle::destroyed";
  }
  
  sub AnyEvent::Handle::destroyed::AUTOLOAD {
     #nop
  }
  
  =item $handle->destroyed
  
  Returns false as long as the handle hasn't been destroyed by a call to C<<
  ->destroy >>, true otherwise.
  
  Can be useful to decide whether the handle is still valid after some
  callback possibly destroyed the handle. For example, C<< ->push_write >>,
  C<< ->starttls >> and other methods can call user callbacks, which in turn
  can destroy the handle, so work can be avoided by checking sometimes:
  
     $hdl->starttls ("accept");
     return if $hdl->destroyed;
     $hdl->push_write (...
  
  Note that the call to C<push_write> will silently be ignored if the handle
  has been destroyed, so often you can just ignore the possibility of the
  handle being destroyed.
  
  =cut
  
  sub destroyed { 0 }
  sub AnyEvent::Handle::destroyed::destroyed { 1 }
  
  =item AnyEvent::Handle::TLS_CTX
  
  This function creates and returns the AnyEvent::TLS object used by default
  for TLS mode.
  
  The context is created by calling L<AnyEvent::TLS> without any arguments.
  
  =cut
  
  our $TLS_CTX;
  
  sub TLS_CTX() {
     $TLS_CTX ||= do {
        require AnyEvent::TLS;
  
        new AnyEvent::TLS
     }
  }
  
  =back
  
  
  =head1 NONFREQUENTLY ASKED QUESTIONS
  
  =over 4
  
  =item I C<undef> the AnyEvent::Handle reference inside my callback and
  still get further invocations!
  
  That's because AnyEvent::Handle keeps a reference to itself when handling
  read or write callbacks.
  
  It is only safe to "forget" the reference inside EOF or error callbacks,
  from within all other callbacks, you need to explicitly call the C<<
  ->destroy >> method.
  
  =item Why is my C<on_eof> callback never called?
  
  Probably because your C<on_error> callback is being called instead: When
  you have outstanding requests in your read queue, then an EOF is
  considered an error as you clearly expected some data.
  
  To avoid this, make sure you have an empty read queue whenever your handle
  is supposed to be "idle" (i.e. connection closes are O.K.). You can set
  an C<on_read> handler that simply pushes the first read requests in the
  queue.
  
  See also the next question, which explains this in a bit more detail.
  
  =item How can I serve requests in a loop?
  
  Most protocols consist of some setup phase (authentication for example)
  followed by a request handling phase, where the server waits for requests
  and handles them, in a loop.
  
  There are two important variants: The first (traditional, better) variant
  handles requests until the server gets some QUIT command, causing it to
  close the connection first (highly desirable for a busy TCP server). A
  client dropping the connection is an error, which means this variant can
  detect an unexpected detection close.
  
  To handle this case, always make sure you have a on-empty read queue, by
  pushing the "read request start" handler on it:
  
     # we assume a request starts with a single line
     my @start_request; @start_request = (line => sub {
        my ($hdl, $line) = @_;
  
        ... handle request
  
        # push next request read, possibly from a nested callback
        $hdl->push_read (@start_request);
     });
  
     # auth done, now go into request handling loop
     # now push the first @start_request
     $hdl->push_read (@start_request);
  
  By always having an outstanding C<push_read>, the handle always expects
  some data and raises the C<EPIPE> error when the connction is dropped
  unexpectedly.
  
  The second variant is a protocol where the client can drop the connection
  at any time. For TCP, this means that the server machine may run out of
  sockets easier, and in general, it means you cannot distinguish a protocl
  failure/client crash from a normal connection close. Nevertheless, these
  kinds of protocols are common (and sometimes even the best solution to the
  problem).
  
  Having an outstanding read request at all times is possible if you ignore
  C<EPIPE> errors, but this doesn't help with when the client drops the
  connection during a request, which would still be an error.
  
  A better solution is to push the initial request read in an C<on_read>
  callback. This avoids an error, as when the server doesn't expect data
  (i.e. is idly waiting for the next request, an EOF will not raise an
  error, but simply result in an C<on_eof> callback. It is also a bit slower
  and simpler:
  
     # auth done, now go into request handling loop
     $hdl->on_read (sub {
        my ($hdl) = @_;
  
        # called each time we receive data but the read queue is empty
        # simply start read the request
  
        $hdl->push_read (line => sub {
           my ($hdl, $line) = @_;
  
           ... handle request
  
           # do nothing special when the request has been handled, just
           # let the request queue go empty.
        });
     });
  
  =item I get different callback invocations in TLS mode/Why can't I pause
  reading?
  
  Unlike, say, TCP, TLS connections do not consist of two independent
  communication channels, one for each direction. Or put differently, the
  read and write directions are not independent of each other: you cannot
  write data unless you are also prepared to read, and vice versa.
  
  This means that, in TLS mode, you might get C<on_error> or C<on_eof>
  callback invocations when you are not expecting any read data - the reason
  is that AnyEvent::Handle always reads in TLS mode.
  
  During the connection, you have to make sure that you always have a
  non-empty read-queue, or an C<on_read> watcher. At the end of the
  connection (or when you no longer want to use it) you can call the
  C<destroy> method.
  
  =item How do I read data until the other side closes the connection?
  
  If you just want to read your data into a perl scalar, the easiest way
  to achieve this is by setting an C<on_read> callback that does nothing,
  clearing the C<on_eof> callback and in the C<on_error> callback, the data
  will be in C<$_[0]{rbuf}>:
  
     $handle->on_read (sub { });
     $handle->on_eof (undef);
     $handle->on_error (sub {
        my $data = delete $_[0]{rbuf};
     });
  
  Note that this example removes the C<rbuf> member from the handle object,
  which is not normally allowed by the API. It is expressly permitted in
  this case only, as the handle object needs to be destroyed afterwards.
  
  The reason to use C<on_error> is that TCP connections, due to latencies
  and packets loss, might get closed quite violently with an error, when in
  fact all data has been received.
  
  It is usually better to use acknowledgements when transferring data,
  to make sure the other side hasn't just died and you got the data
  intact. This is also one reason why so many internet protocols have an
  explicit QUIT command.
  
  =item I don't want to destroy the handle too early - how do I wait until
  all data has been written?
  
  After writing your last bits of data, set the C<on_drain> callback
  and destroy the handle in there - with the default setting of
  C<low_water_mark> this will be called precisely when all data has been
  written to the socket:
  
     $handle->push_write (...);
     $handle->on_drain (sub {
        AE::log debug => "all data submitted to the kernel\n";
        undef $handle;
     });
  
  If you just want to queue some data and then signal EOF to the other side,
  consider using C<< ->push_shutdown >> instead.
  
  =item I want to contact a TLS/SSL server, I don't care about security.
  
  If your TLS server is a pure TLS server (e.g. HTTPS) that only speaks TLS,
  connect to it and then create the AnyEvent::Handle with the C<tls>
  parameter:
  
     tcp_connect $host, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh  => $fh,
           tls => "connect",
           on_error => sub { ... };
  
        $handle->push_write (...);
     };
  
  =item I want to contact a TLS/SSL server, I do care about security.
  
  Then you should additionally enable certificate verification, including
  peername verification, if the protocol you use supports it (see
  L<AnyEvent::TLS>, C<verify_peername>).
  
  E.g. for HTTPS:
  
     tcp_connect $host, $port, sub {
        my ($fh) = @_;
  
         my $handle = new AnyEvent::Handle
            fh       => $fh,
            peername => $host,
            tls      => "connect",
            tls_ctx  => { verify => 1, verify_peername => "https" },
            ...
  
  Note that you must specify the hostname you connected to (or whatever
  "peername" the protocol needs) as the C<peername> argument, otherwise no
  peername verification will be done.
  
  The above will use the system-dependent default set of trusted CA
  certificates. If you want to check against a specific CA, add the
  C<ca_file> (or C<ca_cert>) arguments to C<tls_ctx>:
  
         tls_ctx  => {
            verify          => 1,
            verify_peername => "https",
            ca_file         => "my-ca-cert.pem",
         },
  
  =item I want to create a TLS/SSL server, how do I do that?
  
  Well, you first need to get a server certificate and key. You have
  three options: a) ask a CA (buy one, use cacert.org etc.) b) create a
  self-signed certificate (cheap. check the search engine of your choice,
  there are many tutorials on the net) or c) make your own CA (tinyca2 is a
  nice program for that purpose).
  
  Then create a file with your private key (in PEM format, see
  L<AnyEvent::TLS>), followed by the certificate (also in PEM format). The
  file should then look like this:
  
     -----BEGIN RSA PRIVATE KEY-----
     ...header data
     ... lots of base64'y-stuff
     -----END RSA PRIVATE KEY-----
  
     -----BEGIN CERTIFICATE-----
     ... lots of base64'y-stuff
     -----END CERTIFICATE-----
  
  The important bits are the "PRIVATE KEY" and "CERTIFICATE" parts.  Then
  specify this file as C<cert_file>:
  
     tcp_server undef, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh       => $fh,
           tls      => "accept",
           tls_ctx  => { cert_file => "my-server-keycert.pem" },
           ...
  
  When you have intermediate CA certificates that your clients might not
  know about, just append them to the C<cert_file>.
  
  =back
  
  
  =head1 SUBCLASSING AnyEvent::Handle
  
  In many cases, you might want to subclass AnyEvent::Handle.
  
  To make this easier, a given version of AnyEvent::Handle uses these
  conventions:
  
  =over 4
  
  =item * all constructor arguments become object members.
  
  At least initially, when you pass a C<tls>-argument to the constructor it
  will end up in C<< $handle->{tls} >>. Those members might be changed or
  mutated later on (for example C<tls> will hold the TLS connection object).
  
  =item * other object member names are prefixed with an C<_>.
  
  All object members not explicitly documented (internal use) are prefixed
  with an underscore character, so the remaining non-C<_>-namespace is free
  for use for subclasses.
  
  =item * all members not documented here and not prefixed with an underscore
  are free to use in subclasses.
  
  Of course, new versions of AnyEvent::Handle may introduce more "public"
  member variables, but that's just life. At least it is documented.
  
  =back
  
  =head1 AUTHOR
  
  Robin Redeker C<< <elmex at ta-sa.org> >>, Marc Lehmann <schmorp@schmorp.de>.
  
  =cut
  
  1; # End of AnyEvent::Handle
DARWIN-2LEVEL_ANYEVENT_HANDLE

$fatpacked{"darwin-2level/AnyEvent/Impl/Cocoa.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_COCOA';
  =head1 NAME
  
  AnyEvent::Impl::Cocoa - AnyEvent adaptor for Cocoa::EventLoop
  
  =head1 SYNOPSIS
  
      use AnyEvent;
      use Cocoa::EventLoop;
      
      # do something
  
  =head1 DESCRIPTION
  
  This module provides NSRunLoop support to AnyEvent.
  
  NSRunLoop is an event loop for Cocoa applications, wrapped by
  L<Cocoa::EventLoop>. By using this module, you can use Cocoa based API in
  your AnyEvent application, or AnyEvent within Cocoa applications.
  
  It does not support blocking waits.
  
  =head1 BUGS
  
  Right now, L<Cocoa::EventLoop> (and this module) are in an early
  development phase and has some shortcomings and likely bugs.
  
  For example, there seems to be no way to just handle a single event
  with Cocoa (is there nothing they can implement properly?), so this
  module currently wakes up at least ten times a second when waiting for
  events. Also, events caused by timers might get delayed by up to 0.1
  seconds.
  
  =cut
  
  package AnyEvent::Impl::Cocoa;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Cocoa::EventLoop;
  
  sub io {
     my ($class, %arg) = @_;
  
     Cocoa::EventLoop->io (%arg)
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     Cocoa::EventLoop->timer (%arg)
  }
  
  # does not support blocking waits
  
  #sub loop {
  #   Cocoa::EventLoop->run;
  #}
  
  1;
  
  =head1 AUTHORS
  
  Daisuke Murase <typester@cpan.org>, Marc Lehmann <schmorp@schmorp.de>.
  
  =head1 COPYRIGHTS
  
     Copyright (c) 2009 by KAYAC Inc.
     Copyright (c) 2010,2011 by Marc Lehmann <schmorp@schmorp.de>
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_COCOA

$fatpacked{"darwin-2level/AnyEvent/Impl/EV.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_EV';
  =head1 NAME
  
  AnyEvent::Impl::EV - AnyEvent adaptor for EV
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use EV;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make EV work with AnyEvent except by loading EV before
  creating the first AnyEvent watcher.
  
  EV is the fastest event library for perl, and best supported by
  AnyEvent. Most functions from the L<AE> API are implemented as direct
  aliases to EV functions, so using EV via AE is as fast as using EV
  directly.
  
  =cut
  
  package AnyEvent::Impl::EV;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use EV 4.00;
  
  *AE::time       = \&EV::time;
  *AE::now        = \&EV::now;
  *AE::now_update = \&EV::now_update;
  *AE::timer      = \&EV::timer;
  *AE::signal     = \&EV::signal;
  *AE::idle       = \&EV::idle;
  
  # cannot override directly, as EV doesn't allow arguments
  sub time       { EV::time       }
  sub now        { EV::now        }
  sub now_update { EV::now_update }
  
  *AE::io = defined &EV::_ae_io # 3.8+, but keep just in case it is dropped
     ? \&EV::_ae_io
     : sub($$$) { EV::io $_[0], $_[1] ? EV::WRITE : EV::READ, $_[2] };
  
  sub timer {
     my ($class, %arg) = @_;
  
     EV::timer $arg{after}, $arg{interval}, $arg{cb}
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     EV::io
        $arg{fh},
        $arg{poll} eq "r" ? EV::READ : EV::WRITE,
        $arg{cb}
  }
  
  sub signal {
     my ($class, %arg) = @_;
  
     EV::signal $arg{signal}, $arg{cb}
  }
  
  sub child {
     my ($class, %arg) = @_;
  
     my $cb = $arg{cb};
  
     EV::child $arg{pid}, 0, sub {
        $cb->($_[0]->rpid, $_[0]->rstatus);
     }
  }
  
  sub idle {
     my ($class, %arg) = @_;
  
     EV::idle $arg{cb}
  }
  
  sub _poll {
     EV::run EV::RUN_ONCE;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     EV::run EV::RUN_ONCE until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   EV::run;
  #}
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<EV>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_EV

$fatpacked{"darwin-2level/AnyEvent/Impl/Event.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_EVENT';
  =head1 NAME
  
  AnyEvent::Impl::Event - AnyEvent adaptor for Event
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Event;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Event work with AnyEvent except by loading Event before
  creating the first AnyEvent watcher.
  
  The event module is reasonably efficient and generally works correctly
  even with many watchers, except that its signal handling is inherently
  racy and requires the wake-up-frequently workaround.
  
  =cut
  
  package AnyEvent::Impl::Event;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Event qw(unloop); # we have to import something to make Event use Time::HiRes
  
  sub io {
     my (undef, %arg) = @_;
     $arg{fd} = delete $arg{fh};
     $arg{poll} .= "e" if AnyEvent::WIN32; # work around windows connect bug
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \(Event->io (%arg)), __PACKAGE__
  }
  
  sub timer {
     my (undef, %arg) = @_;
     $arg{after} = 0 if $arg{after} < 0;
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \Event->timer (%arg, repeat => $arg{interval}), __PACKAGE__
  }
  
  sub idle {
     my (undef, %arg) = @_;
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \Event->idle (repeat => 1, min => 0, %arg), __PACKAGE__
  }
  
  sub DESTROY {
     ${$_[0]}->cancel;
  }
  
  sub signal {
     my (undef, %arg) = @_;
  
     my $cb = $arg{cb};
     my $w = Event->signal (
        signal => AnyEvent::Base::sig2name $arg{signal},
        cb     => sub { &$cb }, # event doesn't like callable objects
     );
  
     AnyEvent::Base::_sig_add;
     bless \$w, "AnyEvent::Impl::Event::signal"
  }
  
  sub AnyEvent::Impl::Event::signal::DESTROY {
     AnyEvent::Base::_sig_del;
     ${$_[0]}->cancel;
  }
  
  sub _poll {
     Event::one_event;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Event::one_event until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   Event::loop;
  #}
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Event>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_EVENT

$fatpacked{"darwin-2level/AnyEvent/Impl/EventLib.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_EVENTLIB';
  =head1 NAME
  
  AnyEvent::Impl::EventLib - AnyEvent adaptor for Event::Lib
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Event::Lib;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Event work with AnyEvent except by loading Event::Lib
  before creating the first AnyEvent watcher.
  
  Note: the AnyEvent author has not found recent releases of Event::Lib to
  be even remotely working (not even the examples from the manpage or the
  testsuite work), so this event backend should be avoided (or somebody
  should step up and maintain it, hint, hint).
  
  The L<Event::Lib> module suffers from the same limitations and bugs as
  libevent, most notably it kills already-installed watchers on a file
  descriptor and it is unable to support fork. These are not fatal issues,
  and are worked-around by this module, but the L<Event::Lib> perl module
  itself has many additional bugs such as taking references to file handles
  and callbacks instead of making a copy or freeing still-allocated scalars,
  causing memory corruption and random crashes. Only Tk rivals it in its
  brokenness.
  
  This adaptor module employs the same workaround around the watcher
  problems as Tk and should therefore be avoided. (This was done for
  simplicity, one could in theory work around the problems with lower
  overhead by managing our own watchers).
  
  Event::Lib also leaks file handles and memory and tends to just exit on
  problems.
  
  It also doesn't work around the Windows bug of not signalling TCP
  connection failures.
  
  It also doesn't work with many special devices on Linux (F</dev/random>
  works, F</dev/urandom> fails, F</dev/tty> works, F</dev/null> fails and so
  on).
  
  Event::Lib does not support idle watchers. They could be emulated using
  low-priority timers but as the priority range (and availability) is not
  queryable nor guaranteed, and the default priority is likely the lowest
  one, this module cannot use them.
  
  Avoid Event::Lib if you can.
  
  =cut
  
  package AnyEvent::Impl::EventLib;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Event::Lib;
  
  # Event::Lib doesn't always take a reference to the callback, so closures
  # cause memory corruption and segfaults. it also has an issue actually
  # calling callbacks, so this exists as workaround.
  sub ccb {
     # Event:Lib accesses $_[0] after the callback, when it might be freed,
     # so we keep it referenced until after the callback. This still accesses
     # a freed scalar, but at least it'll not crash.
     my $keep_it = $_[0];
  
     $_[2]();
  }
  
  my $ccb = \&ccb;
  
  sub io {
     my (undef, %arg) = @_;
  
     # work around these bugs in Event::Lib:
     # - adding a callback might destroy other callbacks
     # - only one callback per fd/poll combination
     my ($fh, $mode) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, EV_READ, EV_WRITE;
  
     # event_new errornously takes a reference to fh and cb instead of making a copy
     # fortunately, going through %arg/_dupfh already makes a copy, so it happpens to work
     my $w = event_new $fh, $mode | EV_PERSIST, $ccb, $arg{cb};
     event_add $w;
     bless \\$w, __PACKAGE__
  }
  
  sub timer {
     my (undef, %arg) = @_;
  
     my $ival = $arg{interval};
     my $cb   = $arg{cb};
  
     my $w; $w = timer_new $ccb,
                    $ival
                       ? sub { event_add $w, $ival; &$cb }
                       : sub { undef $w           ; &$cb };
  
     event_add $w, $arg{after} || 1e-10; # work around 0-bug in Event::Lib
  
     bless \\$w, __PACKAGE__
  }
  
  sub DESTROY {
     local $@;
     ${${$_[0]}}->remove;
  }
  
  sub signal {
     my (undef, %arg) = @_;
  
     my $w = signal_new AnyEvent::Base::sig2num $arg{signal}, $ccb, $arg{cb};
     event_add $w;
     AnyEvent::Base::_sig_add;
     bless \\$w, "AnyEvent::Impl::EventLib::signal"
  }
  
  sub AnyEvent::Impl::EventLib::signal::DESTROY {
     AnyEvent::Base::_sig_del;
     local $@;
     ${${$_[0]}}->remove;
  }
  
  #sub loop {
  #   event_mainloop;
  #}
  
  sub _poll {
     event_one_loop;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     event_one_loop until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Event::Lib>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_EVENTLIB

$fatpacked{"darwin-2level/AnyEvent/Impl/FLTK.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_FLTK';
  =head1 NAME
  
  AnyEvent::Impl::FLTK - AnyEvent adaptor for FLTK (Fast Light Toolkit version two)
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use FLTK;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make FLTK work with AnyEvent except by loading FLTK before
  creating the first AnyEvent watcher.
  
  This implementation is not to be confused with AnyEvent::Impl::FLTK by
  Sanko Robinson. That implementation is completely broken, and the author
  is apparently unreachable.
  
  In any case, FLTK suffers from typical GUI-ToolKit diseases, such as O(n)
  or worse for every operation (adding a timer, destroying a timer etc.),
  the typical Not-Well-Tested Perl Interface disases such as non-random
  memory corruption and the typical Event-Loop-as-an-Afterthrough issues,
  such as multiple watchers on the same fd silently overwriting the others.
  
  It doesn't have native idle, signal or child watchers, so all of these are
  emulated.
  
  =cut
  
  package AnyEvent::Impl::FLTK;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use FLTK 0.532 ();
  use Scalar::Util ();
  
  #*AE::timer      = \&EV::timer;
  #*AE::signal     = \&EV::signal;
  #*AE::idle       = \&EV::idle;
  
  # FLTK::get_time_secs returns a glob :/
  # on unix, fltk uses gettimeofday, so we are likely compatible
  # on windows, fltk uses GetTickCount, to which we are unlikely to be compatible with.
  #sub time { FLTK::get_time_secs }
  #*now = \&time;
  
  sub timer_interval_cb {
     my $id = shift; # add_timeout kills @_, so we have to make a copy :(
     $id->[0] = FLTK::add_timeout $id->[1], \&timer_interval_cb, $id;
     &{ $id->[2] }
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     my $cb = $arg{cb};
  
     if ($arg{interval}) {
        my $id = [undef, $arg{interval}, $cb];
  
        $id->[0] = FLTK::add_timeout $arg{after}, \&timer_interval_cb, $id;
  
        return bless $id, "AnyEvent::Impl::FLTK::timer"
     } else {
        # non-repeating timers can be done very efficiently
        # also, FLTK doesn't like callable objects
        return FLTK::add_timeout $arg{after}, sub { &$cb }
     }
  }
  
  sub AnyEvent::Impl::FLTK::timer::DESTROY {
     undef $_[0][0];
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     # only one watcher/fd :(
  
     my $cb = $arg{cb};
     my ($fh, $ev) = AnyEvent::_dupfh $arg{poll}, $arg{fh},
        FLTK::READ,
        FLTK::WRITE | (AnyEvent::WIN32 ? FLTK::EXCEPT : 0);
  
     # fltk hardcodes poll constants and aliases EXCEPT with POLLERR,
     # which is grossly wrong, but likely it doesn't use poll on windows.
     FLTK::add_fd $fh, $ev, sub { &$cb }
  }
  
  # use signal and child emulation - fltk has no facilities for that
  
  # fltk idle watchers are like EV::check watchers, and fltk check watchers
  # are like EV::prepare watchers. both are called when the loop is busy,
  # so we have to use idle watcher emulation.
  
  sub _poll {
     FLTK::wait;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     FLTK::wait until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   FLTK::run;
  #}
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<FLTK>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_FLTK

$fatpacked{"darwin-2level/AnyEvent/Impl/Glib.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_GLIB';
  =head1 NAME
  
  AnyEvent::Impl::Glib - AnyEvent adaptor for Glib
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Glib;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Glib work with AnyEvent except by loading Glib before
  creating the first AnyEvent watcher.
  
  Glib is probably the most inefficient event loop that has ever seen the
  light of the world: Glib not only scans all its watchers (really, ALL of
  them, whether I/O-related, timer-related or what not) during each loop
  iteration, it also does so multiple times and rebuilds the poll list for
  the kernel each time again, dynamically even.
  
  On the positive side, and most importantly, Glib generally works
  correctly, no quarrels there.
  
  If you create many watchers (as in: more than two), you might consider one
  of the L<Glib::EV>, L<EV::Glib> or L<Glib::Event> modules that map Glib to
  other, more efficient, event loops.
  
  This module uses the default Glib main context for all its watchers.
  
  =cut
  
  package AnyEvent::Impl::Glib;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Glib 1.210 (); # (stable 1.220 2009, also Glib 2.4+ required, 2004)
  
  our $mainloop = Glib::MainContext->default;
  
  my %io_cond = (
     r => ["in" , "hup"],
     w => ["out", "hup"],
  );
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = add_watch Glib::IO
        $fd,
        $io_cond{$arg{poll}},
        sub { &$cb; 1 };
  
     bless \\$source, $class
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb   = $arg{cb};
     my $ival = $arg{interval} * 1000;
  
     my $source; $source = add Glib::Timeout $arg{after} < 0 ? 0 : $arg{after} * 1000,
        $ival ? sub {
                  remove Glib::Source $source;
                  $source = add Glib::Timeout $ival, sub { &$cb; 1 };
                  &$cb;
                  0
                }
              : sub { &$cb; 0 };
  
     bless \\$source, $class
  }
  
  sub idle {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $source = add Glib::Idle sub { &$cb; 1 };
  
     bless \\$source, $class
  }
  
  sub DESTROY {
     remove Glib::Source $${$_[0]};
  }
  
  our %pid_w;
  our %pid_cb;
  
  sub child {
     my ($class, %arg) = @_;
  
     $arg{pid} > 0
        or Carp::croak "Glib does not support watching for all pids (pid == 0) as attempted";
  
     my $pid = $arg{pid};
     my $cb  = $arg{cb};
  
     $pid_cb{$pid}{$cb+0} = $cb;
  
     $pid_w{$pid} ||= Glib::Child->watch_add ($pid, sub {
        $_->($_[0], $_[1])
           for values %{ $pid_cb{$pid} };
  
        1
     });
  
     bless [$pid, $cb+0], "AnyEvent::Impl::Glib::child"
  }
  
  sub AnyEvent::Impl::Glib::child::DESTROY {
     my ($pid, $icb) = @{ $_[0] };
  
     delete $pid_cb{$pid}{$icb};
     unless (%{ $pid_cb{$pid} }) {
        delete $pid_cb{$pid};
        remove Glib::Source delete $pid_w{$pid};
     }
  }
  
  #sub loop {
  #   # hackish, but we do not have a mainloop, just a maincontext
  #   $mainloop->iteration (1) while 1;
  #}
  
  sub _poll {
     $mainloop->iteration (1);
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     $mainloop->iteration (1) until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Glib>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_GLIB

$fatpacked{"darwin-2level/AnyEvent/Impl/IOAsync.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_IOASYNC';
  =head1 NAME
  
  AnyEvent::Impl::IOAsync - AnyEvent adaptor for IO::Async
  
  =head1 SYNOPSIS
  
    use AnyEvent;
    use IO::Async::Loop;
  
    # optionally set another event loop
    use AnyEvent::Impl::IOAsync;
    my $loop = new IO::Async::Loop;
    AnyEvent::Impl::IOAsync::set_loop $loop;
  
  =head1 DESCRIPTION
  
  This module provides support for IO::Async as AnyEvent backend. It supports
  I/O, timers, signals and child process watchers. Idle watchers are emulated.
  I/O watchers need to dup their fh because IO::Async only supports IO handles,
  not plain file descriptors.
  
  =head1 PROBLEMS WITH IO::Async
  
  This section had a long list of problems and shortcomings that made it
  almost impossible to support L<IO::Async>. With version 0.33 of IO::Async,
  however, most of these have been fixed, so L<IO::Async> can now be used as
  easily as many other loops.
  
  There are a few remaining problems that require emulation or workarounds:
  
  =over 4
  
  =item No support for multiple watchers per event
  
  In most (all? documentation?) cases you cannot have multiple watchers
  for the same event (what's the point of having all these fancy notifier
  classes when you cannot have multiple notifiers for the same event? That's
  like only allowing one timer per second or so...).
  
  For I/O watchers, AnyEvent has to dup() every file handle, as IO::Async
  fails to support the same or different file handles pointing to the same
  fd (the good thing is that it is documented, but why not fix it instead?).
  
  =back
  
  Apart from these fatal flaws, there are a number of unpleasent properties
  that just need some mentioning:
  
  =over 4
  
  =item Confusing and misleading names
  
  Another rather negative point about this module family is its name,
  which is deeply confusing: Despite the "async" in the name, L<IO::Async>
  only does I<synchronous> I/O, there is nothing "asynchronous" about it
  whatsoever (when I first heard about it, I thought, "wow, a second async
  I/O module, what does it do compared to L<IO::AIO>", and was somehow set
  back when I learned that the only "async" aspect of it is the name).
  
  =item Inconsistent, incomplete and convoluted API
  
  Implementing AnyEvent's rather simple timers on top of IO::Async's timers
  was a nightmare (try implementing a timer with configurable interval and
  delay value...).
  
  The method naming is chaotic: C<watch_child> creates a child watcher,
  but C<watch_io> is an internal method; C<detach_signal> removes a signal
  watcher, but C<detach_child> forks a subprocess and so on).
  
  =item Unpleasant surprises on GNU/Linux
  
  When you develop your program on FreeBSD and run it on GNU/Linux, you
  might have unpleasant surprises, as IO::Async::Loop will by default use
  L<IO::Async::Loop::Epoll>, which is incompatible with C<fork>, so your
  network server will run into spurious and very hard to debug problems
  under heavy load, as IO::Async forks a lot of processes, e.g. for DNS
  resolution. It would be better if IO::Async would only load "safe"
  backends by default (or fix the epoll backend to work in the presence of
  fork, which admittedly is hard - EV does it for you, and also does not use
  unsafe backends by default).
  
  =back
  
  On the positive side, performance with IO::Async is quite good even in my
  very demanding eyes.
  
  =cut
  
  package AnyEvent::Impl::IOAsync;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Time::HiRes ();
  use Scalar::Util ();
  
  use IO::Async::Loop 0.33;
  
  our $LOOP = new IO::Async::Loop;
  
  sub set_loop($) {
     $LOOP = $_[0];
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
  
     my $id;
  
     if (my $ival = $arg{interval}) {
        my $ival_cb; $ival_cb = sub {
           $id = $LOOP->enqueue_timer (delay => $ival, code => $ival_cb);
           &$cb;
        };
        $id = $LOOP->enqueue_timer (delay => $arg{after}, code => $ival_cb);
  
        # we have to weaken afterwards, but when enqueue dies, we have a memleak.
        # still, we do anything for speed...
        Scalar::Util::weaken $ival_cb;
  
     } else {
        # IO::Async has problems with overloaded objects
        $id = $LOOP->enqueue_timer (delay => $arg{after}, code => sub {
           undef $id; # IO::Async <= 0.43 bug workaround
           &$cb;
        });
     }
  
     bless \\$id, "AnyEvent::Impl::IOAsync::timer"
  }
  
  sub AnyEvent::Impl::IOAsync::timer::DESTROY {
     # Need to be well-behaved during global destruction
     $LOOP->cancel_timer (${${$_[0]}})
        if defined ${${$_[0]}}; # IO::Async <= 0.43 bug workaround
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     # Ensure we have a real IO handle, and not just a UNIX fd integer
     my ($fh) = AnyEvent::_dupfh $arg{poll}, $arg{fh};
  
     my $event = $arg{poll} eq "r" ? "on_read_ready" : "on_write_ready";
  
     $LOOP->watch_io (
        handle => $fh,
        $event => $arg{cb},
     );
  
     bless [$fh, $event], "AnyEvent::Impl::IOAsync::io"
  }
  
  sub AnyEvent::Impl::IOAsync::io::DESTROY {
     $LOOP->unwatch_io (
        handle => $_[0][0],
        $_[0][1] => 1,
     );
  }
  
  sub signal {
     my ($class, %arg) = @_;
  
     my $signal = $arg{signal};
  
     my $id = $LOOP->attach_signal ($arg{signal}, $arg{cb});
     bless [$signal, $id], "AnyEvent::Impl::IOAsync::signal"
  }
  
  sub AnyEvent::Impl::IOAsync::signal::DESTROY {
     $LOOP->detach_signal (@{ $_[0] });
  }
  
  our %pid_cb;
  
  sub child {
     my ($class, %arg) = @_;
  
     my $pid = $arg{pid};
  
     $LOOP->watch_child ($pid, $arg{cb});
     bless [$pid], "AnyEvent::Impl::IOAsync::child"
  }
  
  sub child {
     my ($class, %arg) = @_;
  
     my $pid = $arg{pid};
     my $cb  = $arg{cb};
  
     unless (%{ $pid_cb{$pid} }) {
        $LOOP->watch_child ($pid, sub {
           $_->($_[0], $_[1])
              for values %{ $pid_cb{$pid} };
        });
     }
  
     $pid_cb{$pid}{$cb+0} = $cb;
  
     bless [$pid, $cb+0], "AnyEvent::Impl::IOAsync::child"
  }
  
  sub AnyEvent::Impl::IOAsync::child::DESTROY {
     my ($pid, $icb) = @{ $_[0] };
  
     delete $pid_cb{$pid}{$icb};
  
     unless (%{ $pid_cb{$pid} }) {
        delete $pid_cb{$pid};
        $LOOP->unwatch_child ($pid);
     }
  }
  
  #sub loop {
  #   $LOOP->loop_forever;
  #}
  
  sub _poll {
     $LOOP->loop_once;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     $LOOP->loop_once until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<IO::Async>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
   Paul Evans <leonerd@leonerd.org.uk>
   Rewrote the backend for IO::Async version 0.33.
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_IOASYNC

$fatpacked{"darwin-2level/AnyEvent/Impl/Irssi.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_IRSSI';
  =head1 NAME
  
  AnyEvent::Impl::Irssi - AnyEvent adaptor for Irssi
  
  =head1 SYNOPSIS
  
     use AnyEvent;
    
     # this module gets loaded automatically when running under irssi
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Irssi scripts work with AnyEvent.
  
  Limitations of this backend and implementation details:
  
  =over 4
  
  =item * This backend does not support blocking waits.
  
  That means you must set a callback on any condvars, or otherwise make sure
  to never call C<recv> on a condvar that hasn't been signalled yet.
  
  =item * Child exits will be handled by AnyEvent.
  
  AnyEvent will take over child handling, as Irssi only polls for children
  once/second and cannot handle unspecific child watchers.
  
  This I<should> have no negative effect, as AnyEvent will emit a pidwait
  signal just like irssi itself would.
  
  =item * Artificial timer delays.
  
  Irssi artificially enforces timers to have at least a 10ms delay (by
  croaking, even).
  
  This means that some applications will be limited to a rate of 100Hz (for
  example, L<Coro::AnyEvent> thread scheduling).
  
  =item * Irssi leaks memory like hell.
  
  Yeah.
  
  =back
  
  Apart from that, documentation is notoriously wrong (e.g. file handles
  are not supported by C<input_add>, contrary to documentation), hooking
  into irssi has to be done in... weird... ways, but otherwise, Irssi is
  surprisingly full-featured (for basically being a hack).
  
  =cut
  
  package AnyEvent::Impl::Irssi;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Carp ();
  use Irssi ();
  
  our @ISA;
  
  # irssi works only from certain namespaces, so we
  # create one and use it.
  sub init {
     my $pkg = caller;
  
     push @ISA, $pkg;
  
     local $/;
     eval "package $pkg; " . <DATA>;
     print "AnyEvent::Impl::Irssi fatal compilation error: $@" if $@;
  
     close DATA;
  }
  
  Irssi::command "/script exec -permanent AnyEvent::Impl::Irssi::init 'AnyEvent adaptor'";
  
  1;
  
  __DATA__
  
  BEGIN { AnyEvent::common_sense }
  use base "AnyEvent::Base";
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = Irssi::input_add
        $fd,
        $arg{poll} eq "r" ? Irssi::INPUT_READ : Irssi::INPUT_WRITE,
        $cb,
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::io"
  }
  
  sub AnyEvent::Impl::Irssi::io::DESTROY {
     Irssi::input_remove $${$_[0]};
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb    = $arg{cb};
     my $ival  = $arg{interval} * 1000;
     my $after = $arg{after} * 1000;
  
     my $source; $source = Irssi::timeout_add_once $after > 10 ? $after : 10,
        ($ival ? sub {
                   $source = Irssi::timeout_add $ival > 10 ? $ival : 10, $cb, undef;
                   &$cb;
                   0
                 }
               : $cb),
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::timer"
  }
  
  sub AnyEvent::Impl::Irssi::timer::DESTROY {
     Irssi::timeout_remove $${$_[0]};
  }
  
  my $_pidwait = sub {
     my ($rpid, $rstatus) = @_;
  
     AnyEvent::Base->_emit_childstatus ($rpid, $rstatus);
  };
  
  Irssi::signal_add pidwait => $_pidwait;
  
  sub _emit_childstatus {
     my ($self, $rpid, $rstatus) = @_;
     $self->SUPER::_emit_childstatus ($rpid, $rstatus);
  
     Irssi::signal_remove pidwait => $_pidwait;
     Irssi::signal_emit   pidwait => $rpid+0, $rstatus+0;
     Irssi::signal_add    pidwait => $_pidwait;
  }
  
  #sub loop {
  #   Carp::croak "Irssi does not support blocking waits";
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Irssi>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_IRSSI

$fatpacked{"darwin-2level/AnyEvent/Impl/POE.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_POE';
  =head1 NAME
  
  AnyEvent::Impl::POE - AnyEvent adaptor for POE
  
  =encoding utf-8
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use POE;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make POE work with AnyEvent except by loading POE before
  creating the first AnyEvent watcher. There are some cases where POE will
  issue spurious (and non-suppressible) warnings. These can be avoided by
  loading AnyEvent::Impl::POE before loading any other modules using POE and
  AnyEvent, i.e. in your main program.
  
  AnyEvent::Impl::POE will output some spurious message how to work around
  POE's spurious messages when it detects these cases.
  
  Unfortunately, POE isn't generic enough to implement a fully working
  AnyEvent backend: POE is too badly designed, too badly documented and too
  badly implemented.
  
  Here are the details, and what it means to you if you want to be
  interoperable with POE:
  
  =over 4
  
  =item Weird messages
  
  If you only use C<run_one_timeslice> (as AnyEvent has to for its
  condition variables), POE will print an ugly, unsuppressible, message at
  program exit:
  
     Sessions were started, but POE::Kernel's run() method was never...
  
  The message is correct, the question is why POE prints it in the first
  place in a correct program (this is not a singular case though).
  
  AnyEvent consequently patches the POE kernel so it thinks it already
  ran. Other workarounds, even the one cited in the POE documentation
  itself, have serious side effects, such as throwing away events.
  
  The author of POE verified that this is indeed true, and has no plans to
  change this.
  
  POE has other weird messages, and sometimes weird behaviour, for example,
  it doesn't support overloaded code references as callbacks for no apparent
  reason.
  
  =item One POE session per Event
  
  AnyEvent has to create one POE::Session per event watcher, which is
  immensely slow and makes watchers very large. The reason for this is
  lacking lifetime management (mostly undocumented, too). Without one
  session/watcher it is not possible to easily keep the kernel from running
  endlessly.
  
  This is not just a problem with the way AnyEvent has to interact with
  POE, but is a principal issue with POEs lifetime management (namely
  that stopping the kernel stops sessions, but AnyEvent has no control
  over who and when the kernel starts or stops w.r.t. AnyEvent watcher
  creation/destruction).
  
  From benchmark data it is not clear that session creation is that costly,
  though - the real inefficiencies with POE seem to come from other sources,
  such as event handling.
  
  =item One watcher per fd/event combo
  
  POE, of course, suffers from the same bug as Tk and some other badly
  designed event models in that it doesn't support multiple watchers per
  fd/poll combo. The workaround is the same as with Tk: AnyEvent::Impl::POE
  creates a separate file descriptor to hand to POE, which isn't fast and
  certainly not nice to your resources.
  
  Of course, without the workaround, POE also prints ugly messages again
  that say the program *might* be buggy.
  
  While this is not good to performance, at least regarding speed, with a
  modern Linux kernel, the overhead is actually quite small.
  
  =item Timing Deficiencies
  
  POE manages to not have a function that returns the current time. This is
  extremely problematic, as POE can use different time functions, which can
  differ by more than a second - and user code is left guessing which one is
  used.
  
  In addition, most timer functions in POE want an absolute timestamp, which
  is hard to create if all you have is a relative time and no function to
  return the "current time".
  
  And of course POE doesn't handle time jumps at all (not even when using
  an event loop that happens to do that, such as L<EV>, as it does its own
  unoptimised timer management).
  
  AnyEvent works around the unavailability of the current time using
  relative timers exclusively, in the hope that POE gets it right at least
  internally.
  
  =item Event Non-Ordering
  
  POE cannot guarantee the order of callback invocation for timers, and
  usually gets it wrong. That is, if you have two timers, one timing out
  after another (all else being equal), the callbacks might be called in
  reverse order.
  
  How one manages to even implement stuff that way escapes me.
  
  =item Child Watchers
  
  POE offers child watchers - which is a laudable thing, as few event loops
  do. Unfortunately, they cannot even implement AnyEvent's simple child
  watchers: they are not generic enough (the POE implementation isn't even
  generic enough to let properly designed back-end use their native child
  watcher instead - it insist on doing it itself the broken way).
  
  Unfortunately, POE's child handling is inherently racy: if the child
  exits before the handler is created (which is impossible to avoid in
  general, imagine the forked program to exit immediately because of a bug,
  or imagine the POE kernel being busy for a second), one has to wait for
  another event to occur, which can take an indefinite amount of time.
  
  Of course, whenever POE reaps an unrelated child it will also output a
  message for it that you cannot suppress (which shouldn't be too surprising
  at this point). Very professional.
  
  As a workaround, AnyEvent::Impl::POE will take advantage of undocumented
  behaviour in POE::Kernel to catch the status of all child processes, but
  it cannot guarantee delivery.
  
  How one manages to have such a glaring bug in an event loop after ten
  years of development escapes me.
  
  (There are more annoying bugs, for example, POE runs C<waitpid>
  unconditionally on finalizing, so your program will hang until all child
  processes have exited.)
  
  =item Documentation Quality
  
  At the time of this writing, POE was in its tenth year. Still, its
  documentation is extremely lacking, making it impossible to implement
  stuff as trivial as AnyEvent watchers without having to resort to
  undocumented behaviour or features.
  
  For example, the POE::Kernel manpage has nine occurrences of the word TODO
  with an explanation of whats missing. In general, the POE man pages are
  littered with comments like "section not yet written".
  
  Some other gems:
  
     This allows many object methods to also be package methods.
  
  This is nice, but since it doesn't document I<which> methods these are,
  this is utterly useless information.
  
     Terminal signals will kill sessions if they are not handled by a
     "sig_handled"() call. The OS signals that usually kill or dump a
     process are considered terminal in POE, but they never trigger a
     coredump. These are: HUP, INT, QUIT and TERM.
  
  Although AnyEvent calls C<sig_handled>, removing it has no apparent
  effects on POE handling SIGINT.
  
     refcount_increment SESSION_ID, COUNTER_NAME
  
  Nowhere is explained which COUNTER_NAMEs are valid and which aren't - not
  all scalars (or even strings) are valid counter names. Take your guess,
  failure is of course completely silent. I found this out the hard way, as
  the first name I came up with was silently ignored.
  
     get_next_event_time() returns the time the next event is due, in a form
     compatible with the UNIX time() function.
  
  And surely, one would hope that POE supports sub-second accuracy as
  documented elsewhere, unlike the explanation above implies. Yet:
  
     POE::Kernel timers support subsecond accuracy, but don’t expect too
     much here. Perl is not the right language for realtime programming.
  
  ... of course, Perl is not the right language to expect sub-second
  accuracy - the manpage author must hate Perl to spread so much FUD in
  so little space. The Deliantra game server logs with 100µs-accuracy
  because Perl is fast enough to require this, and is still able to deliver
  map updates with little jitter at exactly the right time. It does not,
  however, use POE.
  
     Furthermore, since the Kernel keeps track of everything sessions do, it
     knows when a session has run out of tasks to perform.
  
  This is impossible - how does the kernel know that a session is no longer
  watching for some (external) event (e.g. by some other session)? It
  cannot, and therefore this is wrong - but you would be hard pressed to
  find out how to work around this and tell the kernel manually about such
  events.
  
  It gets worse, though - the notion of "task" or "resource", although used
  throughout the documentation, is not defined in a usable way. For example,
  waiting for a timeout is considered to be a task, waiting for a signal is
  not (a session that only waits for a signal is considered finished and
  gets removed). The user is left guessing when waiting for an event counts
  as task and when not (in fact, the issue with signals is mentioned in
  passing in a section about child watchers and directly contradicts earlier
  parts in that document).
  
  One could go on endlessly - ten years, no usable documentation.
  
  It is likely that differences between documentation, or the one or two
  things I had to guess, cause unanticipated problems with this adaptor.
  
  =item Fragile and inconsistent API
  
  The POE API is extremely inconsistent - sometimes you have to pass a
  session argument, sometimes it gets ignored, sometimes a session-specific
  method must not use a session argument.
  
  Error handling is sub-standard as well: even for programming mistakes,
  POE does not C<croak> but, in most cases, just sets C<$!> or simply does
  nothing at all, leading to fragile programs.
  
  Sometimes registering a handler uses the "eventname, parameter" ordering
  (timeouts), sometimes it is "parameter, eventname" (signals). There is
  little consistency overall.
  
  =item Lack of knowledge
  
     The IO::Poll event loop provides an alternative that theoretically
     scales better than select().
  
  The IO::Poll "event loop" (who in his right mind would call that an event
  loop) of course scales about identically (sometimes it is a bit faster,
  sometimes a bit slower) to select in theory, and also in practise, of
  course, as both are O(n) in the number of file descriptors, which is
  rather bad.
  
  This is just one place where it gets obvious how little the author of the
  POE manpage understands.
  
  =item No idle events
  
  The POE-recommended workaround to this is apparently to use
  C<fork>. Consequently, idle watchers will have to be emulated by AnyEvent.
  
  =back
  
  On the good side, AnyEvent allows you to write your modules in a 100%
  POE-compatible way (bug-for-bug compatible even), without forcing your
  module to use POE - it is still open to better event models, of which
  there are plenty.
  
  Oh, and one other positive thing:
  
     RUNNING_IN_HELL
  
  POE knows about the nature of the beast!
  
  =cut
  
  package AnyEvent::Impl::POE;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use POE;
  
  # suppress an idiotic warning inside POE
  ${ POE::Kernel->new->[POE::Kernel::KR_RUN] } |= POE::Kernel::KR_RUN_CALLED;
  
  sub io {
     my ($class, %arg) = @_;
  
     # POE itself might do the right thing, but some POE backends don't,
     # so do the safe thing, it's not as if this will slow us down
     # any further *g*
     my ($fh, $pee) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, "select_read", "select_write";
  
     my $cb = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
  
     my $session = POE::Session->create (
        inline_states => {
           _start => sub { $_[KERNEL]->$pee ($fh => "ready") },
           ready  => sub { $cb->() },
           stop   => sub { $_[KERNEL]->$pee ($fh) },
        },
     );
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     my $after = delete $arg{after};
     my $ival  = delete $arg{interval};
     my $cb    = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
  
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              $_[KERNEL]->delay_set (timeout => $after);
           },
           timeout => $ival ? sub { $_[KERNEL]->delay_set (timeout => $ival); $cb->() } : $cb,
           stop => sub {
              $_[KERNEL]->alarm_remove_all;
           },
        },
     );
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub signal {
     my ($class, %arg) = @_;
     my $signal = AnyEvent::Base::sig2name delete $arg{signal};
     my $cb     = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              # I suck - POE
           },
           start => sub {
              $_[KERNEL]->sig ($signal => "catch");
              $_[KERNEL]->refcount_increment ($_[SESSION]->ID => "poe");
           },
           catch => sub {
              $cb->();
              $_[KERNEL]->sig_handled;
           },
           stop => sub {
              $_[KERNEL]->refcount_decrement ($_[SESSION]->ID => "poe");
              $_[KERNEL]->sig ($signal);
           },
        },
     );
     POE::Kernel->call ($session, "start");
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub child {
     my ($class, %arg) = @_;
     my $pid = delete $arg{pid};
     my $cb  = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              # I suck - POE
           },
           start => sub {
              $_[KERNEL]->sig (CHLD => "child");
              $_[KERNEL]->refcount_increment ($_[SESSION]->ID => "poe");
           },
           child => sub {
              my ($rpid, $status) = @_[ARG1, ARG2];
  
              $cb->($rpid, $status) if $rpid == $pid || $pid == 0;
           },
           stop => sub {
              $_[KERNEL]->refcount_decrement ($_[SESSION]->ID => "poe");
              $_[KERNEL]->sig ("CHLD");
           },
        },
     );
     # newer POE versions lose signals unless we call ->sig early.
     POE::Kernel->call ($session, "start");
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub DESTROY {
     POE::Kernel->call (${${$_[0]}}, "stop");
  }
  
  #sub loop {
  #   POE::Kernel->run;
  #}
  
  sub _poll {
     POE::Kernel->loop_do_timeslice;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     POE::Kernel->loop_do_timeslice until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<POE>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_IMPL_POE

$fatpacked{"darwin-2level/AnyEvent/Impl/Perl.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_PERL';
  =head1 NAME
  
  AnyEvent::Impl::Perl - AnyEvent adaptor for AnyEvent's pure perl AnyEvent::Loop
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use AnyEvent::Loop;
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent in case no other
  event loop could be found or loaded.
  
  If you want to use this module instead of autoloading another event loop
  you can simply load L<AnyEvent::Loop> before creating the first watcher.
  
  Naturally, it supports all features of AnyEvent.
  
  See L<AnyEvent::Loop> for more details on performance characteristics.
  
  =cut
  
  package AnyEvent::Impl::Perl;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Loop;
  
  our $VERSION = $AnyEvent::VERSION;
  
  # time() is provided via AnyEvent::Base
  
  *AE::now        = \&AnyEvent::Loop::now;
  *AE::now_update = \&AnyEvent::Loop::now_update;
  *AE::io         = \&AnyEvent::Loop::io;
  *AE::timer      = \&AnyEvent::Loop::timer;
  *AE::idle       = \&AnyEvent::Loop::idle;
  *_poll          = \&AnyEvent::Loop::one_event;
  *loop           = \&AnyEvent::Loop::run; # compatibility with AnyEvent < 6.0
  
  sub now        { $AnyEvent::Loop::NOW }
  sub now_update { AE::now_update       }
  
  sub AnyEvent::CondVar::Base::_wait {
     AnyEvent::Loop::one_event until exists $_[0]{_ae_sent};
  }
  
  sub io {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::io $arg{fh}, $arg{poll} eq "w", $arg{cb}
  }
  
  sub timer {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::timer $arg{after}, $arg{interval}, $arg{cb}
  }
  
  sub idle {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::idle $arg{cb}
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
  
DARWIN-2LEVEL_ANYEVENT_IMPL_PERL

$fatpacked{"darwin-2level/AnyEvent/Impl/Qt.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_QT';
  =head1 NAME
  
  AnyEvent::Impl::Qt - AnyEvent adaptor for Qt
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Qt;
    
     my $app = Qt::Application \@ARGV; # REQUIRED!
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have
  to do anything to make Qt work with AnyEvent except by loading Qt
  before creating the first AnyEvent watcher I<and instantiating the
  Qt::Application object>. Failure to do so will result in segfaults,
  which is why this model doesn't work as a default model and will not be
  autoprobed (but it will be autodetected when the main program uses Qt).
  
  Qt suffers from the same limitations as Event::Lib and Tk, the workaround
  is also the same (duplicating file descriptors).
  
  Qt doesn't support idle events, so they are being emulated.
  
  Avoid Qt if you can.
  
  =cut
  
  package AnyEvent::Impl::Qt::Io;
  
  use Qt;
  use Qt::isa qw(Qt::SocketNotifier); # Socket? what where they smoking
  use Qt::slots cb => [];
  
  sub NEW {
     my ($class, $fh, $mode, $cb) = @_;
     shift->SUPER::NEW (fileno $fh, $mode);
     this->{fh} = $fh;
     this->{cb} = $cb;
     this->connect (this, SIGNAL "activated(int)", SLOT "cb()");
  }
  
  sub cb {
     this->setEnabled (0); # required according to the docs. heavy smoking required.
     this->{cb}->();
     this->setEnabled (1);
  }
  
  package AnyEvent::Impl::Qt::Timer;
  
  use Qt;
  use Qt::isa qw(Qt::Timer);
  use Qt::slots cb => [];
  
  # having to go through these contortions just to get a timer event is
  # considered an advantage over other gui toolkits how?
  
  sub NEW {
     my ($class, $after, $interval, $cb) = @_;
     shift->SUPER::NEW ();
     this->{interval} = $interval;
     this->{cb}       = $cb;
     this->connect (this, SIGNAL "timeout()", SLOT "cb()");
     this->start ($after, 1);
  }
  
  sub cb {
     this->start (this->{interval}, 1) if defined this->{interval};
     this->{cb}->();
  }
  
  package AnyEvent::Impl::Qt;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Qt;
  
  use AnyEvent::Impl::Qt::Timer;
  use AnyEvent::Impl::Qt::Io;
  
  our $app = Qt::Application \@ARGV; # REQUIRED!
  
  sub io {
     my ($class, %arg) = @_;
  
     # work around these bugs in Qt:
     # - adding a callback might destroy other callbacks
     # - only one callback per fd/poll combination
     my ($fh, $qt) = AnyEvent::_dupfh $arg{poll}, $arg{fh},
                        Qt::SocketNotifier::Read (), Qt::SocketNotifier::Write ();
  
     AnyEvent::Impl::Qt::Io $fh, $qt, $arg{cb}
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     # old Qt treats 0 timeout as "idle"
     AnyEvent::Impl::Qt::Timer
        $arg{after} * 1000 || 1,
        $arg{interval} ? $arg{interval} * 1000 || 1 : undef,
        $arg{cb}
  }
  
  # newer Qt have no idle mode for timers anymore...
  #sub idle {
  #   my ($class, %arg) = @_;
  #   
  #   AnyEvent::Impl::Qt::Timer 0, 0, $arg{cb}
  #}
  
  #sub loop {
  #   Qt::app->exec;
  #}
  
  sub _poll {
     Qt::app->processOneEvent;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Qt::app->processOneEvent until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Qt>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
  
DARWIN-2LEVEL_ANYEVENT_IMPL_QT

$fatpacked{"darwin-2level/AnyEvent/Impl/Tk.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_IMPL_TK';
  =head1 NAME
  
  AnyEvent::Impl::Tk - AnyEvent adaptor for Tk
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Tk;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Tk work with AnyEvent except by loading Tk before
  creating the first AnyEvent watcher.
  
  Tk is buggy. Tk is extremely buggy. Tk is so unbelievably buggy that
  for each bug reported and fixed, you get one new bug followed by
  reintroduction of the old bug in a later revision. It is also basically
  unmaintained: the maintainers are not even interested in improving
  the situation - reporting bugs is considered rude, and fixing bugs is
  considered changing holy code, so it's apparently better to leave it
  broken.
  
  I regularly run out of words to describe how bad it really is.
  
  To work around some of the many, many bugs in Tk that don't get fixed,
  this adaptor dup()'s all filehandles that get passed into its I/O
  watchers, so if you register a read and a write watcher for one fh,
  AnyEvent will create two additional file descriptors (and handles).
  
  This creates a high overhead and is slow, but seems to work around most
  known bugs in L<Tk::fileevent> on 32 bit architectures (Tk seems to be
  terminally broken on 64 bit, do not expect more than 10 or so watchers to
  work on 64 bit machines).
  
  Do not expect these workarounds to avoid segfaults and crashes inside Tk.
  
  Note also that Tk event ids wrap around after 2**32 or so events, which on
  my machine can happen within less than 12 hours, after which Tk will stomp
  on random other events and kill them. So don't run Tk programs for more
  than an hour or so.
  
  To be able to access the Tk event loop, this module creates a main
  window and withdraws it immediately. This might cause flickering on some
  platforms, but Tk perversely requires a window to be able to wait for file
  handle readyness notifications. This window is always created (in this
  version of AnyEvent) and can be accessed as C<$AnyEvent::Impl::Tk::mw>.
  
  =cut
  
  package AnyEvent::Impl::Tk;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Tk ();
  
  our $mw = new MainWindow -title => "AnyEvent Dummy Window";
  $mw->withdraw;
  
  END { undef $mw }
  
  sub io {
     my (undef, %arg) = @_;
  
     # work around these bugs in Tk:
     # - removing a callback will destroy other callbacks
     # - removing a callback might crash
     # - adding a callback might destroy other callbacks
     # - only one callback per fh
     # - only one callback per fh/poll combination
     my ($fh, $tk) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, "readable", "writable";
  
     $mw->fileevent ($fh, $tk => $arg{cb});
  
     bless [$fh, $tk], "AnyEvent::Impl::Tk::io"
  }
  
  sub AnyEvent::Impl::Tk::io::DESTROY {
     my ($fh, $tk) = @{$_[0]};
  
     # work around another bug: watchers don't get removed when
     # the fh is closed, contrary to documentation. also, trying
     # to unregister a read callback will make it impossible
     # to remove the write callback.
     # if your program segfaults here then you need to destroy
     # your watchers before program exit. sorry, no way around
     # that.
     $mw->fileevent ($fh, $tk => "");
  }
  
  sub timer {
     my (undef, %arg) = @_;
     
     my $after = $arg{after} < 0 ? 0 : $arg{after} * 1000;
     my $cb = $arg{cb};
     my $id;
  
     if ($arg{interval}) {
        my $ival = $arg{interval} * 1000;
        my $rcb = sub {
           $id = Tk::after $mw, $ival, [$_[0], $_[0]];
           &$cb;
        };
        $id = Tk::after $mw, $after, [$rcb, $rcb];
     } else {
        # tk blesses $cb, thus the extra indirection
        $id = Tk::after $mw, $after, sub { &$cb };
     }
  
     bless \\$id, "AnyEvent::Impl::Tk::after"
  }
  
  sub idle {
     my (undef, %arg) = @_;
  
     my $cb = $arg{cb};
     my $id;
     my $rcb = sub {
        # in their endless stupidity, they decided to give repeating idle watchers
        # strictly higher priority than timers :/
        $id = Tk::after $mw, 0 => [sub {
           $id = Tk::after $mw, idle => [$_[0], $_[0]];
        }, $_[0]];
        &$cb;
     };
  
     $id = Tk::after $mw, idle => [$rcb, $rcb];
     bless \\$id, "AnyEvent::Impl::Tk::after"
  }
  
  sub AnyEvent::Impl::Tk::after::DESTROY {
     Tk::after $mw, cancel => $${$_[0]};
  }
  
  #sub loop {
  #   Tk::MainLoop;
  #}
  
  sub _poll {
     Tk::DoOneEvent (0);
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Tk::DoOneEvent (0) until exists $_[0]{_ae_sent};
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Tk>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  
DARWIN-2LEVEL_ANYEVENT_IMPL_TK

$fatpacked{"darwin-2level/AnyEvent/Log.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_LOG';
  =head1 NAME
  
  AnyEvent::Log - simple logging "framework"
  
  =head1 SYNOPSIS
  
  Simple uses:
  
     use AnyEvent;
  
     AE::log trace => "going to call function abc";
     AE::log debug => "the function returned 3";
     AE::log info  => "file soandso successfully deleted";
     AE::log note  => "wanted to create config, but config was alraedy created";
     AE::log warn  => "couldn't delete the file";
     AE::log error => "failed to retrieve data";
     AE::log crit  => "the battery temperature is too hot";
     AE::log alert => "the battery died";
     AE::log fatal => "no config found, cannot continue"; # never returns
  
  Log level overview:
  
     LVL NAME      SYSLOG   PERL  NOTE
      1  fatal     emerg    exit  system unusable, aborts program!
      2  alert                    failure in primary system
      3  critical  crit           failure in backup system
      4  error     err      die   non-urgent program errors, a bug
      5  warn      warning        possible problem, not necessarily error
      6  note      notice         unusual conditions
      7  info                     normal messages, no action required
      8  debug                    debugging messages for development
      9  trace                    copious tracing output
  
  "Complex" uses (for speed sensitive code, e.g. trace/debug messages):
  
     use AnyEvent::Log;
  
     my $tracer = AnyEvent::Log::logger trace => \$my $trace;
  
     $tracer->("i am here") if $trace;
     $tracer->(sub { "lots of data: " . Dumper $self }) if $trace;
  
  Configuration (also look at the EXAMPLES section):
  
     # set logging for the current package to errors and higher only
     AnyEvent::Log::ctx->level ("error");
  
     # set logging level to suppress anything below "notice"
     $AnyEvent::Log::FILTER->level ("notice");
  
     # send all critical and higher priority messages to syslog,
     # regardless of (most) other settings
     $AnyEvent::Log::COLLECT->attach (new AnyEvent::Log::Ctx
        level         => "critical",
        log_to_syslog => "user",
     );
  
  =head1 DESCRIPTION
  
  This module implements a relatively simple "logging framework". It doesn't
  attempt to be "the" logging solution or even "a" logging solution for
  AnyEvent - AnyEvent simply creates logging messages internally, and this
  module more or less exposes the mechanism, with some extra spiff to allow
  using it from other modules as well.
  
  Remember that the default verbosity level is C<0> (C<off>), so nothing
  will be logged, unless you set C<PERL_ANYEVENT_VERBOSE> to a higher number
  before starting your program, or change the logging level at runtime with
  something like:
  
     use AnyEvent::Log;
     $AnyEvent::Log::FILTER->level ("info");
  
  The design goal behind this module was to keep it simple (and small),
  but make it powerful enough to be potentially useful for any module, and
  extensive enough for the most common tasks, such as logging to multiple
  targets, or being able to log into a database.
  
  The module is also usable before AnyEvent itself is initialised, in which
  case some of the functionality might be reduced.
  
  The amount of documentation might indicate otherwise, but the runtime part
  of the module is still just below 300 lines of code.
  
  =head1 LOGGING LEVELS
  
  Logging levels in this module range from C<1> (highest priority) to C<9>
  (lowest priority). Note that the lowest numerical value is the highest
  priority, so when this document says "higher priority" it means "lower
  numerical value".
  
  Instead of specifying levels by name you can also specify them by aliases:
  
     LVL NAME      SYSLOG   PERL  NOTE
      1  fatal     emerg    exit  system unusable, aborts program!
      2  alert                    failure in primary system
      3  critical  crit           failure in backup system
      4  error     err      die   non-urgent program errors, a bug
      5  warn      warning        possible problem, not necessarily error
      6  note      notice         unusual conditions
      7  info                     normal messages, no action required
      8  debug                    debugging messages for development
      9  trace                    copious tracing output
  
  As you can see, some logging levels have multiple aliases - the first one
  is the "official" name, the second one the "syslog" name (if it differs)
  and the third one the "perl" name, suggesting (only!) that you log C<die>
  messages at C<error> priority. The NOTE column tries to provide some
  rationale on how to chose a logging level.
  
  As a rough guideline, levels 1..3 are primarily meant for users of
  the program (admins, staff), and are the only logged to STDERR by
  default. Levels 4..6 are meant for users and developers alike, while
  levels 7..9 are usually meant for developers.
  
  You can normally only log a single message at highest priority level
  (C<1>, C<fatal>), because logging a fatal message will also quit the
  program - so use it sparingly :)
  
  Some methods also offer some extra levels, such as C<0>, C<off>, C<none>
  or C<all> - these are only valid in the methods they are documented for.
  
  =head1 LOGGING FUNCTIONS
  
  These functions allow you to log messages. They always use the caller's
  package as a "logging context". Also, the main logging function C<log> is
  callable as C<AnyEvent::log> or C<AE::log> when the C<AnyEvent> module is
  loaded.
  
  =over 4
  
  =cut
  
  package AnyEvent::Log;
  
  use Carp ();
  use POSIX ();
  
  # layout of a context
  #       0       1         2        3        4,    5
  # [$title, $level, %$slaves, &$logcb, &$fmtcb, $cap]
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  #use AnyEvent::Util (); need to load this in a delayed fashion, as it uses AE::log
  
  our $VERSION = $AnyEvent::VERSION;
  
  our ($COLLECT, $FILTER, $LOG);
  
  our ($now_int, $now_str1, $now_str2);
  
  # Format Time, not public - yet?
  sub ft($) {
     my $i = int $_[0];
     my $f = sprintf "%06d", 1e6 * ($_[0] - $i);
  
     ($now_int, $now_str1, $now_str2) = ($i, split /\x01/, POSIX::strftime "%Y-%m-%d %H:%M:%S.\x01 %z", localtime $i)
        if $now_int != $i;
  
     "$now_str1$f$now_str2"
  }
  
  our %CTX; # all package contexts
  
  # creates a default package context object for the given package
  sub _pkg_ctx($) {
     my $ctx = bless [$_[0], (1 << 10) - 1 - 1, {}], "AnyEvent::Log::Ctx";
  
     # link "parent" package
     my $parent = $_[0] =~ /^(.+)::/
        ? $CTX{$1} ||= &_pkg_ctx ("$1")
        : $COLLECT;
  
     $ctx->[2]{$parent+0} = $parent;
  
     $ctx
  }
  
  =item AnyEvent::Log::log $level, $msg[, @args]
  
  Requests logging of the given C<$msg> with the given log level, and
  returns true if the message was logged I<somewhere>.
  
  For loglevel C<fatal>, the program will abort.
  
  If only a C<$msg> is given, it is logged as-is. With extra C<@args>, the
  C<$msg> is interpreted as an sprintf format string.
  
  The C<$msg> should not end with C<\n>, but may if that is convenient for
  you. Also, multiline messages are handled properly.
  
  Last not least, C<$msg> might be a code reference, in which case it is
  supposed to return the message. It will be called only then the message
  actually gets logged, which is useful if it is costly to create the
  message in the first place.
  
  This function takes care of saving and restoring C<$!> and C<$@>, so you
  don't have to.
  
  Whether the given message will be logged depends on the maximum log level
  and the caller's package. The return value can be used to ensure that
  messages or not "lost" - for example, when L<AnyEvent::Debug> detects a
  runtime error it tries to log it at C<die> level, but if that message is
  lost it simply uses warn.
  
  Note that you can (and should) call this function as C<AnyEvent::log> or
  C<AE::log>, without C<use>-ing this module if possible (i.e. you don't
  need any additional functionality), as those functions will load the
  logging module on demand only. They are also much shorter to write.
  
  Also, if you optionally generate a lot of debug messages (such as when
  tracing some code), you should look into using a logger callback and a
  boolean enabler (see C<logger>, below).
  
  Example: log something at error level.
  
     AE::log error => "something";
  
  Example: use printf-formatting.
  
     AE::log info => "%5d %-10.10s %s", $index, $category, $msg;
  
  Example: only generate a costly dump when the message is actually being logged.
  
     AE::log debug => sub { require Data::Dump; Data::Dump::dump \%cache };
  
  =cut
  
  # also allow syslog equivalent names
  our %STR2LEVEL = (
     fatal    => 1, emerg    => 1, exit => 1,
     alert    => 2,
     critical => 3, crit     => 3,
     error    => 4, err      => 4, die  => 4,
     warn     => 5, warning  => 5,
     note     => 6, notice   => 6,
     info     => 7,
     debug    => 8,
     trace    => 9,
  );
  
  our $TIME_EXACT;
  
  sub exact_time($) {
     $TIME_EXACT = shift;
     *_ts = $AnyEvent::MODEL
        ? $TIME_EXACT ? \&AE::now : \&AE::time
        : sub () { $TIME_EXACT ? do { require Time::HiRes; Time::HiRes::time () } : time };
  }
  
  BEGIN {
     exact_time 0;
  }
  
  AnyEvent::post_detect {
     exact_time $TIME_EXACT;
  };
  
  our @LEVEL2STR = qw(0 fatal alert crit error warn note info debug trace);
  
  # time, ctx, level, msg
  sub _format($$$$) {
     my $ts = ft $_[0];
     my $ct = " ";
  
     my @res;
  
     for (split /\n/, sprintf "%-5s %s: %s", $LEVEL2STR[$_[2]], $_[1][0], $_[3]) {
        push @res, "$ts$ct$_\n";
        $ct = " + ";
     }
  
     join "", @res
  }
  
  sub fatal_exit() {
     exit 1;
  }
  
  sub _log {
     my ($ctx, $level, $format, @args) = @_;
  
     $level = $level > 0 && $level <= 9
              ? $level+0
              : $STR2LEVEL{$level} || Carp::croak "$level: not a valid logging level, caught";
  
     my $mask = 1 << $level;
  
     my ($success, %seen, @ctx, $now, @fmt);
  
     do
        {
           # if !ref, then it's a level number
           if (!ref $ctx) {
              $level = $ctx;
           } elsif ($ctx->[1] & $mask and !$seen{$ctx+0}++) {
              # logging/recursing into this context
  
              # level cap
              if ($ctx->[5] > $level) {
                 push @ctx, $level; # restore level when going up in tree
                 $level = $ctx->[5];
              }
  
              # log if log cb
              if ($ctx->[3]) {
                 # logging target found
  
                 local ($!, $@);
  
                 # now get raw message, unless we have it already
                 unless ($now) {
                    $format = $format->() if ref $format;
                    $format = sprintf $format, @args if @args;
                    $format =~ s/\n$//;
                    $now = _ts;
                 };
  
                 # format msg
                 my $str = $ctx->[4]
                    ? $ctx->[4]($now, $_[0], $level, $format)
                    : ($fmt[$level] ||= _format $now, $_[0], $level, $format);
  
                 $success = 1;
  
                 $ctx->[3]($str)
                    or push @ctx, values %{ $ctx->[2] }; # not consumed - propagate
              } else {
                 push @ctx, values %{ $ctx->[2] }; # not masked - propagate
              }
           }
        }
     while $ctx = pop @ctx;
  
     fatal_exit if $level <= 1;
  
     $success
  }
  
  sub log($$;@) {
     _log
        $CTX{ (caller)[0] } ||= _pkg_ctx +(caller)[0],
        @_;
  }
  
  =item $logger = AnyEvent::Log::logger $level[, \$enabled]
  
  Creates a code reference that, when called, acts as if the
  C<AnyEvent::Log::log> function was called at this point with the given
  level. C<$logger> is passed a C<$msg> and optional C<@args>, just as with
  the C<AnyEvent::Log::log> function:
  
     my $debug_log = AnyEvent::Log::logger "debug";
  
     $debug_log->("debug here");
     $debug_log->("%06d emails processed", 12345);
     $debug_log->(sub { $obj->as_string });
  
  The idea behind this function is to decide whether to log before actually
  logging - when the C<logger> function is called once, but the returned
  logger callback often, then this can be a tremendous speed win.
  
  Despite this speed advantage, changes in logging configuration will
  still be reflected by the logger callback, even if configuration changes
  I<after> it was created.
  
  To further speed up logging, you can bind a scalar variable to the logger,
  which contains true if the logger should be called or not - if it is
  false, calling the logger can be safely skipped. This variable will be
  updated as long as C<$logger> is alive.
  
  Full example:
  
     # near the init section
     use AnyEvent::Log;
  
     my $debug_log = AnyEvent:Log::logger debug => \my $debug;
  
     # and later in your program
     $debug_log->("yo, stuff here") if $debug;
  
     $debug and $debug_log->("123");
  
  =cut
  
  our %LOGGER;
  
  # re-assess logging status for all loggers
  sub _reassess {
     local $SIG{__DIE__};
     my $die = sub { die };
  
     for (@_ ? $LOGGER{$_[0]} : values %LOGGER) {
        my ($ctx, $level, $renabled) = @$_;
  
        # to detect whether a message would be logged, we actually
        # try to log one and die. this isn't fast, but we can be
        # sure that the logging decision is correct :)
  
        $$renabled = !eval {
           _log $ctx, $level, $die;
  
           1
        };
     }
  }
  
  sub _logger {
     my ($ctx, $level, $renabled) = @_;
  
     $$renabled = 1;
  
     my $logger = [$ctx, $level, $renabled];
  
     $LOGGER{$logger+0} = $logger;
  
     _reassess $logger+0;
  
     require AnyEvent::Util unless $AnyEvent::Util::VERSION;
     my $guard = AnyEvent::Util::guard (sub {
        # "clean up"
        delete $LOGGER{$logger+0};
     });
  
     sub {
        $guard if 0; # keep guard alive, but don't cause runtime overhead
  
        _log $ctx, $level, @_
           if $$renabled;
     }
  }
  
  sub logger($;$) {
     _logger
        $CTX{ (caller)[0] } ||= _pkg_ctx +(caller)[0],
        @_
  }
  
  =item AnyEvent::Log::exact_time $on
  
  By default, C<AnyEvent::Log> will use C<AE::now>, i.e. the cached
  eventloop time, for the log timestamps. After calling this function with a
  true value it will instead resort to C<AE::time>, i.e. fetch the current
  time on each log message. This only makes a difference for event loops
  that actually cache the time (such as L<EV> or L<AnyEvent::Loop>).
  
  This setting can be changed at any time by calling this function.
  
  Since C<AnyEvent::Log> has to work even before the L<AnyEvent> has been
  initialised, this switch will also decide whether to use C<CORE::time> or
  C<Time::HiRes::time> when logging a message before L<AnyEvent> becomes
  available.
  
  =back
  
  =head1 LOGGING CONTEXTS
  
  This module associates every log message with a so-called I<logging
  context>, based on the package of the caller. Every perl package has its
  own logging context.
  
  A logging context has three major responsibilities: filtering, logging and
  propagating the message.
  
  For the first purpose, filtering, each context has a set of logging
  levels, called the log level mask. Messages not in the set will be ignored
  by this context (masked).
  
  For logging, the context stores a formatting callback (which takes the
  timestamp, context, level and string message and formats it in the way
  it should be logged) and a logging callback (which is responsible for
  actually logging the formatted message and telling C<AnyEvent::Log>
  whether it has consumed the message, or whether it should be propagated).
  
  For propagation, a context can have any number of attached I<slave
  contexts>. Any message that is neither masked by the logging mask nor
  masked by the logging callback returning true will be passed to all slave
  contexts.
  
  Each call to a logging function will log the message at most once per
  context, so it does not matter (much) if there are cycles or if the
  message can arrive at the same context via multiple paths.
  
  =head2 DEFAULTS
  
  By default, all logging contexts have an full set of log levels ("all"), a
  disabled logging callback and the default formatting callback.
  
  Package contexts have the package name as logging title by default.
  
  They have exactly one slave - the context of the "parent" package. The
  parent package is simply defined to be the package name without the last
  component, i.e. C<AnyEvent::Debug::Wrapped> becomes C<AnyEvent::Debug>,
  and C<AnyEvent> becomes ... C<$AnyEvent::Log::COLLECT> which is the
  exception of the rule - just like the "parent" of any single-component
  package name in Perl is C<main>, the default slave of any top-level
  package context is C<$AnyEvent::Log::COLLECT>.
  
  Since perl packages form only an approximate hierarchy, this slave
  context can of course be removed.
  
  All other (anonymous) contexts have no slaves and an empty title by
  default.
  
  When the module is loaded it creates the C<$AnyEvent::Log::LOG> logging
  context that simply logs everything via C<warn>, without propagating
  anything anywhere by default.  The purpose of this context is to provide
  a convenient place to override the global logging target or to attach
  additional log targets. It's not meant for filtering.
  
  It then creates the C<$AnyEvent::Log::FILTER> context whose
  purpose is to suppress all messages with priority higher
  than C<$ENV{PERL_ANYEVENT_VERBOSE}>. It then attached the
  C<$AnyEvent::Log::LOG> context to it. The purpose of the filter context
  is to simply provide filtering according to some global log level.
  
  Finally it creates the top-level package context C<$AnyEvent::Log::COLLECT>
  and attaches the C<$AnyEvent::Log::FILTER> context to it, but otherwise
  leaves it at default config. Its purpose is simply to collect all log
  messages system-wide.
  
  The hierarchy is then:
  
     any package, eventually -> $COLLECT -> $FILTER -> $LOG
  
  The effect of all this is that log messages, by default, wander up to the
  C<$AnyEvent::Log::COLLECT> context where all messages normally end up,
  from there to C<$AnyEvent::Log::FILTER> where log messages with lower
  priority then C<$ENV{PERL_ANYEVENT_VERBOSE}> will be filtered out and then
  to the C<$AnyEvent::Log::LOG> context to be passed to C<warn>.
  
  This makes it easy to set a global logging level (by modifying $FILTER),
  but still allow other contexts to send, for example, their debug and trace
  messages to the $LOG target despite the global logging level, or to attach
  additional log targets that log messages, regardless of the global logging
  level.
  
  It also makes it easy to modify the default warn-logger ($LOG) to
  something that logs to a file, or to attach additional logging targets
  (such as loggign to a file) by attaching it to $FILTER.
  
  =head2 CREATING/FINDING/DESTROYING CONTEXTS
  
  =over 4
  
  =item $ctx = AnyEvent::Log::ctx [$pkg]
  
  This function creates or returns a logging context (which is an object).
  
  If a package name is given, then the context for that packlage is
  returned. If it is called without any arguments, then the context for the
  callers package is returned (i.e. the same context as a C<AE::log> call
  would use).
  
  If C<undef> is given, then it creates a new anonymous context that is not
  tied to any package and is destroyed when no longer referenced.
  
  =cut
  
  sub ctx(;$) {
     my $pkg = @_ ? shift : (caller)[0];
  
     ref $pkg
        ? $pkg
        : defined $pkg
           ? $CTX{$pkg} ||= AnyEvent::Log::_pkg_ctx $pkg
           : bless [undef, (1 << 10) - 1 - 1], "AnyEvent::Log::Ctx"
  }
  
  =item AnyEvent::Log::reset
  
  Resets all package contexts and recreates the default hierarchy if
  necessary, i.e. resets the logging subsystem to defaults, as much as
  possible. This process keeps references to contexts held by other parts of
  the program intact.
  
  This can be used to implement config-file (re-)loading: before loading a
  configuration, reset all contexts.
  
  =cut
  
  our $ORIG_VERBOSE = $AnyEvent::VERBOSE;
  $AnyEvent::VERBOSE = 9;
  
  sub reset {
     # hard to kill complex data structures
     # we "recreate" all package loggers and reset the hierarchy
     while (my ($k, $v) = each %CTX) {
        @$v = ($k, (1 << 10) - 1 - 1, { });
  
        $v->attach ($k =~ /^(.+)::/ ? $CTX{$1} : $AnyEvent::Log::COLLECT);
     }
  
     @$_ = ($_->[0], (1 << 10) - 1 - 1)
        for $LOG, $FILTER, $COLLECT;
  
     #$LOG->slaves;
     $LOG->title ('$AnyEvent::Log::LOG');
     $LOG->log_to_warn;
  
     $FILTER->slaves ($LOG);
     $FILTER->title ('$AnyEvent::Log::FILTER');
     $FILTER->level ($ORIG_VERBOSE);
  
     $COLLECT->slaves ($FILTER);
     $COLLECT->title ('$AnyEvent::Log::COLLECT');
  
     _reassess;
  }
  
  # override AE::log/logger
  *AnyEvent::log    = *AE::log    = \&log;
  *AnyEvent::logger = *AE::logger = \&logger;
  
  # convert AnyEvent loggers to AnyEvent::Log loggers
  $_->[0] = ctx $_->[0] # convert "pkg" to "ctx"
     for values %LOGGER;
  
  # create the default logger contexts
  $LOG     = ctx undef;
  $FILTER  = ctx undef;
  $COLLECT = ctx undef;
  
  AnyEvent::Log::reset;
  
  # hello, CPAN, please catch me
  package AnyEvent::Log::LOG;
  package AE::Log::LOG;
  package AnyEvent::Log::FILTER;
  package AE::Log::FILTER;
  package AnyEvent::Log::COLLECT;
  package AE::Log::COLLECT;
  
  package AnyEvent::Log::Ctx;
  
  =item $ctx = new AnyEvent::Log::Ctx methodname => param...
  
  This is a convenience constructor that makes it simpler to construct
  anonymous logging contexts.
  
  Each key-value pair results in an invocation of the method of the same
  name as the key with the value as parameter, unless the value is an
  arrayref, in which case it calls the method with the contents of the
  array. The methods are called in the same order as specified.
  
  Example: create a new logging context and set both the default logging
  level, some slave contexts and a logging callback.
  
     $ctx = new AnyEvent::Log::Ctx
        title   => "dubious messages",
        level   => "error",
        log_cb  => sub { print STDOUT shift; 0 },
        slaves  => [$ctx1, $ctx, $ctx2],
     ;
  
  =back
  
  =cut
  
  sub new {
     my $class = shift;
  
     my $ctx = AnyEvent::Log::ctx undef;
  
     while (@_) {
        my ($k, $v) = splice @_, 0, 2;
        $ctx->$k (ref $v eq "ARRAY" ? @$v : $v);
     }
  
     bless $ctx, $class # do we really support subclassing, hmm?
  }
  
  
  =head2 CONFIGURING A LOG CONTEXT
  
  The following methods can be used to configure the logging context.
  
  =over 4
  
  =item $ctx->title ([$new_title])
  
  Returns the title of the logging context - this is the package name, for
  package contexts, and a user defined string for all others.
  
  If C<$new_title> is given, then it replaces the package name or title.
  
  =cut
  
  sub title {
     $_[0][0] = $_[1] if @_ > 1;
     $_[0][0]
  }
  
  =back
  
  =head3 LOGGING LEVELS
  
  The following methods deal with the logging level set associated with the
  log context.
  
  The most common method to use is probably C<< $ctx->level ($level) >>,
  which configures the specified and any higher priority levels.
  
  All functions which accept a list of levels also accept the special string
  C<all> which expands to all logging levels.
  
  =over 4
  
  =item $ctx->levels ($level[, $level...)
  
  Enables logging for the given levels and disables it for all others.
  
  =item $ctx->level ($level)
  
  Enables logging for the given level and all lower level (higher priority)
  ones. In addition to normal logging levels, specifying a level of C<0> or
  C<off> disables all logging for this level.
  
  Example: log warnings, errors and higher priority messages.
  
     $ctx->level ("warn");
     $ctx->level (5); # same thing, just numeric
  
  =item $ctx->enable ($level[, $level...])
  
  Enables logging for the given levels, leaving all others unchanged.
  
  =item $ctx->disable ($level[, $level...])
  
  Disables logging for the given levels, leaving all others unchanged.
  
  =item $ctx->cap ($level)
  
  Caps the maximum priority to the given level, for all messages logged
  to, or passing through, this context. That is, while this doesn't affect
  whether a message is logged or passed on, the maximum priority of messages
  will be limited to the specified level - messages with a higher priority
  will be set to the specified priority.
  
  Another way to view this is that C<< ->level >> filters out messages with
  a too low priority, while C<< ->cap >> modifies messages with a too high
  priority.
  
  This is useful when different log targets have different interpretations
  of priority. For example, for a specific command line program, a wrong
  command line switch might well result in a C<fatal> log message, while the
  same message, logged to syslog, is likely I<not> fatal to the system or
  syslog facility as a whole, but more likely a mere C<error>.
  
  This can be modeled by having a stderr logger that logs messages "as-is"
  and a syslog logger that logs messages with a level cap of, say, C<error>,
  or, for truly system-critical components, actually C<critical>.
  
  =cut
  
  sub _lvl_lst {
     map {
        $_ > 0 && $_ <= 9 ? $_+0
        : $_ eq "all"     ? (1 .. 9)
        : $STR2LEVEL{$_} || Carp::croak "$_: not a valid logging level, caught"
     } @_
  }
  
  sub _lvl {
     $_[0] =~ /^(?:0|off|none)$/ ? 0 : (_lvl_lst $_[0])[-1]
  }
  
  our $NOP_CB = sub { 0 };
  
  sub levels {
     my $ctx = shift;
     $ctx->[1] = 0;
     $ctx->[1] |= 1 << $_
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub level {
     my $ctx = shift;
     $ctx->[1] = ((1 << &_lvl) - 1) << 1;
     AnyEvent::Log::_reassess;
  }
  
  sub enable {
     my $ctx = shift;
     $ctx->[1] |= 1 << $_
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub disable {
     my $ctx = shift;
     $ctx->[1] &= ~(1 << $_)
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub cap {
     my $ctx = shift;
     $ctx->[5] = &_lvl;
  }
  
  =back
  
  =head3 SLAVE CONTEXTS
  
  The following methods attach and detach another logging context to a
  logging context.
  
  Log messages are propagated to all slave contexts, unless the logging
  callback consumes the message.
  
  =over 4
  
  =item $ctx->attach ($ctx2[, $ctx3...])
  
  Attaches the given contexts as slaves to this context. It is not an error
  to add a context twice (the second add will be ignored).
  
  A context can be specified either as package name or as a context object.
  
  =item $ctx->detach ($ctx2[, $ctx3...])
  
  Removes the given slaves from this context - it's not an error to attempt
  to remove a context that hasn't been added.
  
  A context can be specified either as package name or as a context object.
  
  =item $ctx->slaves ($ctx2[, $ctx3...])
  
  Replaces all slaves attached to this context by the ones given.
  
  =cut
  
  sub attach {
     my $ctx = shift;
  
     $ctx->[2]{$_+0} = $_
        for map { AnyEvent::Log::ctx $_ } @_;
  }
  
  sub detach {
     my $ctx = shift;
  
     delete $ctx->[2]{$_+0}
        for map { AnyEvent::Log::ctx $_ } @_;
  }
  
  sub slaves {
     undef $_[0][2];
     &attach;
  }
  
  =back
  
  =head3 LOG TARGETS
  
  The following methods configure how the logging context actually does
  the logging (which consists of formatting the message and printing it or
  whatever it wants to do with it).
  
  =over 4
  
  =item $ctx->log_cb ($cb->($str)
  
  Replaces the logging callback on the context (C<undef> disables the
  logging callback).
  
  The logging callback is responsible for handling formatted log messages
  (see C<fmt_cb> below) - normally simple text strings that end with a
  newline (and are possibly multiline themselves).
  
  It also has to return true iff it has consumed the log message, and false
  if it hasn't. Consuming a message means that it will not be sent to any
  slave context. When in doubt, return C<0> from your logging callback.
  
  Example: a very simple logging callback, simply dump the message to STDOUT
  and do not consume it.
  
     $ctx->log_cb (sub { print STDERR shift; 0 });
  
  You can filter messages by having a log callback that simply returns C<1>
  and does not do anything with the message, but this counts as "message
  being logged" and might not be very efficient.
  
  Example: propagate all messages except for log levels "debug" and
  "trace". The messages will still be generated, though, which can slow down
  your program.
  
     $ctx->levels ("debug", "trace");
     $ctx->log_cb (sub { 1 }); # do not log, but eat debug and trace messages
  
  =item $ctx->fmt_cb ($fmt_cb->($timestamp, $orig_ctx, $level, $message))
  
  Replaces the formatting callback on the context (C<undef> restores the
  default formatter).
  
  The callback is passed the (possibly fractional) timestamp, the original
  logging context, the (numeric) logging level and the raw message string
  and needs to return a formatted log message. In most cases this will be a
  string, but it could just as well be an array reference that just stores
  the values.
  
  If, for some reason, you want to use C<caller> to find out more baout the
  logger then you should walk up the call stack until you are no longer
  inside the C<AnyEvent::Log> package.
  
  Example: format just the raw message, with numeric log level in angle
  brackets.
  
     $ctx->fmt_cb (sub {
        my ($time, $ctx, $lvl, $msg) = @_;
  
        "<$lvl>$msg\n"
     });
  
  Example: return an array reference with just the log values, and use
  C<PApp::SQL::sql_exec> to store the emssage in a database.
  
     $ctx->fmt_cb (sub { \@_ });
     $ctx->log_cb (sub {
        my ($msg) = @_;
  
        sql_exec "insert into log (when, subsys, prio, msg) values (?, ?, ?, ?)",
                 $msg->[0] + 0,
                 "$msg->[1]",
                 $msg->[2] + 0,
                 "$msg->[3]";
  
        0
     });
  
  =item $ctx->log_to_warn
  
  Sets the C<log_cb> to simply use C<CORE::warn> to report any messages
  (usually this logs to STDERR).
  
  =item $ctx->log_to_file ($path)
  
  Sets the C<log_cb> to log to a file (by appending), unbuffered.
  
  =item $ctx->log_to_path ($path)
  
  Same as C<< ->log_to_file >>, but opens the file for each message. This
  is much slower, but allows you to change/move/rename/delete the file at
  basically any time.
  
  Needless(?) to say, if you do not want to be bitten by some evil person
  calling C<chdir>, the path should be absolute. Doesn't help with
  C<chroot>, but hey...
  
  =item $ctx->log_to_syslog ([$facility])
  
  Logs all messages via L<Sys::Syslog>, mapping C<trace> to C<debug> and
  all the others in the obvious way. If specified, then the C<$facility> is
  used as the facility (C<user>, C<auth>, C<local0> and so on). The default
  facility is C<user>.
  
  Note that this function also sets a C<fmt_cb> - the logging part requires
  an array reference with [$level, $str] as input.
  
  =cut
  
  sub log_cb {
     my ($ctx, $cb) = @_;
  
     $ctx->[3] = $cb;
  }
  
  sub fmt_cb {
     my ($ctx, $cb) = @_;
  
     $ctx->[4] = $cb;
  }
  
  sub log_to_warn {
     my ($ctx, $path) = @_;
  
     $ctx->log_cb (sub {
        warn shift;
        0
     });
  }
  
  sub log_to_file {
     my ($ctx, $path) = @_;
  
     open my $fh, ">>", $path
        or die "$path: $!";
  
     $ctx->log_cb (sub {
        syswrite $fh, shift;
        0
     });
  }
  
  sub log_to_path {
     my ($ctx, $path) = @_;
  
     $ctx->log_cb (sub {
        open my $fh, ">>", $path
           or die "$path: $!";
  
        syswrite $fh, shift;
        0
     });
  }
  
  sub log_to_syslog {
     my ($ctx, $facility) = @_;
  
     require Sys::Syslog;
  
     $ctx->fmt_cb (sub {
        my $str = $_[3];
        $str =~ s/\n(?=.)/\n+ /g;
  
        [$_[2], "($_[1][0]) $str"]
     });
  
     $facility ||= "user";
  
     $ctx->log_cb (sub {
        my $lvl = $_[0][0] < 9 ? $_[0][0] : 8;
  
        Sys::Syslog::syslog ("$facility|" . ($lvl - 1), $_)
           for split /\n/, $_[0][1];
  
        0
     });
  }
  
  =back
  
  =head3 MESSAGE LOGGING
  
  These methods allow you to log messages directly to a context, without
  going via your package context.
  
  =over 4
  
  =item $ctx->log ($level, $msg[, @params])
  
  Same as C<AnyEvent::Log::log>, but uses the given context as log context.
  
  =item $logger = $ctx->logger ($level[, \$enabled])
  
  Same as C<AnyEvent::Log::logger>, but uses the given context as log
  context.
  
  =cut
  
  *log    = \&AnyEvent::Log::_log;
  *logger = \&AnyEvent::Log::_logger;
  
  =back
  
  =cut
  
  package AnyEvent::Log;
  
  =head1 CONFIGURATION VIA $ENV{PERL_ANYEVENT_LOG}
  
  Logging can also be configured by setting the environment variable
  C<PERL_ANYEVENT_LOG> (or C<AE_LOG>).
  
  The value consists of one or more logging context specifications separated
  by C<:> or whitespace. Each logging specification in turn starts with a
  context name, followed by C<=>, followed by zero or more comma-separated
  configuration directives, here are some examples:
  
     # set default logging level
     filter=warn
  
     # log to file instead of to stderr
     log=file=/tmp/mylog
  
     # log to file in addition to stderr
     log=+%file:%file=file=/tmp/mylog
  
     # enable debug log messages, log warnings and above to syslog
     filter=debug:log=+%warnings:%warnings=warn,syslog=LOG_LOCAL0
  
     # log trace messages (only) from AnyEvent::Debug to file
     AnyEvent::Debug=+%trace:%trace=only,trace,file=/tmp/tracelog
  
  A context name in the log specification can be any of the following:
  
  =over 4
  
  =item C<collect>, C<filter>, C<log>
  
  Correspond to the three predefined C<$AnyEvent::Log::COLLECT>,
  C<AnyEvent::Log::FILTER> and C<$AnyEvent::Log::LOG> contexts.
  
  =item C<%name>
  
  Context names starting with a C<%> are anonymous contexts created when the
  name is first mentioned. The difference to package contexts is that by
  default they have no attached slaves.
  
  =item a perl package name
  
  Any other string references the logging context associated with the given
  Perl C<package>. In the unlikely case where you want to specify a package
  context that matches on of the other context name forms, you can add a
  C<::> to the package name to force interpretation as a package.
  
  =back
  
  The configuration specifications can be any number of the following:
  
  =over 4
  
  =item C<stderr>
  
  Configures the context to use Perl's C<warn> function (which typically
  logs to C<STDERR>). Works like C<log_to_warn>.
  
  =item C<file=>I<path>
  
  Configures the context to log to a file with the given path. Works like
  C<log_to_file>.
  
  =item C<path=>I<path>
  
  Configures the context to log to a file with the given path. Works like
  C<log_to_path>.
  
  =item C<syslog> or C<syslog=>I<expr>
  
  Configures the context to log to syslog. If I<expr> is given, then it is
  evaluated in the L<Sys::Syslog> package, so you could use:
  
     log=syslog=LOG_LOCAL0
  
  =item C<nolog>
  
  Configures the context to not log anything by itself, which is the
  default. Same as C<< $ctx->log_cb (undef) >>.
  
  =item C<cap=>I<level>
  
  Caps logging messages entering this context at the given level, i.e.
  reduces the priority of messages with higher priority than this level. The
  default is C<0> (or C<off>), meaning the priority will not be touched.
  
  =item C<0> or C<off>
  
  Sets the logging level of the context to C<0>, i.e. all messages will be
  filtered out.
  
  =item C<all>
  
  Enables all logging levels, i.e. filtering will effectively be switched
  off (the default).
  
  =item C<only>
  
  Disables all logging levels, and changes the interpretation of following
  level specifications to enable the specified level only.
  
  Example: only enable debug messages for a context.
  
     context=only,debug
  
  =item C<except>
  
  Enables all logging levels, and changes the interpretation of following
  level specifications to disable that level. Rarely used.
  
  Example: enable all logging levels except fatal and trace (this is rather
  nonsensical).
  
     filter=exept,fatal,trace
  
  =item C<level>
  
  Enables all logging levels, and changes the interpretation of following
  level specifications to be "that level or any higher priority
  message". This is the default.
  
  Example: log anything at or above warn level.
  
     filter=warn
  
     # or, more verbose
     filter=only,level,warn
  
  =item C<1>..C<9> or a logging level name (C<error>, C<debug> etc.)
  
  A numeric loglevel or the name of a loglevel will be interpreted according
  to the most recent C<only>, C<except> or C<level> directive. By default,
  specifying a logging level enables that and any higher priority messages.
  
  =item C<+>I<context>
  
  Attaches the named context as slave to the context.
  
  =item C<+>
  
  A line C<+> detaches all contexts, i.e. clears the slave list from the
  context. Anonymous (C<%name>) contexts have no attached slaves by default,
  but package contexts have the parent context as slave by default.
  
  Example: log messages from My::Module to a file, do not send them to the
  default log collector.
  
     My::Module=+,file=/tmp/mymodulelog
  
  =back
  
  Any character can be escaped by prefixing it with a C<\> (backslash), as
  usual, so to log to a file containing a comma, colon, backslash and some
  spaces in the filename, you would do this:
  
     PERL_ANYEVENT_LOG='log=file=/some\ \:file\ with\,\ \\-escapes'
  
  Since whitespace (which includes newlines) is allowed, it is fine to
  specify multiple lines in C<PERL_ANYEVENT_LOG>, e.g.:
  
     PERL_ANYEVENT_LOG="
        filter=warn
        AnyEvent::Debug=+%trace
        %trace=only,trace,+log
     " myprog
  
  Also, in the unlikely case when you want to concatenate specifications,
  use whitespace as separator, as C<::> will be interpreted as part of a
  module name, an empty spec with two separators:
  
     PERL_ANYEVENT_LOG="$PERL_ANYEVENT_LOG MyMod=debug"
  
  =cut
  
  for (my $spec = $ENV{PERL_ANYEVENT_LOG}) {
     my %anon;
  
     my $pkg = sub {
        $_[0] eq "log"              ? $LOG
        : $_[0] eq "filter"         ? $FILTER
        : $_[0] eq "collect"        ? $COLLECT
        : $_[0] =~ /^%(.+)$/        ? ($anon{$1} ||= do { my $ctx = ctx undef; $ctx->[0] = $_[0]; $ctx })
        : $_[0] =~ /^(.*?)(?:::)?$/ ? ctx "$1" # egad :/
        : die # never reached?
     };
  
     /\G[[:space:]]+/gc; # skip initial whitespace
  
     while (/\G((?:[^:=[:space:]]+|::|\\.)+)=/gc) {
        my $ctx = $pkg->($1);
        my $level = "level";
  
        while (/\G((?:[^,:[:space:]]+|::|\\.)+)/gc) {
           for ("$1") {
              if ($_ eq "stderr"               ) { $ctx->log_to_warn;
              } elsif (/^file=(.+)/            ) { $ctx->log_to_file ("$1");
              } elsif (/^path=(.+)/            ) { $ctx->log_to_path ("$1");
              } elsif (/^syslog(?:=(.*))?/     ) { require Sys::Syslog; $ctx->log_to_syslog ("$1");
              } elsif ($_ eq "nolog"           ) { $ctx->log_cb (undef);
              } elsif (/^cap=(.+)/             ) { $ctx->cap ("$1");
              } elsif (/^\+(.+)$/              ) { $ctx->attach ($pkg->("$1"));
              } elsif ($_ eq "+"               ) { $ctx->slaves;
              } elsif ($_ eq "off" or $_ eq "0") { $ctx->level (0);
              } elsif ($_ eq "all"             ) { $ctx->level ("all");
              } elsif ($_ eq "level"           ) { $ctx->level ("all"); $level = "level";
              } elsif ($_ eq "only"            ) { $ctx->level ("off"); $level = "enable";
              } elsif ($_ eq "except"          ) { $ctx->level ("all"); $level = "disable";
              } elsif (/^\d$/                  ) { $ctx->$level ($_);
              } elsif (exists $STR2LEVEL{$_}   ) { $ctx->$level ($_);
              } else                             { die "PERL_ANYEVENT_LOG ($spec): parse error at '$_'\n";
              }
           }
  
           /\G,/gc or last;
        }
  
        /\G[:[:space:]]+/gc or last;
     }
  
     /\G[[:space:]]+/gc; # skip trailing whitespace
  
     if (/\G(.+)/g) {
        die "PERL_ANYEVENT_LOG ($spec): parse error at '$1'\n";
     }
  }
  
  1;
  
  =head1 EXAMPLES
  
  This section shows some common configurations, both as code, and as
  C<PERL_ANYEVENT_LOG> string.
  
  =over 4
  
  =item Setting the global logging level.
  
  Either put C<PERL_ANYEVENT_VERBOSE=><number> into your environment before
  running your program, use C<PERL_ANYEVENT_LOG> or modify the log level of
  the root context at runtime:
  
     PERL_ANYEVENT_VERBOSE=5 ./myprog
  
     PERL_ANYEVENT_LOG=log=warn
  
     $AnyEvent::Log::FILTER->level ("warn");
  
  =item Append all messages to a file instead of sending them to STDERR.
  
  This is affected by the global logging level.
  
     $AnyEvent::Log::LOG->log_to_file ($path);
  
     PERL_ANYEVENT_LOG=log=file=/some/path
  
  =item Write all messages with priority C<error> and higher to a file.
  
  This writes them only when the global logging level allows it, because
  it is attached to the default context which is invoked I<after> global
  filtering.
  
     $AnyEvent::Log::FILTER->attach (
        new AnyEvent::Log::Ctx log_to_file => $path);
  
     PERL_ANYEVENT_LOG=filter=+%filelogger:%filelogger=file=/some/path
  
  This writes them regardless of the global logging level, because it is
  attached to the toplevel context, which receives all messages I<before>
  the global filtering.
  
     $AnyEvent::Log::COLLECT->attach (
        new AnyEvent::Log::Ctx log_to_file => $path);
  
     PERL_ANYEVENT_LOG=%filelogger=file=/some/path:collect=+%filelogger
  
  In both cases, messages are still written to STDERR.
  
  =item Additionally log all messages with C<warn> and higher priority to
  C<syslog>, but cap at C<error>.
  
  This logs all messages to the default log target, but also logs messages
  with priority C<warn> or higher (and not filtered otherwise) to syslog
  facility C<user>. Messages with priority higher than C<error> will be
  logged with level C<error>.
  
     $AnyEvent::Log::LOG->attach (
        new AnyEvent::Log::Ctx
           level  => "warn",
           cap    => "error",
           syslog => "user",
     );
  
     PERL_ANYEVENT_LOG=log=+%syslog:%syslog=warn,cap=error,syslog
  
  =item Write trace messages (only) from L<AnyEvent::Debug> to the default logging target(s).
  
  Attach the C<$AnyEvent::Log::LOG> context to the C<AnyEvent::Debug>
  context - this simply circumvents the global filtering for trace messages.
  
     my $debug = AnyEvent::Debug->AnyEvent::Log::ctx;
     $debug->attach ($AnyEvent::Log::LOG);
  
     PERL_ANYEVENT_LOG=AnyEvent::Debug=+log
  
  This of course works for any package, not just L<AnyEvent::Debug>, but
  assumes the log level for AnyEvent::Debug hasn't been changed from the
  default.
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_LOG

$fatpacked{"darwin-2level/AnyEvent/Loop.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_LOOP';
  =head1 NAME
  
  AnyEvent::Loop - AnyEvent's Pure-Perl event loop
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     # use AnyEvent::Loop;
    
     # this module gets loaded automatically when no other loop can be found
  
     # Explicit use:
     use AnyEvent::Loop;
     use AnyEvent;
  
     ...
  
     AnyEvent::Loop::run; # run the event loop
  
  =head1 DESCRIPTION
  
  This module provides an event loop for AnyEvent in case no other event
  loop could be found or loaded. You don't have to do anything to make it
  work with AnyEvent except by possibly loading it before creating the first
  AnyEvent watcher.
  
  This module is I<not> some loop abstracion used by AnyEvent, but just
  another event loop like EV or Glib, just written in pure perl and
  delivered with AnyEvent, so AnyEvent always works, even in the absence of
  any other backend.
  
  If you want to use this module instead of autoloading a potentially better
  event loop you can simply load it (and no other event loops) before
  creating the first watcher.
  
  As for performance, this module is on par with (and usually faster than)
  most select/poll-based C event modules such as Event or Glib (it does not
  even come close to EV, though), with respect to I/O watchers. Timers are
  handled less optimally, but for many common tasks, it is still on par with
  event loops written in C.
  
  This event loop has been optimised for the following use cases:
  
  =over 4
  
  =item monotonic clock is available
  
  This module will use the POSIX monotonic clock option (if it can be
  detected at runtime) or the POSIX C<times> function (if the resolution
  is at least 100Hz), in which case it will not suffer adversely from time
  jumps.
  
  If no monotonic clock is available, this module will not attempt to
  correct for time jumps in any way.
  
  The clock chosen will be reported if the environment variable
  C<$PERL_ANYEVENT_VERBOSE> is set to 8 or higher.
  
  =item any number of watchers on one fd
  
  Supporting a large number of watchers per fd is purely a dirty benchmark
  optimisation not relevant in practise. The more common case of having one
  watcher per fd/poll combo is special-cased, however, and therefore fast,
  too.
  
  =item relatively few active fds per C<select> call
  
  This module expects that only a tiny amount of fds is active at any one
  time. This is relatively typical of larger servers (but not the case where
  C<select> traditionally is fast), at the expense of the "dense activity
  case" where most of the fds are active (which suits C<select>).
  
  The optimal implementation of the "dense" case is not much faster, though,
  so the module should behave very well in most cases, subject to the bad
  scalability of C<select> in the presence of a large number of inactive
  file descriptors.
  
  =item lots of timer changes/iteration, or none at all
  
  This module sorts the timer list using perl's C<sort>, even though a total
  ordering is not required for timers internally.
  
  This sorting is expensive, but means sorting can be avoided unless the
  timer list has changed in a way that requires a new sort.
  
  This means that adding lots of timers is very efficient, as well as not
  changing the timers. Advancing timers (e.g. recreating a timeout watcher
  on activity) is also relatively efficient, for example, if you have a
  large number of timeout watchers that time out after 10 seconds, then the
  timer list will be sorted only once every 10 seconds.
  
  This should not have much of an impact unless you have hundreds or
  thousands of timers, though, or your timers have very small timeouts.
  
  =back
  
  =head1 FUNCTIONS
  
  The only user-visible functions provided by this module loop related -
  watchers are created via the normal AnyEvent mechanisms.
  
  =over 4
  
  =item AnyEvent::Loop::run
  
  Run the event loop, usually the last thing done in the main program when
  you want to use the pure-perl backend.
  
  =item AnyEvent::Loop::one_event
  
  Blocks until at least one new event has been received by the operating
  system, whether or not it was AnyEvent-related.
  
  =back
  
  =cut
  
  package AnyEvent::Loop;
  
  use Scalar::Util qw(weaken);
  use List::Util ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  
  our $VERSION = $AnyEvent::VERSION;
  
  our ($NOW, $MNOW);
  
  sub MAXWAIT() { 3600 } # never sleep for longer than this many seconds
  
  BEGIN {
     local $SIG{__DIE__};
     my $time_hires = eval "use Time::HiRes (); 1";
     my $clk_tck    = eval "use POSIX (); POSIX::sysconf (POSIX::_SC_CLK_TCK ())";
     my $round; # actual granularity
  
     if ($time_hires && eval "&Time::HiRes::clock_gettime (Time::HiRes::CLOCK_MONOTONIC ())") {
        AE::log 8 => "AnyEvent::Loop: using CLOCK_MONOTONIC as timebase.";
        *_update_clock = sub {
           $NOW  = &Time::HiRes::time;
           $MNOW = Time::HiRes::clock_gettime (&Time::HiRes::CLOCK_MONOTONIC);
        };
  
     } elsif (100 <= $clk_tck && $clk_tck <= 1000000 && eval { (POSIX::times ())[0] != -1 }) { # -1 is also a valid return value :/
        AE::log 8 => "AnyEvent::Loop: using POSIX::times (monotonic) as timebase.";
        my $HZ1 = 1 / $clk_tck;
  
        my $last = (POSIX::times ())[0];
        my $next;
        *_update_clock = sub {
           $NOW  = time; # d'oh
  
           $next = (POSIX::times ())[0];
           # we assume 32 bit signed on wrap but 64 bit will never wrap
           $last -= 4294967296 if $last > $next; # 0x100000000, but perl has probelsm with big hex constants
           $MNOW += ($next - $last) * $HZ1;
           $last = $next;
        };
  
        $round = $HZ1;
  
     } elsif (eval "use Time::HiRes (); 1") {
        AE::log 8 => "AnyEvent::Loop: using Time::HiRes::time (non-monotonic) clock as timebase.";
        *_update_clock = sub {
           $NOW = $MNOW = &Time::HiRes::time;
        };
  
     } else {
        AE::log fatal => "FATAL: unable to find sub-second time source (is this really perl 5.8.0 or later?)";
     }
  
     $round = 0.001 if $round < 0.001; # 1ms is enough for us
     $round -= $round * 1e-2; # 0.1 => 0.099
     eval "sub ROUNDUP() { $round }";
  }
  
  _update_clock;
  
  # rely on AnyEvent:Base::time to provide time
  sub now       () { $NOW          }
  sub now_update() { _update_clock }
  
  # fds[0] is for read, fds[1] is for write watchers
  # fds[poll][V] is the bitmask for select
  # fds[poll][W][fd] contains a list of i/o watchers
  # an I/O watcher is a blessed arrayref containing [fh, poll(0/1), callback, queue-index]
  # the queue-index is simply the index in the [W] array, which is only used to improve
  # benchmark results in the synthetic "many watchers on one fd" benchmark.
  my @fds = ([], []);
  sub V() { 0 }
  sub W() { 1 }
  
  my $need_sort = 1e300; # when to re-sort timer list
  my @timer; # list of [ abs-timeout, Timer::[callback] ]
  my @idle;  # list of idle callbacks
  
  # the pure perl mainloop
  sub one_event {
     _update_clock;
  
     # first sort timers if required (slow)
     if ($MNOW >= $need_sort) {
        $need_sort = 1e300;
        @timer = sort { $a->[0] <=> $b->[0] } @timer;
     }
  
     # handle all pending timers
     if (@timer && $timer[0][0] <= $MNOW) {
        do {
           my $timer = shift @timer;
           $timer->[1] && $timer->[1]($timer);
        } while @timer && $timer[0][0] <= $MNOW;
  
     } else {
        # poll for I/O events, we do not do this when there
        # were any pending timers to ensure that one_event returns
        # quickly when some timers have been handled
        my ($wait, @vec, $fds)
           = (@timer && $timer[0][0] < $need_sort ? $timer[0][0] : $need_sort) - $MNOW;
  
        $wait = $wait < MAXWAIT ? $wait + ROUNDUP : MAXWAIT;
        $wait = 0 if @idle;
  
        $fds = CORE::select
          $vec[0] = $fds[0][V],
          $vec[1] = $fds[1][V],
          AnyEvent::WIN32 ? $vec[2] = $fds[1][V] : undef,
          $wait;
  
        _update_clock;
  
        if ($fds > 0) {
           # buggy microshit windows errornously sets exceptfds instead of writefds
           $vec[1] |= $vec[2] if AnyEvent::WIN32;
  
           # prefer write watchers, because they might reduce memory pressure.
           for (1, 0) {
              my $fds = $fds[$_];
  
              # we parse the bitmask by first expanding it into
              # a string of bits
              for (unpack "b*", $vec[$_]) {
                 # and then repeatedly matching a regex against it
                 while (/1/g) {
                    # and use the resulting string position as fd
                    $_ && $_->[2]()
                       for @{ $fds->[W][(pos) - 1] || [] };
                 }
              }
           }
        } elsif (AnyEvent::WIN32 && $fds && $! == AnyEvent::Util::WSAEINVAL) {
           # buggy microshit windoze asks us to route around it
           CORE::select undef, undef, undef, $wait if $wait;
        } elsif (!@timer || $timer[0][0] > $MNOW && !$fds) {
           $$$_ && $$$_->() for @idle = grep $$$_, @idle;
        }
     }
  }
  
  sub run {
     one_event while 1;
  }
  
  sub io($$$) {
     my ($fd, $write, $cb) = @_;
  
     defined ($fd = fileno $fd)
        or $fd = $_[0];
  
     my $self = bless [
        $fd,
        $write,
        $cb,
        # q-idx
     ], "AnyEvent::Loop::io";
  
     my $fds = $fds[$self->[1]];
  
     # add watcher to fds structure
     my $q = $fds->[W][$fd] ||= [];
  
     (vec $fds->[V], $fd, 1) = 1;
  
     $self->[3] = @$q;
     push @$q, $self;
     weaken $q->[-1];
  
     $self
  }
  
  sub AnyEvent::Loop::io::DESTROY {
     my ($self) = @_;
  
     my $fds = $fds[$self->[1]];
  
     # remove watcher from fds structure
     my $fd = $self->[0];
  
     if (@{ $fds->[W][$fd] } == 1) {
        delete $fds->[W][$fd];
        (vec $fds->[V], $fd, 1) = 0;
     } else {
        my $q = $fds->[W][$fd];
        my $last = pop @$q;
  
        if ($last != $self) {
           weaken ($q->[$self->[3]] = $last);
           $last->[3] = $self->[3];
        }
     }
  }
  
  sub timer($$$) {
     my ($after, $interval, $cb) = @_;
     
     my $self;
  
     if ($interval) {
        $self = [$MNOW + $after , sub {
           $_[0][0] = List::Util::max $_[0][0] + $interval, $MNOW;
           push @timer, $_[0];
           weaken $timer[-1];
           $need_sort = $_[0][0] if $_[0][0] < $need_sort;
           &$cb;
        }];
     } else {
        $self = [$MNOW + $after, $cb];
     }
  
     push @timer, $self;
     weaken $timer[-1];
     $need_sort = $self->[0] if $self->[0] < $need_sort;
  
     $self
  }
  
  sub idle($) {
     my $cb = shift;
  
     push @idle, \\$cb;
     weaken ${$idle[-1]};
  
     ${$idle[-1]}
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<AnyEvent>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  =cut
  
  
DARWIN-2LEVEL_ANYEVENT_LOOP

$fatpacked{"darwin-2level/AnyEvent/Socket.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_SOCKET';
  =head1 NAME
  
  AnyEvent::Socket - useful IPv4 and IPv6 stuff. also unix domain sockets. and stuff.
  
  =head1 SYNOPSIS
  
     use AnyEvent::Socket;
     
     tcp_connect "gameserver.deliantra.net", 13327, sub {
        my ($fh) = @_
           or die "gameserver.deliantra.net connect failed: $!";
     
        # enjoy your filehandle
     };
     
     # a simple tcp server
     tcp_server undef, 8888, sub {
        my ($fh, $host, $port) = @_;
     
        syswrite $fh, "The internet is full, $host:$port. Go away!\015\012";
     };
  
  =head1 DESCRIPTION
  
  This module implements various utility functions for handling internet
  protocol addresses and sockets, in an as transparent and simple way as
  possible.
  
  All functions documented without C<AnyEvent::Socket::> prefix are exported
  by default.
  
  =over 4
  
  =cut
  
  package AnyEvent::Socket;
  
  use Carp ();
  use Errno ();
  use Socket qw(AF_INET AF_UNIX SOCK_STREAM SOCK_DGRAM SOL_SOCKET SO_REUSEADDR);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(guard fh_nonblocking AF_INET6);
  use AnyEvent::DNS ();
  
  use base 'Exporter';
  
  our @EXPORT = qw(
     getprotobyname
     parse_hostport format_hostport
     parse_ipv4 parse_ipv6
     parse_ip parse_address
     format_ipv4 format_ipv6
     format_ip format_address
     address_family
     inet_aton
     tcp_server
     tcp_connect
  );
  
  our $VERSION = $AnyEvent::VERSION;
  
  =item $ipn = parse_ipv4 $dotted_quad
  
  Tries to parse the given dotted quad IPv4 address and return it in
  octet form (or undef when it isn't in a parsable format). Supports all
  forms specified by POSIX (e.g. C<10.0.0.1>, C<10.1>, C<10.0x020304>,
  C<0x12345678> or C<0377.0377.0377.0377>).
  
  =cut
  
  sub parse_ipv4($) {
     $_[0] =~ /^      (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* )
                (?:\. (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* ) ){0,3}$/x
        or return undef;
  
     @_ = map /^0/ ? oct : $_, split /\./, $_[0];
  
     # check leading parts against range
     return undef if grep $_ >= 256, @_[0 .. @_ - 2];
  
     # check trailing part against range
     return undef if $_[-1] >= 2 ** (8 * (4 - $#_));
  
     pack "N", (pop)
               + ($_[0] << 24)
               + ($_[1] << 16)
               + ($_[2] <<  8);
  }
  
  =item $ipn = parse_ipv6 $textual_ipv6_address
  
  Tries to parse the given IPv6 address and return it in
  octet form (or undef when it isn't in a parsable format).
  
  Should support all forms specified by RFC 2373 (and additionally all IPv4
  forms supported by parse_ipv4). Note that scope-id's are not supported
  (and will not parse).
  
  This function works similarly to C<inet_pton AF_INET6, ...>.
  
  Example:
  
     print unpack "H*", parse_ipv6 "2002:5345::10.0.0.1";
     # => 2002534500000000000000000a000001
  
  =cut
  
  sub parse_ipv6($) {
     # quick test to avoid longer processing
     my $n = $_[0] =~ y/://;
     return undef if $n < 2 || $n > 8;
  
     my ($h, $t) = split /::/, $_[0], 2;
  
     unless (defined $t) {
        ($h, $t) = (undef, $h);
     }
  
     my @h = split /:/, $h;
     my @t = split /:/, $t;
  
     # check for ipv4 tail
     if (@t && $t[-1]=~ /\./) {
        return undef if $n > 6;
  
        my $ipn = parse_ipv4 pop @t
           or return undef;
  
        push @t, map +(sprintf "%x", $_), unpack "nn", $ipn;
     }
  
     # no :: then we need to have exactly 8 components
     return undef unless @h + @t == 8 || $_[0] =~ /::/;
  
     # now check all parts for validity
     return undef if grep !/^[0-9a-fA-F]{1,4}$/, @h, @t;
  
     # now pad...
     push @h, 0 while @h + @t < 8;
  
     # and done
     pack "n*", map hex, @h, @t
  }
  
  =item $token = parse_unix $hostname
  
  This fucntion exists mainly for symmetry to the other C<parse_protocol>
  functions - it takes a hostname and, if it is C<unix/>, it returns a
  special address token, otherwise C<undef>.
  
  The only use for this function is probably to detect whether a hostname
  matches whatever AnyEvent uses for unix domain sockets.
  
  =cut
  
  sub parse_unix($) {
     $_[0] eq "unix/"
        ? pack "S", AF_UNIX
        : undef
  
  }
  
  =item $ipn = parse_address $ip
  
  Combines C<parse_ipv4> and C<parse_ipv6> in one function. The address
  here refers to the host address (not socket address) in network form
  (binary).
  
  If the C<$text> is C<unix/>, then this function returns a special token
  recognised by the other functions in this module to mean "UNIX domain
  socket".
  
  If the C<$text> to parse is a mapped IPv4 in IPv6 address (:ffff::<ipv4>),
  then it will be treated as an IPv4 address. If you don't want that, you
  have to call C<parse_ipv4> and/or C<parse_ipv6> manually.
  
  Example:
  
     print unpack "H*", parse_address "10.1.2.3";
     # => 0a010203
  
  =item $ipn = AnyEvent::Socket::aton $ip
  
  Same as C<parse_address>, but not exported (think C<Socket::inet_aton> but
  I<without> name resolution).
  
  =cut
  
  sub parse_address($) {
     for (&parse_ipv6) {
        if ($_) {
           s/^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff//;
           return $_;
        } else {
           return &parse_ipv4 || &parse_unix
        }
     }
  }
  
  *aton = \&parse_address;
  
  =item ($name, $aliases, $proto) = getprotobyname $name
  
  Works like the builtin function of the same name, except it tries hard to
  work even on broken platforms (well, that's windows), where getprotobyname
  is traditionally very unreliable.
  
  Example: get the protocol number for TCP (usually 6)
  
     my $proto = getprotobyname "tcp";
  
  =cut
  
  # microsoft can't even get getprotobyname working (the etc/protocols file
  # gets lost fairly often on windows), so we have to hardcode some common
  # protocol numbers ourselves.
  our %PROTO_BYNAME;
  
  $PROTO_BYNAME{tcp}  = Socket::IPPROTO_TCP () if defined &Socket::IPPROTO_TCP;
  $PROTO_BYNAME{udp}  = Socket::IPPROTO_UDP () if defined &Socket::IPPROTO_UDP;
  $PROTO_BYNAME{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
  
  sub getprotobyname($) {
     my $name = lc shift;
  
     defined (my $proton = $PROTO_BYNAME{$name} || (getprotobyname $name)[2])
        or return;
  
     ($name, uc $name, $proton)
  }
  
  =item ($host, $service) = parse_hostport $string[, $default_service]
  
  Splitting a string of the form C<hostname:port> is a common
  problem. Unfortunately, just splitting on the colon makes it hard to
  specify IPv6 addresses and doesn't support the less common but well
  standardised C<[ip literal]> syntax.
  
  This function tries to do this job in a better way, it supports the
  following formats, where C<port> can be a numerical port number of a
  service name, or a C<name=port> string, and the C< port> and C<:port>
  parts are optional. Also, everywhere where an IP address is supported
  a hostname or unix domain socket address is also supported (see
  C<parse_unix>), and strings starting with C</> will also be interpreted as
  unix domain sockets.
  
     hostname:port    e.g. "www.linux.org", "www.x.de:443", "www.x.de:https=443",
     ipv4:port        e.g. "198.182.196.56", "127.1:22"
     ipv6             e.g. "::1", "affe::1"
     [ipv4or6]:port   e.g. "[::1]", "[10.0.1]:80"
     [ipv4or6] port   e.g. "[127.0.0.1]", "[www.x.org] 17"
     ipv4or6 port     e.g. "::1 443", "10.0.0.1 smtp"
     unix/:path       e.g. "unix/:/path/to/socket"
     /path            e.g. "/path/to/socket"
  
  It also supports defaulting the service name in a simple way by using
  C<$default_service> if no service was detected. If neither a service was
  detected nor a default was specified, then this function returns the
  empty list. The same happens when a parse error was detected, such as a
  hostname with a colon in it (the function is rather conservative, though).
  
  Example:
  
    print join ",", parse_hostport "localhost:443";
    # => "localhost,443"
  
    print join ",", parse_hostport "localhost", "https";
    # => "localhost,https"
  
    print join ",", parse_hostport "[::1]";
    # => "," (empty list)
  
    print join ",", parse_host_port "/tmp/debug.sock";
    # => "unix/", "/tmp/debug.sock"
  
  =cut
  
  sub parse_hostport($;$) {
     my ($host, $port);
  
     for ("$_[0]") { # work on a copy, just in case, and also reset pos
  
        # shortcut for /path
        return ("unix/", $_)
           if m%^/%;
  
        # parse host, special cases: "ipv6" or "ipv6 port"
        unless (
           ($host) = /^\s* ([0-9a-fA-F:]*:[0-9a-fA-F:]*:[0-9a-fA-F\.:]*)/xgc
           and parse_ipv6 $host
        ) {
           /^\s*/xgc;
  
           if (/^ \[ ([^\[\]]+) \]/xgc) {
              $host = $1;
           } elsif (/^ ([^\[\]:\ ]+) /xgc) {
              $host = $1;
           } else {
              return;
           }
        }
  
        # parse port
        if (/\G (?:\s+|:) ([^:[:space:]]+) \s*$/xgc) {
           $port = $1;
        } elsif (/\G\s*$/gc && length $_[1]) {
           $port = $_[1];
        } else {
           return;
        }
  
     }
  
     # hostnames must not contain :'s
     return if $host =~ /:/ && !parse_ipv6 $host;
  
     ($host, $port)
  }
  
  =item $string = format_hostport $host, $port
  
  Takes a host (in textual form) and a port and formats in unambigiously in
  a way that C<parse_hostport> can parse it again. C<$port> can be C<undef>.
  
  =cut
  
  sub format_hostport($;$) {
     my ($host, $port) = @_;
  
     $port = ":$port"  if length $port;
     $host = "[$host]" if $host =~ /:/;
  
     "$host$port"
  }
  
  =item $sa_family = address_family $ipn
  
  Returns the address family/protocol-family (AF_xxx/PF_xxx, in one value :)
  of the given host address in network format.
  
  =cut
  
  sub address_family($) {
     4 == length $_[0]
        ? AF_INET
        : 16 == length $_[0]
           ? AF_INET6
           : unpack "S", $_[0]
  }
  
  =item $text = format_ipv4 $ipn
  
  Expects a four octet string representing a binary IPv4 address and returns
  its textual format. Rarely used, see C<format_address> for a nicer
  interface.
  
  =item $text = format_ipv6 $ipn
  
  Expects a sixteen octet string representing a binary IPv6 address and
  returns its textual format. Rarely used, see C<format_address> for a
  nicer interface.
  
  =item $text = format_address $ipn
  
  Covnvert a host address in network format (e.g. 4 octets for IPv4 or 16
  octets for IPv6) and convert it into textual form.
  
  Returns C<unix/> for UNIX domain sockets.
  
  This function works similarly to C<inet_ntop AF_INET || AF_INET6, ...>,
  except it automatically detects the address type.
  
  Returns C<undef> if it cannot detect the type.
  
  If the C<$ipn> is a mapped IPv4 in IPv6 address (:ffff::<ipv4>), then just
  the contained IPv4 address will be returned. If you do not want that, you
  have to call C<format_ipv6> manually.
  
  Example:
  
     print format_address "\x01\x02\x03\x05";
     => 1.2.3.5
  
  =item $text = AnyEvent::Socket::ntoa $ipn
  
  Same as format_address, but not exported (think C<inet_ntoa>).
  
  =cut
  
  sub format_ipv4($) {
     join ".", unpack "C4", $_[0]
  }
  
  sub format_ipv6($) {
     if ($_[0] =~ /^\x00\x00\x00\x00\x00\x00\x00\x00/) {
        if (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 eq $_[0]) {
           return "::";
        } elsif (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1 eq $_[0]) {
           return "::1";
        } elsif (v0.0.0.0.0.0.0.0.0.0.0.0 eq substr $_[0], 0, 12) {
           # v4compatible
           return "::" . format_ipv4 substr $_[0], 12;
        } elsif (v0.0.0.0.0.0.0.0.0.0.255.255 eq substr $_[0], 0, 12) {
           # v4mapped
           return "::ffff:" . format_ipv4 substr $_[0], 12;
        } elsif (v0.0.0.0.0.0.0.0.255.255.0.0 eq substr $_[0], 0, 12) {
           # v4translated
           return "::ffff:0:" . format_ipv4 substr $_[0], 12;
        }
     }
  
     my $ip = sprintf "%x:%x:%x:%x:%x:%x:%x:%x", unpack "n8", $_[0];
  
     # this is admittedly rather sucky
        $ip =~ s/(?:^|:) 0:0:0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)   0:0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)     0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)       0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)         0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)           0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)             0 (?:$|:)/::/x;
  
     $ip
  }
  
  sub format_address($) {
     if (4 == length $_[0]) {
        return &format_ipv4;
     } elsif (16 == length $_[0]) {
        return $_[0] =~ /^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff(....)$/s
           ? format_ipv4 $1
           : &format_ipv6;
     } elsif (AF_UNIX == address_family $_[0]) {
        return "unix/"
     } else {
        return undef
     }
  }
  
  *ntoa = \&format_address;
  
  =item inet_aton $name_or_address, $cb->(@addresses)
  
  Works similarly to its Socket counterpart, except that it uses a
  callback. Use the length to distinguish between ipv4 and ipv6 (4 octets
  for IPv4, 16 for IPv6), or use C<format_address> to convert it to a more
  readable format.
  
  Note that C<resolve_sockaddr>, while initially a more complex interface,
  resolves host addresses, IDNs, service names and SRV records and gives you
  an ordered list of socket addresses to try and should be preferred over
  C<inet_aton>.
  
  Example.
  
     inet_aton "www.google.com", my $cv = AE::cv;
     say unpack "H*", $_
        for $cv->recv;
     # => d155e363
     # => d155e367 etc.
  
     inet_aton "ipv6.google.com", my $cv = AE::cv;
     say unpack "H*", $_
        for $cv->recv;
     # => 20014860a00300000000000000000068
  
  =cut
  
  sub inet_aton {
     my ($name, $cb) = @_;
  
     if (my $ipn = &parse_ipv4) {
        $cb->($ipn);
     } elsif (my $ipn = &parse_ipv6) {
        $cb->($ipn);
     } elsif ($name eq "localhost") { # rfc2606 et al.
        $cb->(v127.0.0.1, v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1);
     } else {
        require AnyEvent::DNS unless $AnyEvent::DNS::VERSION;
  
        my $ipv4 = $AnyEvent::PROTOCOL{ipv4};
        my $ipv6 = $AnyEvent::PROTOCOL{ipv6};
  
        my @res;
  
        my $cv = AE::cv {
           $cb->(map @$_, reverse @res);
        };
  
        $cv->begin;
  
        if ($ipv4) {
           $cv->begin;
           AnyEvent::DNS::a ($name, sub {
              $res[$ipv4] = [map &parse_ipv4, @_];
              $cv->end;
           });
        };
  
        if ($ipv6) {
           $cv->begin;
           AnyEvent::DNS::aaaa ($name, sub {
              $res[$ipv6] = [map &parse_ipv6, @_];
              $cv->end;
           });
        };
  
        $cv->end;
     }
  }
  
  BEGIN {
     *sockaddr_family = $Socket::VERSION >= 1.75
        ? \&Socket::sockaddr_family
        : # for 5.6.x, we need to do something much more horrible
          (Socket::pack_sockaddr_in 0x5555, "\x55\x55\x55\x55"
             | eval { Socket::pack_sockaddr_un "U" }) =~ /^\x00/
             ? sub { unpack "xC", $_[0] }
             : sub { unpack "S" , $_[0] };
  }
  
  # check for broken platforms with an extra field in sockaddr structure
  # kind of a rfc vs. bsd issue, as usual (ok, normally it's a
  # unix vs. bsd issue, a iso C vs. bsd issue or simply a
  # correctness vs. bsd issue.)
  my $pack_family = 0x55 == sockaddr_family ("\x55\x55")
                    ? "xC" : "S";
  
  =item $sa = AnyEvent::Socket::pack_sockaddr $service, $host
  
  Pack the given port/host combination into a binary sockaddr
  structure. Handles both IPv4 and IPv6 host addresses, as well as UNIX
  domain sockets (C<$host> == C<unix/> and C<$service> == absolute
  pathname).
  
  Example:
  
     my $bind = AnyEvent::Socket::pack_sockaddr 43, v195.234.53.120;
     bind $socket, $bind
        or die "bind: $!";
  
  =cut
  
  sub pack_sockaddr($$) {
     my $af = address_family $_[1];
  
     if ($af == AF_INET) {
        Socket::pack_sockaddr_in $_[0], $_[1]
     } elsif ($af == AF_INET6) {
        pack "$pack_family nL a16 L",
           AF_INET6,
           $_[0], # port
           0,     # flowinfo
           $_[1], # addr
           0      # scope id
     } elsif ($af == AF_UNIX) {
        Socket::pack_sockaddr_un $_[0]
     } else {
        Carp::croak "pack_sockaddr: invalid host";
     }
  }
  
  =item ($service, $host) = AnyEvent::Socket::unpack_sockaddr $sa
  
  Unpack the given binary sockaddr structure (as used by bind, getpeername
  etc.) into a C<$service, $host> combination.
  
  For IPv4 and IPv6, C<$service> is the port number and C<$host> the host
  address in network format (binary).
  
  For UNIX domain sockets, C<$service> is the absolute pathname and C<$host>
  is a special token that is understood by the other functions in this
  module (C<format_address> converts it to C<unix/>).
  
  =cut
  
  # perl contains a bug (imho) where it requires that the kernel always returns
  # sockaddr_un structures of maximum length (which is not, AFAICS, required
  # by any standard). try to 0-pad structures for the benefit of those platforms.
  
  my $sa_un_zero = eval { Socket::pack_sockaddr_un "" }; $sa_un_zero ^= $sa_un_zero;
  
  sub unpack_sockaddr($) {
     my $af = sockaddr_family $_[0];
  
     if ($af == AF_INET) {
        Socket::unpack_sockaddr_in $_[0]
     } elsif ($af == AF_INET6) {
        unpack "x2 n x4 a16", $_[0]
     } elsif ($af == AF_UNIX) {
        ((Socket::unpack_sockaddr_un $_[0] ^ $sa_un_zero), pack "S", AF_UNIX)
     } else {
        Carp::croak "unpack_sockaddr: unsupported protocol family $af";
     }
  }
  
  =item resolve_sockaddr $node, $service, $proto, $family, $type, $cb->([$family, $type, $proto, $sockaddr], ...)
  
  Tries to resolve the given nodename and service name into protocol families
  and sockaddr structures usable to connect to this node and service in a
  protocol-independent way. It works remotely similar to the getaddrinfo
  posix function.
  
  For internet addresses, C<$node> is either an IPv4 or IPv6 address, an
  internet hostname (DNS domain name or IDN), and C<$service> is either
  a service name (port name from F</etc/services>) or a numerical port
  number. If both C<$node> and C<$service> are names, then SRV records
  will be consulted to find the real service, otherwise they will be
  used as-is. If you know that the service name is not in your services
  database, then you can specify the service in the format C<name=port>
  (e.g. C<http=80>).
  
  If a host cannot be found via DNS, then it will be looked up in
  F</etc/hosts> (or the file specified via C<< $ENV{PERL_ANYEVENT_HOSTS}
  >>). If they are found, the addresses there will be used. The effect is as
  if entries from F</etc/hosts> would yield C<A> and C<AAAA> records for the
  host name unless DNS already had records for them.
  
  For UNIX domain sockets, C<$node> must be the string C<unix/> and
  C<$service> must be the absolute pathname of the socket. In this case,
  C<$proto> will be ignored.
  
  C<$proto> must be a protocol name, currently C<tcp>, C<udp> or
  C<sctp>. The default is currently C<tcp>, but in the future, this function
  might try to use other protocols such as C<sctp>, depending on the socket
  type and any SRV records it might find.
  
  C<$family> must be either C<0> (meaning any protocol is OK), C<4> (use
  only IPv4) or C<6> (use only IPv6). The default is influenced by
  C<$ENV{PERL_ANYEVENT_PROTOCOLS}>.
  
  C<$type> must be C<SOCK_STREAM>, C<SOCK_DGRAM> or C<SOCK_SEQPACKET> (or
  C<undef> in which case it gets automatically chosen to be C<SOCK_STREAM>
  unless C<$proto> is C<udp>).
  
  The callback will receive zero or more array references that contain
  C<$family, $type, $proto> for use in C<socket> and a binary
  C<$sockaddr> for use in C<connect> (or C<bind>).
  
  The application should try these in the order given.
  
  Example:
  
     resolve_sockaddr "google.com", "http", 0, undef, undef, sub { ... };
  
  =cut
  
  our %HOSTS;
  our $HOSTS;
  
  if (
     open my $fh, "<",
        length $ENV{PERL_ANYEVENT_HOSTS} ? $ENV{PERL_ANYEVENT_HOSTS}
        : AnyEvent::WIN32                ? "$ENV{SystemRoot}/system32/drivers/etc/hosts"
        :                                  "/etc/hosts"
  ) {
     local $/;
     binmode $fh;
     $HOSTS = <$fh>;
  } else {
     $HOSTS = "";
  }
  
  sub _parse_hosts() {
     #%HOSTS = ();
  
     for (split /\n/, $HOSTS) {
        s/#.*$//;
        s/^[ \t]+//;
        y/A-Z/a-z/;
  
        my ($addr, @aliases) = split /[ \t]+/;
        next unless @aliases;
  
        if (my $ip = parse_ipv4 $addr) {
           push @{ $HOSTS{$_}[0] }, $ip
              for @aliases;
        } elsif (my $ip = parse_ipv6 $addr) {
           push @{ $HOSTS{$_}[1] }, $ip
              for @aliases;
        }
     }
  
     undef $HOSTS;
  }
  
  sub resolve_sockaddr($$$$$$) {
     my ($node, $service, $proto, $family, $type, $cb) = @_;
  
     if ($node eq "unix/") {
        return $cb->() if $family || $service !~ /^\//; # no can do
  
        return $cb->([AF_UNIX, defined $type ? $type : SOCK_STREAM, 0, Socket::pack_sockaddr_un $service]);
     }
  
     unless (AF_INET6) {
        $family != 6
           or return $cb->();
  
        $family = 4;
     }
  
     $cb->() if $family == 4 && !$AnyEvent::PROTOCOL{ipv4};
     $cb->() if $family == 6 && !$AnyEvent::PROTOCOL{ipv6};
  
     $family ||= 4 unless $AnyEvent::PROTOCOL{ipv6};
     $family ||= 6 unless $AnyEvent::PROTOCOL{ipv4};
  
     $proto ||= "tcp";
     $type  ||= $proto eq "udp" ? SOCK_DGRAM : SOCK_STREAM;
  
     my $proton = AnyEvent::Socket::getprotobyname $proto
        or Carp::croak "$proto: protocol unknown";
  
     my $port;
  
     if ($service =~ /^(\S+)=(\d+)$/) {
        ($service, $port) = ($1, $2);
     } elsif ($service =~ /^\d+$/) {
        ($service, $port) = (undef, $service);
     } else {
        $port = (getservbyname $service, $proto)[2]
                or Carp::croak "$service/$proto: service unknown";
     }
  
     # resolve a records / provide sockaddr structures
     my $resolve = sub {
        my @target = @_;
  
        my @res;
        my $cv = AE::cv {
           $cb->(
              map $_->[2],
              sort {
                 $AnyEvent::PROTOCOL{$b->[1]} <=> $AnyEvent::PROTOCOL{$a->[1]}
                    or $a->[0] <=> $b->[0]
              }
              @res
           )
        };
  
        $cv->begin;
        for my $idx (0 .. $#target) {
           my ($node, $port) = @{ $target[$idx] };
  
           if (my $noden = parse_address $node) {
              my $af = address_family $noden;
  
              if ($af == AF_INET && $family != 6) {
                 push @res, [$idx, "ipv4", [AF_INET, $type, $proton,
                             pack_sockaddr $port, $noden]]
              }
  
              if ($af == AF_INET6 && $family != 4) {
                 push @res, [$idx, "ipv6", [AF_INET6, $type, $proton,
                             pack_sockaddr $port, $noden]]
              }
           } else {
              $node =~ y/A-Z/a-z/;
  
              my $hosts = $HOSTS{$node};
  
              # a records
              if ($family != 6) {
                 $cv->begin;
                 AnyEvent::DNS::a $node, sub {
                    push @res, [$idx, "ipv4", [AF_INET , $type, $proton, pack_sockaddr $port, parse_ipv4 $_]]
                       for @_;
  
                    # dns takes precedence over hosts
                    push @res,
                       map [$idx, "ipv4", [AF_INET , $type, $proton, pack_sockaddr $port, $_]],
                          @{ $hosts->[0] }
                       unless @_;
  
                    $cv->end;
                 };
              }
  
              # aaaa records
              if ($family != 4) {
                 $cv->begin;
                 AnyEvent::DNS::aaaa $node, sub {
                    push @res, [$idx, "ipv6", [AF_INET6, $type, $proton, pack_sockaddr $port, parse_ipv6 $_]]
                       for @_;
  
                    push @res,
                       map [$idx + 0.5, "ipv6", [AF_INET6, $type, $proton, pack_sockaddr $port, $_]],
                          @{ $hosts->[1] }
                       unless @_;
  
                    $cv->end;
                 };
              }
           }
        }
        $cv->end;
     };
  
     $node = AnyEvent::Util::idn_to_ascii $node
        if $node =~ /[^\x00-\x7f]/;
  
     # parse hosts
     if (defined $HOSTS) {
        _parse_hosts;
        undef &_parse_hosts;
     }
  
     # try srv records, if applicable
     if ($node eq "localhost") {
        $resolve->(["127.0.0.1", $port], ["::1", $port]);
     } elsif (defined $service && !parse_address $node) {
        AnyEvent::DNS::srv $service, $proto, $node, sub {
           my (@srv) = @_;
  
           if (@srv) {
              # the only srv record has "." ("" here) => abort
              $srv[0][2] ne "" || $#srv
                 or return $cb->();
  
              # use srv records then
              $resolve->(
                 map ["$_->[3].", $_->[2]],
                    grep $_->[3] ne ".",
                       @srv
              );
           } else {
              # no srv records, continue traditionally
              $resolve->([$node, $port]);
           }
        };
     } else {
        # most common case
        $resolve->([$node, $port]);
     }
  }
  
  =item $guard = tcp_connect $host, $service, $connect_cb[, $prepare_cb]
  
  This is a convenience function that creates a TCP socket and makes a
  100% non-blocking connect to the given C<$host> (which can be a DNS/IDN
  hostname or a textual IP address, or the string C<unix/> for UNIX domain
  sockets) and C<$service> (which can be a numeric port number or a service
  name, or a C<servicename=portnumber> string, or the pathname to a UNIX
  domain socket).
  
  If both C<$host> and C<$port> are names, then this function will use SRV
  records to locate the real target(s).
  
  In either case, it will create a list of target hosts (e.g. for multihomed
  hosts or hosts with both IPv4 and IPv6 addresses) and try to connect to
  each in turn.
  
  After the connection is established, then the C<$connect_cb> will be
  invoked with the socket file handle (in non-blocking mode) as first, and
  the peer host (as a textual IP address) and peer port as second and third
  arguments, respectively. The fourth argument is a code reference that you
  can call if, for some reason, you don't like this connection, which will
  cause C<tcp_connect> to try the next one (or call your callback without
  any arguments if there are no more connections). In most cases, you can
  simply ignore this argument.
  
     $cb->($filehandle, $host, $port, $retry)
  
  If the connect is unsuccessful, then the C<$connect_cb> will be invoked
  without any arguments and C<$!> will be set appropriately (with C<ENXIO>
  indicating a DNS resolution failure).
  
  The callback will I<never> be invoked before C<tcp_connect> returns, even
  if C<tcp_connect> was able to connect immediately (e.g. on unix domain
  sockets).
  
  The file handle is perfect for being plugged into L<AnyEvent::Handle>, but
  can be used as a normal perl file handle as well.
  
  Unless called in void context, C<tcp_connect> returns a guard object that
  will automatically cancel the connection attempt when it gets destroyed
  - in which case the callback will not be invoked. Destroying it does not
  do anything to the socket after the connect was successful - you cannot
  "uncall" a callback that has been invoked already.
  
  Sometimes you need to "prepare" the socket before connecting, for example,
  to C<bind> it to some port, or you want a specific connect timeout that
  is lower than your kernel's default timeout. In this case you can specify
  a second callback, C<$prepare_cb>. It will be called with the file handle
  in not-yet-connected state as only argument and must return the connection
  timeout value (or C<0>, C<undef> or the empty list to indicate the default
  timeout is to be used).
  
  Note that the socket could be either a IPv4 TCP socket or an IPv6 TCP
  socket (although only IPv4 is currently supported by this module).
  
  Note to the poor Microsoft Windows users: Windows (of course) doesn't
  correctly signal connection errors, so unless your event library works
  around this, failed connections will simply hang. The only event libraries
  that handle this condition correctly are L<EV> and L<Glib>. Additionally,
  AnyEvent works around this bug with L<Event> and in its pure-perl
  backend. All other libraries cannot correctly handle this condition. To
  lessen the impact of this windows bug, a default timeout of 30 seconds
  will be imposed on windows. Cygwin is not affected.
  
  Simple Example: connect to localhost on port 22.
  
     tcp_connect localhost => 22, sub {
        my $fh = shift
           or die "unable to connect: $!";
        # do something
     };
  
  Complex Example: connect to www.google.com on port 80 and make a simple
  GET request without much error handling. Also limit the connection timeout
  to 15 seconds.
  
     tcp_connect "www.google.com", "http",
        sub {
           my ($fh) = @_
              or die "unable to connect: $!";
  
           my $handle; # avoid direct assignment so on_eof has it in scope.
           $handle = new AnyEvent::Handle
              fh     => $fh,
              on_error => sub {
                 AE::log error => "error $_[2]";
                 $_[0]->destroy;
              },
              on_eof => sub {
                 $handle->destroy; # destroy handle
                 AE::log info => "done.";
              };
  
           $handle->push_write ("GET / HTTP/1.0\015\012\015\012");
  
           $handle->push_read (line => "\015\012\015\012", sub {
              my ($handle, $line) = @_;
  
              # print response header
              print "HEADER\n$line\n\nBODY\n";
  
              $handle->on_read (sub {
                 # print response body
                 print $_[0]->rbuf;
                 $_[0]->rbuf = "";
              });
           });
        }, sub {
           my ($fh) = @_;
           # could call $fh->bind etc. here
  
           15
        };
  
  Example: connect to a UNIX domain socket.
  
     tcp_connect "unix/", "/tmp/.X11-unix/X0", sub {
        ...
     }
  
  =cut
  
  sub tcp_connect($$$;$) {
     my ($host, $port, $connect, $prepare) = @_;
  
     # see http://cr.yp.to/docs/connect.html for some tricky aspects
     # also http://advogato.org/article/672.html
  
     my %state = ( fh => undef );
  
     # name/service to type/sockaddr resolution
     resolve_sockaddr $host, $port, 0, 0, undef, sub {
        my @target = @_;
  
        $state{next} = sub {
           return unless exists $state{fh};
  
           my $errno = $!;
           my $target = shift @target
              or return AE::postpone {
                 return unless exists $state{fh};
                 %state = ();
                 $! = $errno;
                 $connect->();
              };
  
           my ($domain, $type, $proto, $sockaddr) = @$target;
  
           # socket creation
           socket $state{fh}, $domain, $type, $proto
              or return $state{next}();
  
           fh_nonblocking $state{fh}, 1;
           
           my $timeout = $prepare && $prepare->($state{fh});
  
           $timeout ||= 30 if AnyEvent::WIN32;
  
           $state{to} = AE::timer $timeout, 0, sub {
              $! = Errno::ETIMEDOUT;
              $state{next}();
           } if $timeout;
  
           # now connect       
           if (
              (connect $state{fh}, $sockaddr)
              || ($! == Errno::EINPROGRESS # POSIX
                  || $! == Errno::EWOULDBLOCK
                  # WSAEINPROGRESS intentionally not checked - it means something else entirely
                  || $! == AnyEvent::Util::WSAEINVAL # not convinced, but doesn't hurt
                  || $! == AnyEvent::Util::WSAEWOULDBLOCK)
           ) {
              $state{ww} = AE::io $state{fh}, 1, sub {
                 # we are connected, or maybe there was an error
                 if (my $sin = getpeername $state{fh}) {
                    my ($port, $host) = unpack_sockaddr $sin;
  
                    delete $state{ww}; delete $state{to};
  
                    my $guard = guard { %state = () };
  
                    $connect->(delete $state{fh}, format_address $host, $port, sub {
                       $guard->cancel;
                       $state{next}();
                    });
                 } else {
                    if ($! == Errno::ENOTCONN) {
                       # dummy read to fetch real error code if !cygwin
                       sysread $state{fh}, my $buf, 1;
  
                       # cygwin 1.5 continously reports "ready' but never delivers
                       # an error with getpeername or sysread.
                       # cygwin 1.7 only reports readyness *once*, but is otherwise
                       # the same, which is actually more broken.
                       # Work around both by using unportable SO_ERROR for cygwin.
                       $! = (unpack "l", getsockopt $state{fh}, Socket::SOL_SOCKET(), Socket::SO_ERROR()) || Errno::EAGAIN
                          if AnyEvent::CYGWIN && $! == Errno::EAGAIN;
                    }
  
                    return if $! == Errno::EAGAIN; # skip spurious wake-ups
  
                    delete $state{ww}; delete $state{to};
  
                    $state{next}();
                 }
              };
           } else {
              $state{next}();
           }
        };
  
        $! = Errno::ENXIO;
        $state{next}();
     };
  
     defined wantarray && guard { %state = () }
  }
  
  =item $guard = tcp_server $host, $service, $accept_cb[, $prepare_cb]
  
  Create and bind a stream socket to the given host address and port, set
  the SO_REUSEADDR flag (if applicable) and call C<listen>. Unlike the name
  implies, this function can also bind on UNIX domain sockets.
  
  For internet sockets, C<$host> must be an IPv4 or IPv6 address (or
  C<undef>, in which case it binds either to C<0> or to C<::>, depending
  on whether IPv4 or IPv6 is the preferred protocol, and maybe to both in
  future versions, as applicable).
  
  To bind to the IPv4 wildcard address, use C<0>, to bind to the IPv6
  wildcard address, use C<::>.
  
  The port is specified by C<$service>, which must be either a service name
  or a numeric port number (or C<0> or C<undef>, in which case an ephemeral
  port will be used).
  
  For UNIX domain sockets, C<$host> must be C<unix/> and C<$service> must be
  the absolute pathname of the socket. This function will try to C<unlink>
  the socket before it tries to bind to it, and will try to unlink it after
  it stops using it. See SECURITY CONSIDERATIONS, below.
  
  For each new connection that could be C<accept>ed, call the C<<
  $accept_cb->($fh, $host, $port) >> with the file handle (in non-blocking
  mode) as first, and the peer host and port as second and third arguments
  (see C<tcp_connect> for details).
  
  Croaks on any errors it can detect before the listen.
  
  If called in non-void context, then this function returns a guard object
  whose lifetime it tied to the TCP server: If the object gets destroyed,
  the server will be stopped (but existing accepted connections will
  not be affected).
  
  If you need more control over the listening socket, you can provide a
  C<< $prepare_cb->($fh, $host, $port) >>, which is called just before the
  C<listen ()> call, with the listen file handle as first argument, and IP
  address and port number of the local socket endpoint as second and third
  arguments.
  
  It should return the length of the listen queue (or C<0> for the default).
  
  Note to IPv6 users: RFC-compliant behaviour for IPv6 sockets listening on
  C<::> is to bind to both IPv6 and IPv4 addresses by default on dual-stack
  hosts. Unfortunately, only GNU/Linux seems to implement this properly, so
  if you want both IPv4 and IPv6 listening sockets you should create the
  IPv6 socket first and then attempt to bind on the IPv4 socket, but ignore
  any C<EADDRINUSE> errors.
  
  Example: bind on some TCP port on the local machine and tell each client
  to go away.
  
     tcp_server undef, undef, sub {
        my ($fh, $host, $port) = @_;
  
        syswrite $fh, "The internet is full, $host:$port. Go away!\015\012";
     }, sub {
        my ($fh, $thishost, $thisport) = @_;
        AE::log info => "bound to $thishost, port $thisport";
     };
  
  Example: bind a server on a unix domain socket.
  
     tcp_server "unix/", "/tmp/mydir/mysocket", sub {
        my ($fh) = @_;
     };
  
  =cut
  
  sub tcp_server($$$;$) {
     my ($host, $service, $accept, $prepare) = @_;
  
     $host = $AnyEvent::PROTOCOL{ipv4} < $AnyEvent::PROTOCOL{ipv6} && AF_INET6
             ? "::" : "0"
        unless defined $host;
  
     my $ipn = parse_address $host
        or Carp::croak "AnyEvent::Socket::tcp_server: cannot parse '$host' as host address";
  
     my $af = address_family $ipn;
  
     my %state;
  
     # win32 perl is too stupid to get this right :/
     Carp::croak "tcp_server/socket: address family not supported"
        if AnyEvent::WIN32 && $af == AF_UNIX;
  
     socket $state{fh}, $af, SOCK_STREAM, 0
        or Carp::croak "tcp_server/socket: $!";
  
     if ($af == AF_INET || $af == AF_INET6) {
        setsockopt $state{fh}, SOL_SOCKET, SO_REUSEADDR, 1
           or Carp::croak "tcp_server/so_reuseaddr: $!"
              unless AnyEvent::WIN32; # work around windows bug
  
        unless ($service =~ /^\d*$/) {
           $service = (getservbyname $service, "tcp")[2]
                      or Carp::croak "$service: service unknown"
        }
     } elsif ($af == AF_UNIX) {
        unlink $service;
     }
  
     bind $state{fh}, pack_sockaddr $service, $ipn
        or Carp::croak "bind: $!";
  
     if ($af == AF_UNIX) {
        my $fh  = $state{fh};
        my $ino = (stat $fh)[1];
        $state{unlink} = guard {
           # this is racy, but is not designed to be foolproof, just best-effort
           unlink $service
              if $ino == (stat $fh)[1];
        };
     }
  
     fh_nonblocking $state{fh}, 1;
  
     my $len;
  
     if ($prepare) {
        my ($service, $host) = unpack_sockaddr getsockname $state{fh};
        $len = $prepare && $prepare->($state{fh}, format_address $host, $service);
     }
     
     $len ||= 128;
  
     listen $state{fh}, $len
        or Carp::croak "listen: $!";
  
     $state{aw} = AE::io $state{fh}, 0, sub {
        # this closure keeps $state alive
        while ($state{fh} && (my $peer = accept my $fh, $state{fh})) {
           fh_nonblocking $fh, 1; # POSIX requires inheritance, the outside world does not
  
           my ($service, $host) = unpack_sockaddr $peer;
           $accept->($fh, format_address $host, $service);
        }
     };
  
     defined wantarray
        ? guard { %state = () } # clear fh and watcher, which breaks the circular dependency
        : ()
  }
  
  =item tcp_nodelay $fh, $enable
  
  Enables (or disables) the C<TCP_NODELAY> socket option (also known as
  Nagle's algorithm). Returns false on error, true otherwise.
  
  =cut
  
  sub tcp_nodelay($$) {
     my $onoff = int ! ! $_[1];
  
     setsockopt $_[0], Socket::IPPROTO_TCP (), Socket::TCP_NODELAY (), $onoff
  }
  
  =item tcp_congestion $fh, $algorithm
  
  Sets the tcp congestion avoidance algorithm (via the C<TCP_CONGESTION>
  socket option). The default is OS-specific, but is usually
  C<reno>. Typical other available choices include C<cubic>, C<lp>, C<bic>,
  C<highspeed>, C<htcp>, C<hybla>, C<illinois>, C<scalable>, C<vegas>,
  C<veno>, C<westwood> and C<yeah>.
  
  =cut
  
  sub tcp_congestion($$) {
     defined TCP_CONGESTION
        ? setsockopt $_[0], Socket::IPPROTO_TCP (), TCP_CONGESTION, "$_[1]"
        : undef
  }
  
  1;
  
  =back
  
  =head1 SECURITY CONSIDERATIONS
  
  This module is quite powerful, with with power comes the ability to abuse
  as well: If you accept "hostnames" and ports from untrusted sources,
  then note that this can be abused to delete files (host=C<unix/>). This
  is not really a problem with this module, however, as blindly accepting
  any address and protocol and trying to bind a server or connect to it is
  harmful in general.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_SOCKET

$fatpacked{"darwin-2level/AnyEvent/Strict.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_STRICT';
  =head1 NAME
  
  AnyEvent::Strict - force strict mode on for the whole process
  
  =head1 SYNOPSIS
  
     use AnyEvent::Strict;
     # strict mode now switched on
  
  =head1 DESCRIPTION
  
  This module implements AnyEvent's strict mode.
  
  Loading it makes AnyEvent check all arguments to AnyEvent-methods, at the
  expense of being slower (often the argument checking takes longer than the
  actual function). It also wraps all callbacks to check for modifications
  of C<$_>, which indicates a programming bug inside the watcher callback.
  
  Normally, you don't load this module yourself but instead use it
  indirectly via the C<PERL_ANYEVENT_STRICT> environment variable (see
  L<AnyEvent>). However, this module can be loaded manually at any time.
  
  =cut
  
  package AnyEvent::Strict;
  
  use Carp qw(croak);
  use Errno ();
  use POSIX ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  AnyEvent::_isa_hook 1 => "AnyEvent::Strict", 1;
  
  BEGIN {
     if (defined &Internals::SvREADONLY) {
        # readonly available (at least 5.8.9+, working better in 5.10.1+)
        *wrap = sub {
           my $cb = shift;
  
           sub {
              local $_;
              Internals::SvREADONLY $_, 1;
              &$cb;
           }
        };
     } else {
        # or not :/
        my $magic = []; # a unique magic value
  
        *wrap = sub {
           my $cb = shift;
  
           sub {
              local $_ = $magic;
  
              &$cb;
  
              if (!ref $_ || $_ != $magic) {
                 require AnyEvent::Debug;
                 die "callback $cb (" . AnyEvent::Debug::cb2str ($cb) . ") modified \$_ without restoring it.\n";
              }
           }
        };
     }
  }
  
  our (@FD_INUSE, $FD_I);
  our $FD_CHECK_W = AE::timer 4, 4, sub {
     my $cnt = (@FD_INUSE < 100 * 10 ? int @FD_INUSE * 0.1 : 100) || 10;
  
     if ($FD_I <= 0) {
        #pop @FD_INUSE while @FD_INUSE && !$FD_INUSE[-1];
        $FD_I = @FD_INUSE
           or return; # empty
     }
  
     $cnt = $FD_I if $cnt > $FD_I;
  
     eval {
        do {
           !$FD_INUSE[--$FD_I]
              or (POSIX::lseek $FD_I, 0, 1) != -1
              or $! != Errno::EBADF
              or die;
        } while --$cnt;
        1
     } or AE::log crit => "file descriptor $FD_I registered with AnyEvent but prematurely closed, event loop might malfunction.\n";
  };
  
  sub io {
     my $class = shift;
     my (%arg, $fh, $cb, $fd) = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->io called with illegal cb argument '$arg{cb}'";
     $cb = wrap delete $arg{cb};
   
     $arg{poll} =~ /^[rw]$/
        or croak "AnyEvent->io called with illegal poll argument '$arg{poll}'";
  
     $fh = delete $arg{fh};
  
     if ($fh =~ /^\s*\d+\s*$/) {
        $fd = $fh;
        $fh = AnyEvent::_dupfh $arg{poll}, $fh;
     } else {
        defined eval { $fd = fileno $fh }
           or croak "AnyEvent->io called with illegal fh argument '$fh'";
     }
  
     -f $fh
        and croak "AnyEvent->io called with fh argument pointing to a file";
  
     delete $arg{poll};
   
     croak "AnyEvent->io called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     ++$FD_INUSE[$fd];
  
     bless [
        $fd,
        $class->SUPER::io (@_, cb => $cb)
     ], "AnyEvent::Strict::io";
  }
  
  sub AnyEvent::Strict::io::DESTROY {
     --$FD_INUSE[$_[0][0]];
  }
  
  sub timer {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->timer called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     exists $arg{after}
        or croak "AnyEvent->timer called without mandatory 'after' parameter";
     delete $arg{after};
   
     !$arg{interval} or $arg{interval} > 0
        or croak "AnyEvent->timer called with illegal interval argument '$arg{interval}'";
     delete $arg{interval};
   
     croak "AnyEvent->timer called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::timer (@_, cb => $cb)
  }
  
  sub signal {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->signal called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     defined AnyEvent::Base::sig2num $arg{signal} and $arg{signal} == 0
        or croak "AnyEvent->signal called with illegal signal name '$arg{signal}'";
     delete $arg{signal};
   
     croak "AnyEvent->signal called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::signal (@_, cb => $cb)
  }
  
  sub child {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->child called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     $arg{pid} =~ /^-?\d+$/
        or croak "AnyEvent->child called with malformed pid value '$arg{pid}'";
     delete $arg{pid};
   
     croak "AnyEvent->child called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::child (@_, cb => $cb)
  }
  
  sub idle {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or croak "AnyEvent->idle called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     croak "AnyEvent->idle called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::idle (@_, cb => $cb)
  }
  
  sub condvar {
     my $class = shift;
     my %arg = @_;
  
     !exists $arg{cb} or ref $arg{cb}
        or croak "AnyEvent->condvar called with illegal cb argument '$arg{cb}'";
     my @cb = exists $arg{cb} ? (cb => wrap delete $arg{cb}) : ();
   
     croak "AnyEvent->condvar called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::condvar (@cb);
  }
  
  sub time {
     my $class = shift;
  
     @_
        and croak "AnyEvent->time wrongly called with paramaters";
  
     $class->SUPER::time (@_)
  }
  
  sub now {
     my $class = shift;
  
     @_
        and croak "AnyEvent->now wrongly called with paramaters";
  
     $class->SUPER::now (@_)
  }
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_STRICT

$fatpacked{"darwin-2level/AnyEvent/TLS.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_TLS';
  package AnyEvent::TLS;
  
  use Carp qw(croak);
  use Scalar::Util ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  
  use Net::SSLeay;
  
  =head1 NAME
  
  AnyEvent::TLS - SSLv2/SSLv3/TLSv1 contexts for use in AnyEvent::Handle
  
  =cut
  
  our $VERSION = $AnyEvent::VERSION;
  
  =head1 SYNOPSIS
  
     # via AnyEvent::Handle
  
     use AnyEvent;
     use AnyEvent::Handle;
     use AnyEvent::Socket;
  
     # simple https-client
     my $handle = new AnyEvent::Handle
        connect  => [$host, $port],
        tls      => "connect",
        tls_ctx  => { verify => 1, verify_peername => "https" },
        ...
  
     # simple ssl-server
     tcp_server undef, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh       => $fh,
           tls      => "accept",
           tls_ctx  => { cert_file => "my-server-keycert.pem" },
           ...
  
     # directly
  
     my $tls = new AnyEvent::TLS
        verify => 1,
        verify_peername => "ldaps",
        ca_file => "/etc/cacertificates.pem";
  
  =head1 DESCRIPTION
  
  This module is a helper module that implements TLS/SSL (Transport Layer
  Security/Secure Sockets Layer) contexts. A TLS context is a common set of
  configuration values for use in establishing TLS connections.
  
  For some quick facts about SSL/TLS, see the section of the same name near
  the end of the document.
  
  A single TLS context can be used for any number of TLS connections that
  wish to use the same certificates, policies etc.
  
  Note that this module is inherently tied to L<Net::SSLeay>, as this
  library is used to implement it. Since that perl module is rather ugly,
  and OpenSSL has a rather ugly license, AnyEvent might switch TLS providers
  at some future point, at which this API will change dramatically, at least
  in the Net::SSLeay-specific parts (most constructor arguments should still
  work, though).
  
  Although this module does not require a specific version of Net::SSLeay,
  many features will gradually stop working, or bugs will be introduced with
  old versions (verification might succeed when it shouldn't - this is a
  real security issue). Version 1.35 is recommended, 1.33 should work, 1.32
  might, and older versions are yours to keep.
  
  =head1 USAGE EXAMPLES
  
  See the L<AnyEvent::Handle> manpage, NONFREQUENTLY ASKED QUESTIONS, for
  some actual usage examples.
  
  =head1 PUBLIC METHODS AND FUNCTIONS
  
  =over 4
  
  =cut
  
  our $REF_IDX; # our session ex_data id
  
  # create temp file, populate it, and return a guard and filename
  sub _tmpfile($) {
     require File::Temp unless $File::Temp::VERSION;
  
     # File::Temp opens the file with mode 0600
     my ($fh, $path) = File::Temp::tempfile ("aetlsXXXXXXXXX", TMPDIR => 1, EXLOCK => 0);
     my $guard = AnyEvent::Util::guard { unlink $path };
  
     syswrite $fh, $_[0];
     close $fh;
  
     ($path, $guard)
  }
  
  our %DH_PARAMS = (
     # These are the DH parameters from "Assigned Number for SKIP Protocols"
     # (http://www.skip-vpn.org/spec/numbers.html).
     # (or http://web.archive.org/web/20011212141438/http://www.skip-vpn.org/spec/numbers.html#params)
     # See there for how they were generated.
     # Note that g might not be a generator,
     # but this is not a problem since p is a safe prime.
     skip512 => "MEYCQQD1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak|XUGfnHy9iUsiGSa6q6Jew1XpKgVfAgEC",
     skip1024 => "MIGHAoGBAPSI/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsY|jY67VYy4XTjTNP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6|ypUM2Zafq9AKUJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XpL3jHAgEC",
     skip2048 => "MIIBCAKCAQEA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadWoxTpj0BV|89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeSWc39uK50|T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0iP1YTknb|zSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF040zT9fBdX|Q6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQClCbAkbT|CD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwIBAg==",
     skip4096 => "MIICCAKCAgEA+hRyUsFN4VpJ1O8JLcCo/VWr19k3BCgJ4uk+d+KhehjdRqNDNyOQ|l/MOyQNQfWXPeGKmOmIig6Ev/nm6Nf9Z2B1h3R4hExf+zTiHnvVPeRBhjdQi81rt|Xeoh6TNrSBIKIHfUJWBh3va0TxxjQIs6IZOLeVNRLMqzeylWqMf49HsIXqbcokUS|Vt1BkvLdW48j8PPv5DsKRN3tloTxqDJGo9tKvj1Fuk74A+Xda1kNhB7KFlqMyN98|VETEJ6c7KpfOo30mnK30wqw3S8OtaIR/maYX72tGOno2ehFDkq3pnPtEbD2CScxc|alJC+EL7RPk5c/tgeTvCngvc1KZn92Y//EI7G9tPZtylj2b56sHtMftIoYJ9+ODM|sccD5Piz/rejE3Ome8EOOceUSCYAhXn8b3qvxVI1ddd1pED6FHRhFvLrZxFvBEM9|ERRMp5QqOaHJkM+Dxv8Cj6MqrCbfC4u+ZErxodzuusgDgvZiLF22uxMZbobFWyte|OvOzKGtwcTqO/1wV5gKkzu1ZVswVUQd5Gg8lJicwqRWyyNRczDDoG9jVDxmogKTH|AaqLulO7R8Ifa1SwF2DteSGVtgWEN8gDpN3RBmmPTDngyF2DHb5qmpnznwtFKdTL|KWbuHn491xNO25CQWMtem80uKw+pTnisBRF/454n1Jnhub144YRBoN8CAQI=",
  
     # generated on a linux desktop with openssl using /dev/urandom - entropy_avail was >= 3600 each time
     # the 8192 bit key took 25 hours to generate :/
     schmorp1024 => "MIGHAoGBAN+GjqAhNxLesSuGfDzYe6HdexXtHuxe85umshfPHfnmLSkGWl/FE27+|v+50mwY5XaNnCmo1VvGju4iTKxWoZTGgslUSc8KX197XWAXIpab8ESyg442if9Kr|vSOuu0fopwvvTOgHK8mkEWI4joU5G4/MQy+pnC5NIEVBP4HtGiTrAgEC",
     schmorp1539 => "MIHHAoHBByJzpVGUsXysX8w/+uuXRUCL9exhAixoHkaJU5lf4noJUtp9F0yr/5rb|hF8M9mSZJ+RlPyB+Zt37GPp1WQDO1+/2yZJX9kHE3+h5JCRoR8PKc2G+ts9jhM7r|CnTQ0z0b6s12Pusf+UhQPwLust4JAYE/LPuTK8yFiVx5L2a+aZhGMVlYN/12SEtY|jRl3lGXdZj9g8E2PzTQbA9CGy5dGIvz/ENTzTVleKuQ+80bzpVEPjZL9tv43Zc+l|MFLzxuE5uwIBAg==",
     schmorp2048 => "MIIBCAKCAQEAhR5Fn9h3Tgnc+q4o3CMkZtre3lLUyDT+1bf3aiVOt22JdDQndZLc|FeKz8AqliB3UIgNExc6oDtuG4znKPgklfOnHv/a9tl1AYQbV+QFM/E0jYl6oG8tF|Epgxezt1GCivvtu64ql0s213wr64QffNMt3hva8lNqK1PXfqp13PzzLzAVsfghrv|fMAX7/bYm1T5fAJdcah6FeZkKof+mqbs8HtRjfvrUF2npEM2WdupFu190vcwABnN|TTJheXCWv2BF2f9EEr61q3OUhSNWIThtZP+NKe2bACm1PebT0drAcaxKoMz9LjKr|y5onGs0TOuQ7JmhtZL45Zr4LwBcyTucLUwIBAg==",
     schmorp4096 => "MIICCAKCAgEA5WwA5lQg09YRYqc/JILCd2AfBmYBkF19wmCEJB8G3JhTxv8EGvYk|xyP2ecKVUvHTG8Xw/qpW8nRqzPIyV8QRf6YFYSf33Qnx2xYhcnqOumU3nfC0SNOL|/w2q1BA9BbHtW4574P+6hOQx9ftRtbtZ2HPKBMRcAKGjpYZiKopv0+UAM4NpEC2p|bfajp7pyVLeb/Aqm/oWP3L63wPlY1SDp+XRzrOAKB+/uLGqEwV0bBaxxGL29BpOp|O2z1ALGXiDCcLs9WTn9WqUhWDzUN6fahm53rd7zxwpFCb6K2YhaK0peG95jzSUJ8|aoL0KgWuC6v5+gPJHRu0HrQIdfAdN4VchqYOKE46uNNkQl8VJGu4RjYB7lFBpRwO|g2HCsGMo2X7BRmA1st66fh+JOd1smXMZG/2ozTOooL+ixcx4spNneg4aQerWl5cb|nWXKtPCp8yPzt/zoNzL3Fon2Ses3sNgMos0M/ZbnigScDxz84Ms6V/X8Z0L4m/qX|mL42dP40tgvmgqi6BdsBzcIWeHlEcIhmGcsEBxxKEg7gjb0OjjvatpUCJhmRrGjJ|LtMkBR68qr42OBMN/PBB4KPOWNUqTauXZajfCwYdbpvV24ZhtkcRdw1zisyARBSh|aTKW/GV8iLsUzlYN27LgVEwMwnWQaoecW6eOTNKGUURC3In6XZSvVzsCAQI=",
     schmorp8192 => "MIIECAKCBAEA/SAEbRSSLenVxoInHiltm/ztSwehGOhOiUKfzDcKlRBZHlCC9jBl|S/aeklM6Ucg8E6J2bnfoh6CAdnE/glQOn6CifhZr8X/rnlL9/eP+r9m+aiAw4l0D|MBd8BondbEqwTZthMmLtx0SslnevsFAZ1Cj8WgmUNaSPOukvJ1N7aQ98U+E99Pw3|VG8ANBydXqLqW2sogS8FtZoMbVywcQuaGmC7M6i3Akxe3CCSIpR/JkEZIytREBSC|CH+x3oW/w+wHzq3w8DGB9hqz1iMXqDMiPIMSdXC0DaIPokLnd7X8u6N14yCAco2h|P0gspD3J8pS2FpUY8ZTVjzbVCjhNNmTryBZAxHSWBuX4xYcCHUtfGlUe/IGLSVE1|xIdFpZUfvlvAJjVq0/TtDMg3r2JSXrhQVlr8MPJwSApDVr5kOBHT/uABio4z+5yR|PAvundznfyo9GGAWhIA36GQqsxSQfoRTjWssFoR/cu+9aomRwwOLkvObu8nCVVLH|nLdKDk5cIR0TvNs9HZ6ZmkzL7ah7cPzEKl7U6eE6yZLVYMNecnPLS6PSAIG4gxcq|CVQrrZjQLfTDrJn0OGgpShX85RaDsuiRtp2bpDZ23YDqdwr4wRjvIargjqc2zcF+|jIb7dUS6ci7bVG/CGOQUuiMWAiXZ3a1f343SMf9A05/sf1xwnMeco6STBLZ3X+PA|4urU+grtpWaFtS/fPD2ILn8nrJ3WuSKKUeSnVM46mmJQsOkyn7z8l3jNLB17GYKo|qc+0UuU/2PM9qtZdZElSM/ACLV2vdCuaibop4B9UIP9z3F8kfZ72+zKxpGiE+Bo1|x8SfG8FQw90mYIx+qZzJ8MCvc2wh+l4wDX5KxrhwvcouE2tHQlwfDgv/DiIXp173|hAmUCV0+bPRW8IIJvBODdAWtJe9hNwxj1FFYmPA7l4wa3gXV4I6tb+iO1MbwVjZ/|116tD5MdCo3JuSisgPYCHfkQccwEO0FHEuBbmfN+fQimQ8H0dePP8XctwbkplsB+|aLT5hYKmva/j9smEswgyHglPwc3WvZ+2DgKk7A7DHi7a2gDwCRQlHaXtNWx3992R|dfNgkSeB1CvGSQoo95WpC9ZoqGmcSlVqdetDU8iglPmfYTKO8aIPA6TuTQ/lQ0IW|90LQmqP23FwnNFiyqX8+rztLq4KVkTyeHIQwig6vFxgD8N+SbZCW2PPiB72TVF2U|WePU8MRTv1OIGBUBajF49k28HnZPSGlILHtFEkYkbPvomcE5ENnoejwzjktOTS5d|/R3SIOvCauOzadtzwTYOXT78ORaR1KI1cm8DzkkwJTd/Rrk07Q5vnvnSJQMwFUeH|PwJIgWBQf/GZ/OsDHmkbYR2ZWDClbKw2mwIBAg==",
  );
  
  =item $tls = new AnyEvent::TLS key => value...
  
  The constructor supports these arguments (all as key => value pairs).
  
  =over 4
  
  =item method => "SSLv2" | "SSLv3" | "TLSv1" | "any"
  
  The protocol parser to use. C<SSLv2>, C<SSLv3> and C<TLSv1> will use
  a parser for those protocols only (so will I<not> accept or create
  connections with/to other protocol versions), while C<any> (the
  default) uses a parser capable of all three protocols.
  
  The default is to use C<"any"> but disable SSLv2. This has the effect of
  sending a SSLv2 hello, indicating the support for SSLv3 and TLSv1, but not
  actually negotiating an (insecure) SSLv2 connection.
  
  Specifying a specific version is almost always wrong to use for a server
  speaking to a wide variety of clients (e.g. web browsers), and often wrong
  for a client. If you only want to allow a specific protocol version, use
  the C<sslv2>, C<sslv3> or C<tlsv1> arguments instead.
  
  For new services it is usually a good idea to enforce a C<TLSv1> method
  from the beginning.
  
  =item sslv2 => $enabled
  
  Enable or disable SSLv2 (normally I<disabled>).
  
  =item sslv3 => $enabled
  
  Enable or disable SSLv3 (normally I<enabled>).
  
  =item tlsv1 => $enabled
  
  Enable or disable TLSv1 (normally I<enabled>).
  
  =item verify => $enable
  
  Enable or disable peer certificate checking (default is I<disabled>, which
  is I<not recommended>).
  
  This is the "master switch" for all verify-related parameters and
  functions.
  
  If it is disabled, then no peer certificate verification will be done
  - the connection will be encrypted, but the peer certificate won't be
  verified against any known CAs, or whether it is still valid or not. No
  peername verification or custom verification will be done either.
  
  If enabled, then the peer certificate (required in client mode, optional
  in server mode, see C<verify_require_client_cert>) will be checked against
  its CA certificate chain - that means there must be a signing chain from
  the peer certificate to any of the CA certificates you trust locally, as
  specified by the C<ca_file> and/or C<ca_path> and/or C<ca_cert> parameters
  (or the system default CA repository, if all of those parameters are
  missing - see also the L<AnyEvent> manpage for the description of
  PERL_ANYEVENT_CA_FILE).
  
  Other basic checks, such as checking the validity period, will also be
  done, as well as optional peername/hostname/common name verification
  C<verify_peername>.
  
  An optional C<verify_cb> callback can also be set, which will be invoked
  with the verification results, and which can override the decision.
  
  =item verify_require_client_cert => $enable
  
  Enable or disable mandatory client certificates (default is
  I<disabled>). When this mode is enabled, then a client certificate will be
  required in server mode (a server certificate is mandatory, so in client
  mode, this switch has no effect).
  
  =item verify_peername => $scheme | $callback->($tls, $cert, $peername)
  
  TLS only protects the data that is sent - it cannot automatically verify
  that you are really talking to the right peer. The reason is that
  certificates contain a "common name" (and a set of possible alternative
  "names") that need to be checked against the peername (usually, but not
  always, the DNS name of the server) in a protocol-dependent way.
  
  This can be implemented by specifying a callback that has to verify that
  the actual C<$peername> matches the given certificate in C<$cert>.
  
  Since this can be rather hard to implement, AnyEvent::TLS offers a variety
  of predefined "schemes" (lifted from L<IO::Socket::SSL>) that are named
  like the protocols that use them:
  
  =over 4
  
  =item ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)
  
  Simple wildcards in subjectAltNames are possible, e.g. *.example.org
  matches www.example.org but not lala.www.example.org. If nothing from
  subjectAltNames matches, it checks against the common name, but there are
  no wildcards allowed.
  
  =item http (rfc2818)
  
  Extended wildcards in subjectAltNames are possible, e.g. *.example.org or
  even www*.example.org. Wildcards in the common name are not allowed. The
  common name will be only checked if no host names are given in
  subjectAltNames.
  
  =item smtp (rfc3207)
  
  This RFC isn't very useful in determining how to do verification so it
  just assumes that subjectAltNames are possible, but no wildcards are
  possible anywhere.
  
  =item [$check_cn, $wildcards_in_alt, $wildcards_in_cn]
  
  You can also specify a scheme yourself by using an array reference with
  three integers.
  
  C<$check_cn> specifies if and how the common name field is used: C<0>
  means it will be completely ignored, C<1> means it will only be used if
  no host names have been found in the subjectAltNames, and C<2> means the
  common name will always be checked against the peername.
  
  C<$wildcards_in_alt> and C<$wildcards_in_cn> specify whether and where
  wildcards (C<*>) are allowed in subjectAltNames and the common name,
  respectively. C<0> means no wildcards are allowed, C<1> means they
  are allowed only as the first component (C<*.example.org>), and C<2>
  means they can be used anywhere (C<www*.example.org>), except that very
  dangerous matches will not be allowed (C<*.org> or C<*>).
  
  =back
  
  You can specify either the name of the parent protocol (recommended,
  e.g. C<http>, C<ldap>), the protocol name as usually used in URIs
  (e.g. C<https>, C<ldaps>) or the RFC (not recommended, e.g. C<rfc2995>,
  C<rfc3920>).
  
  This verification will only be done when verification is enabled (C<<
  verify => 1 >>).
  
  =item verify_cb => $callback->($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)
  
  Provide a custom peer verification callback used by TLS sessions,
  which is called with the result of any other verification (C<verify>,
  C<verify_peername>).
  
  This callback will only be called when verification is enabled (C<< verify
  => 1 >>).
  
  C<$tls> is the C<AnyEvent::TLS> object associated with the session,
  while C<$ref> is whatever the user associated with the session (usually
  an L<AnyEvent::Handle> object when used by AnyEvent::Handle).
  
  C<$depth> is the current verification depth - C<$depth = 0> means the
  certificate to verify is the peer certificate, higher levels are its CA
  certificate and so on. In most cases, you can just return C<$preverify_ok>
  if the C<$depth> is non-zero:
  
     verify_cb => sub {
        my ($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert) = @_;
  
        return $preverify_ok
           if $depth;
  
        # more verification
     },
  
  C<$preverify_ok> is true iff the basic verification of the certificates
  was successful (a valid CA chain must exist, the certificate has passed
  basic validity checks, peername verification succeeded).
  
  C<$x509_store_ctx> is the Net::SSLeay::X509_CTX> object.
  
  C<$cert> is the C<Net::SSLeay::X509> object representing the
  peer certificate, or zero if there was an error. You can call
  C<AnyEvent::TLS::certname $cert> to get a nice user-readable string to
  identify the certificate.
  
  The callback must return either C<0> to indicate failure, or C<1> to
  indicate success.
  
  =item verify_client_once => $enable
  
  Enable or disable skipping the client certificate verification on
  renegotiations (default is I<disabled>, the certificate will always be
  checked). Only makes sense in server mode.
  
  =item ca_file => $path
  
  If this parameter is specified and non-empty, it will be the path to a
  file with (server) CA certificates in PEM format that will be loaded. Each
  certificate will look like:
  
     -----BEGIN CERTIFICATE-----
     ... (CA certificate in base64 encoding) ...
     -----END CERTIFICATE-----
  
  You have to enable verify mode (C<< verify => 1 >>) for this parameter to
  have any effect.
  
  =item ca_path => $path
  
  If this parameter is specified and non-empty, it will be
  the path to a directory with hashed CA certificate files in
  PEM format. When the ca certificate is being verified, the
  certificate will be hashed and looked up in that directory (see
  L<http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html> for
  details)
  
  The certificates specified via C<ca_file> take precedence over the ones
  found in C<ca_path>.
  
  You have to enable verify mode (C<< verify => 1 >>) for this parameter to
  have any effect.
  
  =item ca_cert => $string
  
  In addition or instead of using C<ca_file> and/or C<ca_path>, you can
  also use C<ca_cert> to directly specify the CA certificates (there can be
  multiple) in PEM format, in a string.
  
  =item check_crl => $enable
  
  Enable or disable certificate revocation list checking. If enabled, then
  peer certificates will be checked against a list of revoked certificates
  issued by the CA. The revocation lists will be expected in the C<ca_path>
  directory.
  
  certificate verification will fail if this is enabled but no revocation
  list was found.
  
  This requires OpenSSL >= 0.9.7b. Check the OpenSSL documentation for more
  details.
  
  =item key_file => $path
  
  Path to the local private key file in PEM format (might be a combined
  certificate/private key file).
  
  The local certificate is used to authenticate against the peer - servers
  mandatorily need a certificate and key, clients can use a certificate and
  key optionally to authenticate, e.g. for log-in purposes.
  
  The key in the file should look similar this:
  
     -----BEGIN RSA PRIVATE KEY-----
     ...header data
     ... (key data in base64 encoding) ...
     -----END RSA PRIVATE KEY-----
  
  =item key => $string
  
  The private key string in PEM format (see C<key_file>, only one of
  C<key_file> or C<key> can be specified).
  
  The idea behind being able to specify a string is to avoid blocking in
  I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
  needed OpenSSL functionality, this is currently implemented by writing to
  a temporary file.
  
  =item cert_file => $path
  
  The path to the local certificate file in PEM format (might be a combined
  certificate/private key file, including chained certificates).
  
  The local certificate (and key) are used to authenticate against the
  peer - servers mandatorily need a certificate and key, clients can use
  certificate and key optionally to authenticate, e.g. for log-in purposes.
  
  The certificate in the file should look like this:
  
     -----BEGIN CERTIFICATE-----
     ... (certificate in base64 encoding) ...
     -----END CERTIFICATE-----
  
  If the certificate file or string contain both the certificate and
  private key, then there is no need to specify a separate C<key_file> or
  C<key>.
  
  Additional signing certifiates to send to the peer (in SSLv3 and newer)
  can be specified by appending them to the certificate proper: the order
  must be from issuer certificate over any intermediate CA certificates to
  the root CA.
  
  So the recommended ordering for a combined key/cert/chain file, specified
  via C<cert_file> or C<cert> looks like this:
  
    certificate private key
    client/server certificate
    ca 1, signing client/server certficate
    ca 2, signing ca 1
    ...
  
  =item cert => $string
  
  The local certificate in PEM format (might be a combined
  certificate/private key file). See C<cert_file>.
  
  The idea behind being able to specify a string is to avoid blocking in
  I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
  needed OpenSSL functionality, this is currently implemented by writing to
  a temporary file.
  
  =item cert_password => $string | $callback->($tls)
  
  The certificate password - if the certificate is password-protected, then
  you can specify its password here.
  
  Instead of providing a password directly (which is not so recommended),
  you can also provide a password-query callback. The callback will be
  called whenever a password is required to decode a local certificate, and
  is supposed to return the password.
  
  =item dh_file => $path
  
  Path to a file containing Diffie-Hellman parameters in PEM format, for
  use in servers. See also C<dh> on how to specify them directly, or use a
  pre-generated set.
  
  Diffie-Hellman key exchange generates temporary encryption keys that
  are not transferred over the connection, which means that even if the
  certificate key(s) are made public at a later time and a full dump of the
  connection exists, the key still cannot be deduced.
  
  These ciphers are only available with SSLv3 and later (which is the
  default with AnyEvent::TLS), and are only used in server/accept
  mode. Anonymous DH protocols are usually disabled by default, and usually
  not even compiled into the underlying library, as they provide no direct
  protection against man-in-the-middle attacks. The same is true for the
  common practise of self-signed certificates that you have to accept first,
  of course.
  
  =item dh => $string
  
  Specify the Diffie-Hellman parameters in PEM format directly as a string
  (see C<dh_file>), the default is C<schmorp1539> unless C<dh_file> was
  specified.
  
  AnyEvent::TLS supports supports a number of precomputed DH parameters,
  since computing them is expensive. They are:
  
     # from "Assigned Number for SKIP Protocols"
     skip512, skip1024, skip2048, skip4096
  
     # from schmorp
     schmorp1024, schmorp1539, schmorp2048, schmorp4096, schmorp8192
  
  The default was chosen as a trade-off between security and speed, and
  should be secure for a few years. It is said that 2048 bit DH parameters
  are safe till 2030, and DH parameters shorter than 900 bits are totally
  insecure.
  
  To disable DH protocols completely, specify C<undef> as C<dh> parameter.
  
  =item dh_single_use => $enable
  
  Enables or disables "use only once" mode when using Diffie-Hellman key
  exchange. When enabled (default), each time a new key is exchanged a new
  Diffie-Hellman key is generated, which improves security as each key is
  only used once. When disabled, the key will be created as soon as the
  AnyEvent::TLS object is created and will be reused.
  
  All the DH parameters supplied with AnyEvent::TLS should be safe with
  C<dh_single_use> switched off, but YMMV.
  
  =item cipher_list => $string
  
  The list of ciphers to use, as a string (example:
  C<AES:ALL:!aNULL:!eNULL:+RC4:@STRENGTH>). The format
  of this string and its default value is documented at
  L<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>.
  
  =item session_ticket => $enable
  
  Enables or disables RC5077 support (Session Resumption without Server-Side
  State). The default is disabled for clients, as many (buggy) TLS/SSL
  servers choke on it, but enabled for servers.
  
  When enabled and supported by the server, a session ticket will be
  provided to the client, which allows fast resuming of connections.
  
  =item prepare => $coderef->($tls)
  
  If this argument is present, then it will be called with the new
  AnyEvent::TLS object after any other initialisation has bee done, in case
  you wish to fine-tune something...
  
  =cut
  
  #=item trust => $trust
  #
  #Sets the expected (root) certificate use on this context, i.e. what 
  #certificates to trust. The default is C<compat>, and the following strings
  #are supported:
  #
  #   compat          any certifictae will do
  #   ssl_client      only trust client certificates
  #   ssl_server      only trust server certificates
  #   email           only trust e-mail certificates
  #   object_sign     only trust signing (CA) certificates
  #   ocsp_sign       only trust ocsp signing certs
  #   ocsp_request    only trust ocsp request certs
  
  # purpose?
  
  #TODO
  # verify_depth?
  # reuse_ctx
  # session_cache_size
  # session_cache
  
  #=item debug => $level
  #
  #Enable or disable sending debugging output to STDERR. This is, as
  #the name says, mostly for debugging. The default is taken from the
  #C<PERL_ANYEVENT_TLS_DEBUG> environment variable.
  #
  #=cut
  
  =back
  
  =cut
  
  sub init ();
  
  #our %X509_TRUST = (
  #   compat       => 1,
  #   ssl_client   => 2,
  #   ssl_server   => 3,
  #   email        => 4,
  #   object_sign  => 5,
  #   ocsp_sign    => 6,
  #   ocsp_request => 7,
  #);
  
  sub new {
     my ($class, %arg) = @_;
  
     init unless $REF_IDX;
  
     my $method = lc $arg{method} || "any";
  
     my $ctx = $method eq "any"    ? Net::SSLeay::CTX_new       ()
             : $method eq "sslv23" ? Net::SSLeay::CTX_new       () # deliberately undocumented
             : $method eq "sslv2"  ? Net::SSLeay::CTX_v2_new    ()
             : $method eq "sslv3"  ? Net::SSLeay::CTX_v3_new    ()
             : $method eq "tlsv1"  ? Net::SSLeay::CTX_tlsv1_new ()
             : croak "'$method' is not a valid AnyEvent::TLS method (must be one of SSLv2, SSLv3, TLSv1 or any)";
  
     my $self = bless { ctx => $ctx }, $class; # to make sure it's destroyed if we croak
  
     my $op = Net::SSLeay::OP_ALL ();
  
     $op |= Net::SSLeay::OP_NO_SSLv2      () unless $arg{sslv2};
     $op |= Net::SSLeay::OP_NO_SSLv3      () if exists $arg{sslv3} && !$arg{sslv3};
     $op |= Net::SSLeay::OP_NO_TLSv1      () if exists $arg{tlsv1} && !$arg{tlsv1};
     $op |= Net::SSLeay::OP_SINGLE_DH_USE () if !exists $arg{dh_single_use} || $arg{dh_single_use};
  
     Net::SSLeay::CTX_set_options ($ctx, $op);
  
     Net::SSLeay::CTX_set_cipher_list ($ctx, $arg{cipher_list})
        or croak "'$arg{cipher_list}' was not accepted as a valid cipher list by AnyEvent::TLS"
           if exists $arg{cipher_list};
  
     my ($dh_bio, $dh_file);
  
     if (exists $arg{dh_file}) {
        croak
  
        $dh_file = $arg{dh_file};
  
        $dh_bio = Net::SSLeay::BIO_new_file ($dh_file, "r")
           or croak "$dh_file: failed to open DH parameter file: $!";
     } else {
        $arg{dh} = "schmorp1539" unless exists $arg{dh};
  
        if (defined $arg{dh}) {
           $dh_file = "dh string";
  
           if ($arg{dh} =~ /^\w+$/) {
              $dh_file = "dh params $arg{dh}";
              $arg{dh} = "-----BEGIN DH PARAMETERS-----\n"
                       . $DH_PARAMS{$arg{dh}} . "\n"
                       . "-----END DH PARAMETERS-----";
              $arg{dh} =~ s/\|/\n/g;
           }
  
           $dh_bio = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
           Net::SSLeay::BIO_write ($dh_bio, $arg{dh});
        }
     }
  
     if ($dh_bio) {
        my $dh = Net::SSLeay::PEM_read_bio_DHparams ($dh_bio);
        Net::SSLeay::BIO_free ($dh_bio);
        $dh or croak "$dh_file: failed to parse DH parameters - not PEM format?";
        my $rv = Net::SSLeay::CTX_set_tmp_dh ($ctx, $dh);
        Net::SSLeay::DH_free ($dh);
        $rv or croak "$dh_file: failed to set DH parameters";
     }
  
     if ($arg{verify}) {
        $self->{verify_mode} = Net::SSLeay::VERIFY_PEER ();
  
        $self->{verify_mode} |= Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT ()
           if $arg{verify_require_client_cert};
  
        $self->{verify_mode} |= Net::SSLeay::VERIFY_CLIENT_ONCE ()
           if $arg{verify_client_once};
  
     } else {
        $self->{verify_mode} = Net::SSLeay::VERIFY_NONE ();
     }
  
     $self->{verify_peername} = $arg{verify_peername}
        if exists $arg{verify_peername};
  
     $self->{verify_cb} = $arg{verify_cb}
        if exists $arg{verify_cb};
  
     $self->{session_ticket} = $arg{session_ticket}
        if exists $arg{session_ticket};
  
     $self->{debug} = $ENV{PERL_ANYEVENT_TLS_DEBUG}
        if length $ENV{PERL_ANYEVENT_TLS_DEBUG};
  
     $self->{debug} = $arg{debug}
        if exists $arg{debug};
  
     my $pw = $arg{cert_password};
     Net::SSLeay::CTX_set_default_passwd_cb ($ctx, ref $pw ? $pw : sub { $pw });
  
     if ($self->{verify_mode}) {
        if (exists $arg{ca_file} or exists $arg{ca_path} or exists $arg{ca_cert}) {
           # either specified: use them
           if (exists $arg{ca_cert}) {
              my ($ca_file, $g1) = _tmpfile delete $arg{ca_cert};
              Net::SSLeay::CTX_load_verify_locations ($ctx, $ca_file, undef);
           }
           if (exists $arg{ca_file} or exists $arg{ca_path}) {
              Net::SSLeay::CTX_load_verify_locations ($ctx, $arg{ca_file}, $arg{ca_path});
           }
        } elsif (length $ENV{PERL_ANYEVENT_CA_FILE} or length $ENV{PERL_ANYEVENT_CA_PATH}) {
           Net::SSLeay::CTX_load_verify_locations (
              $ctx,
              $ENV{PERL_ANYEVENT_CA_FILE},
              $ENV{PERL_ANYEVENT_CA_PATH},
           );
        } else {
           # else fall back to defaults
           Net::SSLeay::CTX_set_default_verify_paths ($ctx);
        }
     }
  
     if (exists $arg{cert} or exists $arg{cert_file}) {
        my ($g1, $g2);
  
        if (exists $arg{cert}) {
           croak "specifying both cert_file and cert is not allowed"
              if exists $arg{cert_file};
  
          ($arg{cert_file}, $g1) = _tmpfile delete $arg{cert};
        }
  
        if (exists $arg{key} or exists $arg{key_file}) {
           if (exists $arg{key}) {
              croak "specifying both key_file and key is not allowed"
                 if exists $arg{key_file};
             ($arg{key_file}, $g2) = _tmpfile delete $arg{key};
           }
        } else {
           $arg{key_file} = $arg{cert_file};
        }
  
        Net::SSLeay::CTX_use_PrivateKey_file
              ($ctx, $arg{key_file}, Net::SSLeay::FILETYPE_PEM ())
           or croak "$arg{key_file}: failed to load local private key (key_file or key)";
  
        Net::SSLeay::CTX_use_certificate_chain_file ($ctx, $arg{cert_file})
           or croak "$arg{cert_file}: failed to use local certificate chain (cert_file or cert)";
     }
  
     if ($arg{check_crl}) {
        Net::SSLeay::OPENSSL_VERSION_NUMBER () >= 0x00090702f
           or croak "check_crl requires openssl v0.9.7b or higher";
  
        Net::SSLeay::X509_STORE_set_flags (
           Net::SSLeay::CTX_get_cert_store ($ctx),
           Net::SSLeay::X509_V_FLAG_CRL_CHECK ());
     }
  
     Net::SSLeay::CTX_set_read_ahead ($ctx, 1);
  
     $arg{prepare}->($self)
        if $arg{prepare};
  
     $self
  }
  
  =item $tls = new_from_ssleay AnyEvent::TLS $ctx
  
  This constructor takes an existing L<Net::SSLeay> SSL_CTX object
  (which is just an integer) and converts it into an C<AnyEvent::TLS>
  object. This only works because AnyEvent::TLS is currently implemented
  using Net::SSLeay. As this is such a horrible perl module and OpenSSL has
  such an annoying license, this might change in the future, in which case
  this method might vanish.
  
  =cut
  
  sub new_from_ssleay {
     my ($class, $ctx) = @_;
  
     bless { ctx => $ctx }, $class
  }
  
  =item $ctx = $tls->ctx
  
  Returns the actual L<Net::SSLeay::CTX> object (just an integer).
  
  =cut
  
  sub ctx {
     $_[0]{ctx}
  }
  
  sub verify_hostname($$$);
  
  sub _verify_hostname {
     my ($self, $cn, $cert) = @_;
     
     return 1
        unless defined $cn;
  
     return 1
        unless exists $self->{verify_peername} && "none" ne lc $self->{verify_peername};
  
     return $self->{verify_peername}->($self, $cn, $cert)
        if ref $self->{verify_peername} && "ARRAY" ne ref $self->{verify_peername};
  
     verify_hostname $cn, $cert, $self->{verify_peername}
  }
  
  sub verify {
     my ($self, $session, $ref, $cn, $preverify_ok, $x509_store_ctx) = @_;
  
     my $cert = $x509_store_ctx
        ? Net::SSLeay::X509_STORE_CTX_get_current_cert ($x509_store_ctx)
        : undef;
     my $depth = Net::SSLeay::X509_STORE_CTX_get_error_depth ($x509_store_ctx);
  
     $preverify_ok &&= $self->_verify_hostname ($cn, $cert)
        unless $depth;
  
     $preverify_ok = $self->{verify_cb}->($self, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)
        if $self->{verify_cb};
  
     $preverify_ok
  }
  
  #=item $ssl = $tls->_get_session ($mode[, $ref])
  #
  #Creates a new Net::SSLeay::SSL session object, puts it into C<$mode>
  #(C<accept> or C<connect>) and optionally associates it with the given
  #C<$ref>. If C<$mode> is already a C<Net::SSLeay::SSL> object, then just
  #associate data with it.
  #
  #=cut
  
  #our %REF_MAP;
  
  sub _get_session($$;$$) {
     my ($self, $mode, $ref, $cn) = @_;
  
     my $session;
  
     if ($mode eq "accept") {
        $session = Net::SSLeay::new ($self->{ctx});
        Net::SSLeay::set_accept_state ($session);
  
        Net::SSLeay::set_options ($session, eval { Net::SSLeay::OP_NO_TICKET () })
           unless $self->{session_ticket} || !exists $self->{session_ticket};
  
     } elsif ($mode eq "connect") {
        $session = Net::SSLeay::new ($self->{ctx});
        Net::SSLeay::set_connect_state ($session);
  
        Net::SSLeay::set_options ($session, eval { Net::SSLeay::OP_NO_TICKET () })
           unless $self->{session_ticket};
     } else {
        croak "'$mode': unsupported TLS mode (must be either 'connect' or 'accept')"
     }
  
  #   # associate data
  #   Net::SSLeay::set_ex_data ($session, $REF_IDX, $ref+0);
  #   Scalar::Util::weaken ($REF_MAP{$ref+0} = $ref)
  #      if ref $ref;
     
     if ($self->{debug}) {
        #d# Net::SSLeay::set_info_callback ($session, 50000);
     }
  
     if ($self->{verify_mode}) {
        Scalar::Util::weaken $self;
        Scalar::Util::weaken $ref;
  
        # we have to provide a dummy callbacks as at least Net::SSLeay <= 1.35
        # try to call it even if specified as 0 or undef.
        Net::SSLeay::set_verify
           $session,
           $self->{verify_mode},
           sub { $self->verify ($session, $ref, $cn, @_) };
     }
  
     $session
  }
  
  sub _put_session($$) {
     my ($self, $session) = @_;
  
     # clear callback, if any
     # this leaks memoryin Net::SSLeay up to at least 1.35, but there
     # apparently is no other way.
     Net::SSLeay::set_verify $session, 0, undef;
  
  #   # disassociate data
  #   delete $REF_MAP{Net::SSLeay::get_ex_data ($session, $REF_IDX)};
  
     Net::SSLeay::free ($session);
  }
  
  #sub _ref($) {
  #   $REF_MAP{Net::SSLeay::get_ex_data ($_[0], $REF_IDX)}
  #}
  
  sub DESTROY {
     my ($self) = @_;
  
     # better be safe than sorry with net-ssleay
     Net::SSLeay::CTX_set_default_passwd_cb ($self->{ctx});
  
     Net::SSLeay::CTX_free ($self->{ctx});
  }
  
  =item AnyEvent::TLS::init
  
  AnyEvent::TLS does on-demand initialisation, and normally there is no need to call an initialise
  function.
  
  As initialisation might take some time (to read e.g. C</dev/urandom>), this
  could be annoying in some highly interactive programs. In that case, you can
  call C<AnyEvent::TLS::init> to make sure there will be no costly initialisation
  later. It is harmless to call C<AnyEvent::TLS::init> multiple times.
  
  =cut
  
  sub init() {
     return if $REF_IDX;
  
     AE::log 5 => "AnyEvent::TLS: Net::SSLeay versions older than 1.33 might malfunction."
        if $Net::SSLeay::VERSION < 1.33;
  
     Net::SSLeay::load_error_strings ();
     Net::SSLeay::SSLeay_add_ssl_algorithms ();
     Net::SSLeay::randomize ();
  
     $REF_IDX = Net::SSLeay::get_ex_new_index (0, 0, 0, 0, 0)
        until $REF_IDX; # Net::SSLeay uses id #0 for its own stuff without allocating it
  }
  
  =item $certname = AnyEvent::TLS::certname $x509
  
  Utility function that returns a user-readable string identifying the X509
  certificate object.
  
  =cut
  
  sub certname {
     $_[0]
        ? Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_issuer_name ($_[0]))
          . Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_subject_name ($_[0]))
        : undef
  }
  
  our %CN_SCHEME = (
     # each tuple is [$cn_wildcards, $alt_wildcards, $check_cn]
     # where *_wildcards is 0 for none allowed, 1 for allowed at beginning and 2 for allowed everywhere
     # and check_cn is 0 for do not check, 1 for check when no alternate dns names and 2 always
     # all of this is from IO::Socket::SSL
  
     rfc4513 => [0, 1, 2],
     rfc2818 => [0, 2, 1],
     rfc3207 => [0, 0, 2], # see IO::Socket::SSL, rfc seems unclear
     none    => [],        # do not check
  
     ldap    => "rfc4513",                    ldaps => "ldap",
     http    => "rfc2818",                    https => "http",
     smtp    => "rfc3207",                    smtps => "smtp",
  
     xmpp    => "rfc3920", rfc3920 => "http",
     pop3    => "rfc2595", rfc2595 => "ldap", pop3s => "pop3",
     imap    => "rfc2595", rfc2595 => "ldap", imaps => "imap",
     acap    => "rfc2595", rfc2595 => "ldap",
     nntp    => "rfc4642", rfc4642 => "ldap", nntps => "nntp",
     ftp     => "rfc4217", rfc4217 => "http", ftps  => "ftp" ,
  );
  
  sub match_cn($$$) {
     my ($name, $cn, $type) = @_;
  
     # remove leading and trailing garbage
     for ($name, $cn) {
        s/[\x00-\x1f]+$//;
        s/^[\x00-\x1f]+//;
     }
  
     my $pattern;
  
     ### IMPORTANT!
     # we accept only a single wildcard and only for a single part of the FQDN
     # e.g *.example.org does match www.example.org but not bla.www.example.org
     # The RFCs are in this regard unspecific but we don't want to have to
     # deal with certificates like *.com, *.co.uk or even *
     # see also http://nils.toedtmann.net/pub/subjectAltName.txt
     if ($type == 2 and $name =~m{^([^.]*)\*(.+)} ) {
        $pattern = qr{^\Q$1\E[^.]*\Q$2\E$}i;
     } elsif ($type == 1 and $name =~m{^\*(\..+)$} ) {
        $pattern = qr{^[^.]*\Q$1\E$}i;
     } else {
        $pattern = qr{^\Q$name\E$}i;
     }
  
     $cn =~ $pattern
  }
  
  # taken verbatim from IO::Socket::SSL, then changed to take advantage of
  # AnyEvent utilities.
  sub verify_hostname($$$) {
     my ($cn, $cert, $scheme) = @_;
  
     while (!ref $scheme) {
        $scheme = $CN_SCHEME{$scheme}
           or return 1;
     }
  
     my $cert_cn =
        Net::SSLeay::X509_NAME_get_text_by_NID (
           Net::SSLeay::X509_get_subject_name ($cert), Net::SSLeay::NID_commonName ());
  
     my @cert_alt = Net::SSLeay::X509_get_subjectAltNames ($cert);
  
     # rfc2460 - convert to network byte order
     my $ip = AnyEvent::Socket::parse_address $cn;
  
     my $alt_dns_count;
  
     while (my ($type, $name) = splice @cert_alt, 0, 2) {
        if ($type == Net::SSLeay::GEN_IPADD ()) {
           # $name is already packed format (inet_xton)
           return 1 if $ip eq $name;
        } elsif ($type == Net::SSLeay::GEN_DNS ()) {
           $alt_dns_count++;
  
           return 1 if match_cn $name, $cn, $scheme->[1];
        }
     }
  
     if ($scheme->[2] == 2
         || ($scheme->[2] == 1 && !$alt_dns_count)) {
        return 1 if match_cn $cert_cn, $cn, $scheme->[0];
     }
  
     0
  }
  
  =back
  
  =head1 SSL/TLS QUICK FACTS
  
  Here are some quick facts about TLS/SSL that might help you:
  
  =over 4
  
  =item * A certificate is the public key part, a key is the private key part.
  
  While not strictly true, certificates are the things you can hand around
  publicly as a kind of identity, while keys should really be kept private,
  as proving that you have the private key is usually interpreted as being
  the entity behind the certificate.
  
  =item * A certificate is signed by a CA (Certificate Authority).
  
  By signing, the CA basically claims that the certificate it signs
  really belongs to the identity named in it, verified according to the
  CA policies. For e.g. HTTPS, the CA usually makes some checks that the
  hostname mentioned in the certificate really belongs to the company/person
  that requested the signing and owns the domain.
  
  =item * CAs can be certified by other CAs.
  
  Or by themselves - a certificate that is signed by a CA that is itself
  is called a self-signed certificate, a trust chain of length zero. When
  you find a certificate signed by another CA, which is in turn signed by
  another CA you trust, you have a trust chain of depth two.
  
  =item * "Trusting" a CA means trusting all certificates it has signed.
  
  If you "trust" a CA certificate, then all certificates signed by it are
  automatically considered trusted as well.
  
  =item * A successfully verified certificate means that you can be
  reasonably sure that whoever you are talking with really is who he claims
  he is.
  
  By verifying certificates against a number of CAs that you trust (meaning
  it is signed directly or indirectly by such a CA), you can find out that
  the other side really is whoever he claims, according to the CA policies,
  and your belief in the integrity of the CA.
  
  =item * Verifying the certificate signature is not everything.
  
  Even when the certificate is correct, it might belong to somebody else: if
  www.attacker.com can make your computer believe that it is really called
  www.mybank.com (by making your DNS server believe this for example),
  then it could send you the certificate for www.attacker.com that your
  software trusts because it is signed by a CA you trust, and intercept
  all your traffic that you think goes to www.mybank.com. This works
  because your software sees that the certificate is correctly signed (for
  www.attacker.com) and you think you are talking to your bank.
  
  To thwart this attack vector, peername verification should be used, which
  basically checks that the certificate (for www.attacker.com) really
  belongs to the host you are trying to talk to (www.mybank.com), which in
  this example is not the case, as www.attacker.com (from the certificate)
  doesn't match www.mybank.com (the hostname used to create the connection).
  
  So peername verification is almost as important as checking the CA
  signing. Unfortunately, every protocol implements this differently, if at
  all...
  
  =item * Switching off verification is sometimes reasonable.
  
  You can switch off verification. You still get an encrypted connection
  that is protected against eavesdropping and injection - you just lose
  protection against man in the middle attacks, i.e. somebody else with
  enough abilities to to intercept all traffic can masquerade herself as the
  other side.
  
  For many applications, switching off verification is entirely
  reasonable. Downloading random stuff from websites using HTTPS for no
  reason is such an application. Talking to your bank and entering TANs is
  not such an application.
  
  =item * A SSL/TLS server always needs a certificate/key pair to operate,
  for clients this is optional.
  
  Apart from (usually disabled) anonymous cipher suites, a server always
  needs a certificate/key pair to operate.
  
  Clients almost never use certificates, but if they do, they can be used
  to authenticate the client, just as server certificates can be used to
  authenticate the server.
  
  =item * SSL version 2 is very insecure.
  
  SSL version 2 is old and not only has it some security issues, SSLv2-only
  implementations are usually buggy, too, due to their age.
  
  =item * Sometimes, even losing your "private" key might not expose all your
  data.
  
  With Diffie-Hellman ephemeral key exchange, you can lose the DH parameters
  (the "keys"), but all your connections are still protected. Diffie-Hellman
  needs special set-up (done by default by AnyEvent::TLS).
  
  =back
  
  =head1 SECURITY CONSIDERATIONS
  
  When you use any of the options that pass in keys or certificates
  as strings (e.g. C<ca_cert>), then, due to serious shortcomings in
  L<Net::SSLeay>, this module creates a temporary file to store the string -
  see L<File::Temp> and possibly its C<safe_level> setting for more details
  on what to watch out for.
  
  =head1 BUGS
  
  To to the abysmal code quality of Net::SSLeay, this module will leak small
  amounts of memory per TLS connection (currently at least one perl scalar).
  
  =head1 AUTHORS
  
  Marc Lehmann <schmorp@schmorp.de>.
  
  Some of the API, documentation and implementation (verify_hostname),
  and a lot of ideas/workarounds/knowledge have been taken from the
  L<IO::Socket::SSL> module. Care has been taken to keep the API similar to
  that and other modules, to the extent possible while providing a sensible
  API for AnyEvent.
  
  =cut
  
  1
  
DARWIN-2LEVEL_ANYEVENT_TLS

$fatpacked{"darwin-2level/AnyEvent/Util.pm"} = <<'DARWIN-2LEVEL_ANYEVENT_UTIL';
  =head1 NAME
  
  AnyEvent::Util - various utility functions.
  
  =head1 SYNOPSIS
  
     use AnyEvent::Util;
  
  =head1 DESCRIPTION
  
  This module implements various utility functions, mostly replacing
  well-known functions by event-ised counterparts.
  
  All functions documented without C<AnyEvent::Util::> prefix are exported
  by default.
  
  =over 4
  
  =cut
  
  package AnyEvent::Util;
  
  use Carp ();
  use Errno ();
  use Socket ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use base 'Exporter';
  
  our @EXPORT = qw(fh_nonblocking guard fork_call portable_pipe portable_socketpair run_cmd);
  our @EXPORT_OK = qw(
     AF_INET6 WSAEWOULDBLOCK WSAEINPROGRESS WSAEINVAL
     close_all_fds_except
     punycode_encode punycode_decode idn_nameprep idn_to_ascii idn_to_unicode
  );
  
  our $VERSION = $AnyEvent::VERSION;
  
  BEGIN {
     # provide us with AF_INET6, but only if allowed
     if (
        $AnyEvent::PROTOCOL{ipv6}
        && _AF_INET6
        && socket my $ipv6_socket, _AF_INET6, Socket::SOCK_DGRAM(), 0 # check if they can be created
     ) {
        *AF_INET6 = \&_AF_INET6;
     } else {
        # disable ipv6
        *AF_INET6 = sub () { 0 };
        delete $AnyEvent::PROTOCOL{ipv6};
     }
  
     # fix buggy Errno on some non-POSIX platforms
     # such as openbsd and windows.
     my %ERR = (
        EBADMSG => Errno::EDOM   (),
        EPROTO  => Errno::ESPIPE (),
     );
  
     while (my ($k, $v) = each %ERR) {
        next if eval "Errno::$k ()";
        AE::log 8 => "AnyEvent::Util: broken Errno module, adding Errno::$k.";
  
        eval "sub Errno::$k () { $v }";
        push @Errno::EXPORT_OK, $k;
        push @{ $Errno::EXPORT_TAGS{POSIX} }, $k;
     }
  }
  
  =item ($r, $w) = portable_pipe
  
  Calling C<pipe> in Perl is portable - except it doesn't really work on
  sucky windows platforms (at least not with most perls - cygwin's perl
  notably works fine): On windows, you actually get two file handles you
  cannot use select on.
  
  This function gives you a pipe that actually works even on the broken
  windows platform (by creating a pair of TCP sockets on windows, so do not
  expect any speed from that, and using C<pipe> everywhere else).
  
  See C<portable_socketpair>, below, for a bidirectional "pipe".
  
  Returns the empty list on any errors.
  
  =item ($fh1, $fh2) = portable_socketpair
  
  Just like C<portable_pipe>, above, but returns a bidirectional pipe
  (usually by calling C<socketpair> to create a local loopback socket pair,
  except on windows, where it again returns two interconnected TCP sockets).
  
  Returns the empty list on any errors.
  
  =cut
  
  BEGIN {
     if (AnyEvent::WIN32) {
        *_win32_socketpair = sub () {
           # perl's socketpair emulation fails on many vista machines, because
           # vista returns fantasy port numbers.
  
           for (1..10) {
              socket my $l, Socket::AF_INET(), Socket::SOCK_STREAM(), 0
                 or next;
  
              bind $l, Socket::pack_sockaddr_in 0, "\x7f\x00\x00\x01"
                 or next;
  
              my $sa = getsockname $l
                 or next;
  
              listen $l, 1
                 or next;
  
              socket my $r, Socket::AF_INET(), Socket::SOCK_STREAM(), 0
                 or next;
  
              bind $r, Socket::pack_sockaddr_in 0, "\x7f\x00\x00\x01"
                 or next;
  
              connect $r, $sa
                 or next;
  
              accept my $w, $l
                 or next;
  
              # vista has completely broken peername/sockname that return
              # fantasy ports. this combo seems to work, though.
              #
              (Socket::unpack_sockaddr_in getpeername $r)[0]
              == (Socket::unpack_sockaddr_in getsockname $w)[0]
                 or (($! = WSAEINVAL), next);
  
              # vista example (you can't make this shit up...):
              #(Socket::unpack_sockaddr_in getsockname $r)[0] == 53364
              #(Socket::unpack_sockaddr_in getpeername $r)[0] == 53363
              #(Socket::unpack_sockaddr_in getsockname $w)[0] == 53363
              #(Socket::unpack_sockaddr_in getpeername $w)[0] == 53365
  
              return ($r, $w);
           }
  
           ()
        };
  
        *portable_socketpair = \&_win32_socketpair;
        *portable_pipe       = \&_win32_socketpair;
     } else {
        *portable_pipe = sub () {
           my ($r, $w);
  
           pipe $r, $w
              or return;
  
           ($r, $w);
        };
  
        *portable_socketpair = sub () {
           socketpair my $fh1, my $fh2, Socket::AF_UNIX(), Socket::SOCK_STREAM(), 0
              or return;
  
           ($fh1, $fh2)
        };
     }
  }
  
  =item fork_call { CODE } @args, $cb->(@res)
  
  Executes the given code block asynchronously, by forking. Everything the
  block returns will be transferred to the calling process (by serialising and
  deserialising via L<Storable>).
  
  If there are any errors, then the C<$cb> will be called without any
  arguments. In that case, either C<$@> contains the exception (and C<$!> is
  irrelevant), or C<$!> contains an error number. In all other cases, C<$@>
  will be C<undef>ined.
  
  The code block must not ever call an event-polling function or use
  event-based programming that might cause any callbacks registered in the
  parent to run.
  
  Win32 spoilers: Due to the endlessly sucky and broken native windows
  perls (there is no way to cleanly exit a child process on that platform
  that doesn't also kill the parent), you have to make sure that your main
  program doesn't exit as long as any C<fork_calls> are still in progress,
  otherwise the program won't exit. Also, on most windows platforms some
  memory will leak for every invocation. We are open for improvements that
  don't require XS hackery.
  
  Note that forking can be expensive in large programs (RSS 200MB+). On
  windows, it is abysmally slow, do not expect more than 5..20 forks/s on
  that sucky platform (note this uses perl's pseudo-threads, so avoid those
  like the plague).
  
  Example: poor man's async disk I/O (better use L<IO::AIO>).
  
     fork_call {
        open my $fh, "</etc/passwd"
           or die "passwd: $!";
        local $/;
        <$fh>
     } sub {
        my ($passwd) = @_;
        ...
     };
  
  =item $AnyEvent::Util::MAX_FORKS [default: 10]
  
  The maximum number of child processes that C<fork_call> will fork in
  parallel. Any additional requests will be queued until a slot becomes free
  again.
  
  The environment variable C<PERL_ANYEVENT_MAX_FORKS> is used to initialise
  this value.
  
  =cut
  
  our $MAX_FORKS = int 1 * $ENV{PERL_ANYEVENT_MAX_FORKS};
  $MAX_FORKS = 10 if $MAX_FORKS <= 0;
  
  my $forks;
  my @fork_queue;
  
  sub _fork_schedule;
  sub _fork_schedule {
     require Storable unless $Storable::VERSION;
     require POSIX    unless $POSIX::VERSION;
  
     while ($forks < $MAX_FORKS) {
        my $job = shift @fork_queue
           or last;
  
        ++$forks;
  
        my $coderef = shift @$job;
        my $cb = pop @$job;
        
        # gimme a break...
        my ($r, $w) = portable_pipe
           or ($forks and last) # allow failures when we have at least one job
           or die "fork_call: $!";
  
        my $pid = fork;
  
        if ($pid != 0) {
           # parent
           close $w;
  
           my $buf;
  
           my $ww; $ww = AE::io $r, 0, sub {
              my $len = sysread $r, $buf, 65536, length $buf;
  
              return unless defined $len or $! != Errno::EINTR;
  
              if (!$len) {
                 undef $ww;
                 close $r;
                 --$forks;
                 _fork_schedule;
                 
                 my $result = eval { Storable::thaw ($buf) };
                 $result = [$@] unless $result;
                 $@ = shift @$result;
  
                 $cb->(@$result);
  
                 # work around the endlessly broken windows perls
                 kill 9, $pid if AnyEvent::WIN32;
  
                 # clean up the pid
                 waitpid $pid, 0;
              }
           };
  
        } elsif (defined $pid) {
           # child
           close $r;
  
           my $result = eval {
              local $SIG{__DIE__};
  
              Storable::freeze ([undef, $coderef->(@$job)])
           };
  
           $result = Storable::freeze (["$@"])
              if $@;
  
           # windows forces us to these contortions
           my $ofs;
  
           while () {
              my $len = (length $result) - $ofs
                 or last;
  
              $len = syswrite $w, $result, $len < 65536 ? $len : 65536, $ofs;
  
              last unless $len || (!defined $len && $! == Errno::EINTR);
  
              $ofs += $len;
           }
  
           # on native windows, _exit KILLS YOUR FORKED CHILDREN!
           if (AnyEvent::WIN32) {
              shutdown $w, 1; # signal parent to please kill us
              sleep 10; # give parent a chance to clean up
              sysread $w, (my $buf), 1; # this *might* detect the parent exiting in some cases.
           }
           POSIX::_exit (0);
           exit 1;
           
        } elsif (($! != &Errno::EAGAIN && $! != &Errno::ENOMEM) || !$forks) {
           # we ignore some errors as long as we can run at least one job
           # maybe we should wait a few seconds and retry instead
           die "fork_call: $!";
        }
     }
  }
  
  sub fork_call(&@) {
     push @fork_queue, [@_];
     _fork_schedule;
  }
  
  END {
     if (AnyEvent::WIN32) {
        while ($forks) {
           @fork_queue = ();
           AnyEvent->one_event;
        }
     }
  }
  
  # to be removed
  sub dotted_quad($) {
     $_[0] =~ /^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)$/x
  }
  
  # just a forwarder
  sub inet_aton {
     require AnyEvent::Socket;
     *inet_aton = \&AnyEvent::Socket::inet_aton;
     goto &inet_aton
  }
  
  =item fh_nonblocking $fh, $nonblocking
  
  Sets the blocking state of the given filehandle (true == nonblocking,
  false == blocking). Uses fcntl on anything sensible and ioctl FIONBIO on
  broken (i.e. windows) platforms.
  
  =cut
  
  BEGIN {
     *fh_nonblocking = AnyEvent::WIN32
        ? sub($$) {
            ioctl $_[0], 0x8004667e, pack "L", $_[1]; # FIONBIO
          }
        : sub($$) {
            fcntl $_[0], AnyEvent::F_SETFL, $_[1] ? AnyEvent::O_NONBLOCK : 0;
          }
     ;
  }
  
  =item $guard = guard { CODE }
  
  This function creates a special object that, when called, will execute
  the code block.
  
  This is often handy in continuation-passing style code to clean up some
  resource regardless of where you break out of a process.
  
  The L<Guard> module will be used to implement this function, if it is
  available. Otherwise a pure-perl implementation is used.
  
  While the code is allowed to throw exceptions in unusual conditions, it is
  not defined whether this exception will be reported (at the moment, the
  Guard module and AnyEvent's pure-perl implementation both try to report
  the error and continue).
  
  You can call one method on the returned object:
  
  =item $guard->cancel
  
  This simply causes the code block not to be invoked: it "cancels" the
  guard.
  
  =cut
  
  BEGIN {
     if (!$ENV{PERL_ANYEVENT_AVOID_GUARD} && eval { require Guard; $Guard::VERSION >= 0.5 }) {
        *guard = \&Guard::guard;
        AE::log 8 => "AnyEvent::Util: using Guard module to implement guards.";
     } else {
        *AnyEvent::Util::guard::DESTROY = sub {
           local $@;
  
           eval {
              local $SIG{__DIE__};
              ${$_[0]}->();
           };
  
           AE::log 4 => "runtime error in AnyEvent::guard callback: $@" if $@;
        };
  
        *AnyEvent::Util::guard::cancel = sub ($) {
           ${$_[0]} = sub { };
        };
  
        *guard = sub (&) {
           bless \(my $cb = shift), "AnyEvent::Util::guard"
        };
  
        AE::log 8 => "AnyEvent::Util: using pure-perl guard implementation.";
     }
  }
  
  =item AnyEvent::Util::close_all_fds_except @fds
  
  This rarely-used function simply closes all file descriptors (or tries to)
  of the current process except the ones given as arguments.
  
  When you want to start a long-running background server, then it is often
  beneficial to do this, as too many C-libraries are too stupid to mark
  their internal fd's as close-on-exec.
  
  The function expects to be called shortly before an C<exec> call.
  
  Example: close all fds except 0, 1, 2.
  
     close_all_fds_except 0, 2, 1;
  
  =cut
  
  sub close_all_fds_except {
     my %except; @except{@_} = ();
  
     require POSIX unless $POSIX::VERSION;
  
     # some OSes have a usable /dev/fd, sadly, very few
     if ($^O =~ /(freebsd|cygwin|linux)/) {
        # netbsd, openbsd, solaris have a broken /dev/fd
        my $dir;
        if (opendir $dir, "/dev/fd" or opendir $dir, "/proc/self/fd") {
           my @fds = sort { $a <=> $b } grep /^\d+$/, readdir $dir;
           # broken OS's have device nodes for 0..63 usually, solaris 0..255
           if (@fds < 20 or "@fds" ne join " ", 0..$#fds) {
              # assume the fds array is valid now
              exists $except{$_} or POSIX::close ($_)
                 for @fds;
              return;
           }
        }
     }
  
     my $fd_max = eval { POSIX::sysconf (POSIX::_SC_OPEN_MAX ()) - 1 } || 1023;
  
     exists $except{$_} or POSIX::close ($_)
        for 0..$fd_max;
  }
  
  =item $cv = run_cmd $cmd, key => value...
  
  Run a given external command, potentially redirecting file descriptors and
  return a condition variable that gets sent the exit status (like C<$?>)
  when the program exits I<and> all redirected file descriptors have been
  exhausted.
  
  The C<$cmd> is either a single string, which is then passed to a shell, or
  an arrayref, which is passed to the C<execvp> function.
  
  The key-value pairs can be:
  
  =over 4
  
  =item ">" => $filename
  
  Redirects program standard output into the specified filename, similar to C<<
  >filename >> in the shell.
  
  =item ">" => \$data
  
  Appends program standard output to the referenced scalar. The condvar will
  not be signalled before EOF or an error is signalled.
  
  =item ">" => $filehandle
  
  Redirects program standard output to the given filehandle (or actually its
  underlying file descriptor).
  
  =item ">" => $callback->($data)
  
  Calls the given callback each time standard output receives some data,
  passing it the data received. On EOF or error, the callback will be
  invoked once without any arguments.
  
  The condvar will not be signalled before EOF or an error is signalled.
  
  =item "fd>" => $see_above
  
  Like ">", but redirects the specified fd number instead.
  
  =item "<" => $see_above
  
  The same, but redirects the program's standard input instead. The same
  forms as for ">" are allowed.
  
  In the callback form, the callback is supposed to return data to be
  written, or the empty list or C<undef> or a zero-length scalar to signal
  EOF.
  
  Similarly, either the write data must be exhausted or an error is to be
  signalled before the condvar is signalled, for both string-reference and
  callback forms.
  
  =item "fd<" => $see_above
  
  Like "<", but redirects the specified file descriptor instead.
  
  =item on_prepare => $cb
  
  Specify a callback that is executed just before the command is C<exec>'ed,
  in the child process. Be careful not to use any event handling or other
  services not available in the child.
  
  This can be useful to set up the environment in special ways, such as
  changing the priority of the command or manipulating signal handlers (e.g.
  setting C<SIGINT> to C<IGNORE>).
  
  =item close_all => $boolean
  
  When C<close_all> is enabled (default is disabled), then all extra file
  descriptors will be closed, except the ones that were redirected and C<0>,
  C<1> and C<2>.
  
  See C<close_all_fds_except> for more details.
  
  =item '$$' => \$pid
  
  A reference to a scalar which will receive the PID of the newly-created
  subprocess after C<run_cmd> returns.
  
  Note the the PID might already have been recycled and used by an unrelated
  process at the time C<run_cmd> returns, so it's not useful to send
  signals, use a unique key in data structures and so on.
  
  =back
  
  Example: run C<rm -rf />, redirecting standard input, output and error to
  F</dev/null>.
  
     my $cv = run_cmd [qw(rm -rf /)],
        "<", "/dev/null",
        ">", "/dev/null",
        "2>", "/dev/null";
     $cv->recv and die "d'oh! something survived!"
  
  Example: run F<openssl> and create a self-signed certificate and key,
  storing them in C<$cert> and C<$key>. When finished, check the exit status
  in the callback and print key and certificate.
  
     my $cv = run_cmd [qw(openssl req 
                       -new -nodes -x509 -days 3650
                       -newkey rsa:2048 -keyout /dev/fd/3
                       -batch -subj /CN=AnyEvent
                      )],
        "<", "/dev/null",
        ">" , \my $cert,
        "3>", \my $key,
        "2>", "/dev/null";
  
     $cv->cb (sub {
        shift->recv and die "openssl failed";
  
        print "$key\n$cert\n";
     });
  
  =cut
  
  sub run_cmd {
     my $cmd = shift;
  
     require POSIX unless $POSIX::VERSION;
  
     my $cv = AE::cv;
  
     my %arg;
     my %redir;
     my @exe;
  
     while (@_) {
        my ($type, $ob) = splice @_, 0, 2;
  
        my $fd = $type =~ s/^(\d+)// ? $1 : undef;
  
        if ($type eq ">") {
           $fd = 1 unless defined $fd;
  
           if (defined eval { fileno $ob }) {
              $redir{$fd} = $ob;
           } elsif (ref $ob) {
              my ($pr, $pw) = AnyEvent::Util::portable_pipe;
              $cv->begin;
  
              fcntl $pr, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              my $w; $w = AE::io $pr, 0,
                 "SCALAR" eq ref $ob
                    ? sub {
                         defined (sysread $pr, $$ob, 16384, length $$ob
                                  and return)
                            or ($! == Errno::EINTR and return);
                         undef $w; $cv->end;
                      }
                    : sub {
                         my $buf;
                         defined (sysread $pr, $buf, 16384
                                  and return $ob->($buf))
                            or ($! == Errno::EINTR and return);
                         undef $w; $cv->end;
                         $ob->();
                      }
              ;
              $redir{$fd} = $pw;
           } else {
              push @exe, sub {
                 open my $fh, ">", $ob
                    or POSIX::_exit (125);
                 $redir{$fd} = $fh;
              };
           }
  
        } elsif ($type eq "<") {
           $fd = 0 unless defined $fd;
  
           if (defined eval { fileno $ob }) {
              $redir{$fd} = $ob;
           } elsif (ref $ob) {
              my ($pr, $pw) = AnyEvent::Util::portable_pipe;
              $cv->begin;
  
              my $data;
              if ("SCALAR" eq ref $ob) {
                 $data = $$ob;
                 $ob = sub { };
              } else {
                 $data = $ob->();
              }
  
              fcntl $pw, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              my $w; $w = AE::io $pw, 1, sub {
                 my $len = syswrite $pw, $data;
  
                 return unless defined $len or $! != Errno::EINTR;
  
                 if (!$len) {
                    undef $w; $cv->end;
                 } else {
                    substr $data, 0, $len, "";
                    unless (length $data) {
                       $data = $ob->();
                       unless (length $data) {
                          undef $w; $cv->end
                       }
                    }
                 }
              };
  
              $redir{$fd} = $pr;
           } else {
              push @exe, sub {
                 open my $fh, "<", $ob
                    or POSIX::_exit (125);
                 $redir{$fd} = $fh;
              };
           }
  
        } else {
           $arg{$type} = $ob;
        }
     }
  
     my $pid = fork;
  
     defined $pid
        or Carp::croak "fork: $!";
  
     unless ($pid) {
        # step 1, execute
        $_->() for @exe;
  
        # step 2, move any existing fd's out of the way
        # this also ensures that dup2 is never called with fd1==fd2
        # so the cloexec flag is always cleared
        my (@oldfh, @close);
        for my $fh (values %redir) {
           push @oldfh, $fh; # make sure we keep it open
           $fh = fileno $fh; # we only want the fd
  
           # dup if we are in the way
           # if we "leak" fds here, they will be dup2'ed over later
           defined ($fh = POSIX::dup ($fh)) or POSIX::_exit (124)
              while exists $redir{$fh};
        }
  
        # step 3, execute redirects
        while (my ($k, $v) = each %redir) {
           defined POSIX::dup2 ($v, $k)
              or POSIX::_exit (123);
        }
  
        # step 4, close everything else, except 0, 1, 2
        if ($arg{close_all}) {
           close_all_fds_except 0, 1, 2, keys %redir
        } else {
           POSIX::close ($_)
              for values %redir;
        }
  
        eval { $arg{on_prepare}(); 1 } or POSIX::_exit (123)
           if exists $arg{on_prepare};
  
        ref $cmd
           ? exec {$cmd->[0]} @$cmd
           : exec $cmd;
  
        POSIX::_exit (126);
     }
  
     ${$arg{'$$'}} = $pid
        if $arg{'$$'};
  
     %redir = (); # close child side of the fds
  
     my $status;
     $cv->begin (sub { shift->send ($status) });
     my $cw; $cw = AE::child $pid, sub {
        $status = $_[1];
        undef $cw; $cv->end;
     };
  
     $cv
  }
  
  =item AnyEvent::Util::punycode_encode $string
  
  Punycode-encodes the given C<$string> and returns its punycode form. Note
  that uppercase letters are I<not> casefolded - you have to do that
  yourself.
  
  Croaks when it cannot encode the string.
  
  =item AnyEvent::Util::punycode_decode $string
  
  Tries to punycode-decode the given C<$string> and return its unicode
  form. Again, uppercase letters are not casefoled, you have to do that
  yourself.
  
  Croaks when it cannot decode the string.
  
  =cut
  
  sub punycode_encode($) {
     require "AnyEvent/Util/idna.pl";
     goto &punycode_encode;
  }
  
  sub punycode_decode($) {
     require "AnyEvent/Util/idna.pl";
     goto &punycode_decode;
  }
  
  =item AnyEvent::Util::idn_nameprep $idn[, $display]
  
  Implements the IDNA nameprep normalisation algorithm. Or actually the
  UTS#46 algorithm. Or maybe something similar - reality is complicated
  between IDNA2003, UTS#46 and IDNA2008. If C<$display> is true then the name
  is prepared for display, otherwise it is prepared for lookup (default).
  
  If you have no clue what this means, look at C<idn_to_ascii> instead.
  
  This function is designed to avoid using a lot of resources - it uses
  about 1MB of RAM (most of this due to Unicode::Normalize). Also, names
  that are already "simple" will only be checked for basic validity, without
  the overhead of full nameprep processing.
  
  =cut
  
  our ($uts46_valid, $uts46_imap);
  
  sub idn_nameprep($;$) {
     local $_ = $_[0];
  
     # lowercasing these should always be valid, and is required for xn-- detection
     y/A-Z/a-z/;
  
     if (/[^0-9a-z\-.]/) {
        # load the mapping data
        unless (defined $uts46_imap) {
           require Unicode::Normalize;
           require "lib/AnyEvent/Util/uts46data.pl";
        }
  
        # uts46 nameprep
  
        # I naively tried to use a regex/transliterate approach first,
        # with one regex and one y///, but the compiled code was 4.5MB.
        # this version has a bit-table for the valid class, and
        # a char-replacement search string
  
        # for speed (cough) reasons, we skip-case 0-9a-z, -, ., which
        # really ought to be trivially valid. A-Z is valid, but already lowercased.
        s{
           ([^0-9a-z\-.])
        }{
           my $chr = $1;
           unless (vec $uts46_valid, ord $chr, 1) {
              # not in valid class, search for mapping
              utf8::encode $chr; # the imap table is in utf-8
              (my $rep = index $uts46_imap, "\x00$chr") >= 0
                 or Carp::croak "$_[0]: disallowed characters ($chr) during idn_nameprep" . unpack "H*", $chr;
  
              (substr $uts46_imap, $rep, 128) =~ /\x00 .[\x80-\xbf]* ([^\x00]*) \x00/x
                 or die "FATAL: idn_nameprep imap table has unexpected contents";
  
              $rep = $1;
              $chr = $rep unless $rep =~ s/^\x01// && $_[1]; # replace unless deviation and display
              utf8::decode $chr;
           }
           $chr
        }gex;
  
        # KC
        $_ = Unicode::Normalize::NFKC ($_);
     }
  
     # decode punycode components, check for invalid xx-- prefixes
     s{
        (^|\.)(..)--([^\.]*)
     }{
        my ($pfx, $ace, $pc) = ($1, $2, $3);
  
        if ($ace eq "xn") {
           $pc = punycode_decode $pc; # will croak on error (we hope :)
  
           require Unicode::Normalize;
           $pc eq Unicode::Normalize::NFC ($pc)
              or Carp::croak "$_[0]: punycode label not in NFC detected during idn_nameprep";
  
           "$pfx$pc"
        } elsif ($ace !~ /^[a-z0-9]{2}$/) {
           "$pfx$ace--$pc"
        } else {
           Carp::croak "$_[0]: hyphens in 3rd/4th position of a label are not allowed";
        }
     }gex;
  
     # uts46 verification
     /\.-|-\./
        and Carp::croak "$_[0]: invalid hyphens detected during idn_nameprep";
  
     # missing: label begin with combining mark, idna2008 bidi
  
     # now check validity of each codepoint
     if (/[^0-9a-z\-.]/) {
        # load the mapping data
        unless (defined $uts46_imap) {
           require "lib/AnyEvent/Util/uts46data.pl";
        }
  
        vec $uts46_valid, ord, 1
           or $_[1] && 0 <= index $uts46_imap, pack "C0U*", 0, ord, 1 # deviation == \x00$chr\x01
           or Carp::croak "$_[0]: disallowed characters during idn_nameprep"
           for split //;
     }
  
     $_
  }
  
  =item $domainname = AnyEvent::Util::idn_to_ascii $idn
  
  Converts the given unicode string (C<$idn>, international domain name,
  e.g. 日本語。ＪＰ) to a pure-ASCII domain name (this is usually
  called the "IDN ToAscii" transform). This transformation is idempotent,
  which means you can call it just in case and it will do the right thing.
  
  Unlike some other "ToAscii" implementations, this one works on full domain
  names and should never fail - if it cannot convert the name, then it will
  return it unchanged.
  
  This function is an amalgam of IDNA2003, UTS#46 and IDNA2008 - it tries to
  be reasonably compatible to other implementations, reasonably secure, as
  much as IDNs can be secure, and reasonably efficient when confronted with
  IDNs that are already valid DNS names.
  
  =cut
  
  sub idn_to_ascii($) {
     return $_[0]
        unless $_[0] =~ /[^\x00-\x7f]/;
  
     my @output;
  
     eval {
        # punycode by label
        for (split /\./, (idn_nameprep $_[0]), -1) {
           if (/[^\x00-\x7f]/) {
              eval {
                 push @output, "xn--" . punycode_encode $_;
                 1;
              } or do {
                 push @output, $_;
              };
           } else {
              push @output, $_;
           }
        }
  
        1
     } or return $_[0];
  
     shift @output
        while !length $output[0] && @output > 1;
  
     join ".", @output
  }
  
  =item $idn = AnyEvent::Util::idn_to_unicode $idn
  
  Converts the given unicode string (C<$idn>, international domain name,
  e.g. 日本語。ＪＰ, www.deliantra.net, www.xn--l-0ga.de) to
  unicode form (this is usually called the "IDN ToUnicode" transform). This
  transformation is idempotent, which means you can call it just in case and
  it will do the right thing.
  
  Unlike some other "ToUnicode" implementations, this one works on full
  domain names and should never fail - if it cannot convert the name, then
  it will return it unchanged.
  
  This function is an amalgam of IDNA2003, UTS#46 and IDNA2008 - it tries to
  be reasonably compatible to other implementations, reasonably secure, as
  much as IDNs can be secure, and reasonably efficient when confronted with
  IDNs that are already valid DNS names.
  
  At the moment, this function simply calls C<idn_nameprep $idn, 1>,
  returning its argument when that function fails.
  
  =cut
  
  sub idn_to_unicode($) {
     my $res = eval { idn_nameprep $_[0], 1 };
     defined $res ? $res : $_[0]
  }
  
  
  1;
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
DARWIN-2LEVEL_ANYEVENT_UTIL

$fatpacked{"darwin-2level/HTTP/Parser/XS.pm"} = <<'DARWIN-2LEVEL_HTTP_PARSER_XS';
  package HTTP::Parser::XS;
  
  use strict;
  use warnings;
  
  use base qw(Exporter);
  
  our %EXPORT_TAGS = (
      'all' => [ qw/parse_http_request parse_http_response
                    HEADERS_NONE HEADERS_AS_HASHREF HEADERS_AS_ARRAYREF/ ],
  );
  our @EXPORT_OK = @{$EXPORT_TAGS{all}};
  our @EXPORT = ();
  
  # header format for parse_http_response()
  use constant {
      HEADERS_NONE => 0,       # don't parse headers. It's fastest. if you want only special headers, also fastest.
      HEADERS_AS_HASHREF => 1,    # HTTP::Headers compatible HashRef, { header_name => "header_value" or ["val1", "val2"] }
      HEADERS_AS_ARRAYREF =>2,    # Ordered ArrayRef : [ name, value, name2, value2 ... ]
  };
  
  our $VERSION = '0.14';
  
  our $BACKEND;
  
  if (not __PACKAGE__->can('parse_http_response')) {
      $BACKEND = $ENV{PERL_HTTP_PARSER_XS} || ($ENV{PERL_ONLY} ? 'pp' : '');
      if ($BACKEND !~ /\b pp \b/xms) {
          eval {
              require XSLoader;
              XSLoader::load(__PACKAGE__, $VERSION);
              $BACKEND = 'xs';
          };
          die $@ if $@ && $BACKEND =~ /\bxs\b/;
      }
      if (not __PACKAGE__->can('parse_http_response')) {
          require HTTP::Parser::XS::PP;
          $BACKEND = 'pp';
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  HTTP::Parser::XS - a fast, primitive HTTP request parser
  
  =head1 SYNOPSIS
  
    use HTTP::Parser::XS qw(parse_http_request);
  
    # for HTTP servers
    my $ret = parse_http_request(
        "GET / HTTP/1.0\r\nHost: ...\r\n\r\n",
        \%env,
    );
    if ($ret == -2) {
        # request is incomplete
        ...
    } elsif ($ret == -1) {
        # request is broken
        ...
    } else {
        # $ret includes the size of the request, %env now contains a PSGI
        # request, if it is a POST / PUT request, read request content by
        # yourself
        ...
    }
  
  
    # for HTTP clients
    use HTTP::Parser::XS qw(parse_http_response HEADERS_AS_ARRAYREF);
    my %special_headers = (
      'content-length' => undef,
    );
    my($ret, $minor_version, $status, $message, $headers)
      = parse_http_response($response, HEADERS_AS_ARRAYREF, \%special_headers);
  
    if($ret == -1) }
      # response is incomplete
    }
    elsif($ret == -2) {
      # response is broken
    }
    else {
      # $ret is the length of the headers, starting the content body
  
      # the other values are the response messages. For example:
      # $status  = 200
      # $message = "OK"
      # $headers = [ 'content-type' => 'text/html', ... ]
  
      # and $special_headers{'content-length'} will be filled in
    }
  
  
  =head1 DESCRIPTION
  
  HTTP::Parser::XS is a fast, primitive HTTP request/response parser.
  
  The request parser can be used either for writing a synchronous HTTP server or a event-driven server.
  
  The response parser can be used for writing HTTP clients.
  
  Note that even if this distribution name ends C<::XS>, B<pure Perl>
  implementation is supported, so you can use this module on compiler-less
  environments.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item parse_http_request($request_string, \%env)
  
  Tries to parse given request string, and if successful, inserts variables into %env.  For the name of the variables inserted, please refer to the PSGI specification.  The return values are:
  
  =over 8
  
  =item >=0
  
  length of the request (request line and the request headers), in bytes
  
  =item -1
  
  given request is corrupt
  
  =item -2
  
  given request is incomplete
  
  =back
  
  =item parse_http_response($response_string, $header_format, \%special_headers)
  
  Tries to parse given response string. I<$header_format> must be
  C<HEADERS_AS_ARRAYREF>, C<HEADERS_AS_HASHREF>, or C<HEADERS_NONE>,
  which are exportable constants.
  
  The optional I<%special_headers> is for headers you specifically require.
  You can set any HTTP response header names, which must be lower-cased,
  and their default values, and then the values are filled in by
  C<parse_http_response()>.
  For example, if you want the C<Cointent-Length> field, set its name with
  default values like C<< %h = ('content-length' => undef) >> and pass it as
  I<%special_headers>. After parsing, C<$h{'content-length'}> is set
  if the response has the C<Content-Length> field, otherwise it's not touched.
  
  The return values are:
  
  =over 8
  
  =item C<$ret>
  
  The parsering status, which is the same as C<parse_http_response()>. i.e.
  the length of the response headers in bytes, C<-1> for incomplete headers,
  or C<-2> for errors.
  
  If the given response string is broken or imcomplete, C<parse_http_response()>
  returns only this value.
  
  =item C<$minor_version>
  
  The minor version of the given response.
  i.e. C<1> for HTTP/1.1, C<0> for HTTP/1.0.
  
  =item C<$status>
  
  The HTTP status of the given response. e.g. C<200> for success.
  
  =item C<$message>
  
  The HTTP status message. e.g. C<OK> for success.
  
  =item C<$headers>
  
  The HTTP headers for the given response. It is an ARRAY reference
  if I<$header_format> is C<HEADERS_AS_ARRAYREF>, a HASH reference on
  C<HEADERS_AS_HASHREF>, an C<undef> on C<HEADERS_NONE>.
  
  The names of the headers are normalized to lower-cased.
  
  =back
  
  =back
  
  =head1 LIMITATIONS
  
  Both C<parse_http_request()> and C<parse_http_response()> in XS
  implementation have some size limitations.
  
  =head2 The number of headers
  
  The number of headers is limited to C<128>. If it exceeds, both parsing
  routines report parsing errors, i.e. return C<-1> for C<$ret>.
  
  =head2 The size of header names
  
  The size of header names is limited to C<1024>, but the parsers do not the
  same action.
  
  C<parse_http_request()> returns C<-1> if too-long header names exist.
  
  C<parse_http_request()> simply ignores too-long header names.
  
  =head1 COPYRIGHT
  
  Copyright 2009- Kazuho Oku
  
  =head1 AUTHOR
  
  Kazuho Oku
  gfx
  mala
  tokuhirom
  
  =head1 THANKS TO
  
  nothingmuch
  charsbar
  
  =head1 SEE ALSO
  
  L<http://github.com/kazuho/picohttpparser>
  
  L<HTTP::Parser>
  L<HTTP::HeaderParser::XS>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_HTTP_PARSER_XS

$fatpacked{"darwin-2level/HTTP/Parser/XS/PP.pm"} = <<'DARWIN-2LEVEL_HTTP_PARSER_XS_PP';
  package HTTP::Parser::XS::PP;
  use strict;
  use warnings;
  use utf8;
  
  sub HTTP::Parser::XS::parse_http_request {
      my($chunk, $env) = @_;
      Carp::croak("second param to parse_http_request should be a hashref") unless (ref $env|| '') eq 'HASH';
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my $minor;
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/1\.(\d+)$/;
      $minor = $1;
  
      my($path, $query) = ( $uri =~ /^([^?#]*)(?:\?([^#]*))?/s );
      # following validations are just needed to pass t/01simple.t
      if ($path =~ /%(?:[0-9a-f][^0-9a-f]|[^0-9a-f][0-9a-f])/i) {
          # invalid char in url-encoded path
          return -1;
      }
      if ($path =~ /%(?:[0-9a-f])$/i) {
          # partially url-encoded
          return -1;
      }
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{REQUEST_URI}     = $uri;
      $env->{SERVER_PROTOCOL} = "HTTP/1.$minor";
      ($env->{PATH_INFO}      = $path) =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  # ----------------------------------------------------------
  
  my %PARSER_FUNC = (
      HTTP::Parser::XS::HEADERS_NONE()        => \&_parse_as_none,
      HTTP::Parser::XS::HEADERS_AS_HASHREF()  => \&_parse_as_hashref,
      HTTP::Parser::XS::HEADERS_AS_ARRAYREF() => \&_parse_as_arrayref,
  );
  
  sub HTTP::Parser::XS::parse_http_response {
      my ($str, $header_format, $special_headers) = @_;
      return -2 unless $str;
  
      my $len = length $str;
      
      my ($sl, $remain) = split /\r?\n/, $_[0], 2;
      my ($proto, $rc, $msg) = split(' ', $sl, 3);
      return -1 unless $proto =~m{^HTTP/1.(\d)};
      my $minor_version = $1;
      return -1 unless $rc =~m/^\d+$/;
  
      my ($header_str, $content) = split /\r?\n\r?\n/, $remain, 2;
  
      my $parser_func = $PARSER_FUNC{$header_format};
      die 'unknown header format: '. $header_format unless $parser_func;
  
      my $header = $parser_func->($header_str, $special_headers || +{});
  
      return -2 if ($str !~/\r?\n\r?\n/ && $remain !~/\r?\n\r?\n/ && !defined $content);
      my $parsed = $len - (defined $content ? length $content : 0);
  
      return ($parsed, $minor_version, $rc, $msg, $header);
  }
  
  # return special headers only
  sub _parse_as_none {
      my ($str, $special) = @_;
      return unless defined $str;
      return unless keys %$special;
  
      my ($field, $value, $f);
      for ( split /\r?\n/, $str ) {
          if ( defined $field ) {
              if ( ord == 9 || ord == 32 ) {
                  $value .= "\n$_";
                  next;
              }
              $f = lc($field); 
              exists $special->{$f} and $special->{$f} = $value;
          }
          ( $field, $value ) = split /[ \t]*: ?/, $_, 2;
      }
      if ( defined $field ) {
          $f = lc($field); 
          exists $special->{$f} and $special->{$f} = $value;
      }
  }
  
  # return headers as arrayref
  sub _parse_as_arrayref {
      my ($str, $special) = @_;
      return [] unless defined $str;
  
      my (@headers, $field, $value, $f );
      for ( split /\r?\n/, $str ) {
          if ( defined $field ) {
              if ( ord == 9 || ord == 32 ) {
                  $value .= "\n$_";
                  next;
              }
              $f = lc($field); 
              push @headers, $f, $value;
              exists $special->{$f} and $special->{$f} = $value;
          }
          ( $field, $value ) = split /[ \t]*: ?/, $_, 2;
      }
      if ( defined $field ) {
          $f = lc($field); 
          push @headers, $f, $value; 
          exists $special->{$f} and $special->{$f} = $value;
      }
      return \@headers;
  }
  
  # return headers as HTTP::Header compatible HashRef
  sub _parse_as_hashref {
      my ($str, $special) = @_;
      return +{} unless defined $str;
      
      my ( %self, $field, $value, $f );
      for ( split /\r?\n/, $str ) {
          if ( defined $field ) {
              if ( ord == 9 || ord == 32 ) {
                  $value .= "\n$_";
                  next;
              }
              $f = lc($field); 
              if ( defined $self{$f} ) {
                  my $h = $self{$f};
                  ref($h) eq 'ARRAY'
                    ? push( @$h, $value )
                    : ( $self{$f} = [ $h, $value ] );
              }
              else { $self{$f} = $value }
          }
          ( $field, $value ) = split /[ \t]*: ?/, $_, 2;
      }
      if ( defined $field ) {
          $f = lc($field); 
          if ( defined $self{$f} ) {
              my $h = $self{$f};
              ref($h) eq 'ARRAY'
                ? push( @$h, $value )
                : ( $self{$f} = [ $h, $value ] );
          }
          else { $self{$f} = $value }
      }
      return \%self;
  }
  
  1;
  
DARWIN-2LEVEL_HTTP_PARSER_XS_PP

$fatpacked{"oo.pm"} = <<'OO';
  package oo;
  
  use strictures 1;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
OO

$fatpacked{"state51/MonitoringJS/Updater.pm"} = <<'STATE51_MONITORINGJS_UPDATER';
  package state51::MonitoringJS::Updater;
  use strict;
  use warnings;
  use AnyEvent;
  use AnyEvent::Handle;
  use AnyEvent::Util qw/ portable_pipe fh_nonblocking /;
  use Moo;
  
  has filename => (
      is => 'ro',
      required => 1,
  );
  
  has on_read => (
      is => 'ro',
      required => 1,
  );
  
  sub run {
      my $self = shift;
      my $r;
      my $child_pid = open($r, "-|", "tail", "-f", $self->filename)
         // die "can't fork: $!";
      fh_nonblocking $r, 1;
      $self->{hdl} = AnyEvent::Handle->new(
          fh => $r,
          on_read => sub {
              my $hdl = shift;
              my $buf = $hdl->rbuf;
              $hdl->rbuf('');
              $self->on_read->($_) for split("\n", $buf);
          },
      );
      return $self;
  }
  
  1;
  
STATE51_MONITORINGJS_UPDATER

$fatpacked{"strictures.pm"} = <<'STRICTURES';
  package strictures;
  
  use strict;
  use warnings FATAL => 'all';
  
  our $VERSION = '1.002002'; # 1.2.2
  
  sub VERSION {
    for ($_[1]) {
      last unless defined && !ref && int != 1;
      die "Major version specified as $_ - this is strictures version 1";
    }
    # disable this since Foo->VERSION(undef) correctly returns the version
    # and that can happen either if our caller passes undef explicitly or
    # because the for above autovivified $_[1] - I could make it stop but
    # it's pointless since we don't want to blow up if the caller does
    # something valid either.
    no warnings 'uninitialized';
    shift->SUPER::VERSION(@_);
  }
  
  sub import {
    strict->import;
    warnings->import(FATAL => 'all');
    my $extra_tests = do {
      if (exists $ENV{PERL_STRICTURES_EXTRA}) {
        $ENV{PERL_STRICTURES_EXTRA}
      } else {
        !!($0 =~ /^x?t\/.*(?:load|compile|coverage|use_ok).*\.t$/
           and (-e '.git' or -e '.svn'))
      }
    };
    if ($extra_tests) {
      if (eval {
            require indirect;
            require multidimensional;
            require bareword::filehandles;
            1
          }) {
        indirect->unimport(':fatal');
        multidimensional->unimport;
        bareword::filehandles->unimport;
      } else {
        die "strictures.pm extra testing active but couldn't load modules.
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  
  Error loading modules was: $@";
      }
    }
  }
  
  1;
  
  __END__
  =head1 NAME
  
  strictures - turn on strict and make all warnings fatal
  
  =head1 SYNOPSIS
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
  
  except when called from a file where $0 matches:
  
    /^x?t\/.*(?:load|compile|coverage|use_ok).*\.t$/
  
  and when either '.git' or '.svn' is present in the current directory (with
  the intention of only forcing extra tests on the author side) - or when the
  PERL_STRICTURES_EXTRA environment variable is set, in which case
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  Note that _EXTRA may at some point add even more tests, with only a minor
  version increase, but any changes to the effect of 'use strictures' in
  normal mode will involve a major version bump.
  
  Be aware: THIS MEANS THE EXTRA TEST MODULES ARE REQUIRED FOR AUTHORS OF
  STRICTURES USING CODE - but not by end users thereof.
  
  =head1 DESCRIPTION
  
  I've been writing the equivalent of this module at the top of my code for
  about a year now. I figured it was time to make it shorter.
  
  Things like the importer in 'use Moose' don't help me because they turn
  warnings on but don't make them fatal - which from my point of view is
  useless because I want an exception to tell me my code isn't warnings clean.
  
  Any time I see a warning from my code, that indicates a mistake.
  
  Any time my code encounters a mistake, I want a crash - not spew to STDERR
  and then unknown (and probably undesired) subsequent behaviour.
  
  I also want to ensure that obvious coding mistakes, like indirect object
  syntax (and not so obvious mistakes that cause things to accidentally compile
  as such) get caught, but not at the cost of an XS dependency and not at the
  cost of blowing things up on another machine.
  
  Therefore, strictures turns on indirect checking only when it thinks it's
  running in a compilation (or pod coverage) test - though if this causes
  undesired behaviour this can be overridden by setting the
  PERL_STRICTURES_EXTRA environment variable.
  
  If additional useful author side checks come to mind, I'll add them to the
  _EXTRA code path only - this will result in a minor version increase (i.e.
  1.000000 to 1.001000 (1.1.0) or similar). Any fixes only to the mechanism of
  this code will result in a subversion increas (i.e. 1.000000 to 1.000001
  (1.0.1)).
  
  If the behaviour of 'use strictures' in normal mode changes in any way, that
  will constitute a major version increase - and the code already checks
  when its version is tested to ensure that
  
    use strictures 1;
  
  will continue to only introduce the current set of strictures even if 2.0 is
  installed.
  
  =head1 METHODS
  
  =head2 import
  
  This method does the setup work described above in L</DESCRIPTION>
  
  =head2 VERSION
  
  This method traps the strictures->VERSION(1) call produced by a use line
  with a version number on it and does the version check.
  
  =head1 COMMUNITY AND SUPPORT
  
  =head2 IRC channel
  
  irc.perl.org #toolchain
  
  (or bug 'mst' in query on there or freenode)
  
  =head2 Git repository
  
  Gitweb is on http://git.shadowcat.co.uk/ and the clone URL is:
  
    git clone git://git.shadowcat.co.uk/p5sagit/strictures.git
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  None required yet. Maybe this module is perfect (hahahahaha ...).
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the strictures L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
STRICTURES

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/usr/bin/env perl

# WARNING - Do not edit this file unless you have the perl
#           dependencies installed which are noted in the README, otherwise
#           the Makefile in this directory will try to rebuild the server script

use strict;
use warnings;
use FindBin qw/$Bin/;
use lib "$Bin/lib";
use Cwd qw/ abs_path /;
use File::Spec;

use Plack::Runner;
use Plack::App::File;
use Plack::Builder;
use Plack::Loader;
use HTTP::Server::PSGI;
use Cwd qw/ abs_path /;
use File::stat;
use File::Find;

# Work out where the root is, no matter where we were run
use constant ROOT =>
    abs_path(
        -d File::Spec->catdir($Bin, "js")
        ? $Bin
      : -d File::Spec->catdir($Bin, "..", "js")
        ? File::Spec->catdir($Bin, "..")
      : die("Cannot find js/ folder for app root")
    );

# Find the newest js or CSS file's mtime
my $youngest = 0;
my $wanted = sub {
    return if -d $File::Find::name;
    my $time = stat($File::Find::name)->mtime;
    $youngest = $time if $time > $youngest;
};
find($wanted, map { File::Spec->catdir(ROOT, $_) } qw/ js css /);
{   # Find app.html's mtime
    local $File::Find::name = File::Spec->catdir(ROOT, "maint", "app.html");
    $wanted->();
}

# Find mtime for minified version
my $minified_mtime = stat(File::Spec->catdir(ROOT, 'index.html'))->mtime;

# And use the minified version if possible, or the multi-file version if
# the application has been edited.
my @index = $minified_mtime > $youngest ? ("index.html") : ("maint", "app.html");

# Helper function to locate a file
sub file {
    Plack::App::File->new(file => File::Spec->catdir(ROOT, @_))
}

# Load AnyEvent correctly in PP mode.
BEGIN { $ENV{PERL_ANYEVENT_MODEL} = 'Perl' }
use AnyEvent;
BEGIN { AnyEvent::detect() }
use Scalar::Util qw/ refaddr /;
use state51::MonitoringJS::Updater;

my %update_handles;

my $production_log = "/var/log/nagios3/nagios.log";
my $nagios_log_file = -r $production_log
    ? $production_log
    : File::Spec->catpath(ROOT, "test", "nagios.log");

my $updater = state51::MonitoringJS::Updater->new(
    filename => $nagios_log_file,
    on_read => sub {
        my $line = shift;
        $_->send_msg({
            type => 'nagios_result',
            line => $line,
        }) for values %update_handles;
    },
)->run;

# Build the app coderef
my $app = builder {
    mount "/favicon.ico"                => file("favicon.ico");
    mount "/puppet/nodes/"              => file(qw/testdata mongodb_nodes.json/);
    mount "/puppet/nagios_host_groups/" => file(qw/testdata mongodb_nagios_host_groups.json/);
    mount "/nagios-api/state"           => file(qw/testdata nagios-api-state.json/);
    mount "/"                           => file(@index);
    mount "/dev"                        => file("maint", "app.html");
    mount "/js"                         => Plack::App::File->new(root => File::Spec->catdir(ROOT, "js"));
    mount "/css"                        => Plack::App::File->new(root => File::Spec->catdir(ROOT, "css"));
    mount "/img"                        => Plack::App::File->new(root => File::Spec->catdir(ROOT, "img"));
    mount "/test"                       => file(qw/test index.html/);
    mount "/test/vendor/qunit.js"       => file(qw/test vendor qunit.js/);
    mount "/test/vendor/qunit.css"      => file(qw/test vendor qunit.css/);
    mount "/test/model.js"              => file(qw/test model.js/);
    mount "/test/view.js"              => file(qw/test view.js/);
    mount "/test/collections.js"        => file(qw/test collections.js/);
    mount '/_hippie' => builder {
        enable "+Web::Hippie";
        sub {
            my $env = shift;
            my $interval = $env->{'hippie.args'} || 5;
            my $h = $env->{'hippie.handle'};
 
            if ($env->{PATH_INFO} eq '/init') {
                $update_handles{refaddr($h)} = $h;
            }
            elsif ($env->{PATH_INFO} eq '/message') {
                my $msg = $env->{'hippie.message'};
                warn "==> got msg from client: ".Dumper($msg);
            }
            else {
                return [ '400', [ 'Content-Type' => 'text/plain' ], [ "" ] ]
                    unless $h;
 
                if ($env->{PATH_INFO} eq '/error') {
                    warn "==> disconnecting $h";
                    delete $update_handles{refaddr($h)};
                }
                else {
                    die "unknown hippie message";
                }
            }
            return [ '200', [ 'Content-Type' => 'application/hippie' ], [ "" ] ]
        }
    };
};

# Use Plack::Runner here so we can be directly run with perl
# as a perl script. The caller magic also allows us to be used
# as a psgi script, as we don't run anything when require'd
use Fliggy::Server;
$ENV{PLACK_SERVER} = "Fliggy";

unless (caller()) {
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
}

# And return the app as the final value to be a valid psgi.
return $app;

